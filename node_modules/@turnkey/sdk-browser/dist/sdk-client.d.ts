import { type WalletInterface } from "@turnkey/wallet-stamper";
import { type TurnkeySDKBrowserConfig, type User, type ReadWriteSession, Session, Stamper, IframeClientParams, PasskeyClientParams } from "./__types__/base";
import type { SubOrganization } from "@models";
import { TurnkeyBrowserClient, TurnkeyIframeClient, TurnkeyPasskeyClient, TurnkeyWalletClient } from "./__clients__/browser-clients";
export interface OauthProvider {
    providerName: string;
    oidcToken: string;
}
export interface ApiKey {
    apiKeyName: string;
    publicKey: string;
    curveType: "API_KEY_CURVE_P256" | "API_KEY_CURVE_SECP256K1" | "API_KEY_CURVE_ED25519";
    expirationSeconds?: string;
}
export interface Authenticator {
    authenticatorName: string;
    challenge: string;
    attestation: {
        credentialId: string;
        clientDataJson: string;
        attestationObject: string;
        transports: ("AUTHENTICATOR_TRANSPORT_BLE" | "AUTHENTICATOR_TRANSPORT_INTERNAL" | "AUTHENTICATOR_TRANSPORT_NFC" | "AUTHENTICATOR_TRANSPORT_USB" | "AUTHENTICATOR_TRANSPORT_HYBRID")[];
    };
}
export declare class TurnkeyBrowserSDK {
    config: TurnkeySDKBrowserConfig;
    protected stamper: Stamper | undefined;
    constructor(config: TurnkeySDKBrowserConfig);
    /**
     * Creates a passkey client. The parameters override the default values passed to the underlying Turnkey `WebauthnStamper`
     * @param PasskeyClientParams
     * @returns new TurnkeyPasskeyClient
     */
    passkeyClient: (params?: PasskeyClientParams) => TurnkeyPasskeyClient;
    iframeClient: (params: IframeClientParams) => Promise<TurnkeyIframeClient>;
    walletClient: (wallet: WalletInterface) => TurnkeyWalletClient;
    serverSign: <TResponseType>(methodName: string, params: any[], serverSignUrl?: string) => Promise<TResponseType>;
    /**
     * If there is a valid, current user session, this will return a read-enabled TurnkeyBrowserClient that can make read requests to Turnkey without additional authentication. This is powered by a session header resulting from a prior successful `login` call.
     *
     * @returns {Promise<TurnkeyBrowserClient | undefined>}
     */
    currentUserSession: () => Promise<TurnkeyBrowserClient | undefined>;
    /**
     * If there is a valid, current read-session, this will return an auth bundle and its expiration. This auth bundle can be used in conjunction with an iframeStamper to create a read + write session.
     * @deprecated use `getSession` instead
     * @returns {Promise<ReadWriteSession | undefined>}
     */
    getReadWriteSession: () => Promise<ReadWriteSession | undefined>;
    /**
     * If there is a valid, active READ_WRITE session, this will return it
     *
     * @returns {Promise<Session | undefined>}
     */
    getSession: () => Promise<Session | undefined>;
    /**
     * Fetches the current user's organization details.
     *
     * @returns {Promise<SubOrganization | undefined>}
     */
    getCurrentSubOrganization: () => Promise<SubOrganization | undefined>;
    /**
     * Fetches the currently active user.
     *
     * @returns {Promise<User | undefined>}
     */
    getCurrentUser: () => Promise<User | undefined>;
    /**
     * Clears out all data pertaining to an end user session.
     *
     * @returns {Promise<boolean>}
     */
    logout: () => Promise<boolean>;
}
export { TurnkeyBrowserClient, TurnkeyIframeClient, TurnkeyPasskeyClient, TurnkeyWalletClient, };
//# sourceMappingURL=sdk-client.d.ts.map