'use strict';

var walletStamper = require('@turnkey/wallet-stamper');
var iframeStamper = require('@turnkey/iframe-stamper');
var webauthnStamper = require('@turnkey/webauthn-stamper');
var window = require('./__polyfills__/window.js');
var base = require('./__types__/base.js');
var storage = require('./storage.js');
var browserClients = require('./__clients__/browser-clients.js');
var version = require('./__generated__/version.js');

class TurnkeyBrowserSDK {
    constructor(config) {
        /**
         * Creates a passkey client. The parameters override the default values passed to the underlying Turnkey `WebauthnStamper`
         * @param PasskeyClientParams
         * @returns new TurnkeyPasskeyClient
         */
        this.passkeyClient = (params) => {
            const targetRpId = params?.rpId ?? this.config.rpId ?? window.location.hostname;
            if (!targetRpId) {
                throw new Error("Tried to initialize a passkey client with no rpId defined");
            }
            this.stamper = new webauthnStamper.WebauthnStamper({
                rpId: targetRpId,
                ...(params?.timeout !== undefined && { timeout: params?.timeout }),
                ...(params?.userVerification !== undefined && {
                    userVerification: params?.userVerification,
                }),
                ...(params?.allowCredentials !== undefined && {
                    allowCredentials: params?.allowCredentials,
                }),
            });
            return new browserClients.TurnkeyPasskeyClient({
                stamper: this.stamper,
                apiBaseUrl: this.config.apiBaseUrl,
                organizationId: this.config.defaultOrganizationId,
            });
        };
        this.iframeClient = async (params) => {
            if (!params.iframeUrl) {
                throw new Error("Tried to initialize iframeClient with no iframeUrl defined");
            }
            const TurnkeyIframeElementId = params.iframeElementId ?? "turnkey-default-iframe-element-id";
            this.stamper = new iframeStamper.IframeStamper({
                iframeContainer: params.iframeContainer,
                iframeUrl: params.iframeUrl,
                iframeElementId: TurnkeyIframeElementId,
            });
            await this.stamper.init(params.dangerouslyOverrideIframeKeyTtl ?? undefined);
            return new browserClients.TurnkeyIframeClient({
                stamper: this.stamper,
                apiBaseUrl: this.config.apiBaseUrl,
                organizationId: this.config.defaultOrganizationId,
            });
        };
        this.walletClient = (wallet) => {
            return new browserClients.TurnkeyWalletClient({
                stamper: new walletStamper.WalletStamper(wallet),
                wallet,
                apiBaseUrl: this.config.apiBaseUrl,
                organizationId: this.config.defaultOrganizationId,
            });
        };
        this.serverSign = async (methodName, params, serverSignUrl) => {
            const targetServerSignUrl = serverSignUrl ?? this.config.serverSignUrl;
            if (!targetServerSignUrl) {
                throw new Error("Tried to call serverSign with no serverSignUrl defined");
            }
            const stringifiedBody = JSON.stringify({
                methodName: methodName,
                params: params,
            });
            const response = await fetch(targetServerSignUrl, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-Client-Version": version.VERSION,
                },
                body: stringifiedBody,
                redirect: "follow",
            });
            if (!response.ok) {
                let res;
                try {
                    res = await response.json();
                }
                catch (_) {
                    throw new Error(`${response.status} ${response.statusText}`);
                }
                throw new base.TurnkeyRequestError(res);
            }
            const data = await response.json();
            return data;
        };
        /**
         * If there is a valid, current user session, this will return a read-enabled TurnkeyBrowserClient that can make read requests to Turnkey without additional authentication. This is powered by a session header resulting from a prior successful `login` call.
         *
         * @returns {Promise<TurnkeyBrowserClient | undefined>}
         */
        this.currentUserSession = async () => {
            const currentUser = await this.getCurrentUser();
            if (!currentUser?.session?.read) {
                return;
            }
            if (currentUser?.session?.read?.expiry > Date.now()) {
                return new browserClients.TurnkeyBrowserClient({
                    readOnlySession: currentUser?.session?.read?.token,
                    apiBaseUrl: this.config.apiBaseUrl,
                    organizationId: currentUser?.organization?.organizationId ??
                        this.config.defaultOrganizationId,
                });
            }
            else {
                await this.logout();
            }
            return;
        };
        /**
         * If there is a valid, current read-session, this will return an auth bundle and its expiration. This auth bundle can be used in conjunction with an iframeStamper to create a read + write session.
         * @deprecated use `getSession` instead
         * @returns {Promise<ReadWriteSession | undefined>}
         */
        this.getReadWriteSession = async () => {
            const currentUser = await storage.getStorageValue(storage.StorageKeys.UserSession);
            if (currentUser?.session?.write) {
                if (currentUser.session.write.expiry > Date.now()) {
                    return currentUser.session.write;
                }
                else {
                    await storage.removeStorageValue(storage.StorageKeys.ReadWriteSession);
                }
            }
            return;
        };
        /**
         * If there is a valid, active READ_WRITE session, this will return it
         *
         * @returns {Promise<Session | undefined>}
         */
        this.getSession = async () => {
            const currentSession = await storage.getStorageValue(storage.StorageKeys.Session);
            if (currentSession?.sessionType === base.SessionType.READ_WRITE) {
                if (currentSession?.expiry > Date.now()) {
                    return currentSession;
                }
                else {
                    await storage.removeStorageValue(storage.StorageKeys.Session);
                }
            }
            return;
        };
        /**
         * Fetches the current user's organization details.
         *
         * @returns {Promise<SubOrganization | undefined>}
         */
        this.getCurrentSubOrganization = async () => {
            const currentUser = await this.getCurrentUser();
            return currentUser?.organization;
        };
        /**
         * Fetches the currently active user.
         *
         * @returns {Promise<User | undefined>}
         */
        this.getCurrentUser = async () => {
            try {
                const session = await storage.getStorageValue(storage.StorageKeys.Session);
                if (session?.userId && session?.organizationId) {
                    return {
                        userId: session.userId,
                        organization: {
                            organizationId: session.organizationId,
                            organizationName: "",
                        },
                        session: {
                            ...(session.sessionType === base.SessionType.READ_ONLY && {
                                read: {
                                    token: session.token,
                                    expiry: session.expiry,
                                },
                            }),
                            ...(session.sessionType === base.SessionType.READ_WRITE && {
                                write: {
                                    credentialBundle: session.token,
                                    expiry: session.expiry,
                                },
                            }),
                        },
                    };
                }
                else {
                    return undefined;
                }
            }
            catch (error) {
                return;
            }
        };
        /**
         * Clears out all data pertaining to an end user session.
         *
         * @returns {Promise<boolean>}
         */
        this.logout = async () => {
            await storage.removeStorageValue(storage.StorageKeys.AuthBundle); // DEPRECATED
            await storage.removeStorageValue(storage.StorageKeys.CurrentUser);
            await storage.removeStorageValue(storage.StorageKeys.UserSession);
            await storage.removeStorageValue(storage.StorageKeys.ReadWriteSession);
            await storage.removeStorageValue(storage.StorageKeys.Client);
            await storage.removeStorageValue(storage.StorageKeys.Session);
            return true;
        };
        this.config = config;
    }
}

exports.TurnkeyBrowserClient = browserClients.TurnkeyBrowserClient;
exports.TurnkeyIframeClient = browserClients.TurnkeyIframeClient;
exports.TurnkeyPasskeyClient = browserClients.TurnkeyPasskeyClient;
exports.TurnkeyWalletClient = browserClients.TurnkeyWalletClient;
exports.TurnkeyBrowserSDK = TurnkeyBrowserSDK;
//# sourceMappingURL=sdk-client.js.map
