"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.channelWindow = void 0;
function channelWindow(window, id) {
    // Store the original postMessage function
    const originalPostMessage = window.postMessage.bind(window);
    // Create a wrapped postMessage that includes the channel ID
    const wrappedPostMessage = (message, targetOriginOrOptions = '*', transfer) => {
        const wrappedMessage = {
            __channelId: id,
            payload: message,
        };
        if (typeof targetOriginOrOptions === 'string') {
            return originalPostMessage(wrappedMessage, targetOriginOrOptions, transfer);
        }
        return originalPostMessage(wrappedMessage, targetOriginOrOptions);
    };
    // Create a wrapped addEventListener that filters by channel ID
    const originalAddEventListener = window.addEventListener.bind(window);
    const wrappedAddEventListener = (type, listener, options) => {
        if (type !== 'message') {
            return originalAddEventListener(type, listener, options);
        }
        const wrappedListener = (event) => {
            const data = event.data;
            // Type guard to ensure data has the correct shape
            const isWrappedMessage = (data) => {
                return (data !== null &&
                    typeof data === 'object' &&
                    '__channelId' in data &&
                    'payload' in data &&
                    typeof data.__channelId === 'string');
            };
            // Only process messages with matching channel ID
            if (isWrappedMessage(data) && data.__channelId === id) {
                const newEvent = new MessageEvent('message', {
                    bubbles: event.bubbles,
                    cancelable: event.cancelable,
                    composed: event.composed,
                    data: data.payload,
                    origin: event.origin,
                    lastEventId: event.lastEventId,
                    source: event.source,
                    ports: Array.from(event.ports),
                });
                if (typeof listener === 'function') {
                    listener(newEvent);
                }
                else {
                    listener.handleEvent(newEvent);
                }
            }
        };
        return originalAddEventListener('message', wrappedListener, options);
    };
    // Create a wrapped removeEventListener that handles the wrapped listeners
    const originalRemoveEventListener = window.removeEventListener.bind(window);
    return Object.assign(Object.assign({}, window), { postMessage: wrappedPostMessage, addEventListener: wrappedAddEventListener, removeEventListener: originalRemoveEventListener });
}
exports.channelWindow = channelWindow;
//# sourceMappingURL=window.js.map