var Jm = Object.defineProperty;
var e2 = (t0, e0, n0) => e0 in t0 ? Jm(t0, e0, { enumerable: !0, configurable: !0, writable: !0, value: n0 }) : t0[e0] = n0;
var xg = (t0, e0, n0) => (e2(t0, typeof e0 != "symbol" ? e0 + "" : e0, n0), n0);
import { shortString, constants, WalletAccount } from "starknet";
import { c as commonjsGlobal, d as getDefaultExportFromCjs, g as getAugmentedNamespace, C as Connector, a as ConnectorNotConnectedError, e as UserNotConnectedError, U as UserRejectedRequestError } from "./connector-d58f0dd8.js";
import { r as require$$1 } from "./___vite-browser-external_commonjs-proxy-00a81d47.js";
const T$5 = "0.9.2", d$2 = {
  version: T$5
};
var w$3 = /* @__PURE__ */ ((t0) => (t0.SUCCESS = "SUCCESS", t0.NOT_CONNECTED = "NOT_CONNECTED", t0.ERROR = "ERROR", t0.CANCELED = "CANCELED", t0.USER_INTERACTION_REQUIRED = "USER_INTERACTION_REQUIRED", t0))(w$3 || {});
function r(t0) {
  return Array.isArray(t0) ? t0 : [t0];
}
function k$3(t0) {
  const e0 = t0.pathname.split("/");
  if (t0.hostname === "localhost" || t0.hostname === "127.0.0.1" || t0.hostname === "0.0.0.0") {
    if (typeof XMLHttpRequest > "u")
      return console.warn(
        `Cannot make synchronous HTTP call in Node.js environment for ${t0.toString()}`
      ), shortString.encodeShortString("LOCALHOST");
    const n0 = new XMLHttpRequest();
    n0.open("POST", t0.toString(), !1), n0.setRequestHeader("Content-Type", "application/json");
    const r0 = JSON.stringify({
      jsonrpc: "2.0",
      method: "starknet_chainId",
      params: [],
      id: 1
    });
    try {
      if (n0.send(r0), n0.status === 200) {
        const i0 = JSON.parse(n0.responseText);
        if (i0.result)
          return i0.result;
      }
      throw new Error(
        `Failed to get chain ID from ${t0.toString()}: ${n0.status} ${n0.statusText}`
      );
    } catch (i0) {
      throw new Error(`Failed to connect to ${t0.toString()}: ${i0}`);
    }
  }
  if (e0.includes("starknet")) {
    if (e0.includes("mainnet"))
      return constants.StarknetChainId.SN_MAIN;
    if (e0.includes("sepolia"))
      return constants.StarknetChainId.SN_SEPOLIA;
  } else if (e0.length >= 3) {
    const n0 = e0[2];
    if (e0.includes("katana"))
      return shortString.encodeShortString(
        `WP_${n0.toUpperCase().replace(/-/g, "_")}`
      );
    if (e0.includes("mainnet"))
      return shortString.encodeShortString(
        `GG_${n0.toUpperCase().replace(/-/g, "_")}`
      );
  }
  throw new Error(`Chain ${t0.toString()} not supported`);
}
let j$6 = class Fm extends Error {
  constructor() {
    super("Not ready to connect"), Object.setPrototypeOf(this, Fm.prototype);
  }
};
const f$3 = "https://x.cartridge.gg", O$4 = {
  ACCOUNTS: "accounts"
}, L$6 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjgwMCIgdmlld0JveD0iMCAwIDgwMCA4MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2RfNTExMl83ODIpIj4KPHBhdGggZD0iTTQ2OS4yMzYgNzBDNDgyLjM5IDcwIDQ5My4wNTMgODAuNjYzIDQ5My4wNTMgOTMuODE2NFYxNDcuMTQ3TDUxNS4zMzggMTQ3LjE0N0w1MTUuNDI4IDE0Ny4xNDdMNTE1LjU1NCAxNDcuMTQ3TDUxNS44MjYgMTQ3LjE0OUM1MTYuMDE2IDE0Ny4xNTEgNTE2LjIyNSAxNDcuMTUzIDUxNi40NTEgMTQ3LjE1N0M1MTYuOTA0IDE0Ny4xNjQgNTE3LjQyOCAxNDcuMTc2IDUxOC4wMiAxNDcuMTk1QzUxOS4yMDEgMTQ3LjIzNCA1MjAuNjYgMTQ3LjMwNCA1MjIuMzYxIDE0Ny40MjRDNTI1Ljc0MSAxNDcuNjYzIDUzMC4xODUgMTQ4LjExNCA1MzUuMzYzIDE0OC45NjlDNTQ1LjAwMSAxNTAuNTYyIDU1OC41NTYgMTUzLjc4IDU3Mi45MTggMTYwLjYwM0w3MzAuNDIgMjI2LjY3MUw3MzIuMTAxIDIyNy41MDVDNzcxLjc4NyAyNDcuMTc3IDc4OS45OTMgMjg2LjI5NiA3ODkuOTkzIDMyMi4wMzZWNTg1Ljg2NUM3ODkuOTkzIDU4Ni4wNTQgNzg5Ljk5NCA1ODYuMjU0IDc4OS45OTQgNTg2LjQ2M0w3ODkuOTk2IDU4Ni45MTNDNzkwLjAzOCA1OTcuMDk2IDc5MC4xNjEgNjI2Ljk5NiA3NjQuMjMxIDY1Mi44MjNMNzE0Ljc2IDcwMi4wOTVMNzE0LjY0MSA3MDIuMjE1QzcwNC42MDEgNzEyLjI3NSA2OTIuMTIzIDcyMC42NTIgNjc2LjI4NCA3MjQuODc5QzY2NC4zOSA3MjguMDU0IDY1Mi44MjcgNzI3Ljk2NiA2NDguNjM3IDcyNy45MzRMNjQ4LjYxOSA3MjcuOTMzQzY0OC40MDkgNzI3LjkzMiA2NDguMjE5IDcyNy45MyA2NDguMDQ3IDcyNy45M0w2NDcuNzUyIDcyNy45MjlINDgwLjcyMUM0NzQuMDk0IDcyNy45MjkgNDY4LjcyMSA3MjIuNTU2IDQ2OC43MjEgNzE1LjkyOVY2NjguMzg4SDMyOC41ODZDMzI4LjU4NiA2NzIuNjI5IDMyOC41NzIgNjk4LjA1MiAzMjguNTYxIDcxNS45NDRDMzI4LjU1NyA3MjIuNTY5IDMyMy4xODYgNzI3LjkyOSAzMTYuNTYxIDcyNy45MjlIMTUyLjI0NkMxNTIuMTA0IDcyNy45MjkgMTUxLjk0MiA3MjcuOTI5IDE1MS43NjIgNzI3LjkzMUwxNTEuMzYyIDcyNy45MzRDMTQ3LjE3MiA3MjcuOTY2IDEzNS42MDkgNzI4LjA1NCAxMjMuNzE0IDcyNC44NzlDMTA3Ljg3MyA3MjAuNjUxIDk1LjM5MzggNzEyLjI3MiA4NS4zNTI5IDcwMi4yMUw4NS4yMzg2IDcwMi4wOTVMMzUuNjcgNjUyLjcyNUwzNS41NzIzIDY1Mi42MjdDOS44NjI0MiA2MjYuNzggOS45NjY3IDU5Ny4xODUgMTAuMDAzIDU4Ni44NzRDMTAuMDA0MyA1ODYuNTEzIDEwLjAwNTUgNTg2LjE3NyAxMC4wMDU1IDU4NS44NjVWMzIyLjAzNkMxMC4wMDU1IDI4Ni40MyAyOC4xNjYyIDI0Ny4xOTkgNjcuODk3NyAyMjcuNTA1TDY5LjU3OSAyMjYuNjcxTDIyNy4wODEgMTYwLjYwM0MyNDEuNDQzIDE1My43OCAyNTQuOTk4IDE1MC41NjIgMjY0LjYzNiAxNDguOTY5QzI2OS44MTQgMTQ4LjExNCAyNzQuMjU4IDE0Ny42NjMgMjc3LjYzOCAxNDcuNDI0QzI3OS4zMzggMTQ3LjMwNCAyODAuNzk4IDE0Ny4yMzQgMjgxLjk3OSAxNDcuMTk1QzI4Mi41NzEgMTQ3LjE3NiAyODMuMDk1IDE0Ny4xNjQgMjgzLjU0NyAxNDcuMTU3TDI4My45MTcgMTQ3LjE1MkwyODQuMTczIDE0Ny4xNDlMMjg0LjQ0NSAxNDcuMTQ3TDI4NC41NzEgMTQ3LjE0N0wyODQuNjYgMTQ3LjE0N0wzMDYuOTQyIDE0Ny4xNDdWOTMuODE2NEMzMDYuOTQyIDgwLjY2MyAzMTcuNjA1IDcwIDMzMC43NTggNzBINDY5LjIzNloiIGZpbGw9IiMxOTFBMUEiLz4KPHBhdGggZD0iTTM2Ni40ODMgMTI5LjU0SDQzMy41MTJWMjA2LjY4N0gzNjYuNDgzVjEyOS41NFoiIGZpbGw9IiNGQkNCNEEiLz4KPHBhdGggZD0iTTI2OS4wMSA2MDIuNDI5SDE0NC4wMDhDMTM1Ljc2OCA2MDIuNDI5IDEzNS43NjggNTk0LjE0NiAxMzUuNzY4IDU5NC4xNDZWMjgwLjg1QzEzNS43NjggMjgwLjg1IDEzNS43NjggMjcyLjY0NCAxNDQuMDA4IDI3Mi42NDRIMzY2LjQ4M0wzNjYuNDgzIDIwNi42ODdIMjg0LjY5QzI4NC42OSAyMDYuNjg3IDI2OC4xMzQgMjA2LjY4NyAyNTEuNTc5IDIxNC44OTNMOTQuMzQxNCAyODAuODVDNzcuNzg2MSAyODkuMDU3IDY5LjU0NjkgMzA1LjYyMyA2OS41NDY5IDMyMi4wMzVWNTg1Ljg2M0M2OS41NDY5IDU5NC4xNDcgNjkuNTQ2OSA2MDIuMzUzIDc3Ljc4NjEgNjEwLjYzNkwxMjcuNDUyIDY2MC4xMDRDMTM1LjY5MSA2NjguMzg3IDE0MS45MjggNjY4LjM4NyAxNTIuMjQ3IDY2OC4zODdIMjY5LjAyOUMyNjkuMDM3IDY0OC4zNCAyNjkuMDQ2IDYyNC42NTUgMjY5LjA1NCA2MDIuODg3SDUyOC4wMTNWNjY4LjM4N0g2NDcuNzUzQzY1OC4wNzEgNjY4LjM4NyA2NjQuMzA4IDY2OC4zODcgNjcyLjU0NyA2NjAuMTA0TDcyMi4yMTMgNjEwLjYzNkM3MzAuNDUzIDYwMi40MjkgNzMwLjQ1MyA1OTQuMTQ3IDczMC40NTMgNTg1Ljg2M1YzMjIuMDM1QzczMC40NTMgMzA1LjU0NiA3MjIuMjEzIDI4OS4wNTcgNzA1LjY1OCAyODAuODVMNTQ4LjQyMSAyMTQuODkzQzUzMS44NjUgMjA2LjY4NyA1MTUuMzEgMjA2LjY4NyA1MTUuMzEgMjA2LjY4N0g0MzMuNTEyTDQzMy41MTIgMjcyLjY0NEg2NTYuMDY5QzY2NC4zMDggMjcyLjY0NCA2NjQuMzA4IDI4MC44NSA2NjQuMzA4IDI4MC44NVY1OTQuMTQ2QzY2NC4zMDggNTk0LjE0NiA2NjQuMzA4IDYwMi40MjkgNjU2LjA2OSA2MDIuNDI5SDUyOC4yNjJWNTM3LjM5NkgyNjkuMDc1QzI2OS4wNzUgNTQzLjcwNyAyNjkuMDE3IDU5Ni45MTIgMjY5LjAxIDYwMi40MjlaIiBmaWxsPSIjRkJDQjRBIi8+CjxwYXRoIGQ9Ik0yNjkuMDA5IDQzNi4xNzJINTI4LjI2MlYzNzAuNjgxSDI2OS4wNzVDMjY5LjA3NSAzNzcuMzczIDI2OS4wMDkgNDM2Ljc4OCAyNjkuMDA5IDQzNi4xNzJaIiBmaWxsPSIjRkJDQjRBIi8+CjwvZz4KPGRlZnM+CjxmaWx0ZXIgaWQ9ImZpbHRlcjBfZF81MTEyXzc4MiIgeD0iLTQiIHk9IjAiIHdpZHRoPSI4MDgiIGhlaWdodD0iODA4IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUNvbG9yTWF0cml4IGluPSJTb3VyY2VBbHBoYSIgdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEyNyAwIiByZXN1bHQ9ImhhcmRBbHBoYSIvPgo8ZmVPZmZzZXQgZHk9IjQiLz4KPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIvPgo8ZmVDb21wb3NpdGUgaW4yPSJoYXJkQWxwaGEiIG9wZXJhdG9yPSJvdXQiLz4KPGZlQ29sb3JNYXRyaXggdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMjUgMCIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9ImVmZmVjdDFfZHJvcFNoYWRvd181MTEyXzc4MiIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9ImVmZmVjdDFfZHJvcFNoYWRvd181MTEyXzc4MiIgcmVzdWx0PSJzaGFwZSIvPgo8L2ZpbHRlcj4KPC9kZWZzPgo8L3N2Zz4K";
function E$3() {
}
let S$5 = class {
  constructor() {
    xg(this, "m_lastPromise", Promise.resolve());
  }
  /**
   * Acquire lock
   * @param [bypass=false] option to skip lock acquisition
   */
  async obtain(e0 = !1) {
    let n0 = E$3;
    if (e0)
      return n0;
    const r0 = this.m_lastPromise;
    return this.m_lastPromise = new Promise((i0) => n0 = i0), await r0, n0;
  }
};
const Y$4 = new S$5();
let b$5 = class {
  constructor() {
    xg(this, "id", "controller");
    xg(this, "name", "Controller");
    xg(this, "version", d$2.version);
    xg(this, "icon", L$6);
    xg(this, "account");
    xg(this, "subscriptions", []);
    xg(this, "_probePromise", null);
    xg(this, "request", async (e0) => {
      switch (e0.type) {
        case "wallet_getPermissions":
          return await this.safeProbe(), this.account ? [O$4.ACCOUNTS] : [];
        case "wallet_requestAccounts": {
          if (this.account)
            return [this.account.address];
          const r0 = e0.params && e0.params.silent_mode;
          return this.account = await this.safeProbe(), !this.account && !r0 && (this.account = await this.connect()), this.account ? [this.account.address] : [];
        }
        case "wallet_watchAsset":
          throw {
            code: 63,
            message: "An unexpected error occurred",
            data: "wallet_watchAsset not implemented"
          };
        case "wallet_addStarknetChain": {
          let r0 = e0.params;
          return this.addStarknetChain(r0);
        }
        case "wallet_switchStarknetChain": {
          let r0 = e0.params;
          return this.switchStarknetChain(r0.chainId);
        }
        case "wallet_requestChainId":
          if (!this.account)
            throw {
              code: 63,
              message: "An unexpected error occurred",
              data: "Account not initialized"
            };
          return await this.account.getChainId();
        case "wallet_deploymentData":
          throw {
            code: 63,
            message: "An unexpected error occurred",
            data: "wallet_deploymentData not implemented"
          };
        case "wallet_addInvokeTransaction":
          if (!this.account)
            throw {
              code: 63,
              message: "An unexpected error occurred",
              data: "Account not initialized"
            };
          let n0 = e0.params;
          return await this.account.execute(
            n0.calls.map((r0) => ({
              contractAddress: r0.contract_address,
              entrypoint: r0.entry_point,
              calldata: r0.calldata
            }))
          );
        case "wallet_addDeclareTransaction":
          throw {
            code: 63,
            message: "An unexpected error occurred",
            data: "wallet_addDeclareTransaction not implemented"
          };
        case "wallet_signTypedData": {
          if (!this.account)
            throw {
              code: 63,
              message: "An unexpected error occurred",
              data: "Account not initialized"
            };
          return await this.account.signMessage(e0.params);
        }
        case "wallet_supportedSpecs":
          return [];
        case "wallet_supportedWalletApi":
          return [];
        default:
          throw {
            code: 63,
            message: "An unexpected error occurred",
            data: `Unknown RPC call type: ${e0.type}`
          };
      }
    });
    xg(this, "on", (e0, n0) => {
      if (e0 !== "accountsChanged" && e0 !== "networkChanged")
        throw new Error(`Unknown event: ${e0}`);
      this.subscriptions.push({ type: e0, handler: n0 });
    });
    xg(this, "off", (e0, n0) => {
      if (e0 !== "accountsChanged" && e0 !== "networkChanged")
        throw new Error(`Unknown event: ${e0}`);
      const r0 = this.subscriptions.findIndex(
        (i0) => i0.type === e0 && i0.handler === n0
      );
      r0 >= 0 && this.subscriptions.splice(r0, 1);
    });
  }
  async safeProbe() {
    if (this.account)
      return this.account;
    if (this._probePromise)
      return this._probePromise;
    const e0 = await Y$4.obtain();
    return await new Promise(async (n0) => {
      try {
        this._probePromise = this.probe();
        const r0 = await this._probePromise;
        n0(r0);
      } finally {
        this._probePromise = null;
      }
    }).finally(() => {
      e0();
    });
  }
  emitNetworkChanged(e0) {
    this.subscriptions.filter((n0) => n0.type === "networkChanged").forEach((n0) => {
      n0.handler(e0);
    });
  }
  emitAccountsChanged(e0) {
    this.subscriptions.filter((n0) => n0.type === "accountsChanged").forEach((n0) => {
      n0.handler(e0);
    });
  }
};
var te$4 = Object.defineProperty, ne$4 = (t0, e0, n0) => e0 in t0 ? te$4(t0, e0, { enumerable: !0, configurable: !0, writable: !0, value: n0 }) : t0[e0] = n0, _$3 = (t0, e0, n0) => (ne$4(t0, typeof e0 != "symbol" ? e0 + "" : e0, n0), n0), K$5 = (t0, e0, n0) => {
  if (!e0.has(t0))
    throw TypeError("Cannot " + n0);
}, N$5 = (t0, e0, n0) => (K$5(t0, e0, "read from private field"), n0 ? n0.call(t0) : e0.get(t0)), T$4 = (t0, e0, n0) => {
  if (e0.has(t0))
    throw TypeError("Cannot add the same private member more than once");
  e0 instanceof WeakSet ? e0.add(t0) : e0.set(t0, n0);
}, B$4 = (t0, e0, n0, r0) => (K$5(t0, e0, "write to private field"), r0 ? r0.call(t0, n0) : e0.set(t0, n0), n0), E$2 = (t0, e0, n0) => (K$5(t0, e0, "access private method"), n0);
const generateUID = () => `${Date.now()}-${Math.floor(Math.random() * 8999999999999) + 1e12}`, shuffle = (t0) => {
  for (let e0 = t0.length - 1; e0 > 0; e0--) {
    const n0 = Math.floor(Math.random() * (e0 + 1));
    [t0[e0], t0[n0]] = [t0[n0], t0[e0]];
  }
  return t0;
}, pipe$1 = (...t0) => (e0) => t0.reduce((n0, r0) => n0.then(r0), Promise.resolve(e0));
function ensureKeysArray(t0) {
  return Object.keys(t0);
}
const ssrSafeWindow = typeof window < "u" ? window : null;
function getBuilderId() {
  return typeof FEDERATION_BUILD_IDENTIFIER < "u" ? FEDERATION_BUILD_IDENTIFIER : "";
}
function isDebugMode$1() {
  return !1;
}
function isBrowserEnv$1() {
  return typeof window < "u";
}
const LOG_CATEGORY$1 = "[ Federation Runtime ]";
function assert$2(t0, e0) {
  t0 || error(e0);
}
function error(t0) {
  throw t0 instanceof Error ? (t0.message = `${LOG_CATEGORY$1}: ${t0.message}`, t0) : new Error(`${LOG_CATEGORY$1}: ${t0}`);
}
function warn$1(t0) {
  t0 instanceof Error ? (t0.message = `${LOG_CATEGORY$1}: ${t0.message}`, console.warn(t0)) : console.warn(`${LOG_CATEGORY$1}: ${t0}`);
}
function addUniqueItem(t0, e0) {
  return t0.findIndex((n0) => n0 === e0) === -1 && t0.push(e0), t0;
}
function getFMId(t0) {
  return "version" in t0 && t0.version ? `${t0.name}:${t0.version}` : "entry" in t0 && t0.entry ? `${t0.name}:${t0.entry}` : `${t0.name}`;
}
function isRemoteInfoWithEntry(t0) {
  return typeof t0.entry < "u";
}
function isPureRemoteEntry(t0) {
  return !t0.entry.includes(".json") && t0.entry.includes(".js");
}
function safeToString$1(t0) {
  try {
    return JSON.stringify(t0, null, 2);
  } catch {
    return "";
  }
}
function isObject$2(t0) {
  return t0 && typeof t0 == "object";
}
const objectToString = Object.prototype.toString;
function isPlainObject(t0) {
  return objectToString.call(t0) === "[object Object]";
}
function _extends$1$1() {
  return _extends$1$1 = Object.assign || function(t0) {
    for (var e0 = 1; e0 < arguments.length; e0++) {
      var n0 = arguments[e0];
      for (var r0 in n0)
        Object.prototype.hasOwnProperty.call(n0, r0) && (t0[r0] = n0[r0]);
    }
    return t0;
  }, _extends$1$1.apply(this, arguments);
}
function _object_without_properties_loose$1(t0, e0) {
  if (t0 == null)
    return {};
  var n0 = {}, r0 = Object.keys(t0), i0, o0;
  for (o0 = 0; o0 < r0.length; o0++)
    i0 = r0[o0], !(e0.indexOf(i0) >= 0) && (n0[i0] = t0[i0]);
  return n0;
}
const nativeGlobal = (() => {
  try {
    return new Function("return this")();
  } catch {
    return globalThis;
  }
})(), Global = nativeGlobal;
function definePropertyGlobalVal(t0, e0, n0) {
  Object.defineProperty(t0, e0, {
    value: n0,
    configurable: !1,
    writable: !0
  });
}
function includeOwnProperty(t0, e0) {
  return Object.hasOwnProperty.call(t0, e0);
}
includeOwnProperty(globalThis, "__GLOBAL_LOADING_REMOTE_ENTRY__") || definePropertyGlobalVal(globalThis, "__GLOBAL_LOADING_REMOTE_ENTRY__", {});
const globalLoading = globalThis.__GLOBAL_LOADING_REMOTE_ENTRY__;
function setGlobalDefaultVal(t0) {
  var e0, n0, r0, i0, o0, s0;
  includeOwnProperty(t0, "__VMOK__") && !includeOwnProperty(t0, "__FEDERATION__") && definePropertyGlobalVal(t0, "__FEDERATION__", t0.__VMOK__), includeOwnProperty(t0, "__FEDERATION__") || (definePropertyGlobalVal(t0, "__FEDERATION__", {
    __GLOBAL_PLUGIN__: [],
    __INSTANCES__: [],
    moduleInfo: {},
    __SHARE__: {},
    __MANIFEST_LOADING__: {},
    __PRELOADED_MAP__: /* @__PURE__ */ new Map()
  }), definePropertyGlobalVal(t0, "__VMOK__", t0.__FEDERATION__)), (e0 = t0.__FEDERATION__).__GLOBAL_PLUGIN__ != null || (e0.__GLOBAL_PLUGIN__ = []), (n0 = t0.__FEDERATION__).__INSTANCES__ != null || (n0.__INSTANCES__ = []), (r0 = t0.__FEDERATION__).moduleInfo != null || (r0.moduleInfo = {}), (i0 = t0.__FEDERATION__).__SHARE__ != null || (i0.__SHARE__ = {}), (o0 = t0.__FEDERATION__).__MANIFEST_LOADING__ != null || (o0.__MANIFEST_LOADING__ = {}), (s0 = t0.__FEDERATION__).__PRELOADED_MAP__ != null || (s0.__PRELOADED_MAP__ = /* @__PURE__ */ new Map());
}
setGlobalDefaultVal(globalThis);
setGlobalDefaultVal(nativeGlobal);
function getGlobalFederationInstance(t0, e0) {
  const n0 = getBuilderId();
  return globalThis.__FEDERATION__.__INSTANCES__.find((r0) => !!(n0 && r0.options.id === getBuilderId() || r0.options.name === t0 && !r0.options.version && !e0 || r0.options.name === t0 && e0 && r0.options.version === e0));
}
function setGlobalFederationInstance(t0) {
  globalThis.__FEDERATION__.__INSTANCES__.push(t0);
}
function getGlobalFederationConstructor() {
  return globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__;
}
function setGlobalFederationConstructor(t0, e0 = isDebugMode$1()) {
  e0 && (globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__ = t0, globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR_VERSION__ = "0.1.2");
}
function getInfoWithoutType(t0, e0) {
  if (typeof e0 == "string") {
    if (t0[e0])
      return {
        value: t0[e0],
        key: e0
      };
    {
      const n0 = Object.keys(t0);
      for (const r0 of n0) {
        const [i0, o0] = r0.split(":"), s0 = `${i0}:${e0}`, a0 = t0[s0];
        if (a0)
          return {
            value: a0,
            key: s0
          };
      }
      return {
        value: void 0,
        key: e0
      };
    }
  } else
    throw new Error("key must be string");
}
const getGlobalSnapshot = () => nativeGlobal.__FEDERATION__.moduleInfo, getTargetSnapshotInfoByModuleInfo = (t0, e0) => {
  const n0 = getFMId(t0), r0 = getInfoWithoutType(e0, n0).value;
  if (r0 && !r0.version && "version" in t0 && t0.version && (r0.version = t0.version), r0)
    return r0;
  if ("version" in t0 && t0.version) {
    const { version: i0 } = t0, o0 = _object_without_properties_loose$1(t0, [
      "version"
    ]), s0 = getFMId(o0), a0 = getInfoWithoutType(nativeGlobal.__FEDERATION__.moduleInfo, s0).value;
    if (a0?.version === i0)
      return a0;
  }
}, getGlobalSnapshotInfoByModuleInfo = (t0) => getTargetSnapshotInfoByModuleInfo(t0, nativeGlobal.__FEDERATION__.moduleInfo), setGlobalSnapshotInfoByModuleInfo = (t0, e0) => {
  const n0 = getFMId(t0);
  return nativeGlobal.__FEDERATION__.moduleInfo[n0] = e0, nativeGlobal.__FEDERATION__.moduleInfo;
}, addGlobalSnapshot = (t0) => (nativeGlobal.__FEDERATION__.moduleInfo = _extends$1$1({}, nativeGlobal.__FEDERATION__.moduleInfo, t0), () => {
  const e0 = Object.keys(t0);
  for (const n0 of e0)
    delete nativeGlobal.__FEDERATION__.moduleInfo[n0];
}), getRemoteEntryExports = (t0, e0) => {
  const n0 = e0 || `__FEDERATION_${t0}:custom__`, r0 = globalThis[n0];
  return {
    remoteEntryKey: n0,
    entryExports: r0
  };
}, getGlobalHostPlugins = () => nativeGlobal.__FEDERATION__.__GLOBAL_PLUGIN__, getPreloaded = (t0) => globalThis.__FEDERATION__.__PRELOADED_MAP__.get(t0), setPreloaded = (t0) => globalThis.__FEDERATION__.__PRELOADED_MAP__.set(t0, !0), DEFAULT_SCOPE = "default", DEFAULT_REMOTE_TYPE = "global", buildIdentifier = "[0-9A-Za-z-]+", build = `(?:\\+(${buildIdentifier}(?:\\.${buildIdentifier})*))`, numericIdentifier = "0|[1-9]\\d*", numericIdentifierLoose = "[0-9]+", nonNumericIdentifier = "\\d*[a-zA-Z-][a-zA-Z0-9-]*", preReleaseIdentifierLoose = `(?:${numericIdentifierLoose}|${nonNumericIdentifier})`, preReleaseLoose = `(?:-?(${preReleaseIdentifierLoose}(?:\\.${preReleaseIdentifierLoose})*))`, preReleaseIdentifier = `(?:${numericIdentifier}|${nonNumericIdentifier})`, preRelease = `(?:-(${preReleaseIdentifier}(?:\\.${preReleaseIdentifier})*))`, xRangeIdentifier = `${numericIdentifier}|x|X|\\*`, xRangePlain = `[v=\\s]*(${xRangeIdentifier})(?:\\.(${xRangeIdentifier})(?:\\.(${xRangeIdentifier})(?:${preRelease})?${build}?)?)?`, hyphenRange = `^\\s*(${xRangePlain})\\s+-\\s+(${xRangePlain})\\s*$`, mainVersionLoose = `(${numericIdentifierLoose})\\.(${numericIdentifierLoose})\\.(${numericIdentifierLoose})`, loosePlain = `[v=\\s]*${mainVersionLoose}${preReleaseLoose}?${build}?`, gtlt = "((?:<|>)?=?)", comparatorTrim = `(\\s*)${gtlt}\\s*(${loosePlain}|${xRangePlain})`, loneTilde = "(?:~>?)", tildeTrim = `(\\s*)${loneTilde}\\s+`, loneCaret = "(?:\\^)", caretTrim = `(\\s*)${loneCaret}\\s+`, star = "(<|>)?=?\\s*\\*", caret = `^${loneCaret}${xRangePlain}$`, mainVersion = `(${numericIdentifier})\\.(${numericIdentifier})\\.(${numericIdentifier})`, fullPlain = `v?${mainVersion}${preRelease}?${build}?`, tilde = `^${loneTilde}${xRangePlain}$`, xRange = `^${gtlt}\\s*${xRangePlain}$`, comparator = `^${gtlt}\\s*(${fullPlain})$|^$`, gte0 = "^\\s*>=\\s*0.0.0\\s*$";
function parseRegex(t0) {
  return new RegExp(t0);
}
function isXVersion(t0) {
  return !t0 || t0.toLowerCase() === "x" || t0 === "*";
}
function pipe(...t0) {
  return (e0) => t0.reduce((n0, r0) => r0(n0), e0);
}
function extractComparator(t0) {
  return t0.match(parseRegex(comparator));
}
function combineVersion(t0, e0, n0, r0) {
  const i0 = `${t0}.${e0}.${n0}`;
  return r0 ? `${i0}-${r0}` : i0;
}
function parseHyphen(t0) {
  return t0.replace(parseRegex(hyphenRange), (e0, n0, r0, i0, o0, s0, a0, c0, l0, u0, d0, h0) => (isXVersion(r0) ? n0 = "" : isXVersion(i0) ? n0 = `>=${r0}.0.0` : isXVersion(o0) ? n0 = `>=${r0}.${i0}.0` : n0 = `>=${n0}`, isXVersion(l0) ? c0 = "" : isXVersion(u0) ? c0 = `<${Number(l0) + 1}.0.0-0` : isXVersion(d0) ? c0 = `<${l0}.${Number(u0) + 1}.0-0` : h0 ? c0 = `<=${l0}.${u0}.${d0}-${h0}` : c0 = `<=${c0}`, `${n0} ${c0}`.trim()));
}
function parseComparatorTrim(t0) {
  return t0.replace(parseRegex(comparatorTrim), "$1$2$3");
}
function parseTildeTrim(t0) {
  return t0.replace(parseRegex(tildeTrim), "$1~");
}
function parseCaretTrim(t0) {
  return t0.replace(parseRegex(caretTrim), "$1^");
}
function parseCarets(t0) {
  return t0.trim().split(/\s+/).map((e0) => e0.replace(parseRegex(caret), (n0, r0, i0, o0, s0) => isXVersion(r0) ? "" : isXVersion(i0) ? `>=${r0}.0.0 <${Number(r0) + 1}.0.0-0` : isXVersion(o0) ? r0 === "0" ? `>=${r0}.${i0}.0 <${r0}.${Number(i0) + 1}.0-0` : `>=${r0}.${i0}.0 <${Number(r0) + 1}.0.0-0` : s0 ? r0 === "0" ? i0 === "0" ? `>=${r0}.${i0}.${o0}-${s0} <${r0}.${i0}.${Number(o0) + 1}-0` : `>=${r0}.${i0}.${o0}-${s0} <${r0}.${Number(i0) + 1}.0-0` : `>=${r0}.${i0}.${o0}-${s0} <${Number(r0) + 1}.0.0-0` : r0 === "0" ? i0 === "0" ? `>=${r0}.${i0}.${o0} <${r0}.${i0}.${Number(o0) + 1}-0` : `>=${r0}.${i0}.${o0} <${r0}.${Number(i0) + 1}.0-0` : `>=${r0}.${i0}.${o0} <${Number(r0) + 1}.0.0-0`)).join(" ");
}
function parseTildes(t0) {
  return t0.trim().split(/\s+/).map((e0) => e0.replace(parseRegex(tilde), (n0, r0, i0, o0, s0) => isXVersion(r0) ? "" : isXVersion(i0) ? `>=${r0}.0.0 <${Number(r0) + 1}.0.0-0` : isXVersion(o0) ? `>=${r0}.${i0}.0 <${r0}.${Number(i0) + 1}.0-0` : s0 ? `>=${r0}.${i0}.${o0}-${s0} <${r0}.${Number(i0) + 1}.0-0` : `>=${r0}.${i0}.${o0} <${r0}.${Number(i0) + 1}.0-0`)).join(" ");
}
function parseXRanges(t0) {
  return t0.split(/\s+/).map((e0) => e0.trim().replace(parseRegex(xRange), (n0, r0, i0, o0, s0, a0) => {
    const c0 = isXVersion(i0), l0 = c0 || isXVersion(o0), u0 = l0 || isXVersion(s0);
    return r0 === "=" && u0 && (r0 = ""), a0 = "", c0 ? r0 === ">" || r0 === "<" ? "<0.0.0-0" : "*" : r0 && u0 ? (l0 && (o0 = 0), s0 = 0, r0 === ">" ? (r0 = ">=", l0 ? (i0 = Number(i0) + 1, o0 = 0, s0 = 0) : (o0 = Number(o0) + 1, s0 = 0)) : r0 === "<=" && (r0 = "<", l0 ? i0 = Number(i0) + 1 : o0 = Number(o0) + 1), r0 === "<" && (a0 = "-0"), `${r0 + i0}.${o0}.${s0}${a0}`) : l0 ? `>=${i0}.0.0${a0} <${Number(i0) + 1}.0.0-0` : u0 ? `>=${i0}.${o0}.0${a0} <${i0}.${Number(o0) + 1}.0-0` : n0;
  })).join(" ");
}
function parseStar(t0) {
  return t0.trim().replace(parseRegex(star), "");
}
function parseGTE0(t0) {
  return t0.trim().replace(parseRegex(gte0), "");
}
function compareAtom(t0, e0) {
  return t0 = Number(t0) || t0, e0 = Number(e0) || e0, t0 > e0 ? 1 : t0 === e0 ? 0 : -1;
}
function comparePreRelease(t0, e0) {
  const { preRelease: n0 } = t0, { preRelease: r0 } = e0;
  if (n0 === void 0 && r0)
    return 1;
  if (n0 && r0 === void 0)
    return -1;
  if (n0 === void 0 && r0 === void 0)
    return 0;
  for (let i0 = 0, o0 = n0.length; i0 <= o0; i0++) {
    const s0 = n0[i0], a0 = r0[i0];
    if (s0 !== a0)
      return s0 === void 0 && a0 === void 0 ? 0 : s0 ? a0 ? compareAtom(s0, a0) : -1 : 1;
  }
  return 0;
}
function compareVersion(t0, e0) {
  return compareAtom(t0.major, e0.major) || compareAtom(t0.minor, e0.minor) || compareAtom(t0.patch, e0.patch) || comparePreRelease(t0, e0);
}
function eq(t0, e0) {
  return t0.version === e0.version;
}
function compare(t0, e0) {
  switch (t0.operator) {
    case "":
    case "=":
      return eq(t0, e0);
    case ">":
      return compareVersion(t0, e0) < 0;
    case ">=":
      return eq(t0, e0) || compareVersion(t0, e0) < 0;
    case "<":
      return compareVersion(t0, e0) > 0;
    case "<=":
      return eq(t0, e0) || compareVersion(t0, e0) > 0;
    case void 0:
      return !0;
    default:
      return !1;
  }
}
function parseComparatorString(t0) {
  return pipe(
    parseCarets,
    parseTildes,
    parseXRanges,
    parseStar
  )(t0);
}
function parseRange(t0) {
  return pipe(
    parseHyphen,
    parseComparatorTrim,
    parseTildeTrim,
    parseCaretTrim
  )(t0.trim()).split(/\s+/).join(" ");
}
function satisfy(t0, e0) {
  if (!t0)
    return !1;
  const n0 = parseRange(e0).split(" ").map((u0) => parseComparatorString(u0)).join(" ").split(/\s+/).map((u0) => parseGTE0(u0)), r0 = extractComparator(t0);
  if (!r0)
    return !1;
  const [, i0, , o0, s0, a0, c0] = r0, l0 = {
    operator: i0,
    version: combineVersion(o0, s0, a0, c0),
    major: o0,
    minor: s0,
    patch: a0,
    preRelease: c0?.split(".")
  };
  for (const u0 of n0) {
    const d0 = extractComparator(u0);
    if (!d0)
      return !1;
    const [, h0, , g0, w0, y0, E0] = d0, b0 = {
      operator: h0,
      version: combineVersion(g0, w0, y0, E0),
      major: g0,
      minor: w0,
      patch: y0,
      preRelease: E0?.split(".")
    };
    if (!compare(b0, l0))
      return !1;
  }
  return !0;
}
function _extends$6() {
  return _extends$6 = Object.assign || function(t0) {
    for (var e0 = 1; e0 < arguments.length; e0++) {
      var n0 = arguments[e0];
      for (var r0 in n0)
        Object.prototype.hasOwnProperty.call(n0, r0) && (t0[r0] = n0[r0]);
    }
    return t0;
  }, _extends$6.apply(this, arguments);
}
function formatShare(t0, e0) {
  let n0;
  return "get" in t0 ? n0 = t0.get : n0 = () => Promise.resolve(t0.lib), _extends$6({
    deps: [],
    useIn: [],
    from: e0,
    loading: null
  }, t0, {
    shareConfig: _extends$6({
      requiredVersion: `^${t0.version}`,
      singleton: !1,
      eager: !1,
      strictVersion: !1
    }, t0.shareConfig),
    get: n0,
    loaded: "lib" in t0 ? !0 : void 0,
    scope: Array.isArray(t0.scope) ? t0.scope : [
      "default"
    ],
    strategy: t0.strategy || "version-first"
  });
}
function formatShareConfigs(t0, e0) {
  return t0 ? Object.keys(t0).reduce((n0, r0) => (n0[r0] = formatShare(t0[r0], e0), n0), {}) : {};
}
function versionLt(t0, e0) {
  const n0 = (r0) => {
    if (!Number.isNaN(Number(r0))) {
      const i0 = r0.split(".");
      let o0 = r0;
      for (let s0 = 0; s0 < 3 - i0.length; s0++)
        o0 += ".0";
      return o0;
    }
    return r0;
  };
  return !!satisfy(n0(t0), `<=${n0(e0)}`);
}
const findVersion = (t0, e0, n0, r0) => {
  const i0 = t0[e0][n0], o0 = r0 || function(s0, a0) {
    return versionLt(s0, a0);
  };
  return Object.keys(i0).reduce((s0, a0) => !s0 || o0(s0, a0) || s0 === "0" ? a0 : s0, 0);
}, isLoaded = (t0) => !!t0.loaded || typeof t0.lib == "function";
function findSingletonVersionOrderByVersion(t0, e0, n0) {
  const r0 = t0[e0][n0];
  return findVersion(t0, e0, n0, function(i0, o0) {
    return !isLoaded(r0[i0]) && versionLt(i0, o0);
  });
}
function findSingletonVersionOrderByLoaded(t0, e0, n0) {
  const r0 = t0[e0][n0];
  return findVersion(t0, e0, n0, function(i0, o0) {
    return isLoaded(r0[o0]) ? isLoaded(r0[i0]) ? !!versionLt(i0, o0) : !0 : isLoaded(r0[i0]) ? !1 : versionLt(i0, o0);
  });
}
function getFindShareFunction(t0) {
  return t0 === "loaded-first" ? findSingletonVersionOrderByLoaded : findSingletonVersionOrderByVersion;
}
function getRegisteredShare(t0, e0, n0, r0) {
  if (!t0)
    return;
  const { shareConfig: i0, scope: o0 = DEFAULT_SCOPE, strategy: s0 } = n0, a0 = Array.isArray(o0) ? o0 : [
    o0
  ];
  for (const c0 of a0)
    if (i0 && t0[c0] && t0[c0][e0]) {
      const { requiredVersion: l0 } = i0, u0 = getFindShareFunction(s0)(t0, c0, e0), d0 = () => {
        if (i0.singleton) {
          if (typeof l0 == "string" && !satisfy(u0, l0)) {
            const g0 = `Version ${u0} from ${u0 && t0[c0][e0][u0].from} of shared singleton module ${e0} does not satisfy the requirement of ${n0.from} which needs ${l0})`;
            i0.strictVersion ? error(g0) : warn$1(g0);
          }
          return t0[c0][e0][u0];
        } else {
          if (l0 === !1 || l0 === "*" || satisfy(u0, l0))
            return t0[c0][e0][u0];
          for (const [g0, w0] of Object.entries(t0[c0][e0]))
            if (satisfy(g0, l0))
              return w0;
        }
      }, h0 = {
        shareScopeMap: t0,
        scope: c0,
        pkgName: e0,
        version: u0,
        GlobalFederation: Global.__FEDERATION__,
        resolver: d0
      };
      return (r0.emit(h0) || h0).resolver();
    }
}
function getGlobalShareScope() {
  return Global.__FEDERATION__.__SHARE__;
}
function _define_property$3(t0, e0, n0) {
  return e0 in t0 ? Object.defineProperty(t0, e0, {
    value: n0,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t0[e0] = n0, t0;
}
var MANIFEST_EXT = ".json", BROWSER_LOG_KEY = "FEDERATION_DEBUG", BROWSER_LOG_VALUE = "1", NameTransformSymbol = {
  AT: "@",
  HYPHEN: "-",
  SLASH: "/"
}, _obj, NameTransformMap = (_obj = {}, _define_property$3(_obj, NameTransformSymbol.AT, "scope_"), _define_property$3(_obj, NameTransformSymbol.HYPHEN, "_"), _define_property$3(_obj, NameTransformSymbol.SLASH, "__"), _obj), _obj1;
_obj1 = {}, _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.AT], NameTransformSymbol.AT), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.HYPHEN], NameTransformSymbol.HYPHEN), _define_property$3(_obj1, NameTransformMap[NameTransformSymbol.SLASH], NameTransformSymbol.SLASH);
var SEPARATOR$1 = ":";
function isBrowserEnv() {
  return typeof window < "u";
}
function isDebugMode() {
  return typeof process < "u" && process.env && process.env.FEDERATION_DEBUG ? !!process.env.FEDERATION_DEBUG : typeof FEDERATION_DEBUG < "u" && !!FEDERATION_DEBUG;
}
function _array_like_to_array$2(t0, e0) {
  (e0 == null || e0 > t0.length) && (e0 = t0.length);
  for (var n0 = 0, r0 = new Array(e0); n0 < e0; n0++)
    r0[n0] = t0[n0];
  return r0;
}
function _array_without_holes(t0) {
  if (Array.isArray(t0))
    return _array_like_to_array$2(t0);
}
function _class_call_check(t0, e0) {
  if (!(t0 instanceof e0))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(t0, e0) {
  for (var n0 = 0; n0 < e0.length; n0++) {
    var r0 = e0[n0];
    r0.enumerable = r0.enumerable || !1, r0.configurable = !0, "value" in r0 && (r0.writable = !0), Object.defineProperty(t0, r0.key, r0);
  }
}
function _create_class(t0, e0, n0) {
  return e0 && _defineProperties(t0.prototype, e0), n0 && _defineProperties(t0, n0), t0;
}
function _define_property$2(t0, e0, n0) {
  return e0 in t0 ? Object.defineProperty(t0, e0, {
    value: n0,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t0[e0] = n0, t0;
}
function _iterable_to_array$1(t0) {
  if (typeof Symbol < "u" && t0[Symbol.iterator] != null || t0["@@iterator"] != null)
    return Array.from(t0);
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(t0) {
  return _array_without_holes(t0) || _iterable_to_array$1(t0) || _unsupported_iterable_to_array$2(t0) || _non_iterable_spread();
}
function _unsupported_iterable_to_array$2(t0, e0) {
  if (t0) {
    if (typeof t0 == "string")
      return _array_like_to_array$2(t0, e0);
    var n0 = Object.prototype.toString.call(t0).slice(8, -1);
    if (n0 === "Object" && t0.constructor && (n0 = t0.constructor.name), n0 === "Map" || n0 === "Set")
      return Array.from(n0);
    if (n0 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n0))
      return _array_like_to_array$2(t0, e0);
  }
}
function safeToString(t0) {
  try {
    return JSON.stringify(t0, null, 2);
  } catch {
    return "";
  }
}
var DEBUG_LOG = "[ FEDERATION DEBUG ]";
function safeGetLocalStorageItem() {
  try {
    if (typeof window < "u" && window.localStorage)
      return localStorage.getItem(BROWSER_LOG_KEY) === BROWSER_LOG_VALUE;
  } catch {
    return typeof document < "u";
  }
  return !1;
}
var Logger = /* @__PURE__ */ function() {
  function t0(e0) {
    _class_call_check(this, t0), _define_property$2(this, "enable", !1), _define_property$2(this, "identifier", void 0), this.identifier = e0 || DEBUG_LOG, isBrowserEnv() && safeGetLocalStorageItem() ? this.enable = !0 : isDebugMode() && (this.enable = !0);
  }
  return _create_class(t0, [
    {
      key: "info",
      value: function(e0, n0) {
        if (this.enable) {
          var r0 = safeToString(n0) || "";
          isBrowserEnv() ? console.info("%c ".concat(this.identifier, ": ").concat(e0, " ").concat(r0), "color:#3300CC") : console.info("\x1B[34m%s", "".concat(this.identifier, ": ").concat(e0, " ").concat(r0 ? `
`.concat(r0) : ""));
        }
      }
    },
    {
      key: "logOriginalInfo",
      value: function() {
        for (var e0 = arguments.length, n0 = new Array(e0), r0 = 0; r0 < e0; r0++)
          n0[r0] = arguments[r0];
        if (this.enable)
          if (isBrowserEnv()) {
            var i0;
            console.info("%c ".concat(this.identifier, ": OriginalInfo"), "color:#3300CC"), (i0 = console).log.apply(i0, _to_consumable_array(n0));
          } else {
            var o0;
            console.info("%c ".concat(this.identifier, ": OriginalInfo"), "color:#3300CC"), (o0 = console).log.apply(o0, _to_consumable_array(n0));
          }
      }
    }
  ]), t0;
}(), LOG_CATEGORY = "[ Federation Runtime ]";
new Logger();
var composeKeyWithSeparator = function() {
  for (var t0 = arguments.length, e0 = new Array(t0), n0 = 0; n0 < t0; n0++)
    e0[n0] = arguments[n0];
  return e0.length ? e0.reduce(function(r0, i0) {
    return i0 ? r0 ? "".concat(r0).concat(SEPARATOR$1).concat(i0) : i0 : r0;
  }, "") : "";
}, getResourceUrl = function(t0, e0) {
  if ("getPublicPath" in t0) {
    var n0 = new Function(t0.getPublicPath)();
    return "".concat(n0).concat(e0);
  } else
    return "publicPath" in t0 ? "".concat(t0.publicPath).concat(e0) : (console.warn("Can not get resource url, if in debug mode, please ignore", t0, e0), "");
}, warn = function(t0) {
  console.warn("".concat(LOG_CATEGORY, ": ").concat(t0));
};
function _define_property$1(t0, e0, n0) {
  return e0 in t0 ? Object.defineProperty(t0, e0, {
    value: n0,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t0[e0] = n0, t0;
}
function _object_spread$1(t0) {
  for (var e0 = 1; e0 < arguments.length; e0++) {
    var n0 = arguments[e0] != null ? arguments[e0] : {}, r0 = Object.keys(n0);
    typeof Object.getOwnPropertySymbols == "function" && (r0 = r0.concat(Object.getOwnPropertySymbols(n0).filter(function(i0) {
      return Object.getOwnPropertyDescriptor(n0, i0).enumerable;
    }))), r0.forEach(function(i0) {
      _define_property$1(t0, i0, n0[i0]);
    });
  }
  return t0;
}
function ownKeys(t0, e0) {
  var n0 = Object.keys(t0);
  if (Object.getOwnPropertySymbols) {
    var r0 = Object.getOwnPropertySymbols(t0);
    e0 && (r0 = r0.filter(function(i0) {
      return Object.getOwnPropertyDescriptor(t0, i0).enumerable;
    })), n0.push.apply(n0, r0);
  }
  return n0;
}
function _object_spread_props(t0, e0) {
  return e0 = e0 ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(t0, Object.getOwnPropertyDescriptors(e0)) : ownKeys(Object(e0)).forEach(function(n0) {
    Object.defineProperty(t0, n0, Object.getOwnPropertyDescriptor(e0, n0));
  }), t0;
}
var simpleJoinRemoteEntry = function(t0, e0) {
  if (!t0)
    return e0;
  var n0 = function(i0) {
    if (i0 === ".")
      return "";
    if (i0.startsWith("./"))
      return i0.replace("./", "");
    if (i0.startsWith("/")) {
      var o0 = i0.slice(1);
      return o0.endsWith("/") ? o0.slice(0, -1) : o0;
    }
    return i0;
  }, r0 = n0(t0);
  return r0 ? r0.endsWith("/") ? "".concat(r0).concat(e0) : "".concat(r0, "/").concat(e0) : e0;
};
function generateSnapshotFromManifest(t0) {
  var e0 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n0, r0, i0 = e0.remotes, o0 = i0 === void 0 ? {} : i0, s0 = e0.overrides, a0 = s0 === void 0 ? {} : s0, c0 = e0.version, l0, u0 = function() {
    return "publicPath" in t0.metaData ? t0.metaData.publicPath : t0.metaData.getPublicPath;
  }, d0 = Object.keys(a0), h0 = {};
  if (!Object.keys(o0).length) {
    var g0;
    h0 = ((g0 = t0.remotes) === null || g0 === void 0 ? void 0 : g0.reduce(function(I0, f0) {
      var m0, A0 = f0.federationContainerName;
      return d0.includes(A0) ? m0 = a0[A0] : "version" in f0 ? m0 = f0.version : m0 = f0.entry, I0[A0] = {
        matchedVersion: m0
      }, I0;
    }, {})) || {};
  }
  Object.keys(o0).forEach(function(I0) {
    return h0[I0] = {
      matchedVersion: d0.includes(I0) ? a0[I0] : o0[I0]
    };
  });
  var w0 = t0.metaData, y0 = w0.remoteEntry, E0 = y0.path, b0 = y0.name, O0 = y0.type, S0 = w0.types, k0 = w0.buildInfo.buildVersion, D0 = w0.globalName, z0 = t0.exposes, G0 = {
    version: c0 || "",
    buildVersion: k0,
    globalName: D0,
    remoteEntry: simpleJoinRemoteEntry(E0, b0),
    remoteEntryType: O0,
    remoteTypes: simpleJoinRemoteEntry(S0.path, S0.name),
    remoteTypesZip: S0.zip || "",
    remoteTypesAPI: S0.api || "",
    remotesInfo: h0,
    shared: t0?.shared.map(function(I0) {
      return {
        assets: I0.assets,
        sharedName: I0.name
      };
    }),
    modules: z0?.map(function(I0) {
      return {
        moduleName: I0.name,
        modulePath: I0.path,
        assets: I0.assets
      };
    })
  };
  if (!((n0 = t0.metaData) === null || n0 === void 0) && n0.prefetchInterface) {
    var K0 = t0.metaData.prefetchInterface;
    G0 = _object_spread_props(_object_spread$1({}, G0), {
      prefetchInterface: K0
    });
  }
  if (!((r0 = t0.metaData) === null || r0 === void 0) && r0.prefetchEntry) {
    var U0 = t0.metaData.prefetchEntry, F0 = U0.path, H0 = U0.name, P0 = U0.type;
    G0 = _object_spread_props(_object_spread$1({}, G0), {
      prefetchEntry: simpleJoinRemoteEntry(F0, H0),
      prefetchEntryType: P0
    });
  }
  return "publicPath" in t0.metaData ? l0 = _object_spread_props(_object_spread$1({}, G0), {
    publicPath: u0()
  }) : l0 = _object_spread_props(_object_spread$1({}, G0), {
    getPublicPath: u0()
  }), l0;
}
function isManifestProvider(t0) {
  return !!("remoteEntry" in t0 && t0.remoteEntry.includes(MANIFEST_EXT));
}
function asyncGeneratorStep$1(t0, e0, n0, r0, i0, o0, s0) {
  try {
    var a0 = t0[o0](s0), c0 = a0.value;
  } catch (l0) {
    n0(l0);
    return;
  }
  a0.done ? e0(c0) : Promise.resolve(c0).then(r0, i0);
}
function _async_to_generator$1(t0) {
  return function() {
    var e0 = this, n0 = arguments;
    return new Promise(function(r0, i0) {
      var o0 = t0.apply(e0, n0);
      function s0(c0) {
        asyncGeneratorStep$1(o0, r0, i0, s0, a0, "next", c0);
      }
      function a0(c0) {
        asyncGeneratorStep$1(o0, r0, i0, s0, a0, "throw", c0);
      }
      s0(void 0);
    });
  };
}
function _instanceof(t0, e0) {
  return e0 != null && typeof Symbol < "u" && e0[Symbol.hasInstance] ? !!e0[Symbol.hasInstance](t0) : t0 instanceof e0;
}
function _ts_generator$1(t0, e0) {
  var n0, r0, i0, o0, s0 = {
    label: 0,
    sent: function() {
      if (i0[0] & 1)
        throw i0[1];
      return i0[1];
    },
    trys: [],
    ops: []
  };
  return o0 = {
    next: a0(0),
    throw: a0(1),
    return: a0(2)
  }, typeof Symbol == "function" && (o0[Symbol.iterator] = function() {
    return this;
  }), o0;
  function a0(l0) {
    return function(u0) {
      return c0([
        l0,
        u0
      ]);
    };
  }
  function c0(l0) {
    if (n0)
      throw new TypeError("Generator is already executing.");
    for (; s0; )
      try {
        if (n0 = 1, r0 && (i0 = l0[0] & 2 ? r0.return : l0[0] ? r0.throw || ((i0 = r0.return) && i0.call(r0), 0) : r0.next) && !(i0 = i0.call(r0, l0[1])).done)
          return i0;
        switch (r0 = 0, i0 && (l0 = [
          l0[0] & 2,
          i0.value
        ]), l0[0]) {
          case 0:
          case 1:
            i0 = l0;
            break;
          case 4:
            return s0.label++, {
              value: l0[1],
              done: !1
            };
          case 5:
            s0.label++, r0 = l0[1], l0 = [
              0
            ];
            continue;
          case 7:
            l0 = s0.ops.pop(), s0.trys.pop();
            continue;
          default:
            if (i0 = s0.trys, !(i0 = i0.length > 0 && i0[i0.length - 1]) && (l0[0] === 6 || l0[0] === 2)) {
              s0 = 0;
              continue;
            }
            if (l0[0] === 3 && (!i0 || l0[1] > i0[0] && l0[1] < i0[3])) {
              s0.label = l0[1];
              break;
            }
            if (l0[0] === 6 && s0.label < i0[1]) {
              s0.label = i0[1], i0 = l0;
              break;
            }
            if (i0 && s0.label < i0[2]) {
              s0.label = i0[2], s0.ops.push(l0);
              break;
            }
            i0[2] && s0.ops.pop(), s0.trys.pop();
            continue;
        }
        l0 = e0.call(t0, s0);
      } catch (u0) {
        l0 = [
          6,
          u0
        ], r0 = 0;
      } finally {
        n0 = i0 = 0;
      }
    if (l0[0] & 5)
      throw l0[1];
    return {
      value: l0[0] ? l0[1] : void 0,
      done: !0
    };
  }
}
function safeWrapper(t0, e0) {
  return _safeWrapper.apply(this, arguments);
}
function _safeWrapper() {
  return _safeWrapper = _async_to_generator$1(function(t0, e0) {
    var n0, r0;
    return _ts_generator$1(this, function(i0) {
      switch (i0.label) {
        case 0:
          return i0.trys.push([
            0,
            2,
            ,
            3
          ]), [
            4,
            t0()
          ];
        case 1:
          return n0 = i0.sent(), [
            2,
            n0
          ];
        case 2:
          return r0 = i0.sent(), !e0 && warn(r0), [
            2
          ];
        case 3:
          return [
            2
          ];
      }
    });
  }), _safeWrapper.apply(this, arguments);
}
function isStaticResourcesEqual(t0, e0) {
  var n0 = /^(https?:)?\/\//i, r0 = t0.replace(n0, "").replace(/\/$/, ""), i0 = e0.replace(n0, "").replace(/\/$/, "");
  return r0 === i0;
}
function createScript(t0, e0, n0, r0) {
  for (var i0 = null, o0 = !0, s0 = document.getElementsByTagName("script"), a0 = 0; a0 < s0.length; a0++) {
    var c0 = s0[a0], l0 = c0.getAttribute("src");
    if (l0 && isStaticResourcesEqual(l0, t0)) {
      i0 = c0, o0 = !1;
      break;
    }
  }
  if (!i0 && (i0 = document.createElement("script"), i0.type = "text/javascript", i0.src = t0, r0)) {
    var u0 = r0(t0);
    _instanceof(u0, HTMLScriptElement) && (i0 = u0);
  }
  n0 && Object.keys(n0).forEach(function(h0) {
    i0 && (h0 === "async" || h0 === "defer" ? i0[h0] = n0[h0] : i0.setAttribute(h0, n0[h0]));
  });
  var d0 = function(h0, g0) {
    if (i0 && (i0.onerror = null, i0.onload = null, safeWrapper(function() {
      i0 != null && i0.parentNode && i0.parentNode.removeChild(i0);
    }), h0)) {
      var w0 = h0(g0);
      return e0(), w0;
    }
    e0();
  };
  return i0.onerror = d0.bind(null, i0.onerror), i0.onload = d0.bind(null, i0.onload), {
    script: i0,
    needAttach: o0
  };
}
function createLink(t0, e0) {
  for (var n0 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r0 = arguments.length > 3 ? arguments[3] : void 0, i0 = null, o0 = !0, s0 = document.getElementsByTagName("link"), a0 = 0; a0 < s0.length; a0++) {
    var c0 = s0[a0], l0 = c0.getAttribute("href"), u0 = c0.getAttribute("ref");
    if (l0 && isStaticResourcesEqual(l0, t0) && u0 === n0.ref) {
      i0 = c0, o0 = !1;
      break;
    }
  }
  if (!i0 && (i0 = document.createElement("link"), i0.setAttribute("href", t0), r0)) {
    var d0 = r0(t0);
    _instanceof(d0, HTMLLinkElement) && (i0 = d0);
  }
  n0 && Object.keys(n0).forEach(function(g0) {
    i0 && i0.setAttribute(g0, n0[g0]);
  });
  var h0 = function(g0, w0) {
    if (i0 && (i0.onerror = null, i0.onload = null, safeWrapper(function() {
      i0 != null && i0.parentNode && i0.parentNode.removeChild(i0);
    }), g0)) {
      var y0 = g0(w0);
      return e0(), y0;
    }
    e0();
  };
  return i0.onerror = h0.bind(null, i0.onerror), i0.onload = h0.bind(null, i0.onload), {
    link: i0,
    needAttach: o0
  };
}
function loadScript(t0, e0) {
  var n0 = e0.attrs, r0 = e0.createScriptHook;
  return new Promise(function(i0, o0) {
    var s0 = createScript(t0, i0, n0, r0), a0 = s0.script, c0 = s0.needAttach;
    c0 && document.getElementsByTagName("head")[0].appendChild(a0);
  });
}
function _array_like_to_array(t0, e0) {
  (e0 == null || e0 > t0.length) && (e0 = t0.length);
  for (var n0 = 0, r0 = new Array(e0); n0 < e0; n0++)
    r0[n0] = t0[n0];
  return r0;
}
function _array_with_holes(t0) {
  if (Array.isArray(t0))
    return t0;
}
function asyncGeneratorStep(t0, e0, n0, r0, i0, o0, s0) {
  try {
    var a0 = t0[o0](s0), c0 = a0.value;
  } catch (l0) {
    n0(l0);
    return;
  }
  a0.done ? e0(c0) : Promise.resolve(c0).then(r0, i0);
}
function _async_to_generator(t0) {
  return function() {
    var e0 = this, n0 = arguments;
    return new Promise(function(r0, i0) {
      var o0 = t0.apply(e0, n0);
      function s0(c0) {
        asyncGeneratorStep(o0, r0, i0, s0, a0, "next", c0);
      }
      function a0(c0) {
        asyncGeneratorStep(o0, r0, i0, s0, a0, "throw", c0);
      }
      s0(void 0);
    });
  };
}
function _iterable_to_array_limit(t0, e0) {
  var n0 = t0 == null ? null : typeof Symbol < "u" && t0[Symbol.iterator] || t0["@@iterator"];
  if (n0 != null) {
    var r0 = [], i0 = !0, o0 = !1, s0, a0;
    try {
      for (n0 = n0.call(t0); !(i0 = (s0 = n0.next()).done) && (r0.push(s0.value), !(e0 && r0.length === e0)); i0 = !0)
        ;
    } catch (c0) {
      o0 = !0, a0 = c0;
    } finally {
      try {
        !i0 && n0.return != null && n0.return();
      } finally {
        if (o0)
          throw a0;
      }
    }
    return r0;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(t0, e0) {
  return _array_with_holes(t0) || _iterable_to_array_limit(t0, e0) || _unsupported_iterable_to_array(t0, e0) || _non_iterable_rest();
}
function _unsupported_iterable_to_array(t0, e0) {
  if (t0) {
    if (typeof t0 == "string")
      return _array_like_to_array(t0, e0);
    var n0 = Object.prototype.toString.call(t0).slice(8, -1);
    if (n0 === "Object" && t0.constructor && (n0 = t0.constructor.name), n0 === "Map" || n0 === "Set")
      return Array.from(n0);
    if (n0 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n0))
      return _array_like_to_array(t0, e0);
  }
}
function _ts_generator(t0, e0) {
  var n0, r0, i0, o0, s0 = {
    label: 0,
    sent: function() {
      if (i0[0] & 1)
        throw i0[1];
      return i0[1];
    },
    trys: [],
    ops: []
  };
  return o0 = {
    next: a0(0),
    throw: a0(1),
    return: a0(2)
  }, typeof Symbol == "function" && (o0[Symbol.iterator] = function() {
    return this;
  }), o0;
  function a0(l0) {
    return function(u0) {
      return c0([
        l0,
        u0
      ]);
    };
  }
  function c0(l0) {
    if (n0)
      throw new TypeError("Generator is already executing.");
    for (; s0; )
      try {
        if (n0 = 1, r0 && (i0 = l0[0] & 2 ? r0.return : l0[0] ? r0.throw || ((i0 = r0.return) && i0.call(r0), 0) : r0.next) && !(i0 = i0.call(r0, l0[1])).done)
          return i0;
        switch (r0 = 0, i0 && (l0 = [
          l0[0] & 2,
          i0.value
        ]), l0[0]) {
          case 0:
          case 1:
            i0 = l0;
            break;
          case 4:
            return s0.label++, {
              value: l0[1],
              done: !1
            };
          case 5:
            s0.label++, r0 = l0[1], l0 = [
              0
            ];
            continue;
          case 7:
            l0 = s0.ops.pop(), s0.trys.pop();
            continue;
          default:
            if (i0 = s0.trys, !(i0 = i0.length > 0 && i0[i0.length - 1]) && (l0[0] === 6 || l0[0] === 2)) {
              s0 = 0;
              continue;
            }
            if (l0[0] === 3 && (!i0 || l0[1] > i0[0] && l0[1] < i0[3])) {
              s0.label = l0[1];
              break;
            }
            if (l0[0] === 6 && s0.label < i0[1]) {
              s0.label = i0[1], i0 = l0;
              break;
            }
            if (i0 && s0.label < i0[2]) {
              s0.label = i0[2], s0.ops.push(l0);
              break;
            }
            i0[2] && s0.ops.pop(), s0.trys.pop();
            continue;
        }
        l0 = e0.call(t0, s0);
      } catch (u0) {
        l0 = [
          6,
          u0
        ], r0 = 0;
      } finally {
        n0 = i0 = 0;
      }
    if (l0[0] & 5)
      throw l0[1];
    return {
      value: l0[0] ? l0[1] : void 0,
      done: !0
    };
  }
}
function importNodeModule(t0) {
  if (!t0)
    throw new Error("import specifier is required");
  var e0 = new Function("name", "return import(name)");
  return e0(t0).then(function(n0) {
    return n0.default;
  }).catch(function(n0) {
    throw console.error("Error importing module ".concat(t0, ":"), n0), n0;
  });
}
function createScriptNode(url, cb, attrs, createScriptHook) {
  if (createScriptHook) {
    var hookResult = createScriptHook(url);
    hookResult && typeof hookResult == "object" && "url" in hookResult && (url = hookResult.url);
  }
  var urlObj;
  try {
    urlObj = new URL(url);
  } catch (t0) {
    console.error("Error constructing URL:", t0), cb(new Error("Invalid URL: ".concat(t0)));
    return;
  }
  var getFetch = function() {
    var t0 = _async_to_generator(function() {
      var e0;
      return _ts_generator(this, function(n0) {
        switch (n0.label) {
          case 0:
            return typeof fetch > "u" ? [
              4,
              importNodeModule("node-fetch")
            ] : [
              3,
              2
            ];
          case 1:
            return e0 = n0.sent(), [
              2,
              e0?.default || e0
            ];
          case 2:
            return [
              2,
              fetch
            ];
          case 3:
            return [
              2
            ];
        }
      });
    });
    return function() {
      return t0.apply(this, arguments);
    };
  }();
  console.log("fetching", urlObj.href), getFetch().then(function(f) {
    f(urlObj.href).then(function(t0) {
      return t0.text();
    }).then(function() {
      var _ref = _async_to_generator(function(data) {
        var _ref, path, vm, scriptContext, urlDirname, filename, script, exportedInterface, container;
        return _ts_generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                Promise.all([
                  importNodeModule("path"),
                  importNodeModule("vm")
                ])
              ];
            case 1:
              _ref = _sliced_to_array.apply(void 0, [
                _state.sent(),
                2
              ]), path = _ref[0], vm = _ref[1], scriptContext = {
                exports: {},
                module: {
                  exports: {}
                }
              }, urlDirname = urlObj.pathname.split("/").slice(0, -1).join("/"), filename = path.basename(urlObj.pathname);
              try {
                if (script = new vm.Script("(function(exports, module, require, __dirname, __filename) {".concat(data, `
})`), filename), script.runInThisContext()(scriptContext.exports, scriptContext.module, eval("require"), urlDirname, filename), exportedInterface = scriptContext.module.exports || scriptContext.exports, attrs && exportedInterface && attrs.globalName)
                  return container = exportedInterface[attrs.globalName] || exportedInterface, cb(void 0, container), [
                    2
                  ];
                cb(void 0, exportedInterface);
              } catch (t0) {
                cb(new Error("Script execution error: ".concat(t0)));
              }
              return [
                2
              ];
          }
        });
      });
      return function(t0) {
        return _ref.apply(this, arguments);
      };
    }()).catch(function(t0) {
      cb(t0);
    });
  });
}
function loadScriptNode(t0, e0) {
  return new Promise(function(n0, r0) {
    createScriptNode(t0, function(i0, o0) {
      if (i0)
        r0(i0);
      else {
        var s0, a0, c0 = (e0 == null || (s0 = e0.attrs) === null || s0 === void 0 ? void 0 : s0.globalName) || "__FEDERATION_".concat(e0 == null || (a0 = e0.attrs) === null || a0 === void 0 ? void 0 : a0.name, ":custom__"), l0 = globalThis[c0] = o0;
        n0(l0);
      }
    }, e0.attrs, e0.createScriptHook);
  });
}
function matchRemoteWithNameAndExpose(t0, e0) {
  for (const n0 of t0) {
    const r0 = e0.startsWith(n0.name);
    let i0 = e0.replace(n0.name, "");
    if (r0) {
      if (i0.startsWith("/")) {
        const a0 = n0.name;
        return i0 = `.${i0}`, {
          pkgNameOrAlias: a0,
          expose: i0,
          remote: n0
        };
      } else if (i0 === "")
        return {
          pkgNameOrAlias: n0.name,
          expose: ".",
          remote: n0
        };
    }
    const o0 = n0.alias && e0.startsWith(n0.alias);
    let s0 = n0.alias && e0.replace(n0.alias, "");
    if (n0.alias && o0) {
      if (s0 && s0.startsWith("/")) {
        const a0 = n0.alias;
        return s0 = `.${s0}`, {
          pkgNameOrAlias: a0,
          expose: s0,
          remote: n0
        };
      } else if (s0 === "")
        return {
          pkgNameOrAlias: n0.alias,
          expose: ".",
          remote: n0
        };
    }
  }
}
function matchRemote(t0, e0) {
  for (const n0 of t0)
    if (e0 === n0.name || n0.alias && e0 === n0.alias)
      return n0;
}
function registerPlugins(t0, e0) {
  const n0 = getGlobalHostPlugins();
  n0.length > 0 && n0.forEach((r0) => {
    t0 != null && t0.find((i0) => i0.name !== r0.name) && t0.push(r0);
  }), t0 && t0.length > 0 && t0.forEach((r0) => {
    e0.forEach((i0) => {
      i0.applyPlugin(r0);
    });
  });
}
function _extends$5() {
  return _extends$5 = Object.assign || function(t0) {
    for (var e0 = 1; e0 < arguments.length; e0++) {
      var n0 = arguments[e0];
      for (var r0 in n0)
        Object.prototype.hasOwnProperty.call(n0, r0) && (t0[r0] = n0[r0]);
    }
    return t0;
  }, _extends$5.apply(this, arguments);
}
async function loadEsmEntry({ entry: t0, remoteEntryExports: e0 }) {
  return new Promise((n0, r0) => {
    try {
      e0 ? n0(e0) : new Function("callbacks", `import("${t0}").then(callbacks[0]).catch(callbacks[1])`)([
        n0,
        r0
      ]);
    } catch (i0) {
      r0(i0);
    }
  });
}
async function loadEntryScript({ name: t0, globalName: e0, entry: n0, createScriptHook: r0 }) {
  const { entryExports: i0 } = getRemoteEntryExports(t0, e0);
  return i0 || (typeof document > "u" ? loadScriptNode(n0, {
    attrs: {
      name: t0,
      globalName: e0
    },
    createScriptHook: r0
  }).then(() => {
    const { remoteEntryKey: o0, entryExports: s0 } = getRemoteEntryExports(t0, e0);
    return assert$2(s0, `
        Unable to use the ${t0}'s '${n0}' URL with ${o0}'s globalName to get remoteEntry exports.
        Possible reasons could be:

        1. '${n0}' is not the correct URL, or the remoteEntry resource or name is incorrect.

        2. ${o0} cannot be used to get remoteEntry exports in the window object.
      `), s0;
  }).catch((o0) => o0) : loadScript(n0, {
    attrs: {},
    createScriptHook: r0
  }).then(() => {
    const { remoteEntryKey: o0, entryExports: s0 } = getRemoteEntryExports(t0, e0);
    return assert$2(s0, `
      Unable to use the ${t0}'s '${n0}' URL with ${o0}'s globalName to get remoteEntry exports.
      Possible reasons could be:

      1. '${n0}' is not the correct URL, or the remoteEntry resource or name is incorrect.

      2. ${o0} cannot be used to get remoteEntry exports in the window object.
    `), s0;
  }).catch((o0) => o0));
}
function getRemoteEntryUniqueKey(t0) {
  const { entry: e0, name: n0 } = t0;
  return composeKeyWithSeparator(n0, e0);
}
async function getRemoteEntry({ remoteEntryExports: t0, remoteInfo: e0, createScriptHook: n0 }) {
  const { entry: r0, name: i0, type: o0, entryGlobalName: s0 } = e0, a0 = getRemoteEntryUniqueKey(e0);
  return t0 || (globalLoading[a0] || (o0 === "esm" ? globalLoading[a0] = loadEsmEntry({
    entry: r0,
    remoteEntryExports: t0
  }) : globalLoading[a0] = loadEntryScript({
    name: i0,
    globalName: s0,
    entry: r0,
    createScriptHook: n0
  })), globalLoading[a0]);
}
function getRemoteInfo(t0) {
  return _extends$5({}, t0, {
    entry: "entry" in t0 ? t0.entry : "",
    type: t0.type || DEFAULT_REMOTE_TYPE,
    entryGlobalName: t0.entryGlobalName || t0.name,
    shareScope: t0.shareScope || DEFAULT_SCOPE
  });
}
function _extends$4() {
  return _extends$4 = Object.assign || function(t0) {
    for (var e0 = 1; e0 < arguments.length; e0++) {
      var n0 = arguments[e0];
      for (var r0 in n0)
        Object.prototype.hasOwnProperty.call(n0, r0) && (t0[r0] = n0[r0]);
    }
    return t0;
  }, _extends$4.apply(this, arguments);
}
let Module = class {
  async getEntry() {
    if (this.remoteEntryExports)
      return this.remoteEntryExports;
    const t0 = await getRemoteEntry({
      remoteInfo: this.remoteInfo,
      remoteEntryExports: this.remoteEntryExports,
      createScriptHook: (e0) => {
        const n0 = this.host.loaderHook.lifecycle.createScript.emit({
          url: e0
        });
        if (typeof document > "u" || n0 instanceof HTMLScriptElement)
          return n0;
      }
    });
    return assert$2(t0, `remoteEntryExports is undefined 
 ${safeToString$1(this.remoteInfo)}`), this.remoteEntryExports = t0, this.remoteEntryExports;
  }
  async get(t0, e0) {
    const { loadFactory: n0 = !0 } = e0 || {
      loadFactory: !0
    }, r0 = await this.getEntry();
    if (!this.inited) {
      const o0 = this.host.shareScopeMap, s0 = this.remoteInfo.shareScope || "default";
      o0[s0] || (o0[s0] = {});
      const a0 = o0[s0], c0 = [], l0 = {
        version: this.remoteInfo.version || ""
      };
      Object.defineProperty(l0, "hostId", {
        value: this.host.options.id || this.host.name,
        enumerable: !1
      });
      const u0 = await this.host.hooks.lifecycle.beforeInitContainer.emit({
        shareScope: a0,
        remoteEntryInitOptions: l0,
        initScope: c0,
        remoteInfo: this.remoteInfo,
        origin: this.host
      });
      await r0.init(u0.shareScope, u0.initScope, u0.remoteEntryInitOptions), await this.host.hooks.lifecycle.initContainer.emit(_extends$4({}, u0, {
        remoteEntryExports: r0
      }));
    }
    this.lib = r0, this.inited = !0;
    const i0 = await r0.get(t0);
    return assert$2(i0, `${getFMId(this.remoteInfo)} remote don't export ${t0}.`), n0 ? await i0() : i0;
  }
  constructor({ remoteInfo: t0, host: e0 }) {
    this.inited = !1, this.lib = void 0, this.remoteInfo = t0, this.host = e0;
  }
};
class SyncHook {
  on(e0) {
    typeof e0 == "function" && this.listeners.add(e0);
  }
  once(e0) {
    const n0 = this;
    this.on(function r0(...i0) {
      return n0.remove(r0), e0.apply(null, i0);
    });
  }
  emit(...e0) {
    let n0;
    return this.listeners.size > 0 && this.listeners.forEach((r0) => {
      n0 = r0(...e0);
    }), n0;
  }
  remove(e0) {
    this.listeners.delete(e0);
  }
  removeAll() {
    this.listeners.clear();
  }
  constructor(e0) {
    this.type = "", this.listeners = /* @__PURE__ */ new Set(), e0 && (this.type = e0);
  }
}
class AsyncHook extends SyncHook {
  emit(...e0) {
    let n0;
    const r0 = Array.from(this.listeners);
    if (r0.length > 0) {
      let i0 = 0;
      const o0 = (s0) => s0 === !1 ? !1 : i0 < r0.length ? Promise.resolve(r0[i0++].apply(null, e0)).then(o0) : s0;
      n0 = o0();
    }
    return Promise.resolve(n0);
  }
}
function checkReturnData(t0, e0) {
  if (!isObject$2(e0))
    return !1;
  if (t0 !== e0) {
    for (const n0 in t0)
      if (!(n0 in e0))
        return !1;
  }
  return !0;
}
class SyncWaterfallHook extends SyncHook {
  emit(e0) {
    isObject$2(e0) || error(`The data for the "${this.type}" hook should be an object.`);
    for (const n0 of this.listeners)
      try {
        const r0 = n0(e0);
        if (checkReturnData(e0, r0))
          e0 = r0;
        else {
          this.onerror(`A plugin returned an unacceptable value for the "${this.type}" type.`);
          break;
        }
      } catch (r0) {
        warn$1(r0), this.onerror(r0);
      }
    return e0;
  }
  constructor(e0) {
    super(), this.onerror = error, this.type = e0;
  }
}
class AsyncWaterfallHook extends SyncHook {
  emit(e0) {
    isObject$2(e0) || error(`The response data for the "${this.type}" hook must be an object.`);
    const n0 = Array.from(this.listeners);
    if (n0.length > 0) {
      let r0 = 0;
      const i0 = (s0) => (warn$1(s0), this.onerror(s0), e0), o0 = (s0) => {
        if (checkReturnData(e0, s0)) {
          if (e0 = s0, r0 < n0.length)
            try {
              return Promise.resolve(n0[r0++](e0)).then(o0, i0);
            } catch (a0) {
              return i0(a0);
            }
        } else
          this.onerror(`A plugin returned an incorrect value for the "${this.type}" type.`);
        return e0;
      };
      return Promise.resolve(o0(e0));
    }
    return Promise.resolve(e0);
  }
  constructor(e0) {
    super(), this.onerror = error, this.type = e0;
  }
}
class PluginSystem {
  applyPlugin(e0) {
    assert$2(isPlainObject(e0), "Plugin configuration is invalid.");
    const n0 = e0.name;
    assert$2(n0, "A name must be provided by the plugin."), this.registerPlugins[n0] || (this.registerPlugins[n0] = e0, Object.keys(this.lifecycle).forEach((r0) => {
      const i0 = e0[r0];
      i0 && this.lifecycle[r0].on(i0);
    }));
  }
  removePlugin(e0) {
    assert$2(e0, "A name is required.");
    const n0 = this.registerPlugins[e0];
    assert$2(n0, `The plugin "${e0}" is not registered.`), Object.keys(n0).forEach((r0) => {
      r0 !== "name" && this.lifecycle[r0].remove(n0[r0]);
    });
  }
  inherit({ lifecycle: e0, registerPlugins: n0 }) {
    Object.keys(e0).forEach((r0) => {
      assert$2(!this.lifecycle[r0], `The hook "${r0}" has a conflict and cannot be inherited.`), this.lifecycle[r0] = e0[r0];
    }), Object.keys(n0).forEach((r0) => {
      assert$2(!this.registerPlugins[r0], `The plugin "${r0}" has a conflict and cannot be inherited.`), this.applyPlugin(n0[r0]);
    });
  }
  constructor(e0) {
    this.registerPlugins = {}, this.lifecycle = e0, this.lifecycleKeys = Object.keys(e0);
  }
}
function _extends$3() {
  return _extends$3 = Object.assign || function(t0) {
    for (var e0 = 1; e0 < arguments.length; e0++) {
      var n0 = arguments[e0];
      for (var r0 in n0)
        Object.prototype.hasOwnProperty.call(n0, r0) && (t0[r0] = n0[r0]);
    }
    return t0;
  }, _extends$3.apply(this, arguments);
}
function defaultPreloadArgs(t0) {
  return _extends$3({
    resourceCategory: "sync",
    share: !0,
    depsRemote: !0,
    prefetchInterface: !1
  }, t0);
}
function formatPreloadArgs(t0, e0) {
  return e0.map((n0) => {
    const r0 = matchRemote(t0, n0.nameOrAlias);
    return assert$2(r0, `Unable to preload ${n0.nameOrAlias} as it is not included in ${!r0 && safeToString$1({
      remoteInfo: r0,
      remotes: t0
    })}`), {
      remote: r0,
      preloadConfig: defaultPreloadArgs(n0)
    };
  });
}
function normalizePreloadExposes(t0) {
  return t0 ? t0.map((e0) => e0 === "." ? e0 : e0.startsWith("./") ? e0.replace("./", "") : e0) : [];
}
function preloadAssets(t0, e0, n0) {
  const { cssAssets: r0, jsAssetsWithoutEntry: i0, entryAssets: o0 } = n0;
  if (e0.options.inBrowser) {
    o0.forEach((a0) => {
      const { moduleInfo: c0 } = a0, l0 = e0.moduleCache.get(t0.name);
      getRemoteEntry(l0 ? {
        remoteInfo: c0,
        remoteEntryExports: l0.remoteEntryExports,
        createScriptHook: (u0) => {
          const d0 = e0.loaderHook.lifecycle.createScript.emit({
            url: u0
          });
          if (d0 instanceof HTMLScriptElement)
            return d0;
        }
      } : {
        remoteInfo: c0,
        remoteEntryExports: void 0,
        createScriptHook: (u0) => {
          const d0 = e0.loaderHook.lifecycle.createScript.emit({
            url: u0
          });
          if (d0 instanceof HTMLScriptElement)
            return d0;
        }
      });
    });
    const s0 = document.createDocumentFragment();
    r0.forEach((a0) => {
      const { link: c0, needAttach: l0 } = createLink(a0, () => {
      }, {
        rel: "preload",
        as: "style"
      }, (u0) => {
        const d0 = e0.loaderHook.lifecycle.createLink.emit({
          url: u0
        });
        if (d0 instanceof HTMLLinkElement)
          return d0;
      });
      l0 && s0.appendChild(c0);
    }), i0.forEach((a0) => {
      const { link: c0, needAttach: l0 } = createLink(a0, () => {
      }, {
        rel: "preload",
        as: "script"
      }, (u0) => {
        const d0 = e0.loaderHook.lifecycle.createLink.emit({
          url: u0
        });
        if (d0 instanceof HTMLLinkElement)
          return d0;
      });
      l0 && document.head.appendChild(c0);
    }), document.head.appendChild(s0);
  }
}
function _extends$2() {
  return _extends$2 = Object.assign || function(t0) {
    for (var e0 = 1; e0 < arguments.length; e0++) {
      var n0 = arguments[e0];
      for (var r0 in n0)
        Object.prototype.hasOwnProperty.call(n0, r0) && (t0[r0] = n0[r0]);
    }
    return t0;
  }, _extends$2.apply(this, arguments);
}
function assignRemoteInfo(t0, e0) {
  (!("remoteEntry" in e0) || !e0.remoteEntry) && error(`The attribute remoteEntry of ${name} must not be undefined.`);
  const { remoteEntry: n0 } = e0, r0 = getResourceUrl(e0, n0);
  t0.type = e0.remoteEntryType, t0.entryGlobalName = e0.globalName, t0.entry = r0, t0.version = e0.version, t0.buildVersion = e0.buildVersion;
}
function snapshotPlugin() {
  return {
    name: "snapshot-plugin",
    async afterResolve(t0) {
      const { remote: e0, pkgNameOrAlias: n0, expose: r0, origin: i0, remoteInfo: o0 } = t0;
      if (!isRemoteInfoWithEntry(e0) || !isPureRemoteEntry(e0)) {
        const { remoteSnapshot: s0, globalSnapshot: a0 } = await i0.snapshotHandler.loadRemoteSnapshotInfo(e0);
        assignRemoteInfo(o0, s0);
        const c0 = {
          remote: e0,
          preloadConfig: {
            nameOrAlias: n0,
            exposes: [
              r0
            ],
            resourceCategory: "sync",
            share: !1,
            depsRemote: !1
          }
        }, l0 = await i0.hooks.lifecycle.generatePreloadAssets.emit({
          origin: i0,
          preloadOptions: c0,
          remoteInfo: o0,
          remote: e0,
          remoteSnapshot: s0,
          globalSnapshot: a0
        });
        return l0 && preloadAssets(o0, i0, l0), _extends$2({}, t0, {
          remoteSnapshot: s0
        });
      }
      return t0;
    }
  };
}
function splitId(t0) {
  const e0 = t0.split(":");
  return e0.length === 1 ? {
    name: e0[0],
    version: void 0
  } : e0.length === 2 ? {
    name: e0[0],
    version: e0[1]
  } : {
    name: e0[1],
    version: e0[2]
  };
}
function traverseModuleInfo(t0, e0, n0, r0, i0 = {}, o0) {
  const s0 = getFMId(e0), { value: a0 } = getInfoWithoutType(t0, s0), c0 = o0 || a0;
  if (c0 && !isManifestProvider(c0) && (n0(c0, e0, r0), c0.remotesInfo)) {
    const l0 = Object.keys(c0.remotesInfo);
    for (const u0 of l0) {
      if (i0[u0])
        continue;
      i0[u0] = !0;
      const d0 = splitId(u0), h0 = c0.remotesInfo[u0];
      traverseModuleInfo(t0, {
        name: d0.name,
        version: h0.matchedVersion
      }, n0, !1, i0, void 0);
    }
  }
}
function generatePreloadAssets(t0, e0, n0, r0, i0) {
  const o0 = [], s0 = [], a0 = [], c0 = /* @__PURE__ */ new Set(), l0 = /* @__PURE__ */ new Set(), { options: u0 } = t0, { preloadConfig: d0 } = e0, { depsRemote: h0 } = d0;
  traverseModuleInfo(r0, n0, (w0, y0, E0) => {
    let b0;
    if (E0)
      b0 = d0;
    else if (Array.isArray(h0)) {
      const G0 = h0.find((K0) => K0.nameOrAlias === y0.name || K0.nameOrAlias === y0.alias);
      if (!G0)
        return;
      b0 = defaultPreloadArgs(G0);
    } else if (h0 === !0)
      b0 = d0;
    else
      return;
    const O0 = getResourceUrl(w0, "remoteEntry" in w0 ? w0.remoteEntry : "");
    O0 && a0.push({
      name: y0.name,
      moduleInfo: {
        name: y0.name,
        entry: O0,
        type: "remoteEntryType" in w0 ? w0.remoteEntryType : "global",
        entryGlobalName: "globalName" in w0 ? w0.globalName : y0.name,
        shareScope: "",
        version: "version" in w0 ? w0.version : void 0
      },
      url: O0
    });
    let S0 = "modules" in w0 ? w0.modules : [];
    const k0 = normalizePreloadExposes(b0.exposes);
    if (k0.length && "modules" in w0) {
      var D0;
      S0 = w0 == null || (D0 = w0.modules) == null ? void 0 : D0.reduce((G0, K0) => (k0?.indexOf(K0.moduleName) !== -1 && G0.push(K0), G0), []);
    }
    function z0(G0) {
      const K0 = G0.map((U0) => getResourceUrl(w0, U0));
      return b0.filter ? K0.filter(b0.filter) : K0;
    }
    if (S0) {
      const G0 = S0.length;
      for (let K0 = 0; K0 < G0; K0++) {
        const U0 = S0[K0], F0 = `${y0.name}/${U0.moduleName}`;
        t0.hooks.lifecycle.handlePreloadModule.emit({
          id: U0.moduleName === "." ? y0.name : F0,
          name: y0.name,
          remoteSnapshot: w0,
          preloadConfig: b0,
          remote: y0,
          origin: t0
        }), !getPreloaded(F0) && (b0.resourceCategory === "all" ? (o0.push(...z0(U0.assets.css.async)), o0.push(...z0(U0.assets.css.sync)), s0.push(...z0(U0.assets.js.async)), s0.push(...z0(U0.assets.js.sync))) : (b0.resourceCategory = "sync") && (o0.push(...z0(U0.assets.css.sync)), s0.push(...z0(U0.assets.js.sync))), setPreloaded(F0));
      }
    }
  }, !0, {}, i0), i0.shared && i0.shared.forEach((w0) => {
    var y0;
    const E0 = (y0 = u0.shared) == null ? void 0 : y0[w0.sharedName];
    if (!E0)
      return;
    const b0 = getRegisteredShare(t0.shareScopeMap, w0.sharedName, E0, t0.hooks.lifecycle.resolveShare);
    b0 && typeof b0.lib == "function" && (w0.assets.js.sync.forEach((O0) => {
      c0.add(O0);
    }), w0.assets.css.sync.forEach((O0) => {
      l0.add(O0);
    }));
  });
  const g0 = s0.filter((w0) => !c0.has(w0));
  return {
    cssAssets: o0.filter((w0) => !l0.has(w0)),
    jsAssetsWithoutEntry: g0,
    entryAssets: a0
  };
}
const generatePreloadAssetsPlugin = function() {
  return {
    name: "generate-preload-assets-plugin",
    async generatePreloadAssets(t0) {
      const { origin: e0, preloadOptions: n0, remoteInfo: r0, remote: i0, globalSnapshot: o0, remoteSnapshot: s0 } = t0;
      return isRemoteInfoWithEntry(i0) && isPureRemoteEntry(i0) ? {
        cssAssets: [],
        jsAssetsWithoutEntry: [],
        entryAssets: [
          {
            name: i0.name,
            url: i0.entry,
            moduleInfo: {
              name: r0.name,
              entry: i0.entry,
              type: "global",
              entryGlobalName: "",
              shareScope: ""
            }
          }
        ]
      } : (assignRemoteInfo(r0, s0), generatePreloadAssets(e0, n0, r0, o0, s0));
    }
  };
};
function _extends$1() {
  return _extends$1 = Object.assign || function(t0) {
    for (var e0 = 1; e0 < arguments.length; e0++) {
      var n0 = arguments[e0];
      for (var r0 in n0)
        Object.prototype.hasOwnProperty.call(n0, r0) && (t0[r0] = n0[r0]);
    }
    return t0;
  }, _extends$1.apply(this, arguments);
}
class SnapshotHandler {
  async loadSnapshot(e0) {
    const { options: n0 } = this.HostInstance, { hostGlobalSnapshot: r0, remoteSnapshot: i0, globalSnapshot: o0 } = this.getGlobalRemoteInfo(e0), { remoteSnapshot: s0, globalSnapshot: a0 } = await this.hooks.lifecycle.loadSnapshot.emit({
      options: n0,
      moduleInfo: e0,
      hostGlobalSnapshot: r0,
      remoteSnapshot: i0,
      globalSnapshot: o0
    });
    return {
      remoteSnapshot: s0,
      globalSnapshot: a0
    };
  }
  async loadRemoteSnapshotInfo(e0) {
    const { options: n0 } = this.HostInstance;
    await this.hooks.lifecycle.beforeLoadRemoteSnapshot.emit({
      options: n0,
      moduleInfo: e0
    });
    let r0 = getGlobalSnapshotInfoByModuleInfo({
      name: this.HostInstance.options.name,
      version: this.HostInstance.options.version
    });
    r0 || (r0 = {
      version: this.HostInstance.options.version || "",
      remoteEntry: "",
      remotesInfo: {}
    }, addGlobalSnapshot({
      [this.HostInstance.options.name]: r0
    })), r0 && "remotesInfo" in r0 && !getInfoWithoutType(r0.remotesInfo, e0.name).value && ("version" in e0 || "entry" in e0) && (r0.remotesInfo = _extends$1({}, r0?.remotesInfo, {
      [e0.name]: {
        matchedVersion: "version" in e0 ? e0.version : e0.entry
      }
    }));
    const { hostGlobalSnapshot: i0, remoteSnapshot: o0, globalSnapshot: s0 } = this.getGlobalRemoteInfo(e0), { remoteSnapshot: a0, globalSnapshot: c0 } = await this.hooks.lifecycle.loadSnapshot.emit({
      options: n0,
      moduleInfo: e0,
      hostGlobalSnapshot: i0,
      remoteSnapshot: o0,
      globalSnapshot: s0
    });
    if (a0)
      if (isManifestProvider(a0)) {
        const l0 = await this.getManifestJson(a0.remoteEntry, e0, {}), u0 = setGlobalSnapshotInfoByModuleInfo(_extends$1({}, e0, {
          entry: a0.remoteEntry
        }), l0);
        return {
          remoteSnapshot: l0,
          globalSnapshot: u0
        };
      } else {
        const { remoteSnapshot: l0 } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
          options: this.HostInstance.options,
          moduleInfo: e0,
          remoteSnapshot: a0,
          from: "global"
        });
        return {
          remoteSnapshot: l0,
          globalSnapshot: c0
        };
      }
    else if (isRemoteInfoWithEntry(e0)) {
      const l0 = await this.getManifestJson(e0.entry, e0, {}), u0 = setGlobalSnapshotInfoByModuleInfo(e0, l0), { remoteSnapshot: d0 } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
        options: this.HostInstance.options,
        moduleInfo: e0,
        remoteSnapshot: l0,
        from: "global"
      });
      return {
        remoteSnapshot: d0,
        globalSnapshot: u0
      };
    } else
      error(`
          Cannot get remoteSnapshot with the name: '${e0.name}', version: '${e0.version}' from __FEDERATION__.moduleInfo. The following reasons may be causing the problem:

          1. The Deploy platform did not deliver the correct data. You can use __FEDERATION__.moduleInfo to check the remoteInfo.

          2. The remote '${e0.name}' version '${e0.version}' is not released.

          The transformed module info: ${JSON.stringify(c0)}
        `);
  }
  getGlobalRemoteInfo(e0) {
    const n0 = getGlobalSnapshotInfoByModuleInfo({
      name: this.HostInstance.options.name,
      version: this.HostInstance.options.version
    }), r0 = n0 && "remotesInfo" in n0 && n0.remotesInfo && getInfoWithoutType(n0.remotesInfo, e0.name).value;
    return r0 && r0.matchedVersion ? {
      hostGlobalSnapshot: n0,
      globalSnapshot: getGlobalSnapshot(),
      remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({
        name: e0.name,
        version: r0.matchedVersion
      })
    } : {
      hostGlobalSnapshot: void 0,
      globalSnapshot: getGlobalSnapshot(),
      remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({
        name: e0.name,
        version: "version" in e0 ? e0.version : void 0
      })
    };
  }
  async getManifestJson(e0, n0, r0) {
    const i0 = async () => {
      let s0 = this.manifestCache.get(e0);
      if (s0)
        return s0;
      try {
        let a0 = await this.loaderHook.lifecycle.fetch.emit(e0, {});
        return (!a0 || !(a0 instanceof Response)) && (a0 = await fetch(e0, {})), s0 = await a0.json(), assert$2(s0.metaData && s0.exposes && s0.shared, `${e0} is not a federation manifest`), this.manifestCache.set(e0, s0), s0;
      } catch (a0) {
        error(`Failed to get manifestJson for ${n0.name}. The manifest URL is ${e0}. Please ensure that the manifestUrl is accessible.
          
 Error message:
          
 ${a0}`);
      }
    }, o0 = async () => {
      const s0 = await i0(), a0 = generateSnapshotFromManifest(s0, {
        version: e0
      }), { remoteSnapshot: c0 } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({
        options: this.HostInstance.options,
        moduleInfo: n0,
        manifestJson: s0,
        remoteSnapshot: a0,
        manifestUrl: e0,
        from: "manifest"
      });
      return c0;
    };
    return this.manifestLoading[e0] || (this.manifestLoading[e0] = o0().then((s0) => s0)), this.manifestLoading[e0];
  }
  constructor(e0) {
    this.loadingHostSnapshot = null, this.manifestCache = /* @__PURE__ */ new Map(), this.hooks = new PluginSystem({
      beforeLoadRemoteSnapshot: new AsyncHook("beforeLoadRemoteSnapshot"),
      loadSnapshot: new AsyncWaterfallHook("loadGlobalSnapshot"),
      loadRemoteSnapshot: new AsyncWaterfallHook("loadRemoteSnapshot")
    }), this.manifestLoading = Global.__FEDERATION__.__MANIFEST_LOADING__, this.HostInstance = e0, this.loaderHook = e0.loaderHook;
  }
}
function _extends() {
  return _extends = Object.assign || function(t0) {
    for (var e0 = 1; e0 < arguments.length; e0++) {
      var n0 = arguments[e0];
      for (var r0 in n0)
        Object.prototype.hasOwnProperty.call(n0, r0) && (t0[r0] = n0[r0]);
    }
    return t0;
  }, _extends.apply(this, arguments);
}
function _object_without_properties_loose(t0, e0) {
  if (t0 == null)
    return {};
  var n0 = {}, r0 = Object.keys(t0), i0, o0;
  for (o0 = 0; o0 < r0.length; o0++)
    i0 = r0[o0], !(e0.indexOf(i0) >= 0) && (n0[i0] = t0[i0]);
  return n0;
}
class FederationHost {
  _setGlobalShareScopeMap() {
    const e0 = getGlobalShareScope(), n0 = this.options.id || this.options.name;
    n0 && !e0[n0] && (e0[n0] = this.shareScopeMap);
  }
  initOptions(e0) {
    this.registerPlugins(e0.plugins);
    const n0 = this.formatOptions(this.options, e0);
    return this.options = n0, n0;
  }
  async loadShare(e0, n0) {
    var r0;
    const i0 = Object.assign({}, (r0 = this.options.shared) == null ? void 0 : r0[e0], n0);
    i0 != null && i0.scope && await Promise.all(i0.scope.map(async (l0) => {
      await Promise.all(this.initializeSharing(l0, i0.strategy));
    }));
    const o0 = await this.hooks.lifecycle.beforeLoadShare.emit({
      pkgName: e0,
      shareInfo: i0,
      shared: this.options.shared,
      origin: this
    }), { shareInfo: s0 } = o0;
    assert$2(s0, `Cannot find ${e0} Share in the ${this.options.name}. Please ensure that the ${e0} Share parameters have been injected`);
    const a0 = getRegisteredShare(this.shareScopeMap, e0, s0, this.hooks.lifecycle.resolveShare), c0 = (l0) => {
      l0.useIn || (l0.useIn = []), addUniqueItem(l0.useIn, this.options.name);
    };
    if (a0 && a0.lib)
      return c0(a0), a0.lib;
    if (a0 && a0.loading && !a0.loaded) {
      const l0 = await a0.loading;
      return a0.loaded = !0, a0.lib || (a0.lib = l0), c0(a0), l0;
    } else if (a0) {
      const l0 = (async () => {
        const u0 = await a0.get();
        s0.lib = u0, s0.loaded = !0, c0(s0);
        const d0 = getRegisteredShare(this.shareScopeMap, e0, s0, this.hooks.lifecycle.resolveShare);
        return d0 && (d0.lib = u0, d0.loaded = !0), u0;
      })();
      return this.setShared({
        pkgName: e0,
        loaded: !1,
        shared: a0,
        from: this.options.name,
        lib: null,
        loading: l0
      }), l0;
    } else {
      if (n0)
        return !1;
      const l0 = (async () => {
        const u0 = await s0.get();
        s0.lib = u0, s0.loaded = !0, c0(s0);
        const d0 = getRegisteredShare(this.shareScopeMap, e0, s0, this.hooks.lifecycle.resolveShare);
        return d0 && (d0.lib = u0, d0.loaded = !0), u0;
      })();
      return this.setShared({
        pkgName: e0,
        loaded: !1,
        shared: s0,
        from: this.options.name,
        lib: null,
        loading: l0
      }), l0;
    }
  }
  loadShareSync(e0, n0) {
    var r0;
    const i0 = Object.assign({}, (r0 = this.options.shared) == null ? void 0 : r0[e0], n0);
    i0 != null && i0.scope && i0.scope.forEach((a0) => {
      this.initializeSharing(a0, i0.strategy);
    });
    const o0 = getRegisteredShare(this.shareScopeMap, e0, i0, this.hooks.lifecycle.resolveShare), s0 = (a0) => {
      a0.useIn || (a0.useIn = []), addUniqueItem(a0.useIn, this.options.name);
    };
    if (o0) {
      if (typeof o0.lib == "function")
        return s0(o0), o0.loaded || (o0.loaded = !0, o0.from === this.options.name && (i0.loaded = !0)), o0.lib;
      if (typeof o0.get == "function") {
        const a0 = o0.get();
        if (!(a0 instanceof Promise))
          return s0(o0), this.setShared({
            pkgName: e0,
            loaded: !0,
            from: this.options.name,
            lib: a0,
            shared: o0
          }), a0;
      }
    }
    if (i0.lib)
      return i0.loaded || (i0.loaded = !0), i0.lib;
    if (i0.get) {
      const a0 = i0.get();
      if (a0 instanceof Promise)
        throw new Error(`
        The loadShareSync function was unable to load ${e0}. The ${e0} could not be found in ${this.options.name}.
        Possible reasons for failure: 

        1. The ${e0} share was registered with the 'get' attribute, but loadShare was not used beforehand.

        2. The ${e0} share was not registered with the 'lib' attribute.

      `);
      return i0.lib = a0, this.setShared({
        pkgName: e0,
        loaded: !0,
        from: this.options.name,
        lib: i0.lib,
        shared: i0
      }), i0.lib;
    }
    throw new Error(`
        The loadShareSync function was unable to load ${e0}. The ${e0} could not be found in ${this.options.name}.
        Possible reasons for failure: 

        1. The ${e0} share was registered with the 'get' attribute, but loadShare was not used beforehand.

        2. The ${e0} share was not registered with the 'lib' attribute.

      `);
  }
  initRawContainer(e0, n0, r0) {
    const i0 = getRemoteInfo({
      name: e0,
      entry: n0
    }), o0 = new Module({
      host: this,
      remoteInfo: i0
    });
    return o0.remoteEntryExports = r0, this.moduleCache.set(e0, o0), o0;
  }
  async _getRemoteModuleAndOptions(e0) {
    const n0 = await this.hooks.lifecycle.beforeRequest.emit({
      id: e0,
      options: this.options,
      origin: this
    }), { id: r0 } = n0, i0 = matchRemoteWithNameAndExpose(this.options.remotes, r0);
    assert$2(i0, `
        Unable to locate ${r0} in ${this.options.name}. Potential reasons for failure include:

        1. ${r0} was not included in the 'remotes' parameter of ${this.options.name || "the host"}.

        2. ${r0} could not be found in the 'remotes' of ${this.options.name} with either 'name' or 'alias' attributes.
        3. ${r0} is not online, injected, or loaded.
        4. ${r0}  cannot be accessed on the expected.
        5. The 'beforeRequest' hook was provided but did not return the correct 'remoteInfo' when attempting to load ${r0}.
      `);
    const { remote: o0 } = i0, s0 = getRemoteInfo(o0), a0 = await this.hooks.lifecycle.afterResolve.emit(_extends({
      id: r0
    }, i0, {
      options: this.options,
      origin: this,
      remoteInfo: s0
    })), { remote: c0, expose: l0 } = a0;
    assert$2(c0 && l0, `The 'beforeRequest' hook was executed, but it failed to return the correct 'remote' and 'expose' values while loading ${r0}.`);
    let u0 = this.moduleCache.get(c0.name);
    const d0 = {
      host: this,
      remoteInfo: s0
    };
    return u0 || (u0 = new Module(d0), this.moduleCache.set(c0.name, u0)), {
      module: u0,
      moduleOptions: d0,
      remoteMatchInfo: a0
    };
  }
  async loadRemote(e0, n0) {
    try {
      const { loadFactory: r0 = !0 } = n0 || {
        loadFactory: !0
      }, { module: i0, moduleOptions: o0, remoteMatchInfo: s0 } = await this._getRemoteModuleAndOptions(e0), { pkgNameOrAlias: a0, remote: c0, expose: l0, id: u0 } = s0, d0 = await i0.get(l0, n0), h0 = await this.hooks.lifecycle.onLoad.emit({
        id: u0,
        pkgNameOrAlias: a0,
        expose: l0,
        exposeModule: r0 ? d0 : void 0,
        exposeModuleFactory: r0 ? void 0 : d0,
        remote: c0,
        options: o0,
        moduleInstance: i0,
        origin: this
      });
      return typeof h0 == "function" ? h0 : d0;
    } catch (r0) {
      const { from: i0 = "runtime" } = n0 || {
        from: "runtime"
      }, o0 = await this.hooks.lifecycle.errorLoadRemote.emit({
        id: e0,
        error: r0,
        from: i0,
        origin: this
      });
      if (!o0)
        throw r0;
      return o0;
    }
  }
  async preloadRemote(e0) {
    await this.hooks.lifecycle.beforePreloadRemote.emit({
      preloadOptions: e0,
      options: this.options,
      origin: this
    });
    const n0 = formatPreloadArgs(this.options.remotes, e0);
    await Promise.all(n0.map(async (r0) => {
      const { remote: i0 } = r0, o0 = getRemoteInfo(i0), { globalSnapshot: s0, remoteSnapshot: a0 } = await this.snapshotHandler.loadRemoteSnapshotInfo(i0), c0 = await this.hooks.lifecycle.generatePreloadAssets.emit({
        origin: this,
        preloadOptions: r0,
        remote: i0,
        remoteInfo: o0,
        globalSnapshot: s0,
        remoteSnapshot: a0
      });
      !c0 || preloadAssets(o0, this, c0);
    }));
  }
  initializeSharing(e0 = DEFAULT_SCOPE, n0) {
    const r0 = this.shareScopeMap, i0 = this.options.name;
    r0[e0] || (r0[e0] = {});
    const o0 = r0[e0], s0 = (u0, d0) => {
      var h0;
      const { version: g0, eager: w0 } = d0;
      o0[u0] = o0[u0] || {};
      const y0 = o0[u0], E0 = y0[g0], b0 = !!(E0 && (E0.eager || (h0 = E0.shareConfig) != null && h0.eager));
      (!E0 || E0.strategy !== "loaded-first" && !E0.loaded && (!w0 != !b0 ? w0 : i0 > E0.from)) && (y0[g0] = d0);
    }, a0 = [], c0 = (u0) => u0 && u0.init && u0.init(r0[e0]), l0 = async (u0) => {
      const { module: d0 } = await this._getRemoteModuleAndOptions(u0);
      if (d0.getEntry) {
        const h0 = await d0.getEntry();
        d0.inited || (c0(h0), d0.inited = !0);
      }
    };
    return Object.keys(this.options.shared).forEach((u0) => {
      const d0 = this.options.shared[u0];
      d0.scope.includes(e0) && s0(u0, d0);
    }), n0 === "version-first" && this.options.remotes.forEach((u0) => {
      u0.shareScope === e0 && a0.push(l0(u0.name));
    }), a0;
  }
  initShareScopeMap(e0, n0) {
    this.shareScopeMap[e0] = n0, this.hooks.lifecycle.initContainerShareScopeMap.emit({
      shareScope: n0,
      options: this.options,
      origin: this
    });
  }
  formatOptions(e0, n0) {
    const r0 = formatShareConfigs(n0.shared || {}, n0.name), i0 = _extends({}, e0.shared, r0), { userOptions: o0, options: s0 } = this.hooks.lifecycle.beforeInit.emit({
      origin: this,
      userOptions: n0,
      options: e0,
      shareInfo: i0
    }), a0 = (o0.remotes || []).reduce((u0, d0) => (this.registerRemote(d0, u0, {
      force: !1
    }), u0), s0.remotes);
    Object.keys(r0).forEach((u0) => {
      const d0 = r0[u0];
      !getRegisteredShare(this.shareScopeMap, u0, d0, this.hooks.lifecycle.resolveShare) && d0 && d0.lib && this.setShared({
        pkgName: u0,
        lib: d0.lib,
        get: d0.get,
        loaded: !0,
        shared: d0,
        from: n0.name
      });
    });
    const c0 = [
      ...s0.plugins
    ];
    o0.plugins && o0.plugins.forEach((u0) => {
      c0.includes(u0) || c0.push(u0);
    });
    const l0 = _extends({}, e0, n0, {
      plugins: c0,
      remotes: a0,
      shared: i0
    });
    return this.hooks.lifecycle.init.emit({
      origin: this,
      options: l0
    }), l0;
  }
  registerPlugins(e0) {
    registerPlugins(e0, [
      this.hooks,
      this.snapshotHandler.hooks,
      this.loaderHook
    ]);
  }
  setShared({ pkgName: e0, shared: n0, from: r0, lib: i0, loading: o0, loaded: s0, get: a0 }) {
    const { version: c0, scope: l0 = "default" } = n0, u0 = _object_without_properties_loose(n0, [
      "version",
      "scope"
    ]);
    (Array.isArray(l0) ? l0 : [
      l0
    ]).forEach((d0) => {
      this.shareScopeMap[d0] || (this.shareScopeMap[d0] = {}), this.shareScopeMap[d0][e0] || (this.shareScopeMap[d0][e0] = {}), !this.shareScopeMap[d0][e0][c0] && (this.shareScopeMap[d0][e0][c0] = _extends({
        version: c0,
        scope: [
          "default"
        ]
      }, u0, {
        lib: i0,
        loaded: s0,
        loading: o0
      }), a0 && (this.shareScopeMap[d0][e0][c0].get = a0));
    });
  }
  removeRemote(e0) {
    const { name: n0 } = e0, r0 = this.options.remotes.findIndex((o0) => o0.name === n0);
    r0 !== -1 && this.options.remotes.splice(r0, 1);
    const i0 = this.moduleCache.get(e0.name);
    if (i0) {
      const o0 = i0.remoteInfo.entryGlobalName;
      globalThis[o0] && delete globalThis[o0];
      const s0 = getRemoteEntryUniqueKey(i0.remoteInfo);
      globalLoading[s0] && delete globalLoading[s0], this.moduleCache.delete(e0.name);
    }
  }
  registerRemote(e0, n0, r0) {
    const i0 = () => {
      if (e0.alias) {
        const s0 = n0.find((a0) => {
          var c0;
          return e0.alias && (a0.name.startsWith(e0.alias) || ((c0 = a0.alias) == null ? void 0 : c0.startsWith(e0.alias)));
        });
        assert$2(!s0, `The alias ${e0.alias} of remote ${e0.name} is not allowed to be the prefix of ${s0 && s0.name} name or alias`);
      }
      "entry" in e0 && isBrowserEnv$1() && !e0.entry.startsWith("http") && (e0.entry = new URL(e0.entry, window.location.origin).href), e0.shareScope || (e0.shareScope = DEFAULT_SCOPE), e0.type || (e0.type = DEFAULT_REMOTE_TYPE);
    }, o0 = n0.find((s0) => s0.name === e0.name);
    if (!o0)
      i0(), n0.push(e0);
    else {
      const s0 = [
        `The remote "${e0.name}" is already registered.`,
        r0 != null && r0.force ? "Hope you have known that OVERRIDE it may have some unexpected errors" : 'If you want to merge the remote, you can set "force: true".'
      ];
      r0 != null && r0.force && (this.removeRemote(o0), i0(), n0.push(e0)), warn$1(s0.join(" "));
    }
  }
  registerRemotes(e0, n0) {
    e0.forEach((r0) => {
      this.registerRemote(r0, this.options.remotes, {
        force: n0?.force
      });
    });
  }
  constructor(e0) {
    this.hooks = new PluginSystem({
      beforeInit: new SyncWaterfallHook("beforeInit"),
      init: new SyncHook(),
      beforeRequest: new AsyncWaterfallHook("beforeRequest"),
      afterResolve: new AsyncWaterfallHook("afterResolve"),
      beforeInitContainer: new AsyncWaterfallHook("beforeInitContainer"),
      initContainerShareScopeMap: new AsyncWaterfallHook("initContainer"),
      initContainer: new AsyncWaterfallHook("initContainer"),
      onLoad: new AsyncHook("onLoad"),
      handlePreloadModule: new SyncHook("handlePreloadModule"),
      errorLoadRemote: new AsyncHook("errorLoadRemote"),
      beforeLoadShare: new AsyncWaterfallHook("beforeLoadShare"),
      loadShare: new AsyncHook(),
      resolveShare: new SyncWaterfallHook("resolveShare"),
      beforePreloadRemote: new AsyncHook(),
      generatePreloadAssets: new AsyncHook("generatePreloadAssets"),
      afterPreloadRemote: new AsyncHook()
    }), this.version = "0.1.2", this.moduleCache = /* @__PURE__ */ new Map(), this.loaderHook = new PluginSystem({
      getModuleInfo: new SyncHook(),
      createScript: new SyncHook(),
      createLink: new SyncHook(),
      fetch: new AsyncHook("fetch")
    });
    const n0 = {
      id: getBuilderId(),
      name: e0.name,
      plugins: [
        snapshotPlugin(),
        generatePreloadAssetsPlugin()
      ],
      remotes: [],
      shared: {},
      inBrowser: isBrowserEnv$1()
    };
    this.name = e0.name, this.options = n0, this.shareScopeMap = {}, this._setGlobalShareScopeMap(), this.snapshotHandler = new SnapshotHandler(this), this.registerPlugins([
      ...n0.plugins,
      ...e0.plugins || []
    ]), this.options = this.formatOptions(n0, e0);
  }
}
let FederationInstance = null;
function init(t0) {
  const e0 = getGlobalFederationInstance(t0.name, t0.version);
  if (e0)
    return e0.initOptions(t0), FederationInstance || (FederationInstance = e0), e0;
  {
    const n0 = getGlobalFederationConstructor() || FederationHost;
    return FederationInstance = new n0(t0), setGlobalFederationInstance(FederationInstance), FederationInstance;
  }
}
function loadRemote(...t0) {
  return assert$2(FederationInstance, "Please call init first"), FederationInstance.loadRemote.apply(FederationInstance, t0);
}
setGlobalFederationConstructor(FederationHost);
function __awaiter(t0, e0, n0, r0) {
  function i0(o0) {
    return o0 instanceof n0 ? o0 : new n0(function(s0) {
      s0(o0);
    });
  }
  return new (n0 || (n0 = Promise))(function(o0, s0) {
    function a0(u0) {
      try {
        l0(r0.next(u0));
      } catch (d0) {
        s0(d0);
      }
    }
    function c0(u0) {
      try {
        l0(r0.throw(u0));
      } catch (d0) {
        s0(d0);
      }
    }
    function l0(u0) {
      u0.done ? o0(u0.value) : i0(u0.value).then(a0, c0);
    }
    l0((r0 = r0.apply(t0, e0 || [])).next());
  });
}
function __generator(t0, e0) {
  var n0 = { label: 0, sent: function() {
    if (o0[0] & 1)
      throw o0[1];
    return o0[1];
  }, trys: [], ops: [] }, r0, i0, o0, s0;
  return s0 = { next: a0(0), throw: a0(1), return: a0(2) }, typeof Symbol == "function" && (s0[Symbol.iterator] = function() {
    return this;
  }), s0;
  function a0(l0) {
    return function(u0) {
      return c0([l0, u0]);
    };
  }
  function c0(l0) {
    if (r0)
      throw new TypeError("Generator is already executing.");
    for (; n0; )
      try {
        if (r0 = 1, i0 && (o0 = l0[0] & 2 ? i0.return : l0[0] ? i0.throw || ((o0 = i0.return) && o0.call(i0), 0) : i0.next) && !(o0 = o0.call(i0, l0[1])).done)
          return o0;
        switch (i0 = 0, o0 && (l0 = [l0[0] & 2, o0.value]), l0[0]) {
          case 0:
          case 1:
            o0 = l0;
            break;
          case 4:
            return n0.label++, { value: l0[1], done: !1 };
          case 5:
            n0.label++, i0 = l0[1], l0 = [0];
            continue;
          case 7:
            l0 = n0.ops.pop(), n0.trys.pop();
            continue;
          default:
            if (o0 = n0.trys, !(o0 = o0.length > 0 && o0[o0.length - 1]) && (l0[0] === 6 || l0[0] === 2)) {
              n0 = 0;
              continue;
            }
            if (l0[0] === 3 && (!o0 || l0[1] > o0[0] && l0[1] < o0[3])) {
              n0.label = l0[1];
              break;
            }
            if (l0[0] === 6 && n0.label < o0[1]) {
              n0.label = o0[1], o0 = l0;
              break;
            }
            if (o0 && n0.label < o0[2]) {
              n0.label = o0[2], n0.ops.push(l0);
              break;
            }
            o0[2] && n0.ops.pop(), n0.trys.pop();
            continue;
        }
        l0 = e0.call(t0, n0);
      } catch (u0) {
        l0 = [6, u0], i0 = 0;
      } finally {
        r0 = o0 = 0;
      }
    if (l0[0] & 5)
      throw l0[1];
    return { value: l0[0] ? l0[1] : void 0, done: !0 };
  }
}
var E_CANCELED = new Error("request for lock canceled"), Semaphore = function() {
  function t0(e0, n0) {
    n0 === void 0 && (n0 = E_CANCELED), this._value = e0, this._cancelError = n0, this._queue = [], this._weightedWaiters = [];
  }
  return t0.prototype.acquire = function(e0, n0) {
    var r0 = this;
    if (e0 === void 0 && (e0 = 1), n0 === void 0 && (n0 = 0), e0 <= 0)
      throw new Error("invalid weight ".concat(e0, ": must be positive"));
    return new Promise(function(i0, o0) {
      var s0 = { resolve: i0, reject: o0, weight: e0, priority: n0 }, a0 = findIndexFromEnd(r0._queue, function(c0) {
        return n0 <= c0.priority;
      });
      a0 === -1 && e0 <= r0._value ? r0._dispatchItem(s0) : r0._queue.splice(a0 + 1, 0, s0);
    });
  }, t0.prototype.runExclusive = function(e0) {
    return __awaiter(this, arguments, void 0, function(n0, r0, i0) {
      var o0, s0, a0;
      return r0 === void 0 && (r0 = 1), i0 === void 0 && (i0 = 0), __generator(this, function(c0) {
        switch (c0.label) {
          case 0:
            return [4, this.acquire(r0, i0)];
          case 1:
            o0 = c0.sent(), s0 = o0[0], a0 = o0[1], c0.label = 2;
          case 2:
            return c0.trys.push([2, , 4, 5]), [4, n0(s0)];
          case 3:
            return [2, c0.sent()];
          case 4:
            return a0(), [7];
          case 5:
            return [2];
        }
      });
    });
  }, t0.prototype.waitForUnlock = function(e0, n0) {
    var r0 = this;
    if (e0 === void 0 && (e0 = 1), n0 === void 0 && (n0 = 0), e0 <= 0)
      throw new Error("invalid weight ".concat(e0, ": must be positive"));
    return this._couldLockImmediately(e0, n0) ? Promise.resolve() : new Promise(function(i0) {
      r0._weightedWaiters[e0 - 1] || (r0._weightedWaiters[e0 - 1] = []), insertSorted(r0._weightedWaiters[e0 - 1], { resolve: i0, priority: n0 });
    });
  }, t0.prototype.isLocked = function() {
    return this._value <= 0;
  }, t0.prototype.getValue = function() {
    return this._value;
  }, t0.prototype.setValue = function(e0) {
    this._value = e0, this._dispatchQueue();
  }, t0.prototype.release = function(e0) {
    if (e0 === void 0 && (e0 = 1), e0 <= 0)
      throw new Error("invalid weight ".concat(e0, ": must be positive"));
    this._value += e0, this._dispatchQueue();
  }, t0.prototype.cancel = function() {
    var e0 = this;
    this._queue.forEach(function(n0) {
      return n0.reject(e0._cancelError);
    }), this._queue = [];
  }, t0.prototype._dispatchQueue = function() {
    for (this._drainUnlockWaiters(); this._queue.length > 0 && this._queue[0].weight <= this._value; )
      this._dispatchItem(this._queue.shift()), this._drainUnlockWaiters();
  }, t0.prototype._dispatchItem = function(e0) {
    var n0 = this._value;
    this._value -= e0.weight, e0.resolve([n0, this._newReleaser(e0.weight)]);
  }, t0.prototype._newReleaser = function(e0) {
    var n0 = this, r0 = !1;
    return function() {
      r0 || (r0 = !0, n0.release(e0));
    };
  }, t0.prototype._drainUnlockWaiters = function() {
    if (this._queue.length === 0)
      for (var e0 = this._value; e0 > 0; e0--) {
        var n0 = this._weightedWaiters[e0 - 1];
        !n0 || (n0.forEach(function(o0) {
          return o0.resolve();
        }), this._weightedWaiters[e0 - 1] = []);
      }
    else
      for (var r0 = this._queue[0].priority, e0 = this._value; e0 > 0; e0--) {
        var n0 = this._weightedWaiters[e0 - 1];
        if (n0) {
          var i0 = n0.findIndex(function(a0) {
            return a0.priority <= r0;
          });
          (i0 === -1 ? n0 : n0.splice(0, i0)).forEach(function(a0) {
            return a0.resolve();
          });
        }
      }
  }, t0.prototype._couldLockImmediately = function(e0, n0) {
    return (this._queue.length === 0 || this._queue[0].priority < n0) && e0 <= this._value;
  }, t0;
}();
function insertSorted(t0, e0) {
  var n0 = findIndexFromEnd(t0, function(r0) {
    return e0.priority <= r0.priority;
  });
  t0.splice(n0 + 1, 0, e0);
}
function findIndexFromEnd(t0, e0) {
  for (var n0 = t0.length - 1; n0 >= 0; n0--)
    if (e0(t0[n0]))
      return n0;
  return -1;
}
var Mutex = function() {
  function t0(e0) {
    this._semaphore = new Semaphore(1, e0);
  }
  return t0.prototype.acquire = function() {
    return __awaiter(this, arguments, void 0, function(e0) {
      var n0, r0;
      return e0 === void 0 && (e0 = 0), __generator(this, function(i0) {
        switch (i0.label) {
          case 0:
            return [4, this._semaphore.acquire(1, e0)];
          case 1:
            return n0 = i0.sent(), r0 = n0[1], [2, r0];
        }
      });
    });
  }, t0.prototype.runExclusive = function(e0, n0) {
    return n0 === void 0 && (n0 = 0), this._semaphore.runExclusive(function() {
      return e0();
    }, 1, n0);
  }, t0.prototype.isLocked = function() {
    return this._semaphore.isLocked();
  }, t0.prototype.waitForUnlock = function(e0) {
    return e0 === void 0 && (e0 = 0), this._semaphore.waitForUnlock(1, e0);
  }, t0.prototype.release = function() {
    this._semaphore.isLocked() && this._semaphore.release();
  }, t0.prototype.cancel = function() {
    return this._semaphore.cancel();
  }, t0;
}();
function isMetaMaskProvider(t0) {
  return t0 !== null && typeof t0 == "object" && t0.hasOwnProperty("isMetaMask") && t0.hasOwnProperty("request");
}
function detectMetaMaskProvider(t0, { timeout: e0 = 3e3 } = {}) {
  let n0 = !1;
  return new Promise((r0) => {
    const i0 = (o0) => {
      const { info: s0, provider: a0 } = o0.detail;
      (s0.rdns === "io.metamask" || s0.rdns === "io.metamask.flask") && isMetaMaskProvider(a0) && (r0(a0), n0 = !0);
    };
    typeof t0.addEventListener == "function" && t0.addEventListener(
      "eip6963:announceProvider",
      i0
    ), setTimeout(() => {
      n0 || r0(null);
    }, e0), typeof t0.dispatchEvent == "function" && t0.dispatchEvent(new Event("eip6963:requestProvider"));
  });
}
async function waitForMetaMaskProvider(t0, e0 = {}) {
  const { timeout: n0 = 3e3, retries: r0 = 0 } = e0;
  let i0 = null;
  try {
    i0 = await detectMetaMaskProvider(t0, { timeout: n0 });
  } catch {
  }
  return i0 || (r0 === 0 ? null : (i0 = await waitForMetaMaskProvider({ timeout: n0, retries: r0 - 1 }), i0));
}
async function detectMetamaskSupport(t0) {
  return await waitForMetaMaskProvider(t0, { retries: 3 });
}
var Q$6, q$6, C$5, G$4, Y$3, J$3;
class MetaMaskVirtualWallet {
  constructor() {
    T$4(this, Q$6), T$4(this, C$5), T$4(this, Y$3), _$3(this, "id", "metamask"), _$3(this, "name", "MetaMask"), _$3(this, "icon", "data:image/svg+xml;utf8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMTIiIGhlaWdodD0iMTg5IiB2aWV3Qm94PSIwIDAgMjEyIDE4OSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cG9seWdvbiBmaWxsPSIjQ0RCREIyIiBwb2ludHM9IjYwLjc1IDE3My4yNSA4OC4zMTMgMTgwLjU2MyA4OC4zMTMgMTcxIDkwLjU2MyAxNjguNzUgMTA2LjMxMyAxNjguNzUgMTA2LjMxMyAxODAgMTA2LjMxMyAxODcuODc1IDg5LjQzOCAxODcuODc1IDY4LjYyNSAxNzguODc1Ii8+PHBvbHlnb24gZmlsbD0iI0NEQkRCMiIgcG9pbnRzPSIxMDUuNzUgMTczLjI1IDEzMi43NSAxODAuNTYzIDEzMi43NSAxNzEgMTM1IDE2OC43NSAxNTAuNzUgMTY4Ljc1IDE1MC43NSAxODAgMTUwLjc1IDE4Ny44NzUgMTMzLjg3NSAxODcuODc1IDExMy4wNjMgMTc4Ljg3NSIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMjU2LjUgMCkiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjkwLjU2MyAxNTIuNDM4IDg4LjMxMyAxNzEgOTEuMTI1IDE2OC43NSAxMjAuMzc1IDE2OC43NSAxMjMuNzUgMTcxIDEyMS41IDE1Mi40MzggMTE3IDE0OS42MjUgOTQuNSAxNTAuMTg4Ii8+PHBvbHlnb24gZmlsbD0iI0Y4OUMzNSIgcG9pbnRzPSI3NS4zNzUgMjcgODguODc1IDU4LjUgOTUuMDYzIDE1MC4xODggMTE3IDE1MC4xODggMTIzLjc1IDU4LjUgMTM2LjEyNSAyNyIvPjxwb2x5Z29uIGZpbGw9IiNGODlEMzUiIHBvaW50cz0iMTYuMzEzIDk2LjE4OCAuNTYzIDE0MS43NSAzOS45MzggMTM5LjUgNjUuMjUgMTM5LjUgNjUuMjUgMTE5LjgxMyA2NC4xMjUgNzkuMzEzIDU4LjUgODMuODEzIi8+PHBvbHlnb24gZmlsbD0iI0Q4N0MzMCIgcG9pbnRzPSI0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi4zNzUgODcuMTg4IDEyNiA2NS4yNSAxMjAuMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VBOEQzQSIgcG9pbnRzPSI0Ni4xMjUgMTAxLjgxMyA2NS4yNSAxMTkuODEzIDY1LjI1IDEzNy44MTMiLz48cG9seWdvbiBmaWxsPSIjRjg5RDM1IiBwb2ludHM9IjY1LjI1IDEyMC4zNzUgODcuNzUgMTI2IDk1LjA2MyAxNTAuMTg4IDkwIDE1MyA2NS4yNSAxMzguMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSI2NS4yNSAxMzguMzc1IDYwLjc1IDE3My4yNSA5MC41NjMgMTUyLjQzOCIvPjxwb2x5Z29uIGZpbGw9IiNFQThFM0EiIHBvaW50cz0iOTIuMjUgMTAyLjM3NSA5NS4wNjMgMTUwLjE4OCA4Ni42MjUgMTI1LjcxOSIvPjxwb2x5Z29uIGZpbGw9IiNEODdDMzAiIHBvaW50cz0iMzkuMzc1IDEzOC45MzggNjUuMjUgMTM4LjM3NSA2MC43NSAxNzMuMjUiLz48cG9seWdvbiBmaWxsPSIjRUI4RjM1IiBwb2ludHM9IjEyLjkzOCAxODguNDM4IDYwLjc1IDE3My4yNSAzOS4zNzUgMTM4LjkzOCAuNTYzIDE0MS43NSIvPjxwb2x5Z29uIGZpbGw9IiNFODgyMUUiIHBvaW50cz0iODguODc1IDU4LjUgNjQuNjg4IDc4Ljc1IDQ2LjEyNSAxMDEuMjUgOTIuMjUgMTAyLjkzOCIvPjxwb2x5Z29uIGZpbGw9IiNERkNFQzMiIHBvaW50cz0iNjAuNzUgMTczLjI1IDkwLjU2MyAxNTIuNDM4IDg4LjMxMyAxNzAuNDM4IDg4LjMxMyAxODAuNTYzIDY4LjA2MyAxNzYuNjI1Ii8+PHBvbHlnb24gZmlsbD0iI0RGQ0VDMyIgcG9pbnRzPSIxMjEuNSAxNzMuMjUgMTUwLjc1IDE1Mi40MzggMTQ4LjUgMTcwLjQzOCAxNDguNSAxODAuNTYzIDEyOC4yNSAxNzYuNjI1IiB0cmFuc2Zvcm09Im1hdHJpeCgtMSAwIDAgMSAyNzIuMjUgMCkiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjcwLjMxMyAxMTIuNSA2NC4xMjUgMTI1LjQzOCA4Ni4wNjMgMTE5LjgxMyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMTUwLjE4OCAwKSIvPjxwb2x5Z29uIGZpbGw9IiNFODhGMzUiIHBvaW50cz0iMTIuMzc1IC41NjMgODguODc1IDU4LjUgNzUuOTM4IDI3Ii8+PHBhdGggZmlsbD0iIzhFNUEzMCIgZD0iTTEyLjM3NTAwMDIsMC41NjI1MDAwMDggTDIuMjUwMDAwMDMsMzEuNTAwMDAwNSBMNy44NzUwMDAxMiw2NS4yNTAwMDEgTDMuOTM3NTAwMDYsNjcuNTAwMDAxIEw5LjU2MjUwMDE0LDcyLjU2MjUgTDUuMDYyNTAwMDgsNzYuNTAwMDAxMSBMMTEuMjUsODIuMTI1MDAxMiBMNy4zMTI1MDAxMSw4NS41MDAwMDEzIEwxNi4zMTI1MDAyLDk2Ljc1MDAwMTQgTDU4LjUwMDAwMDksODMuODEyNTAxMiBDNzkuMTI1MDAxMiw2Ny4zMTI1MDA0IDg5LjI1MDAwMTMsNTguODc1MDAwMyA4OC44NzUwMDEzLDU4LjUwMDAwMDkgQzg4LjUwMDAwMTMsNTguMTI1MDAwOSA2My4wMDAwMDA5LDM4LjgxMjUwMDYgMTIuMzc1MDAwMiwwLjU2MjUwMDAwOCBaIi8+PGcgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMjExLjUgMCkiPjxwb2x5Z29uIGZpbGw9IiNGODlEMzUiIHBvaW50cz0iMTYuMzEzIDk2LjE4OCAuNTYzIDE0MS43NSAzOS45MzggMTM5LjUgNjUuMjUgMTM5LjUgNjUuMjUgMTE5LjgxMyA2NC4xMjUgNzkuMzEzIDU4LjUgODMuODEzIi8+PHBvbHlnb24gZmlsbD0iI0Q4N0MzMCIgcG9pbnRzPSI0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi4zNzUgODcuMTg4IDEyNiA2NS4yNSAxMjAuMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VBOEQzQSIgcG9pbnRzPSI0Ni4xMjUgMTAxLjgxMyA2NS4yNSAxMTkuODEzIDY1LjI1IDEzNy44MTMiLz48cG9seWdvbiBmaWxsPSIjRjg5RDM1IiBwb2ludHM9IjY1LjI1IDEyMC4zNzUgODcuNzUgMTI2IDk1LjA2MyAxNTAuMTg4IDkwIDE1MyA2NS4yNSAxMzguMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSI2NS4yNSAxMzguMzc1IDYwLjc1IDE3My4yNSA5MCAxNTMiLz48cG9seWdvbiBmaWxsPSIjRUE4RTNBIiBwb2ludHM9IjkyLjI1IDEwMi4zNzUgOTUuMDYzIDE1MC4xODggODYuNjI1IDEyNS43MTkiLz48cG9seWdvbiBmaWxsPSIjRDg3QzMwIiBwb2ludHM9IjM5LjM3NSAxMzguOTM4IDY1LjI1IDEzOC4zNzUgNjAuNzUgMTczLjI1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSIxMi45MzggMTg4LjQzOCA2MC43NSAxNzMuMjUgMzkuMzc1IDEzOC45MzggLjU2MyAxNDEuNzUiLz48cG9seWdvbiBmaWxsPSIjRTg4MjFFIiBwb2ludHM9Ijg4Ljg3NSA1OC41IDY0LjY4OCA3OC43NSA0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi45MzgiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjcwLjMxMyAxMTIuNSA2NC4xMjUgMTI1LjQzOCA4Ni4wNjMgMTE5LjgxMyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMTUwLjE4OCAwKSIvPjxwb2x5Z29uIGZpbGw9IiNFODhGMzUiIHBvaW50cz0iMTIuMzc1IC41NjMgODguODc1IDU4LjUgNzUuOTM4IDI3Ii8+PHBhdGggZmlsbD0iIzhFNUEzMCIgZD0iTTEyLjM3NTAwMDIsMC41NjI1MDAwMDggTDIuMjUwMDAwMDMsMzEuNTAwMDAwNSBMNy44NzUwMDAxMiw2NS4yNTAwMDEgTDMuOTM3NTAwMDYsNjcuNTAwMDAxIEw5LjU2MjUwMDE0LDcyLjU2MjUgTDUuMDYyNTAwMDgsNzYuNTAwMDAxMSBMMTEuMjUsODIuMTI1MDAxMiBMNy4zMTI1MDAxMSw4NS41MDAwMDEzIEwxNi4zMTI1MDAyLDk2Ljc1MDAwMTQgTDU4LjUwMDAwMDksODMuODEyNTAxMiBDNzkuMTI1MDAxMiw2Ny4zMTI1MDA0IDg5LjI1MDAwMTMsNTguODc1MDAwMyA4OC44NzUwMDEzLDU4LjUwMDAwMDkgQzg4LjUwMDAwMTMsNTguMTI1MDAwOSA2My4wMDAwMDA5LDM4LjgxMjUwMDYgMTIuMzc1MDAwMiwwLjU2MjUwMDAwOCBaIi8+PC9nPjwvZz48L3N2Zz4="), _$3(this, "windowKey", "starknet_metamask"), _$3(this, "provider", null), _$3(this, "swo", null), _$3(this, "lock"), _$3(this, "version", "v2.0.0"), this.lock = new Mutex();
  }
  async loadWallet(e0) {
    return await E$2(this, C$5, G$4).call(this, e0), this;
  }
  async hasSupport(e0) {
    return this.provider = await detectMetamaskSupport(e0), this.provider !== null;
  }
  async request(e0) {
    return E$2(this, C$5, G$4).call(this).then((n0) => n0.request(
      e0
    ));
  }
  on(e0, n0) {
    E$2(this, C$5, G$4).call(this).then(
      (r0) => r0.on(e0, n0)
    );
  }
  off(e0, n0) {
    E$2(this, C$5, G$4).call(this).then(
      (r0) => r0.off(e0, n0)
    );
  }
}
Q$6 = /* @__PURE__ */ new WeakSet(), q$6 = async function(t0) {
  this.provider || (this.provider = await detectMetamaskSupport(t0)), await init({
    name: "MetaMaskStarknetSnapWallet",
    remotes: [
      {
        name: "MetaMaskStarknetSnapWallet",
        alias: "MetaMaskStarknetSnapWallet",
        entry: `https://snaps.consensys.io/starknet/get-starknet/v1/remoteEntry.js?ts=${Date.now()}`
      }
    ]
  });
  const e0 = await loadRemote("MetaMaskStarknetSnapWallet/index");
  if (!e0)
    throw new Error("Failed to load MetaMask Wallet");
  return new e0.MetaMaskSnapWallet(
    this.provider,
    "*"
  );
}, C$5 = /* @__PURE__ */ new WeakSet(), G$4 = async function(t0 = window) {
  return this.lock.runExclusive(async () => (this.swo || (this.swo = await E$2(this, Q$6, q$6).call(this, t0), E$2(this, Y$3, J$3).call(this)), this.swo));
}, Y$3 = /* @__PURE__ */ new WeakSet(), J$3 = function() {
  this.swo && (this.version = this.swo.version, this.name = this.swo.name, this.id = this.swo.id, this.icon = this.swo.icon);
};
const metaMaskVirtualWallet = new MetaMaskVirtualWallet();
var X$5, Z$4;
const wallets = [
  {
    id: "argentX",
    name: "Argent X",
    icon: "data:image/svg+xml;base64,Cjxzdmcgd2lkdGg9IjQwIiBoZWlnaHQ9IjM2IiB2aWV3Qm94PSIwIDAgNDAgMzYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0yNC43NTgyIC0zLjk3MzY0ZS0wN0gxNC42MjM4QzE0LjI4NTEgLTMuOTczNjRlLTA3IDE0LjAxMzggMC4yODExNzggMTQuMDA2NCAwLjYzMDY4M0MxMy44MDE3IDEwLjQ1NDkgOC44MjIzNCAxOS43NzkyIDAuMjUxODkzIDI2LjM4MzdDLTAuMDIwMjA0NiAyNi41OTMzIC0wLjA4MjE5NDYgMjYuOTg3MiAwLjExNjczNCAyNy4yNzA5TDYuMDQ2MjMgMzUuNzM0QzYuMjQ3OTYgMzYuMDIyIDYuNjQwOTkgMzYuMDg3IDYuOTE3NjYgMzUuODc1NEMxMi4yNzY1IDMxLjc3MjggMTYuNTg2OSAyNi44MjM2IDE5LjY5MSAyMS4zMzhDMjIuNzk1MSAyNi44MjM2IDI3LjEwNTcgMzEuNzcyOCAzMi40NjQ2IDM1Ljg3NTRDMzIuNzQxIDM2LjA4NyAzMy4xMzQxIDM2LjAyMiAzMy4zMzYxIDM1LjczNEwzOS4yNjU2IDI3LjI3MDlDMzkuNDY0MiAyNi45ODcyIDM5LjQwMjIgMjYuNTkzMyAzOS4xMzA0IDI2LjM4MzdDMzAuNTU5NyAxOS43NzkyIDI1LjU4MDQgMTAuNDU0OSAyNS4zNzU5IDAuNjMwNjgzQzI1LjM2ODUgMC4yODExNzggMjUuMDk2OSAtMy45NzM2NGUtMDcgMjQuNzU4MiAtMy45NzM2NGUtMDdaIiBmaWxsPSIjRkY4NzVCIi8+Cjwvc3ZnPgo=",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/argent-x-starknet-wallet/dlcobpjiigpikoobohmabehhmhfoodbb",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/argent-x",
      edge: "https://microsoftedge.microsoft.com/addons/detail/argent-x/ajcicjlkibolbeaaagejfhnofogocgcj"
    }
  },
  {
    id: "braavos",
    name: "Braavos",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8cGF0aAogICAgICAgIGQ9Ik02Mi43MDUgMTMuOTExNkM2Mi44MzU5IDE0LjEzMzMgNjIuNjYyMSAxNC40MDcgNjIuNDAzOSAxNC40MDdDNTcuMTgwNyAxNC40MDcgNTIuOTM0OCAxOC41NDI3IDUyLjgzNTEgMjMuNjgxN0M1MS4wNDY1IDIzLjM0NzcgNDkuMTkzMyAyMy4zMjI2IDQ3LjM2MjYgMjMuNjMxMUM0Ny4yMzYxIDE4LjUxNTYgNDMuMDAwOSAxNC40MDcgMzcuNzk0OCAxNC40MDdDMzcuNTM2NSAxNC40MDcgMzcuMzYyNSAxNC4xMzMxIDM3LjQ5MzUgMTMuOTExMkM0MC4wMjE3IDkuNjI4MDkgNDQuNzIwNCA2Ljc1IDUwLjA5OTEgNi43NUM1NS40NzgxIDYuNzUgNjAuMTc2OSA5LjYyODI2IDYyLjcwNSAxMy45MTE2WiIKICAgICAgICBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMzcyXzQwMjU5KSIgLz4KICAgIDxwYXRoCiAgICAgICAgZD0iTTc4Ljc2MDYgNDUuODcxOEM4MC4yNzI1IDQ2LjMyOTcgODEuNzAyNSA0NS4wMDU1IDgxLjE3MTQgNDMuNTIyMkM3Ni40MTM3IDMwLjIzMzQgNjEuMzkxMSAyNC44MDM5IDUwLjAyNzcgMjQuODAzOUMzOC42NDQyIDI0LjgwMzkgMjMuMjg2OCAzMC40MDcgMTguODc1NCA0My41OTEyQzE4LjM4MjQgNDUuMDY0NSAxOS44MDgzIDQ2LjM0NDYgMjEuMjk3OCA0NS44ODgxTDQ4Ljg3MiAzNy40MzgxQzQ5LjUzMzEgMzcuMjM1NSA1MC4yMzk5IDM3LjIzNDQgNTAuOTAxNyAzNy40MzQ4TDc4Ljc2MDYgNDUuODcxOFoiCiAgICAgICAgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzM3Ml80MDI1OSkiIC8+CiAgICA8cGF0aAogICAgICAgIGQ9Ik0xOC44MTMyIDQ4LjE3MDdMNDguODkzNSAzOS4wNDcyQzQ5LjU1MDYgMzguODQ3OCA1MC4yNTI0IDM4Ljg0NzMgNTAuOTA5OCAzOS4wNDU2TDgxLjE3ODEgNDguMTc1MkM4My42OTEyIDQ4LjkzMzIgODUuNDExIDUxLjI0ODMgODUuNDExIDUzLjg3MzVWODEuMjIzM0M4NS4yOTQ0IDg3Ljg5OTEgNzkuMjk3NyA5My4yNSA3Mi42MjQ1IDkzLjI1SDYxLjU0MDZDNjAuNDQ0OSA5My4yNSA1OS41NTc3IDkyLjM2MzcgNTkuNTU3NyA5MS4yNjhWODEuNjc4OUM1OS41NTc3IDc3LjkwMzEgNjEuNzkyMSA3NC40ODU1IDY1LjI0OTggNzIuOTcyOUM2OS44ODQ5IDcwLjk0NTQgNzUuMzY4MSA2OC4yMDI4IDc2LjM5OTQgNjIuNjk5MkM3Ni43MzIzIDYwLjkyMjkgNzUuNTc0MSA1OS4yMDk0IDczLjgwMjQgNTguODU3M0M2OS4zMjI2IDU3Ljk2NjcgNjQuMzU2MiA1OC4zMTA3IDYwLjE1NjQgNjAuMTg5M0M1NS4zODg3IDYyLjMyMTkgNTQuMTQxNSA2NS44Njk0IDUzLjY3OTcgNzAuNjMzN0w1My4xMjAxIDc1Ljc2NjJDNTIuOTQ5MSA3Ny4zMzQ5IDUxLjQ3ODUgNzguNTM2NiA0OS45MDE0IDc4LjUzNjZDNDguMjY5OSA3OC41MzY2IDQ3LjA0NjUgNzcuMjk0IDQ2Ljg2OTYgNzUuNjcxMkw0Ni4zMjA0IDcwLjYzMzdDNDUuOTI0OSA2Ni41NTI5IDQ1LjIwNzkgNjIuNTg4NyA0MC45ODk1IDYwLjcwMThDMzYuMTc3NiA1OC41NDk0IDMxLjM0MTkgNTcuODM0NyAyNi4xOTc2IDU4Ljg1NzNDMjQuNDI2IDU5LjIwOTQgMjMuMjY3OCA2MC45MjI5IDIzLjYwMDcgNjIuNjk5MkMyNC42NDEgNjguMjUwNyAzMC4wODEyIDcwLjkzMDUgMzQuNzUwMyA3Mi45NzI5QzM4LjIwOCA3NC40ODU1IDQwLjQ0MjQgNzcuOTAzMSA0MC40NDI0IDgxLjY3ODlWOTEuMjY2M0M0MC40NDI0IDkyLjM2MiAzOS41NTU1IDkzLjI1IDM4LjQ1OTkgOTMuMjVIMjcuMzc1NkMyMC43MDI0IDkzLjI1IDE0LjcwNTcgODcuODk5MSAxNC41ODkxIDgxLjIyMzNWNTMuODY2M0MxNC41ODkxIDUxLjI0NDYgMTYuMzA0NSA0OC45MzE2IDE4LjgxMzIgNDguMTcwN1oiCiAgICAgICAgZmlsbD0idXJsKCNwYWludDJfbGluZWFyXzM3Ml80MDI1OSkiIC8+CiAgICA8ZGVmcz4KICAgICAgICA8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMzcyXzQwMjU5IiB4MT0iNDkuMzA1NyIgeTE9IjIuMDc5IiB4Mj0iODAuMzYyNyIgeTI9IjkzLjY1OTciCiAgICAgICAgICAgIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIgLz4KICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5NjAwIiAvPgogICAgICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICAgICAgPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzM3Ml80MDI1OSIgeDE9IjQ5LjMwNTciIHkxPSIyLjA3OSIgeDI9IjgwLjM2MjciIHkyPSI5My42NTk3IgogICAgICAgICAgICBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgICAgICAgIDxzdG9wIHN0b3AtY29sb3I9IiNGNUQ0NUUiIC8+CiAgICAgICAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGOTYwMCIgLz4KICAgICAgICA8L2xpbmVhckdyYWRpZW50PgogICAgICAgIDxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQyX2xpbmVhcl8zNzJfNDAyNTkiIHgxPSI0OS4zMDU3IiB5MT0iMi4wNzkiIHgyPSI4MC4zNjI3IiB5Mj0iOTMuNjU5NyIKICAgICAgICAgICAgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgogICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjRjVENDVFIiAvPgogICAgICAgICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiIC8+CiAgICAgICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDwvZGVmcz4KPC9zdmc+",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/braavos-wallet/jnlgamecbpmbajjfhmmmlhejkemejdma",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/braavos-wallet",
      edge: "https://microsoftedge.microsoft.com/addons/detail/braavos-wallet/hkkpjehhcnhgefhbdcgfkeegglpjchdc",
      ios: `https://link.braavos.app/dapp/${(X$5 = ssrSafeWindow?.location) == null ? void 0 : X$5.host}`,
      android: `https://link.braavos.app/dapp/${(Z$4 = ssrSafeWindow?.location) == null ? void 0 : Z$4.host}`
    }
  },
  {
    id: metaMaskVirtualWallet.id,
    name: metaMaskVirtualWallet.name,
    icon: metaMaskVirtualWallet.icon,
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/ether-metamask/",
      edge: "https://microsoftedge.microsoft.com/addons/detail/metamask/ejbalbakoplchlghecdalmeeeajnimhm?hl=en-US"
    }
  },
  {
    id: "okxwallet",
    name: "OKX Wallet",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJDSURBVHgB7Zq9jtpAEMfHlhEgQLiioXEkoAGECwoKxMcTRHmC5E3IoyRPkPAEkI7unJYmTgEFTYwA8a3NTKScLnCHN6c9r1e3P2llWQy7M/s1Gv1twCP0ej37dDq9x+Zut1t3t9vZjDEHIiSRSPg4ZpDL5fxkMvn1cDh8m0wmfugfO53OoFQq/crn8wxfY9EymQyrVCqMfHvScZx1p9ls3pFxXBy/bKlUipGPrVbLuQqAfsCliq3zl0H84zwtjQrOw4Mt1W63P5LvBm2d+Xz+YzqdgkqUy+WgWCy+Mc/nc282m4FqLBYL+3g8fjDxenq72WxANZbLJeA13zDX67UDioL5ybXwafMYu64Ltn3bdDweQ5R97fd7GyhBQMipx4POeEDHIu2LfDdBIGGz+hJ9CQ1ABjoA2egAZPM6AgiCAEQhsi/C4jHyPA/6/f5NG3Ks2+3CYDC4aTccDrn6ojG54MnEvG00GoVmWLIRNZ7wTCwDHYBsdACy0QHIhiuRETxlICWpMMhGZHmqS8qH6JLyGegAZKMDkI0uKf8X4SWlaZo+Pp1bRrwlJU8ZKLIvUjKh0WiQ3sRUbNVq9c5Ebew7KEo2m/1p4jJ4qAmDaqDQBzj5XyiAT4VCQezJigAU+IDU+z8vJFnGWeC+bKQV/5VZ71FV6L7PA3gg3tXrdQ+DgLhC+75Wq3no69P3MC0NFQpx2lL04Ql9gHK1bRDjsSBIvScBnDTk1WrlGIZBorIDEYJj+rhdgnQ67VmWRe0zlplXl81vcyEt0rSoYDUAAAAASUVORK5CYII=",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/mcohilncbfahbmgdjkbpemcciiolgcge",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/okexwallet",
      edge: "https://microsoftedge.microsoft.com/addons/detail/%E6%AC%A7%E6%98%93-web3-%E9%92%B1%E5%8C%85/pbpjkcldjiffchgbbndmhojiacbgflha",
      safari: "https://apps.apple.com/us/app/okx-wallet/id6463797825"
    }
  },
  {
    id: "keplr",
    name: "Keplr",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAACPfSURBVHgBzV0L0B9VdT9nvy/vB6nVOg4GEx/VER3A1iqo9aMzFgWtoOhgsYaHYNV2lNEqxAdfmKHTakuDTge1FJK2tqOtGqoWFWti8TFSxGDriFSbIK+qgB95h+Tb09397+49r3t3/99/LT0zm//e9917fud3zr27SRB+EbKd1gAcOhFg/kSYmjoBiJ4JhMsB6LHFJetS+wfoAowOQOKnumGVUfSX+23Ba0uRfFaGsh6pNKDqP2PzQN5TbNxqjAeqi2CuWLuvAuU74eT1O+AXIAhDSaX0g+fBFL6ymHShfFhT5RvdknNLzsTIb+cChmzb2OJqJY8aQG9gaAUXaXLbOH0gL4mXmXHC/HYUv1thEWyDk9bPwQAyOQC2H1wHGb29uNtQdLcmFJBv2AsFAPVQJDQPlFBYFACpso7+kFm17g/9sUgr3QFWNI3VtQWO0KaCGXbDBLJwAFSKz2cLjtvglhNFGmr6NomgxEQdT1kYK8N0uzBwH3bosHJo3EKkD1ZG0X6ctAFEW6cAAiwYCAsDwM2HL4e8tHpa45a7NN2UUaxBmFAPmpdt+rGDq0zdrpP2I6yRig06ANHNHuAwjxlzFp67fhOMKeMBoLT6Kby+GHMGmklySVosJAO+ajK9LX6Uxl51eyqZp/tYvVcPbRklynQ7au913aaeBwLRz+6CDU4dhw2yvhVh++EzIcPvBOXXc+SXJz3LMVYeEblOYxKZMx/kF4V70aZPv+q+7ceUmaivHTu0hDSWqzwRWa4rAsTtcOuuM6Gn9APAzYfeVszsM8UAazoVCgDj1DELneqrBgrq/ilyKUFwFE2R8cX8UABD1OmaOx87pkw137gxoP9ssq91xfUZ+Pddl0MP6QbAVwt/Pw+boY+MCQzsquNY6VhCHUoGNeY4fUKjVLR9JdIC8IkxkTrqkerVPsNsHxCk17RUPtFstJw6tE2RfNAPl35Cs7XrSHcGhWPHADBWIJj25XJ8ipbJcUmlZR01Fs+bh0vg+eujBhwHQOnzoaD9pFAi25ZhD2XzPKmHNAAQyC/zHbCelFNGicBPpxP8jZFA0El37xyaHA8oqm8uBGfB89Zv84p8AJTRPuD24m4dpKSLAdhPPGKv8wx4+1l8dO/vtVWL1PvQKMIIxOtFo3VKKy9y4JNmkboflef2N5K5gglO8nYHfgxAhfJHwQQkL9EmXgfHqNcnLkBSwWAPEUFfrG3Xs6k8b+dg66N6RpS7DNMvAp+vwTXrB2Lt7dqugWm4HhyxANhe+P2U5fcBQy0mYh+nntOmL0BcoMREK8vNr8uiCgnKkAEixIO5Zo41IOKKrgPNWFvw1liuVDWHvNi+f/NHs6BErmdJ/Tnugt5Clhl5mVPdUnCkLnMhfVwC8hUz5c69qifm4vYBLrWT285Jq7aUdAOM4ut02ycAkLECilgGb1+1naNcugLJAPPF1iFlid7FxmjH6VO3R99d2zdOwa2k+gNpNVGGcObc5vPRExZvKFwxjahLil1olGf7qd0DgWIXjM+5Hbusg2syxMvVU9RSWv/R/tbvWyUflMZoQ9YwE6vfhxHK1ensy3HC6FlypG56ixZnBDJ1bf/2OwPeU8Qyeh6n5kDrGxZoGSA7CrMiqPEubjFdF5tTnzbGkrkoy+L5HgslGSbyPG4QR85YTp7PABi10sbqTTBIym8T2jnpvsV8EEwQ6EhG8Ha+ZtXHHHjk8M+hr1D7R1TQK1ftumIAtI1Nuo+Vpw+GAHod8rR5qXSqX5mOWzixcpanrIM8RhL9yP6UzM0fLljg1PVzIwY4cujMTovuQBVQD2tnc+zy2ynG6NoGdjJBbO5QWxdoa4aoj9fHwl46jIMBX6Tqt8+j/DwEixcswNsTJNYSwxVkzaIlcF55UwEAc9wwFgA8ZUQnYOt2AcN1b4mybvCh7IN6UH8zLx2ggVcnnY66BqpnxdcILDCaZ3Dn3/RK/nNJAGN7EUy9slkTwBsPeXZhJE3JuoicNn47jJhllwvoVe5RuaJ5Mz7avgCHTZutnBqzy0U0eXblKGIlRuaOHMnXT8ONB2d6Bo+9JeaeTJ2By9pyXslbQ8RRAUU6oI68sdOlpkikkSQIRxoPL4dadmgUSqHzURH5ukaOiqQS1kxPw4nTWfkFL/WDTEr6xR5xBY6v9NGqoFeJEu08BdcrHoDLFr7KQ9np2Glv/EKRSAYoCJQED0GDX2Q5wOYKajAuoW55N5UXAKA8m1mI+jvbUL+6CwGEKFdKQlHDmYRrNWBAgYMzAbZWG5IIZIASGpGTZ+eFdXEPGsf6yZs1wEUnTBeJYzrbmZyOwWgMBRZy7YlL4A1rp2Eh8m8PzsNp39yfrOMqE5i76FK0l1d0+tHjV8Hrj10KQ8h39x2Bk2/5WRisZCQ2HrXKU7GCmKDM6SpCmC9cQA7rus25n3TFEgMNY8U8mErEXIK2UOZvEdK0vvEpKwZT/l2H5uGc2x8S7KDHQzFPaDOC21LlvDCqF1xTmt06sX1JAMk0h8nqDAaICOOgp2BWiB20GZvfZU9bARufuhyGkFL5p9/6INx9KHdezTb7EwfhdQxAKV9LXqaQddOdf3Uu0ndKMIEet58eYIsKBeuIWT7P8sow0UazxGW/unw45R8slP/tB+HHxW87mAoMUbOBmZ4T/Y4h0ykAjSPj+Pxx23aOrQOvUmKgAMdVeaxXBwicJc5duwQ2Pm0Y5T98lODlheXfUyi/sXxyqF9s/2KULgJhgLRPlDKNOSxIJqJ/VGUTMIDxgaQsGsaZq7Q03u7Zx0zDNSesgiGkVP4ZtxSWfyAHHnsYP68WBhNl4NQEVZMzc3M3PZSv71O3nYAecxIXULdHM5Zfry1DVpHS8z5u+RR8/uTOzVJvOffbP4fv7Tka37K2WU5+m9Of+jFxNz3pKeBCqX9S2hd9eXSfGqu1NpTbKrS3xy2fhs+dshqOWTTMjN/63T3w9QcfsSwIvrI9RWOPOn3FBoEdgj0QM57SaTIwELjbz9Y1CDfgLzKKotFN2efaFVPwuResLkDQ/2/QpWTj9/bCP9x9UG4x7UwgrsT+9E88Va0DgbfJmx4jXpAt3WETZThem7HEYYCkwgnc7TLPO2YxwudeOJzy//TO/fDRXQeqIcLcmoHNDE0ZueWx9s7alm8BHYabyAXELDpeFmk3qRsa0wWkqLdRzmdfdMxgyv/AD/bDBwsA8LDDzmYhjFDXEeBN1FUgL2V6nMVfqL+vymI0HWPDvlK6gJx3qG4JBPLdOSj5y+euLKL+KRhCKuXfsb+eQ+phVZlQFgoqT0vsYcnNMjFAWslxIupL8UNbP+/DuoDE+CY+GMm7j18Gr3vSYhhCPvajg/Bn39+/YIvXRI9Obuvr2fOknILGz1guIAkOitdDb2ToZpQ+gqxrFJEPq2OsyVJ++QDvKpT/rmcugyHkE3cdgvfdvq+w/BBUsgFHWzyMW7ws8IHbMoMoGy+oFgzQ2/r1AkdamMlBhDUmdQEx9xJJe2UXP31pBYAh5BsPHIG33bqX+fwI9VcgAIguQKVQC4aktH0mK7V3CwsCo0EXQ2sPl4A0iebNsGYMce9F/rWc8+QlcOVJwxzxfm9uHs7/+sMOKBNb0Ja71cKaJrVyqWMr1rms4el7BoHUL6p3wJqyxDZvoF2ATuvAS4OgzH72L0/Blc8ZxvLv3p/Dq3fMwd4jsfUKGvLjIzU5cpuCH9WS2vz3k+4gMNKZmx1jBow9sGy3YMnB3eM2/jIGwrUrM9j6opWweoBTvlL5Z29/GPYeptbvV2M5oAuTJVtu6tQZ3ikOF17f61MUBul2AWQjUlccJccUjBEqXpDUMYAOsqIgqBf3uJUIn3nJquK0b/K9fqn813zlYbh3/zx7nsaeO/bwVRWKzlvWg3jMYILM2GgouhrvbWDKr8diRHTyqudldDEBA3Dl60+/YiA4rrD8T79k5WDKf+2/KuXrSL2OzsEtr6HClIuReiEvZjYUtf5Yi44YgEwSI/Vic9KBHjpbtElZoF1bh/Kb8Zo6q4sj3utnVlT0P6nsKXz9a7/8MNyzb/RaF1Nb3fYolsRcRb0u6mfZsnM1mhc7RCTxMigR+EWsWhUn66EpmEB4n6RcDFusMvtDL1wOz3rM5Kd8lfJvKix/b171G+iVfV6uwc7+hORxjZ/y2k26hNYFJIIC36ezQxVj3Y5FMCsQljuBYP1dBbbjgutTr3j+MnjpcYtgCLlo+174/oPz7nd8Md9vlOvRvicC1F3BHiWTuotpo8y+lBz17baOuCWHIYaIATzLZ+l3PGcpXHT8EhhC3vn1/fCt+4+MLF8xdgAitidzdcpnBU37VP+BDnNG1lNm9tAea1MwQI/V96iM2j9kFTYzTET/VXpCy9f9mMOeOv8dv7a0AsAQcsUtB+BT/3UYmtM9d0wBCt/3G8OJWQ7PoQ7r9PrukM6DID53t8wJUPSzSLTKv7SZ6r+XlG35OQDJeV307MUVAIaQq79zELb85yFBx9jhkxF4XT5pv36b79I7hngnsRGId2wXeox3AayOg2jZ3qe9NOoXLsiBxeZ52vpFsOmUYU75rr7tYAWACtA84FV/d6/ZiiaftfmXP7hleOuRUmaXtWtdu9ba4xzAt/IIgiMTEqDRwdoA4sUAzyqOeDfPDKf8D912cOTzXcrn/5SL3RLz8wkNDLHArnVTXNkOQHoDopZ+L4NUoOi5q0AK4UmNFXj5zQNOIDoGWLsqg2tftgJWL5mcYq7/j8Pw4VsPyrknAk7sEfwhv0kCo+4PIK3sCbbWvT8KxWYkPQEFDr5Ioh6SzUfmRhYq5ZB5mFep/E+eWZzyrZpc+Z/6wSNw5TcOmICPK5UrQdO8LjfH5R7tq/VzrR57Wjp248EFAEZHBp+2sQuNZA5kmroY67OntBZZXE88plD+WYXyV0+u/HKPf+lX9tf/hg60IBBKM0qH5FYU2bt6Ga+Q7ENXaOqxcUU+RMSNA6TEXYBAIEVHCdbAKK8pY/my7uhmcjXV/RYgXr0U4dozVgym/Ndv2xuOqVvF1kzAx3Zjgjgz+FtVBxie23DcgJOMZzq69oNAdFpRpLhRpqH80BxVQ5zAZxmprf+q314Gxz9u8vP98mj39z69F/YVr3UzV3HsX/5Cct2BOYl0QCHSAO62D2MKj+QDqDFNphX/HIBsD+gkRgMpCxeKl44sgITES5pJdwOXzyyF054y+RHvvXtq5R+i4JoSikT2Sdc4ls/7AkgDw+tL5IsOrIi+HVExgKVx25NUZJXWflDeKP9PJg8mAMDJa6eqa1Iplf+GT+2F+/bkYlGxy7qhiQ9AKCpm+e5a6TYAFgiNLaWAwCcVEV083ee7PI9SxL+pKw291a4J/PjHJej3+2hIpfx/rJWP2u+Dq1hUAPHKYuWectHz95ohmnyAxOt3nQFJSW4DvUFa6zZ5jdhPoMVJnWEFGuxAaCGyp/D1Gz7JLF9t9bjiW4tnrBVYQIqXj2OUJ9Ns/FT9UC+OgvRBkLZstRuwL3sUMJyI37iDR1v5nyiUP1e/0/don8Ac77b1HIYw7Vm5Trf16zw3Jqg7cllAVJaCrJ5fOJL4OUCkN49iWlZwJsb/QUSJ9kS88X8k77nxAPzgJ/PGvyOApG6eX2Y0ZcyHx2IFnQaQykHzKhj6uwMAP45ICgpg9NoGJg9/qP3D+RKHVD0Ir0b5xB8FFii/3r3jf45WZwiefxfWD5D09a2ylQFYJkD/lbhj+bFX596HIcbae4Oh/MeiSwCoC+ehOl4dXaq83raN8qm6qkWkum19VS9F2nqhHa/flj8KAFhVvCfY8rpVcOzqrJpDVs8nq+fE58fvm3q6LMtZ+ypd/8PMObtYm0zUleNnTV7RJiN5NX1lug/TNugCKX6FD0I0XLR/Nwl1IoaqTPh6aJnC97OPAgIKObY4Ov7wq1bCBX8/2vsLyua/nrU7ZdzCOXUbt8AeV7AF4Ni7gSrfNXXGEInlzaqOaut1Lb2x3PaqmYFknbYNYw3OAMgYAdu6MGIEePTk6Y+fgut+d1X15jBlKfwKLIDqitfNTFsYWXRj2YRifQwLGUu2rICCLSRDGJZoruiDardQKT0ovqH7AJYRMCTdw0jBRKG+6P/R3QI2UoLg2nNXVZ+Me/Ru6D8HV+GZqhdLY94oXbqczOmrAUqj6Ky9wKX+Biyesl2AejGAVToJpQsrdhTfx+pFjPD/BARXnb0y6ddDmVQAt9A4CLiF2jqZUlxbt7LuiDUbhTuxQtclqZ7EFVN6UHRQPHDFp6zeAwUsXO64fx6+f/88DCG//qRpmH3FingQSMFydVnMelv3kPt1Mt13zkDCrTfX1uwFh77VZ6kL60geGmW2SrRKh1ZxdX2+EMzqgS2Asfq2HiubgAH2FMHbH358P9z78xyGkFecsBhmf2eFQ//oAEJZsirLcnQZRLKDVbi2+Ma6W4t2ACKAwi8OQkIDnGgMwJXeBnQ0UiJnAREcEsn8PFg9VzaqsknjgPsemofzrt07GAheXoDg8lesgNjauL7U/MYBwxnFA4Z2N0gWSJnDKC1QuILreIFfgrmiMYB4QMkQyJQIudoViLYUKJ9NPjBFzQiTSN3vfQ/lcP6AIDjjxMXwxt9c5isuB0PPoUzuCDKKW73IF+5EKY8snTcMk+UIOr7IHHCaqwEEKL/fXto1kKN4kooP9yRcBOigESQoJpEqfqjHvv/BHC74WHG2PxAI3jizFN744hoE4ARtpC8UytTKDb4bbKDYKLTD/4vtn1Kmr/AI9bcuIMEAMuADq/hcKr5hA7sbgPb8AEw+THwQxK3y/oIJLhwQBBcWILhwZpmlaQDDbD6FB+WiVm4uleqCh7T/t0wQ+mt2DfJswmOFpAuoJj8PMuBzjoa14jkbiLgh4iJaMMEE4ix6yQSX/M0+2Nvvf8PrlAsKEJRXbHdQLS4gWKrnQZhVbuMyLBMEV4COq8hUfCAOkhQr6CNhuwtw6B+aq6Z/swVkwDCgYFRv3EDbnkLw1/Q7gQj3U4995z1H4eKP7B0MBOefurS6hPVQ3OJH1tVY97juAMUOQlpveMfgsgCrZ+g+V+8mmnMA7xI+us3jAJFlwbrDwZBemPZUkEAywaQAaINNuRO5896j8KZr9gwGgvMKAJw3sxQs7aNRBDr5zfsDz2K5xWdkAWb8PmmLtkfBaOo4l97zy32+WlhB7aBiAgpRPXGrp+BCCMwZwKT/VFz7QiaXTNMo6M575+GqGw7AULLht5bC2ScvERQe/LwCgYkDwFV8AIV1IXrHIGMIeXCURRSOFGeF6DeB3jvm8L6awLwbbxO1IpDi79Rrv88/rVqwKOtqxuFf4Hz+lsNV3vvPWQFDyFtOXwb7DxLcdNsjclwIz1jFBM380CsPec1bRPkmEsX3EqFMfQdQj1Gl1bcCqdiqKRt9ENIRhYlPt7gy63RYeFIgYACpG9h8GMAFKCWwqxnjXwoQlD75vQOB4I9evbwa98u3HbEgYArwlOoqGqSSuUq08k1Z8wdZVXaotvx7ARRVgPtRaGPFlYRTPPcLWoKAFNbOWsGEboDCLyI4ChldJRM84ZcyuPC0Yf7W8DvPXl6A6iB8+duP+B+PAgchGoYSytfMIfItSMI9CmPUdUDUtyVj/YcRozIydc1XsvyvSCtAhIVijDCJ/gmES0GS8x39/f2Qvu4Lo7/pe8FAIHjTy5fCrvvmYdf981bxag58vaq/VAJ6DR2GwKBgzRyhTp0v1hE7rb8sN+8C+Nl+CN5U9C+2exBe9DSBIIA5OWy2Z+L7AD7egoVE0Kd3MPyVdpN3/Y0H4fovHoQhZMVShD+5eAU85QlTIZKv14ef3aMO3kgHfF4gh87BUNgpiLMBE+SpMckPDjPgR778DEAp0L4QIrGft9E/2F0EA5moN4FUFuPswVGN1cydg2DLF4YDwR9ftAKe3IIAROQtlQRW+Y1CnQMgpLB70DsFAYhcbTnNhe6VgTr4QXbxMv5CSCyuOCCSdTWrCOXzwyeYQJwxtNXJvADaLQUItt44EAiWIVx5cQCBVnQzPn9LGBSrLdwHiGYC8W0Ce2bzIanaRsqTQHVUKA6EnPyWEbhbiB3wcErWboIrblIhClSfx6xf543qlwD44i2PwBBSguDSDcvgV4pAs6F1CQKb1m8BAzBip4XOsS8HRf1hiKdwvRajgyClcO9wJ5z1M0bglt+Ape2HjJsQ4NBtJwSBfDAC8ckZgXNULK8P/N0++NJAICiVf8XvL69+o0xAMYrW1oxuHXtSKNmAuxOPETgzRF4Hg/kuwGUEQanE3AUYyvfoH5irmESQHMYhAP1No11gaOf7wb/dBzd9azgQbHrzcni8AAE6vtuCI+4KGDu0v5HXx8S/J9Ag0i6gUaa6+CLqKF+k2Y7A+9QLybbnjDGY8sm3LB6feGXBHQB85J/2w3/fM8z3hY8rlH/5m2NM4LgCBxwyKPR3ArZfZweQg/92MHd2AeaNoFIoGAVDS/tim9fSv1YEmLyJ4wBHuT4o1GtrVbb/AMG7rt4zHAgeg/D+N6fdgWUCT9mJdC4BYdmAMYL7QQhJWnQ/BqnuLUBQvDACNx7gfr/px7y9m1AaBRrQUowVKFJGcKAAwaWbhwXBe9/CQeBTsssE0AUGSCievx2044W3gWLhyFI8W9SUu/B//X5MX0NI2SfUDwksluFj1L8tG2hg1HXKFz1Xfmwv/OShHIaQEgTveesyWLlMWXvzbsADI3QEgDCqk0HcDRhXQDYYzbQC2rNzT8kqyPKULH99cBhWmEQobukcCLbMAUEe8n76QA7v+Ys98NMHhwHBYwsQXFaAoDw0atY46grAugV7VuDFDd5BkWQY831g6xdzbalkYwLQ0T65jBC7tCsRY00g2DGmPgrWtN+CEzgQAH5WgOC9m4cDwXHHZnDpHywdgUAoawSKkVVbKpdWa1nD21FkAhTy7IAbo38OIBTmpzllBn9PCTYg8W2gYJIJpH351GHt0IJPPhN/Bg2KBgTvK5jgZwOC4N0tCOxcpc9mbAGS8vl2L27pum/rCvxPwtj+3rNYewIYgjmP8mOAGWQXQBHaB3DB5oOEDGB4+oECBO+/au9gIFhbgOCcVy1ulZUBRIErlaqVz+YLUMcUGJgEAngyVSfUjVI+WMv3joUTlwSBBdEg7wIgNhc+jlIsOCAweSSA8ECh/A9cs6/aJQwhp/zGFJx/7hJB+RiNA/wj5fBMXf4fAWPvBLQFxZSoF9ZjBzfqhyYPJO3za0JxT/rEAkllgqNgrvSYm7jr7nnYVDDBUCA4+XlTsOHcxc6cOX2jejaUVk/xj0hjShduwQv8YoEaZwYc81fcK2VMJFx5RBBnJRJj6zwNertLGN2XILjiz/fCUFKC4DWvXhQUCRbEbkxAUvkcIPotoa3DyooH3u1ZPTp5niLdxQa58CiYILKrmFTacSnQOTgWLhSsqB+00lUf9f2PCxB8dMtwXxqfOjMNp58+zeicWzFjBYi4AbIuhFt9iAVQX7vLfyZubqTRkbDP/UIe+xYJeT7VeaoMdV/8vv58zC1boAhKbC8KH03Vcxt9ikWj7/NI1eV56PTJ84o/bv7GI1X64vOH+V/HGwB88fPzzazDuoJe28AEIVXfI69X35G/xsVT7y6Cw/nbMWL1bcPmXm8RAaJM4ZWjYgnk/S9YSLKO+vXdQqQNYxFxD4xB2P3XChB8/JPDfFBSyssKELz0jGlh8dbaI+cCAGaL6AWGgiHy/OGseKW406VwABsQ6bRSZnpRWT1w6i5QAm0z5bDf0RheGdk0gOMinGdjc/7STYdh22cPw1Dy0tOnAgj0BZHL1LUHQ55rAMId0zngzoyU1slShvnyl6Vj4rkCYBNvZM/+HO776Xy0fUr27a8nQe0foAiwnjuNbuqfoHRFp8hA1bqFhIso/rjhnw9V9y84ZbEaPS6YSD/1aRncRPVXxsjmRz71hzz2J/rz4HmLpvKduG5m15psesmuIr3Gq9Tmad+CctHMwOoX0VlkZGlWnqGth6pepTjeDmsKFG0w5LM8Xcek2X1m8oMSwj3KOl66XYtYHQBQ9SUArLLl3yaSoOe/tsZINl2TYbZ7x/q5Auw7Y9G/jgOi9B6heoz1BX7fyPLRqR/GIvC3dqB2IHo8SrsCfWYAcm7YsQayL5AuVdM58XroUH1sO4c9KV+eBag2O8o5jf5PJMpvcM8DYLSlEucAwO75r8oX5wcQ+gvbNCetFRgBA0/LQyevPjlgIqU4smNqcLC2QnnqXgNDKpqxB0HEv7vKkuWij0h9J1+u7fzWFgB5fmRLkTmnAxyMKMSz+CgLEFtQ3Z/pvwnmNIiYYsAfpwGDzzAeOLwzgcAC4OQZxUMcCEbJntJArrWsLykf1TomlQ8g3IB3wdKpbdAAYOQG8q3tbBxlcaoW9M7y3bYAUQWio0itqFGaAiM5fcrfUE8zhQUPBwaFcfXYoMbQz9z2EQGCkzdqg37dpr+YwgEiSsZ2HVNXcQC0ZXYzzpV12/9mK4fpzRA5yxcW2Ty5dgcgT/hSCtMg8KzaWnejFP4iSS2+AA654IjRLweB159v5WT6cEHi5MVo35ajVTQHQ9sO3efyrnmETc10WgDs3vGE3QUMtoIW9RDIHyhxL3wmB4UBiV3wuHWrcYAilg2tQtH0TfLZmOW3z8jrseqBtkkCBdSCewpI5ZEcW5eDUqqpp0ACrL1mkuJ4ecvsR3B380ziP9qbh/lZ5LEAG7BdDAUE9PIBXEsWymFWaRgF4sxh5iP6CGNxANq5BK0KyoUwL48BWrCQbMfn4wJB5RlWaMvQdRVCycz6gXwlx/sAODIVrL8UAYAiFthdLObVYmYeGNRDg14MDwzk1ImAJSjOWSmlKM/ivb5QK1gwB5m6fLymHJ3n5n256+PVB3BZIZRhWDOSoNd169rmAgDDMDnRJm79AMqgGnnqi+/eXjSYMf9tCWvRDtKkEUUdrMsWknYPfrC2glRdVi+L5MfSmXfAg/WHGTwPMHIwNHrDljoQAq8viNeXOwFO8+weffp39LZ7419l61URuP/X6jQePb/4Ea6glZYOQ3r0GywWDa3ruvIXY1Zt6vboUyccJmiExwg8NhCflEFiTvwZmoS2fgLr35Xlo1fGWFNavQoKHRfguITdeARPBUdcANxRuALK6Hyehx4Q2H0zIVB5DTVDT1Dwh5V9gPXtjrjBHuhFjIHYWg9XgrwnoTTpEqxitSEZZXvP0tZBoVT3eVQ7nl/M9JLLtkjqbyT6vy3/aMdx24jwEr3OGEO/p8iExQswgO3Tt2w2XlUWwKTHG6XJmQdZVmjmq8qE8kDuNjQQBUCbbK1wXYc/k2KF6DMDuFs/DyB15U0b/xq3QUSS/932D29+4uZiDTeBY/3Jew8kGkg8EWMHSPQtWIHMYsu+nc7IB2mUaUi2bccin/lilg9OHjplmkUA4pauJew0aNNl107NQkI6/7/1H35t7SyWINCKid0n8jymAFL5dabew7t9eQN6IHRcDjptkfz+uFW7lqyUjo5yXZ9f5aFsCw6LJIwHI78EdMll16WVX0onAEq5swBBcUpwVtHtbnM6qBYee1ovn2y8rnr6SD+h3BschOLCHC3di04pbX1cXJB6Fh5bm4iSfdqHliF0//XvHOV41sbrpjZDD+kFgFLuvHn9tmxq/tQRCEA+gHgKiitIC7N+jNVXykqCBqQ7kP6QlKJ5G9uXl5e8F2mPUfw2xuJTcwMHyBwQ5SveHE/auCXu87v67yXPeOFds8XG+fK2E2STQp7HPoRo6tS/sX08r8t/Rx9moO3D1BmN2/ccoK0H3pkAqnbe3r9Jh7Lmr3G19I7+fj9jtXg5APoflMTv54qA9+rLtnRTvpbeDMDljq89qQDA/PoCclurjJTlQsQ3R9jBixMMPZtxpBWhx0LuL7kW6QpnmQgbua5Al3fWw7Y8ZZ2BBXDLI4QnLUT5vJ8FyzNmdq3DPJstrOaVxZzX8M/DpNWjYgeInvjpOpmyWvAYAsPiZq61g3P6J63bsoG1/Axi+d5p3uhhsohFC+aA0IanQbSDJrf8imvrPGSbZyP7+74yMQAaKb8tXA5TZxYdbiiumapzAQAIx8WuYiDqBlpqb8vRAoClFwYApSg256BYHwCZUOSkAJC/DAAFzcPO4u6Go5BtKRQ/BwPIYADQ8qyZXTMZZCcW+4UXF6OsyZDWFQ+8DqKKWTgAMhcI4wHAKLatE+wuCoC6LK5cDwCoACbKdxd9FgrGncUrnNtHv9M7h1I6l/8FAVO2ym5DPSIAAAAASUVORK5CYII=",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/keplr/dmkamcknogkgcdfhhbddcghachkejeap",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/keplr",
      edge: "https://microsoftedge.microsoft.com/addons/detail/keplr/ocodgmmffbkkeecmadcijjhkmeohinei"
    }
  },
  {
    id: "fordefi",
    name: "Fordefi",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzNDk0XzY2MjU0KSI+CjxwYXRoIGQ9Ik0xMC44NzY5IDE1LjYzNzhIMS41VjE4LjM5OUMxLjUgMTkuODAxMyAyLjYzNDQ3IDIwLjkzOCA0LjAzMzkyIDIwLjkzOEg4LjI0OTkyTDEwLjg3NjkgMTUuNjM3OFoiIGZpbGw9IiM3OTk0RkYiLz4KPHBhdGggZD0iTTEuNSA5Ljc3NTUxSDE5LjA1MTZMMTcuMDEzOSAxMy44NzExSDEuNVY5Ljc3NTUxWiIgZmlsbD0iIzQ4NkRGRiIvPgo8cGF0aCBkPSJNNy42NTk5NiAzSDEuNTI0NDFWOC4wMDcwNEgyMi40NjEyVjNIMTYuMzI1NlY2LjczOTQ0SDE1LjA2MDZWM0g4LjkyNTAyVjYuNzM5NDRINy42NTk5NlYzWiIgZmlsbD0iIzVDRDFGQSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzNDk0XzY2MjU0Ij4KPHJlY3Qgd2lkdGg9IjIxIiBoZWlnaHQ9IjE4IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS41IDMpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/fordefi/hcmehenccjdmfbojapcbcofkgdpbnlle"
    }
  }
];
var z$4, j$5, P$3, V$4, ee$4, k$2, F$2;
class LocalStorageWrapper {
  constructor(e0) {
    T$4(this, V$4), T$4(this, k$2), T$4(this, z$4, !1), T$4(this, j$5, void 0), T$4(this, P$3, void 0), _$3(this, "value"), B$4(this, P$3, e0), E$2(this, k$2, F$2).call(this);
  }
  set(e0) {
    return !N$5(this, z$4) && !E$2(this, k$2, F$2).call(this) ? !1 : (this.delete(), this.value = e0, e0 && (B$4(this, j$5, `${N$5(this, P$3)}-${generateUID()}`), localStorage.setItem(N$5(this, j$5), e0)), !0);
  }
  get() {
    return E$2(this, V$4, ee$4).call(this), this.value;
  }
  delete() {
    return !N$5(this, z$4) && !E$2(this, k$2, F$2).call(this) ? !1 : (this.value = null, N$5(this, j$5) && localStorage.removeItem(N$5(this, j$5)), !0);
  }
}
z$4 = /* @__PURE__ */ new WeakMap(), j$5 = /* @__PURE__ */ new WeakMap(), P$3 = /* @__PURE__ */ new WeakMap(), V$4 = /* @__PURE__ */ new WeakSet(), ee$4 = function() {
  this.value && this.set(this.value);
}, k$2 = /* @__PURE__ */ new WeakSet(), F$2 = function() {
  try {
    !N$5(this, z$4) && typeof window < "u" && (B$4(this, j$5, Object.keys(localStorage).find(
      (t0) => t0.startsWith(N$5(this, P$3))
    )), B$4(this, z$4, !0), N$5(this, j$5) && this.set(localStorage.getItem(N$5(this, j$5))));
  } catch (t0) {
    console.warn(t0);
  }
  return N$5(this, z$4);
};
const Permission = {
  ACCOUNTS: "accounts"
};
function filterBy(t0, e0) {
  var n0, r0;
  if ((n0 = e0?.include) != null && n0.length) {
    const i0 = new Set(e0.include);
    return t0.filter((o0) => i0.has(o0.id));
  }
  if ((r0 = e0?.exclude) != null && r0.length) {
    const i0 = new Set(e0.exclude);
    return t0.filter((o0) => !i0.has(o0.id));
  }
  return t0;
}
const filterByAuthorized = async (t0) => {
  const e0 = await Promise.all(
    t0.map(async (n0) => {
      try {
        return (await n0.request({
          type: "wallet_getPermissions"
        })).includes(Permission.ACCOUNTS);
      } catch {
        return !1;
      }
    })
  );
  return t0.filter((n0, r0) => e0[r0]);
}, virtualWalletKeys = ensureKeysArray({
  id: !0,
  name: !0,
  icon: !0,
  windowKey: !0,
  loadWallet: !0,
  hasSupport: !0
}), fullWalletKeys = ensureKeysArray({
  id: !0,
  name: !0,
  version: !0,
  icon: !0,
  request: !0,
  on: !0,
  off: !0
});
function createWalletGuard(t0) {
  return function(e0) {
    return e0 !== null && typeof e0 == "object" && t0.every((n0) => n0 in e0);
  };
}
const isFullWallet = createWalletGuard(fullWalletKeys), isVirtualWallet = createWalletGuard(virtualWalletKeys);
function isWalletObject(t0) {
  try {
    return isFullWallet(t0) || isVirtualWallet(t0);
  } catch {
  }
  return !1;
}
function scanObjectForWallets(t0, e0) {
  return Object.values(
    Object.getOwnPropertyNames(t0).reduce((n0, r0) => {
      if (r0.startsWith("starknet")) {
        const i0 = t0[r0];
        e0(i0) && !n0[i0.id] && (n0[i0.id] = i0);
      }
      return n0;
    }, {})
  );
}
const sortBy = (t0, e0) => {
  if (e0 && Array.isArray(e0)) {
    t0.sort((r0, i0) => e0.indexOf(r0.id) - e0.indexOf(i0.id));
    const n0 = t0.length - e0.length;
    return [
      ...t0.slice(n0),
      ...shuffle(t0.slice(0, n0))
    ];
  } else
    return shuffle(t0);
}, virtualWallets = [metaMaskVirtualWallet];
function initiateVirtualWallets(t0) {
  virtualWallets.forEach(async (e0) => {
    e0.windowKey in t0 || await e0.hasSupport(t0) && (t0[e0.windowKey] = e0);
  });
}
const virtualWalletsMap = {};
async function resolveVirtualWallet(t0, e0) {
  let n0 = virtualWalletsMap[e0.id];
  return n0 || (n0 = await e0.loadWallet(t0), virtualWalletsMap[e0.id] = n0), n0;
}
const defaultOptions = {
  windowObject: ssrSafeWindow ?? {},
  isWalletObject,
  storageFactoryImplementation: (t0) => new LocalStorageWrapper(t0)
};
function getStarknet(t0 = {}) {
  const { storageFactoryImplementation: e0, windowObject: n0, isWalletObject: r0 } = {
    ...defaultOptions,
    ...t0
  }, i0 = e0("gsw-last");
  return initiateVirtualWallets(n0), {
    getAvailableWallets: async (o0 = {}) => {
      const s0 = scanObjectForWallets(
        n0,
        r0
      );
      return pipe$1(
        (a0) => filterBy(a0, o0),
        (a0) => sortBy(a0, o0.sort)
      )(s0);
    },
    getAuthorizedWallets: async (o0 = {}) => {
      const s0 = scanObjectForWallets(
        n0,
        r0
      );
      return pipe$1(
        (a0) => filterByAuthorized(a0),
        (a0) => filterBy(a0, o0),
        (a0) => sortBy(a0, o0.sort)
      )(s0);
    },
    getDiscoveryWallets: async (o0 = {}) => pipe$1(
      (s0) => filterBy(s0, o0),
      (s0) => sortBy(s0, o0.sort)
    )(wallets),
    getLastConnectedWallet: async () => {
      const o0 = i0.get(), s0 = scanObjectForWallets(n0, r0).find(
        (c0) => c0.id === o0
      ), [a0] = await filterByAuthorized(
        s0 ? [s0] : []
      );
      return a0 || (i0.delete(), null);
    },
    discoverVirtualWallets: async (o0 = []) => {
      const s0 = new Set(o0), a0 = s0.size > 0 ? virtualWallets.filter(
        (c0) => s0.has(c0.name) || s0.has(c0.id)
      ) : virtualWallets;
      await Promise.all(
        a0.map(async (c0) => {
          await c0.hasSupport(n0) && (n0[c0.windowKey] = c0);
        })
      );
    },
    enable: async (o0, s0) => {
      let a0;
      if (isVirtualWallet(o0))
        a0 = await resolveVirtualWallet(n0, o0);
      else if (isFullWallet(o0))
        a0 = o0;
      else
        throw new Error("Invalid wallet object");
      await a0.request({
        type: "wallet_requestAccounts",
        params: {
          silent_mode: s0?.silent_mode
        }
      });
      const c0 = await a0.request({
        type: "wallet_getPermissions"
      });
      if (!(c0 != null && c0.includes(Permission.ACCOUNTS)))
        throw new Error("Failed to connect to wallet");
      return i0.set(a0.id), a0;
    },
    disconnect: async ({ clearLastWallet: o0 } = {}) => {
      o0 && i0.delete();
    }
  };
}
const main = getStarknet();
var x$5 = Object.defineProperty, O$3 = (t0, e0, n0) => e0 in t0 ? x$5(t0, e0, { enumerable: !0, configurable: !0, writable: !0, value: n0 }) : t0[e0] = n0, m$3 = (t0, e0, n0) => (O$3(t0, typeof e0 != "symbol" ? e0 + "" : e0, n0), n0);
const A$5 = {
  ACCOUNTS: "accounts"
};
let S$4 = class extends Error {
  constructor() {
    super(...arguments), m$3(this, "name", "ConnectorNotConnectedError"), m$3(this, "message", "Connector not connected");
  }
}, R$1 = class extends Error {
  constructor() {
    super(...arguments), m$3(this, "name", "ConnectorNotFoundError"), m$3(this, "message", "Connector not found");
  }
}, T$3 = class extends Error {
  constructor() {
    super(...arguments), m$3(this, "name", "UserRejectedRequestError"), m$3(this, "message", "User rejected request");
  }
};
const U$3 = (t0) => {
  localStorage.setItem("starknetLastConnectedWallet", t0);
}, W$4 = () => {
  localStorage.removeItem("starknetLastConnectedWallet");
};
var q$5 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function L$5(t0) {
  return t0 && t0.__esModule && Object.prototype.hasOwnProperty.call(t0, "default") ? t0.default : t0;
}
function F$1(t0) {
  if (t0.__esModule)
    return t0;
  var e0 = t0.default;
  if (typeof e0 == "function") {
    var n0 = function r0() {
      return this instanceof r0 ? Reflect.construct(e0, arguments, this.constructor) : e0.apply(this, arguments);
    };
    n0.prototype = e0.prototype;
  } else
    n0 = {};
  return Object.defineProperty(n0, "__esModule", { value: !0 }), Object.keys(t0).forEach(function(r0) {
    var i0 = Object.getOwnPropertyDescriptor(t0, r0);
    Object.defineProperty(n0, r0, i0.get ? i0 : {
      enumerable: !0,
      get: function() {
        return t0[r0];
      }
    });
  }), n0;
}
var E$1 = { exports: {} };
(function(t0) {
  var e0 = Object.prototype.hasOwnProperty, n0 = "~";
  function r0() {
  }
  Object.create && (r0.prototype = /* @__PURE__ */ Object.create(null), new r0().__proto__ || (n0 = !1));
  function i0(c0, l0, u0) {
    this.fn = c0, this.context = l0, this.once = u0 || !1;
  }
  function o0(c0, l0, u0, d0, h0) {
    if (typeof u0 != "function")
      throw new TypeError("The listener must be a function");
    var g0 = new i0(u0, d0 || c0, h0), w0 = n0 ? n0 + l0 : l0;
    return c0._events[w0] ? c0._events[w0].fn ? c0._events[w0] = [c0._events[w0], g0] : c0._events[w0].push(g0) : (c0._events[w0] = g0, c0._eventsCount++), c0;
  }
  function s0(c0, l0) {
    --c0._eventsCount === 0 ? c0._events = new r0() : delete c0._events[l0];
  }
  function a0() {
    this._events = new r0(), this._eventsCount = 0;
  }
  a0.prototype.eventNames = function() {
    var c0 = [], l0, u0;
    if (this._eventsCount === 0)
      return c0;
    for (u0 in l0 = this._events)
      e0.call(l0, u0) && c0.push(n0 ? u0.slice(1) : u0);
    return Object.getOwnPropertySymbols ? c0.concat(Object.getOwnPropertySymbols(l0)) : c0;
  }, a0.prototype.listeners = function(c0) {
    var l0 = n0 ? n0 + c0 : c0, u0 = this._events[l0];
    if (!u0)
      return [];
    if (u0.fn)
      return [u0.fn];
    for (var d0 = 0, h0 = u0.length, g0 = new Array(h0); d0 < h0; d0++)
      g0[d0] = u0[d0].fn;
    return g0;
  }, a0.prototype.listenerCount = function(c0) {
    var l0 = n0 ? n0 + c0 : c0, u0 = this._events[l0];
    return u0 ? u0.fn ? 1 : u0.length : 0;
  }, a0.prototype.emit = function(c0, l0, u0, d0, h0, g0) {
    var w0 = n0 ? n0 + c0 : c0;
    if (!this._events[w0])
      return !1;
    var y0 = this._events[w0], E0 = arguments.length, b0, O0;
    if (y0.fn) {
      switch (y0.once && this.removeListener(c0, y0.fn, void 0, !0), E0) {
        case 1:
          return y0.fn.call(y0.context), !0;
        case 2:
          return y0.fn.call(y0.context, l0), !0;
        case 3:
          return y0.fn.call(y0.context, l0, u0), !0;
        case 4:
          return y0.fn.call(y0.context, l0, u0, d0), !0;
        case 5:
          return y0.fn.call(y0.context, l0, u0, d0, h0), !0;
        case 6:
          return y0.fn.call(y0.context, l0, u0, d0, h0, g0), !0;
      }
      for (O0 = 1, b0 = new Array(E0 - 1); O0 < E0; O0++)
        b0[O0 - 1] = arguments[O0];
      y0.fn.apply(y0.context, b0);
    } else {
      var S0 = y0.length, k0;
      for (O0 = 0; O0 < S0; O0++)
        switch (y0[O0].once && this.removeListener(c0, y0[O0].fn, void 0, !0), E0) {
          case 1:
            y0[O0].fn.call(y0[O0].context);
            break;
          case 2:
            y0[O0].fn.call(y0[O0].context, l0);
            break;
          case 3:
            y0[O0].fn.call(y0[O0].context, l0, u0);
            break;
          case 4:
            y0[O0].fn.call(y0[O0].context, l0, u0, d0);
            break;
          default:
            if (!b0)
              for (k0 = 1, b0 = new Array(E0 - 1); k0 < E0; k0++)
                b0[k0 - 1] = arguments[k0];
            y0[O0].fn.apply(y0[O0].context, b0);
        }
    }
    return !0;
  }, a0.prototype.on = function(c0, l0, u0) {
    return o0(this, c0, l0, u0, !1);
  }, a0.prototype.once = function(c0, l0, u0) {
    return o0(this, c0, l0, u0, !0);
  }, a0.prototype.removeListener = function(c0, l0, u0, d0) {
    var h0 = n0 ? n0 + c0 : c0;
    if (!this._events[h0])
      return this;
    if (!l0)
      return s0(this, h0), this;
    var g0 = this._events[h0];
    if (g0.fn)
      g0.fn === l0 && (!d0 || g0.once) && (!u0 || g0.context === u0) && s0(this, h0);
    else {
      for (var w0 = 0, y0 = [], E0 = g0.length; w0 < E0; w0++)
        (g0[w0].fn !== l0 || d0 && !g0[w0].once || u0 && g0[w0].context !== u0) && y0.push(g0[w0]);
      y0.length ? this._events[h0] = y0.length === 1 ? y0[0] : y0 : s0(this, h0);
    }
    return this;
  }, a0.prototype.removeAllListeners = function(c0) {
    var l0;
    return c0 ? (l0 = n0 ? n0 + c0 : c0, this._events[l0] && s0(this, l0)) : (this._events = new r0(), this._eventsCount = 0), this;
  }, a0.prototype.off = a0.prototype.removeListener, a0.prototype.addListener = a0.prototype.on, a0.prefixed = n0, a0.EventEmitter = a0, t0.exports = a0;
})(E$1);
var j$4 = E$1.exports;
const N$4 = /* @__PURE__ */ L$5(j$4);
let M$5 = class extends N$4 {
  /** Handle starknet-react type compatibility */
  eventNames() {
    return ["change", "connect", "disconnect"];
  }
};
const fn$1 = "https://web.ready.co", Ra$1 = (t0) => t0 === constants.StarknetChainId.SN_MAIN ? constants.StarknetChainId.SN_MAIN : constants.StarknetChainId.SN_SEPOLIA, G$3 = constants.NetworkName;
G$3.SN_SEPOLIA;
function hn$1(t0) {
  return t0;
}
function mn$1(t0) {
  return t0.length === 0 ? hn$1 : t0.length === 1 ? t0[0] : function(e0) {
    return t0.reduce((n0, r0) => r0(n0), e0);
  };
}
function yn$1(t0) {
  return typeof t0 == "object" && t0 !== null && "subscribe" in t0;
}
function Ke$2(t0) {
  const e0 = {
    subscribe(n0) {
      let r0 = null, i0 = !1, o0 = !1, s0 = !1;
      function a0() {
        if (r0 === null) {
          s0 = !0;
          return;
        }
        o0 || (o0 = !0, typeof r0 == "function" ? r0() : r0 && r0.unsubscribe());
      }
      return r0 = t0({
        next(c0) {
          i0 || n0.next?.(c0);
        },
        error(c0) {
          i0 || (i0 = !0, n0.error?.(c0), a0());
        },
        complete() {
          i0 || (i0 = !0, n0.complete?.(), a0());
        }
      }), s0 && a0(), {
        unsubscribe: a0
      };
    },
    pipe(...n0) {
      return mn$1(n0)(e0);
    }
  };
  return e0;
}
function dr$2(t0) {
  return (e0) => {
    let n0 = 0, r0 = null;
    const i0 = [];
    function o0() {
      r0 || (r0 = e0.subscribe({
        next(a0) {
          for (const c0 of i0)
            c0.next?.(a0);
        },
        error(a0) {
          for (const c0 of i0)
            c0.error?.(a0);
        },
        complete() {
          for (const a0 of i0)
            a0.complete?.();
        }
      }));
    }
    function s0() {
      if (n0 === 0 && r0) {
        const a0 = r0;
        r0 = null, a0.unsubscribe();
      }
    }
    return {
      subscribe(a0) {
        return n0++, i0.push(a0), o0(), {
          unsubscribe() {
            n0--, s0();
            const c0 = i0.findIndex((l0) => l0 === a0);
            c0 > -1 && i0.splice(c0, 1);
          }
        };
      }
    };
  };
}
function gn$1(t0) {
  return (e0) => ({
    subscribe(n0) {
      let r0 = 0;
      return e0.subscribe({
        next(i0) {
          n0.next?.(t0(i0, r0++));
        },
        error(i0) {
          n0.error?.(i0);
        },
        complete() {
          n0.complete?.();
        }
      });
    }
  });
}
function lr$2(t0) {
  return (e0) => ({
    subscribe(n0) {
      return e0.subscribe({
        next(r0) {
          t0.next?.(r0), n0.next?.(r0);
        },
        error(r0) {
          t0.error?.(r0), n0.error?.(r0);
        },
        complete() {
          t0.complete?.(), n0.complete?.();
        }
      });
    }
  });
}
let _n$1 = class Hm extends Error {
  constructor(e0) {
    super(e0), this.name = "ObservableAbortError", Object.setPrototypeOf(this, Hm.prototype);
  }
};
function pr$2(t0) {
  let e0;
  return {
    promise: new Promise((n0, r0) => {
      let i0 = !1;
      function o0() {
        i0 || (i0 = !0, r0(new _n$1("This operation was aborted.")), s0.unsubscribe());
      }
      const s0 = t0.subscribe({
        next(a0) {
          i0 = !0, n0(a0), o0();
        },
        error(a0) {
          i0 = !0, r0(a0), o0();
        },
        complete() {
          i0 = !0, o0();
        }
      });
      e0 = o0;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: e0
  };
}
const vn$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isObservable: yn$1,
  map: gn$1,
  observable: Ke$2,
  observableToPromise: pr$2,
  share: dr$2,
  tap: lr$2
}, Symbol.toStringTag, { value: "Module" }));
function mr$2(t0) {
  const e0 = /* @__PURE__ */ Object.create(null);
  for (const n0 in t0) {
    const r0 = t0[n0];
    e0[r0] = n0;
  }
  return e0;
}
const et$2 = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  // Internal JSON-RPC error
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
mr$2(et$2);
mr$2(et$2);
const wn$1 = {
  PARSE_ERROR: 400,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  NOT_FOUND: 404,
  FORBIDDEN: 403,
  METHOD_NOT_SUPPORTED: 405,
  TIMEOUT: 408,
  CONFLICT: 409,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  UNPROCESSABLE_CONTENT: 422,
  TOO_MANY_REQUESTS: 429,
  CLIENT_CLOSED_REQUEST: 499,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501
};
function xn$1(t0) {
  return wn$1[t0] ?? 500;
}
function yr$2(t0) {
  return xn$1(t0.code);
}
const gr$2 = () => {
};
function _r$2(t0, e0) {
  return new Proxy(gr$2, {
    get(n0, r0) {
      if (!(typeof r0 != "string" || r0 === "then"))
        return _r$2(t0, [
          ...e0,
          r0
        ]);
    },
    apply(n0, r0, i0) {
      const o0 = e0[e0.length - 1] === "apply";
      return t0({
        args: o0 ? i0.length >= 2 ? i0[1] : [] : i0,
        path: o0 ? e0.slice(0, -1) : e0
      });
    }
  });
}
const Pt$3 = (t0) => _r$2(t0, []), Nt$3 = (t0) => new Proxy(gr$2, {
  get(e0, n0) {
    if (!(typeof n0 != "string" || n0 === "then"))
      return t0(n0);
  }
});
function kn$1(t0) {
  const { path: e0, error: n0, config: r0 } = t0, { code: i0 } = t0.error, o0 = {
    message: n0.message,
    code: et$2[i0],
    data: {
      code: i0,
      httpStatus: yr$2(n0)
    }
  };
  return r0.isDev && typeof t0.error.stack == "string" && (o0.data.stack = t0.error.stack), typeof e0 == "string" && (o0.data.path = e0), r0.errorFormatter({
    ...t0,
    shape: o0
  });
}
function Ft$1(t0, e0) {
  return "error" in e0 ? {
    ...e0,
    error: t0.transformer.output.serialize(e0.error)
  } : "data" in e0.result ? {
    ...e0,
    result: {
      ...e0.result,
      data: t0.transformer.output.serialize(e0.result.data)
    }
  } : e0;
}
function Tn$1(t0, e0) {
  return Array.isArray(e0) ? e0.map((n0) => Ft$1(t0, n0)) : Ft$1(t0, e0);
}
function En$1(t0) {
  return !!t0 && !Array.isArray(t0) && typeof t0 == "object";
}
let Cn$1 = class extends Error {
};
function Lt$1(t0) {
  if (t0 instanceof Error)
    return t0;
  const e0 = typeof t0;
  if (!(e0 === "undefined" || e0 === "function" || t0 === null)) {
    if (e0 !== "object")
      return new Error(String(t0));
    if (En$1(t0)) {
      const n0 = new Cn$1();
      for (const r0 in t0)
        n0[r0] = t0[r0];
      return n0;
    }
  }
}
const Rn$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createFlatProxy: Nt$3,
  createRecursiveProxy: Pt$3,
  getCauseFromUnknown: Lt$1,
  getErrorShape: kn$1,
  transformTRPCResponse: Tn$1
}, Symbol.toStringTag, { value: "Module" }));
function Zn$1(t0) {
  if (t0 instanceof fe$4 || t0 instanceof Error && t0.name === "TRPCError")
    return t0;
  const e0 = new fe$4({
    code: "INTERNAL_SERVER_ERROR",
    cause: t0
  });
  return t0 instanceof Error && t0.stack && (e0.stack = t0.stack), e0;
}
let fe$4 = class extends Error {
  constructor(e0) {
    const n0 = Lt$1(e0.cause), r0 = e0.message ?? n0?.message ?? e0.code;
    super(r0, {
      cause: n0
    }), this.code = e0.code, this.name = "TRPCError", this.cause || (this.cause = n0);
  }
};
function Un$1(t0) {
  return "input" in t0 ? t0 : {
    input: t0,
    output: t0
  };
}
const Te$2 = {
  _default: !0,
  input: {
    serialize: (t0) => t0,
    deserialize: (t0) => t0
  },
  output: {
    serialize: (t0) => t0,
    deserialize: (t0) => t0
  }
}, Ee$2 = ({ shape: t0 }) => t0;
function qn$1(t0) {
  return Object.assign(/* @__PURE__ */ Object.create(null), t0);
}
const Bn$1 = [
  "query",
  "mutation",
  "subscription"
];
function Vn$1(t0) {
  return "router" in t0._def;
}
const zn$1 = {
  _ctx: null,
  _errorShape: null,
  _meta: null,
  queries: {},
  mutations: {},
  subscriptions: {},
  errorFormatter: Ee$2,
  transformer: Te$2
}, Wn$1 = [
  /**
  * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
  * since JS will think that `.then` is something that exists
  */
  "then"
];
function br$2(t0) {
  return function(e0) {
    const n0 = new Set(Object.keys(e0).filter((a0) => Wn$1.includes(a0)));
    if (n0.size > 0)
      throw new Error("Reserved words used in `router({})` call: " + Array.from(n0).join(", "));
    const r0 = qn$1({});
    function i0(a0, c0 = "") {
      for (const [l0, u0] of Object.entries(a0 ?? {})) {
        const d0 = `${c0}${l0}`;
        if (Vn$1(u0)) {
          i0(u0._def.procedures, `${d0}.`);
          continue;
        }
        if (r0[d0])
          throw new Error(`Duplicate key: ${d0}`);
        r0[d0] = u0;
      }
    }
    i0(e0);
    const o0 = {
      _config: t0,
      router: !0,
      procedures: r0,
      ...zn$1,
      record: e0,
      queries: Object.entries(r0).filter((a0) => a0[1]._def.query).reduce((a0, [c0, l0]) => ({
        ...a0,
        [c0]: l0
      }), {}),
      mutations: Object.entries(r0).filter((a0) => a0[1]._def.mutation).reduce((a0, [c0, l0]) => ({
        ...a0,
        [c0]: l0
      }), {}),
      subscriptions: Object.entries(r0).filter((a0) => a0[1]._def.subscription).reduce((a0, [c0, l0]) => ({
        ...a0,
        [c0]: l0
      }), {})
    }, s0 = {
      ...e0,
      _def: o0,
      createCaller(a0) {
        return wr$2()(s0)(a0);
      },
      getErrorShape(a0) {
        const { path: c0, error: l0 } = a0, { code: u0 } = a0.error, d0 = {
          message: l0.message,
          code: et$2[u0],
          data: {
            code: u0,
            httpStatus: yr$2(l0)
          }
        };
        return t0.isDev && typeof a0.error.stack == "string" && (d0.data.stack = a0.error.stack), typeof c0 == "string" && (d0.data.path = c0), this._def._config.errorFormatter({
          ...a0,
          shape: d0
        });
      }
    };
    return s0;
  };
}
function Hn$1(t0) {
  const { type: e0, path: n0 } = t0;
  if (!(n0 in t0.procedures) || !t0.procedures[n0]?._def[e0])
    throw new fe$4({
      code: "NOT_FOUND",
      message: `No "${e0}"-procedure on path "${n0}"`
    });
  const r0 = t0.procedures[n0];
  return r0(t0);
}
function wr$2() {
  return function(t0) {
    const e0 = t0._def;
    return function(n0) {
      return Pt$3(({ path: r0, args: i0 }) => {
        if (r0.length === 1 && Bn$1.includes(r0[0]))
          return Hn$1({
            procedures: e0.procedures,
            path: i0[0],
            rawInput: i0[1],
            ctx: n0,
            type: r0[0]
          });
        const o0 = r0.join("."), s0 = e0.procedures[o0];
        let a0 = "query";
        return s0._def.mutation ? a0 = "mutation" : s0._def.subscription && (a0 = "subscription"), s0({
          path: o0,
          rawInput: i0[0],
          ctx: n0,
          type: a0
        });
      });
    };
  };
}
const Yt$2 = typeof window > "u" || "Deno" in window || globalThis.process?.env?.NODE_ENV === "test" || !!globalThis.process?.env?.JEST_WORKER_ID || !!globalThis.process?.env?.VITEST_WORKER_ID;
function Gt$1(t0) {
  const e0 = t0;
  if (typeof e0 == "function")
    return e0;
  if (typeof e0.parseAsync == "function")
    return e0.parseAsync.bind(e0);
  if (typeof e0.parse == "function")
    return e0.parse.bind(e0);
  if (typeof e0.validateSync == "function")
    return e0.validateSync.bind(e0);
  if (typeof e0.create == "function")
    return e0.create.bind(e0);
  if (typeof e0.assert == "function")
    return (n0) => (e0.assert(n0), n0);
  throw new Error("Could not find a validator fn");
}
function xr$1(t0, ...e0) {
  const n0 = Object.assign(/* @__PURE__ */ Object.create(null), t0);
  for (const r0 of e0)
    for (const i0 in r0) {
      if (i0 in n0 && n0[i0] !== r0[i0])
        throw new Error(`Duplicate key ${i0}`);
      n0[i0] = r0[i0];
    }
  return n0;
}
function Fn$1() {
  function t0(n0) {
    return {
      _middlewares: n0,
      unstable_pipe(r0) {
        const i0 = "_middlewares" in r0 ? r0._middlewares : [
          r0
        ];
        return t0([
          ...n0,
          ...i0
        ]);
      }
    };
  }
  function e0(n0) {
    return t0([
      n0
    ]);
  }
  return e0;
}
function Qt$3(t0) {
  return t0 && typeof t0 == "object" && !Array.isArray(t0);
}
function Jn$1(t0) {
  const e0 = async ({ next: n0, rawInput: r0, input: i0 }) => {
    let o0;
    try {
      o0 = await t0(r0);
    } catch (a0) {
      throw new fe$4({
        code: "BAD_REQUEST",
        cause: a0
      });
    }
    const s0 = Qt$3(i0) && Qt$3(o0) ? {
      ...i0,
      ...o0
    } : o0;
    return n0({
      input: s0
    });
  };
  return e0._type = "input", e0;
}
function Yn$1(t0) {
  const e0 = async ({ next: n0 }) => {
    const r0 = await n0();
    if (!r0.ok)
      return r0;
    try {
      const i0 = await t0(r0.data);
      return {
        ...r0,
        data: i0
      };
    } catch (i0) {
      throw new fe$4({
        message: "Output validation failed",
        code: "INTERNAL_SERVER_ERROR",
        cause: i0
      });
    }
  };
  return e0._type = "output", e0;
}
const kr$2 = "middlewareMarker";
function ce$4(t0, e0) {
  const { middlewares: n0 = [], inputs: r0, meta: i0, ...o0 } = e0;
  return Tr$2({
    ...xr$1(t0, o0),
    inputs: [
      ...t0.inputs,
      ...r0 ?? []
    ],
    middlewares: [
      ...t0.middlewares,
      ...n0
    ],
    meta: t0.meta && i0 ? {
      ...t0.meta,
      ...i0
    } : i0 ?? t0.meta
  });
}
function Tr$2(t0 = {}) {
  const e0 = {
    inputs: [],
    middlewares: [],
    ...t0
  };
  return {
    _def: e0,
    input(n0) {
      const r0 = Gt$1(n0);
      return ce$4(e0, {
        inputs: [
          n0
        ],
        middlewares: [
          Jn$1(r0)
        ]
      });
    },
    output(n0) {
      const r0 = Gt$1(n0);
      return ce$4(e0, {
        output: n0,
        middlewares: [
          Yn$1(r0)
        ]
      });
    },
    meta(n0) {
      return ce$4(e0, {
        meta: n0
      });
    },
    /**
    * @deprecated
    * This functionality is deprecated and will be removed in the next major version.
    */
    unstable_concat(n0) {
      return ce$4(e0, n0._def);
    },
    use(n0) {
      const r0 = "_middlewares" in n0 ? n0._middlewares : [
        n0
      ];
      return ce$4(e0, {
        middlewares: r0
      });
    },
    query(n0) {
      return lt$2({
        ...e0,
        query: !0
      }, n0);
    },
    mutation(n0) {
      return lt$2({
        ...e0,
        mutation: !0
      }, n0);
    },
    subscription(n0) {
      return lt$2({
        ...e0,
        subscription: !0
      }, n0);
    }
  };
}
function lt$2(t0, e0) {
  const n0 = ce$4(t0, {
    resolver: e0,
    middlewares: [
      async function(r0) {
        const i0 = await e0(r0);
        return {
          marker: kr$2,
          ok: !0,
          data: i0,
          ctx: r0.ctx
        };
      }
    ]
  });
  return Qn$1(n0._def);
}
const Gn$1 = `
This is a client-only function.
If you want to call this function on the server, see https://trpc.io/docs/server/server-side-calls
`.trim();
function Qn$1(t0) {
  const e0 = async function(n0) {
    if (!n0 || !("rawInput" in n0))
      throw new Error(Gn$1);
    const r0 = async (o0 = {
      index: 0,
      ctx: n0.ctx
    }) => {
      try {
        const s0 = t0.middlewares[o0.index];
        return await s0({
          ctx: o0.ctx,
          type: n0.type,
          path: n0.path,
          rawInput: o0.rawInput ?? n0.rawInput,
          meta: t0.meta,
          input: o0.input,
          next(a0) {
            const c0 = a0;
            return r0({
              index: o0.index + 1,
              ctx: c0 && "ctx" in c0 ? {
                ...o0.ctx,
                ...c0.ctx
              } : o0.ctx,
              input: c0 && "input" in c0 ? c0.input : o0.input,
              rawInput: c0 && "rawInput" in c0 ? c0.rawInput : o0.rawInput
            });
          }
        });
      } catch (s0) {
        return {
          ok: !1,
          error: Zn$1(s0),
          marker: kr$2
        };
      }
    }, i0 = await r0();
    if (!i0)
      throw new fe$4({
        code: "INTERNAL_SERVER_ERROR",
        message: "No result from middlewares - did you forget to `return next()`?"
      });
    if (!i0.ok)
      throw i0.error;
    return i0.data;
  };
  return e0._def = t0, e0.meta = t0.meta, e0;
}
function Xn$1(...t0) {
  const e0 = xr$1({}, ...t0.map((i0) => i0._def.record)), n0 = t0.reduce((i0, o0) => {
    if (o0._def._config.errorFormatter && o0._def._config.errorFormatter !== Ee$2) {
      if (i0 !== Ee$2 && i0 !== o0._def._config.errorFormatter)
        throw new Error("You seem to have several error formatters");
      return o0._def._config.errorFormatter;
    }
    return i0;
  }, Ee$2), r0 = t0.reduce((i0, o0) => {
    if (o0._def._config.transformer && o0._def._config.transformer !== Te$2) {
      if (i0 !== Te$2 && i0 !== o0._def._config.transformer)
        throw new Error("You seem to have several transformers");
      return o0._def._config.transformer;
    }
    return i0;
  }, Te$2);
  return br$2({
    errorFormatter: n0,
    transformer: r0,
    isDev: t0.some((i0) => i0._def._config.isDev),
    allowOutsideOfServer: t0.some((i0) => i0._def._config.allowOutsideOfServer),
    isServer: t0.some((i0) => i0._def._config.isServer),
    $types: t0[0]?._def._config.$types
  })(e0);
}
let We$3 = class Dm {
  context() {
    return new Dm();
  }
  meta() {
    return new Dm();
  }
  create(e0) {
    return es$1()(e0);
  }
};
const Kn$1 = new We$3();
function es$1() {
  return function(t0) {
    const e0 = t0?.errorFormatter ?? Ee$2, n0 = {
      transformer: Un$1(t0?.transformer ?? Te$2),
      isDev: t0?.isDev ?? globalThis.process?.env?.NODE_ENV !== "production",
      allowOutsideOfServer: t0?.allowOutsideOfServer ?? !1,
      errorFormatter: e0,
      isServer: t0?.isServer ?? Yt$2,
      /**
      * @internal
      */
      $types: Nt$3((r0) => {
        throw new Error(`Tried to access "$types.${r0}" which is not available at runtime`);
      })
    };
    if (!(t0?.isServer ?? Yt$2) && t0?.allowOutsideOfServer !== !0)
      throw new Error("You're trying to use @trpc/server in a non-server environment. This is not supported by default.");
    return {
      /**
      * These are just types, they can't be used
      * @internal
      */
      _config: n0,
      /**
      * Builder object for creating procedures
      * @see https://trpc.io/docs/server/procedures
      */
      procedure: Tr$2({
        meta: t0?.defaultMeta
      }),
      /**
      * Create reusable middlewares
      * @see https://trpc.io/docs/server/middlewares
      */
      middleware: Fn$1(),
      /**
      * Create a router
      * @see https://trpc.io/docs/server/routers
      */
      router: br$2(n0),
      /**
      * Merge Routers
      * @see https://trpc.io/docs/server/merging-routers
      */
      mergeRouters: Xn$1,
      /**
      * Create a server-side caller for a router
      * @see https://trpc.io/docs/server/server-side-calls
      */
      createCallerFactory: wr$2()
    };
  };
}
var vt$3 = {}, tt$2 = {}, ye$3 = {}, S$3 = {};
const ge$3 = /* @__PURE__ */ F$1(vn$1);
var It$3 = {}, Er$2 = ge$3;
function Cr$2(t0) {
  return Er$2.observable((e0) => {
    function n0(r0 = 0, i0 = t0.op) {
      const o0 = t0.links[r0];
      if (!o0)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return o0({
        op: i0,
        next(s0) {
          return n0(r0 + 1, s0);
        }
      });
    }
    return n0().subscribe(e0);
  });
}
function Xt$2(t0) {
  return Array.isArray(t0) ? t0 : [
    t0
  ];
}
function ts$1(t0) {
  return (e0) => {
    const n0 = Xt$2(t0.true).map((i0) => i0(e0)), r0 = Xt$2(t0.false).map((i0) => i0(e0));
    return (i0) => Er$2.observable((o0) => {
      const s0 = t0.condition(i0.op) ? n0 : r0;
      return Cr$2({
        op: i0.op,
        links: s0
      }).subscribe(o0);
    });
  };
}
It$3.createChain = Cr$2;
It$3.splitLink = ts$1;
var _e$3 = {};
const Rr$2 = /* @__PURE__ */ F$1(Rn$1);
var ve$3 = {};
function bt$2(t0) {
  return !!t0 && !Array.isArray(t0) && typeof t0 == "object";
}
function rs$1(t0, e0) {
  if ("error" in t0) {
    const n0 = e0.transformer.deserialize(t0.error);
    return {
      ok: !1,
      error: {
        ...t0,
        error: n0
      }
    };
  }
  return {
    ok: !0,
    result: {
      ...t0.result,
      ...(!t0.result.type || t0.result.type === "data") && {
        type: "data",
        data: e0.transformer.deserialize(t0.result.data)
      }
    }
  };
}
let ft$2 = class extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
};
function ns$1(t0, e0) {
  let n0;
  try {
    n0 = rs$1(t0, e0);
  } catch {
    throw new ft$2();
  }
  if (!n0.ok && (!bt$2(n0.error.error) || typeof n0.error.error.code != "number"))
    throw new ft$2();
  if (n0.ok && !bt$2(n0.result))
    throw new ft$2();
  return n0;
}
ve$3.isObject = bt$2;
ve$3.transformResult = ns$1;
var ss$1 = Rr$2, Kt$2 = ve$3;
function is$2(t0) {
  return t0 instanceof Or$2 || /**
  * @deprecated
  * Delete in next major
  */
  t0 instanceof Error && t0.name === "TRPCClientError";
}
function as$1(t0) {
  return Kt$2.isObject(t0) && Kt$2.isObject(t0.error) && typeof t0.error.code == "number" && typeof t0.error.message == "string";
}
let Or$2 = class lm extends Error {
  static from(e0, n0 = {}) {
    const r0 = e0;
    return is$2(r0) ? (n0.meta && (r0.meta = {
      ...r0.meta,
      ...n0.meta
    }), r0) : as$1(r0) ? new lm(r0.error.message, {
      ...n0,
      result: r0
    }) : r0 instanceof Error ? new lm(r0.message, {
      ...n0,
      cause: ss$1.getCauseFromUnknown(r0)
    }) : new lm("Unknown error", {
      ...n0,
      cause: r0
    });
  }
  constructor(e0, n0) {
    const r0 = n0?.cause;
    super(e0, {
      cause: r0
    }), this.meta = n0?.meta, this.cause = r0, this.shape = n0?.result?.error, this.data = n0?.result?.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, lm.prototype);
  }
};
_e$3.TRPCClientError = Or$2;
var W$3 = {}, os$1 = _e$3;
const er$2 = (t0) => typeof t0 == "function";
function Sr$1(t0) {
  if (t0)
    return t0;
  if (typeof window < "u" && er$2(window.fetch))
    return window.fetch;
  if (typeof globalThis < "u" && er$2(globalThis.fetch))
    return globalThis.fetch;
  throw new Error("No fetch implementation found");
}
function cs$1(t0) {
  return t0 || (typeof window < "u" && window.AbortController ? window.AbortController : typeof globalThis < "u" && globalThis.AbortController ? globalThis.AbortController : null);
}
function us$1(t0) {
  return {
    url: t0.url.toString().replace(/\/$/, ""),
    fetch: t0.fetch,
    AbortController: cs$1(t0.AbortController)
  };
}
function ds$1(t0) {
  const e0 = {};
  for (let n0 = 0; n0 < t0.length; n0++) {
    const r0 = t0[n0];
    e0[n0] = r0;
  }
  return e0;
}
const ls$1 = {
  query: "GET",
  mutation: "POST"
};
function Pr$2(t0) {
  return "input" in t0 ? t0.runtime.transformer.serialize(t0.input) : ds$1(t0.inputs.map((e0) => t0.runtime.transformer.serialize(e0)));
}
const Nr$2 = (t0) => {
  let e0 = t0.url + "/" + t0.path;
  const n0 = [];
  if ("inputs" in t0 && n0.push("batch=1"), t0.type === "query") {
    const r0 = Pr$2(t0);
    r0 !== void 0 && n0.push(`input=${encodeURIComponent(JSON.stringify(r0))}`);
  }
  return n0.length && (e0 += "?" + n0.join("&")), e0;
}, Lr$1 = (t0) => {
  if (t0.type === "query")
    return;
  const e0 = Pr$2(t0);
  return e0 !== void 0 ? JSON.stringify(e0) : void 0;
}, fs$1 = (t0) => jr$2({
  ...t0,
  contentTypeHeader: "application/json",
  getUrl: Nr$2,
  getBody: Lr$1
});
async function Ir$2(t0, e0) {
  const n0 = t0.getUrl(t0), r0 = t0.getBody(t0), { type: i0 } = t0, o0 = await t0.headers();
  /* istanbul ignore if -- @preserve */
  if (i0 === "subscription")
    throw new Error("Subscriptions should use wsLink");
  const s0 = {
    ...t0.contentTypeHeader ? {
      "content-type": t0.contentTypeHeader
    } : {},
    ...t0.batchModeHeader ? {
      "trpc-batch-mode": t0.batchModeHeader
    } : {},
    ...o0
  };
  return Sr$1(t0.fetch)(n0, {
    method: ls$1[i0],
    signal: e0?.signal,
    body: r0,
    headers: s0
  });
}
function jr$2(t0) {
  const e0 = t0.AbortController ? new t0.AbortController() : null, n0 = {};
  let r0 = !1;
  return {
    promise: new Promise((i0, o0) => {
      Ir$2(t0, e0).then((s0) => (n0.response = s0, r0 = !0, s0.json())).then((s0) => {
        n0.responseJSON = s0, i0({
          json: s0,
          meta: n0
        });
      }).catch((s0) => {
        r0 = !0, o0(os$1.TRPCClientError.from(s0, {
          meta: n0
        }));
      });
    }),
    cancel: () => {
      r0 || e0?.abort();
    }
  };
}
W$3.fetchHTTPResponse = Ir$2;
W$3.getBody = Lr$1;
W$3.getFetch = Sr$1;
W$3.getUrl = Nr$2;
W$3.httpRequest = jr$2;
W$3.jsonHttpRequester = fs$1;
W$3.resolveHTTPLinkOptions = us$1;
var jt$2 = {}, ps$1 = ge$3, hs$1 = ve$3, tr$2 = _e$3, wt$2 = W$3;
const pt$2 = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function ht$2(t0) {
  let e0 = null, n0 = null;
  const r0 = () => {
    clearTimeout(n0), n0 = null, e0 = null;
  };
  function i0(a0) {
    const c0 = [
      []
    ];
    let l0 = 0;
    for (; ; ) {
      const u0 = a0[l0];
      if (!u0)
        break;
      const d0 = c0[c0.length - 1];
      if (u0.aborted) {
        u0.reject?.(new Error("Aborted")), l0++;
        continue;
      }
      if (t0.validate(d0.concat(u0).map((h0) => h0.key))) {
        d0.push(u0), l0++;
        continue;
      }
      if (d0.length === 0) {
        u0.reject?.(new Error("Input is too big for a single dispatch")), l0++;
        continue;
      }
      c0.push([]);
    }
    return c0;
  }
  function o0() {
    const a0 = i0(e0);
    r0();
    for (const c0 of a0) {
      if (!c0.length)
        continue;
      const l0 = {
        items: c0,
        cancel: pt$2
      };
      for (const g0 of c0)
        g0.batch = l0;
      const u0 = (g0, w0) => {
        const y0 = l0.items[g0];
        y0.resolve?.(w0), y0.batch = null, y0.reject = null, y0.resolve = null;
      }, { promise: d0, cancel: h0 } = t0.fetch(l0.items.map((g0) => g0.key), u0);
      l0.cancel = h0, d0.then((g0) => {
        for (let w0 = 0; w0 < g0.length; w0++) {
          const y0 = g0[w0];
          u0(w0, y0);
        }
        for (const w0 of l0.items)
          w0.reject?.(new Error("Missing result")), w0.batch = null;
      }).catch((g0) => {
        for (const w0 of l0.items)
          w0.reject?.(g0), w0.batch = null;
      });
    }
  }
  function s0(a0) {
    const c0 = {
      aborted: !1,
      key: a0,
      batch: null,
      resolve: pt$2,
      reject: pt$2
    }, l0 = new Promise((u0, d0) => {
      c0.reject = d0, c0.resolve = u0, e0 || (e0 = []), e0.push(c0);
    });
    return n0 || (n0 = setTimeout(o0)), {
      promise: l0,
      cancel: () => {
        c0.aborted = !0, c0.batch?.items.every((u0) => u0.aborted) && (c0.batch.cancel(), c0.batch = null);
      }
    };
  }
  return {
    load: s0
  };
}
function Ar$2(t0) {
  return function(e0) {
    const n0 = wt$2.resolveHTTPLinkOptions(e0), r0 = e0.maxURLLength ?? 1 / 0;
    return (i0) => {
      const o0 = (u0) => {
        const d0 = (g0) => {
          if (r0 === 1 / 0)
            return !0;
          const w0 = g0.map((E0) => E0.path).join(","), y0 = g0.map((E0) => E0.input);
          return wt$2.getUrl({
            ...n0,
            runtime: i0,
            type: u0,
            path: w0,
            inputs: y0
          }).length <= r0;
        }, h0 = t0({
          ...n0,
          runtime: i0,
          type: u0,
          opts: e0
        });
        return {
          validate: d0,
          fetch: h0
        };
      }, s0 = ht$2(o0("query")), a0 = ht$2(o0("mutation")), c0 = ht$2(o0("subscription")), l0 = {
        query: s0,
        subscription: c0,
        mutation: a0
      };
      return ({ op: u0 }) => ps$1.observable((d0) => {
        const h0 = l0[u0.type], { promise: g0, cancel: w0 } = h0.load(u0);
        let y0;
        return g0.then((E0) => {
          y0 = E0;
          const b0 = hs$1.transformResult(E0.json, i0);
          if (!b0.ok) {
            d0.error(tr$2.TRPCClientError.from(b0.error, {
              meta: E0.meta
            }));
            return;
          }
          d0.next({
            context: E0.meta,
            result: b0.result
          }), d0.complete();
        }).catch((E0) => {
          d0.error(tr$2.TRPCClientError.from(E0, {
            meta: y0?.meta
          }));
        }), () => {
          w0();
        };
      });
    };
  };
}
const ms$2 = (t0) => (e0) => {
  const n0 = e0.map((s0) => s0.path).join(","), r0 = e0.map((s0) => s0.input), { promise: i0, cancel: o0 } = wt$2.jsonHttpRequester({
    ...t0,
    path: n0,
    inputs: r0,
    headers() {
      return t0.opts.headers ? typeof t0.opts.headers == "function" ? t0.opts.headers({
        opList: e0
      }) : t0.opts.headers : {};
    }
  });
  return {
    promise: i0.then((s0) => (Array.isArray(s0.json) ? s0.json : e0.map(() => s0.json)).map((a0) => ({
      meta: s0.meta,
      json: a0
    }))),
    cancel: o0
  };
}, ys$1 = Ar$2(ms$2);
jt$2.createHTTPBatchLink = Ar$2;
jt$2.httpBatchLink = ys$1;
var rt$2 = {};
Object.defineProperty(rt$2, "__esModule", { value: !0 });
var gs$1 = ge$3, _s$1 = ve$3, rr$2 = _e$3, $r$2 = W$3;
function Mr$1(t0) {
  return (e0) => {
    const n0 = $r$2.resolveHTTPLinkOptions(e0);
    return (r0) => ({ op: i0 }) => gs$1.observable((o0) => {
      const { path: s0, input: a0, type: c0 } = i0, { promise: l0, cancel: u0 } = t0.requester({
        ...n0,
        runtime: r0,
        type: c0,
        path: s0,
        input: a0,
        headers() {
          return e0.headers ? typeof e0.headers == "function" ? e0.headers({
            op: i0
          }) : e0.headers : {};
        }
      });
      let d0;
      return l0.then((h0) => {
        d0 = h0.meta;
        const g0 = _s$1.transformResult(h0.json, r0);
        if (!g0.ok) {
          o0.error(rr$2.TRPCClientError.from(g0.error, {
            meta: d0
          }));
          return;
        }
        o0.next({
          context: h0.meta,
          result: g0.result
        }), o0.complete();
      }).catch((h0) => {
        o0.error(rr$2.TRPCClientError.from(h0, {
          meta: d0
        }));
      }), () => {
        u0();
      };
    });
  };
}
const vs$1 = Mr$1({
  requester: $r$2.jsonHttpRequester
});
rt$2.httpLink = vs$1;
rt$2.httpLinkFactory = Mr$1;
var At$3 = {};
Object.defineProperty(At$3, "__esModule", { value: !0 });
var nr$2 = ge$3;
function bs$1(t0) {
  return typeof FormData > "u" ? !1 : t0 instanceof FormData;
}
const mt$2 = {
  css: {
    query: [
      "72e3ff",
      "3fb0d8"
    ],
    mutation: [
      "c5a3fc",
      "904dfc"
    ],
    subscription: [
      "ff49e1",
      "d83fbe"
    ]
  },
  ansi: {
    regular: {
      // Cyan background, black and white text respectively
      query: [
        "\x1B[30;46m",
        "\x1B[97;46m"
      ],
      // Magenta background, black and white text respectively
      mutation: [
        "\x1B[30;45m",
        "\x1B[97;45m"
      ],
      // Green background, black and white text respectively
      subscription: [
        "\x1B[30;42m",
        "\x1B[97;42m"
      ]
    },
    bold: {
      query: [
        "\x1B[1;30;46m",
        "\x1B[1;97;46m"
      ],
      mutation: [
        "\x1B[1;30;45m",
        "\x1B[1;97;45m"
      ],
      subscription: [
        "\x1B[1;30;42m",
        "\x1B[1;97;42m"
      ]
    }
  }
};
function ws$1(t0) {
  const { direction: e0, type: n0, path: r0, id: i0, input: o0 } = t0, s0 = [], a0 = [];
  if (t0.colorMode === "ansi") {
    const [d0, h0] = mt$2.ansi.regular[n0], [g0, w0] = mt$2.ansi.bold[n0], y0 = "\x1B[0m";
    return s0.push(e0 === "up" ? d0 : h0, e0 === "up" ? ">>" : "<<", n0, e0 === "up" ? g0 : w0, `#${i0}`, r0, y0), e0 === "up" ? a0.push({
      input: t0.input
    }) : a0.push({
      input: t0.input,
      // strip context from result cause it's too noisy in terminal wihtout collapse mode
      result: "result" in t0.result ? t0.result.result : t0.result,
      elapsedMs: t0.elapsedMs
    }), {
      parts: s0,
      args: a0
    };
  }
  const [c0, l0] = mt$2.css[n0], u0 = `
    background-color: #${e0 === "up" ? c0 : l0}; 
    color: ${e0 === "up" ? "black" : "white"};
    padding: 2px;
  `;
  return s0.push("%c", e0 === "up" ? ">>" : "<<", n0, `#${i0}`, `%c${r0}%c`, "%O"), a0.push(u0, `${u0}; font-weight: bold;`, `${u0}; font-weight: normal;`), e0 === "up" ? a0.push({
    input: o0,
    context: t0.context
  }) : a0.push({
    input: o0,
    result: t0.result,
    elapsedMs: t0.elapsedMs,
    context: t0.context
  }), {
    parts: s0,
    args: a0
  };
}
const xs$1 = ({ c: t0 = console, colorMode: e0 = "css" }) => (n0) => {
  const r0 = n0.input, i0 = bs$1(r0) ? Object.fromEntries(r0) : r0, { parts: o0, args: s0 } = ws$1({
    ...n0,
    colorMode: e0,
    input: i0
  }), a0 = n0.direction === "down" && n0.result && (n0.result instanceof Error || "error" in n0.result.result) ? "error" : "log";
  t0[a0].apply(null, [
    o0.join(" ")
  ].concat(s0));
};
function ks$1(t0 = {}) {
  const { enabled: e0 = () => !0 } = t0, n0 = t0.colorMode ?? (typeof window > "u" ? "ansi" : "css"), { logger: r0 = xs$1({
    c: t0.console,
    colorMode: n0
  }) } = t0;
  return () => ({ op: i0, next: o0 }) => nr$2.observable((s0) => {
    e0({
      ...i0,
      direction: "up"
    }) && r0({
      ...i0,
      direction: "up"
    });
    const a0 = Date.now();
    function c0(l0) {
      const u0 = Date.now() - a0;
      e0({
        ...i0,
        direction: "down",
        result: l0
      }) && r0({
        ...i0,
        direction: "down",
        elapsedMs: u0,
        result: l0
      });
    }
    return o0(i0).pipe(nr$2.tap({
      next(l0) {
        c0(l0);
      },
      error(l0) {
        c0(l0);
      }
    })).subscribe(s0);
  });
}
At$3.loggerLink = ks$1;
var nt$2 = {};
Object.defineProperty(nt$2, "__esModule", { value: !0 });
var Ts$1 = ge$3, Es$1 = ve$3, Dr$2 = _e$3;
/* istanbul ignore next -- @preserve */
const Cs$1 = (t0) => t0 === 0 ? 0 : Math.min(1e3 * 2 ** t0, 3e4);
function Rs$1(t0) {
  const { url: e0, WebSocket: n0 = WebSocket, retryDelayMs: r0 = Cs$1, onOpen: i0, onClose: o0 } = t0;
  /* istanbul ignore next -- @preserve */
  if (!n0)
    throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
  let s0 = [];
  const a0 = /* @__PURE__ */ Object.create(null);
  let c0 = 0, l0 = null, u0 = null, d0 = k0(), h0 = "connecting";
  function g0() {
    h0 !== "open" || l0 || (l0 = setTimeout(() => {
      l0 = null, s0.length === 1 ? d0.send(JSON.stringify(s0.pop())) : d0.send(JSON.stringify(s0)), s0 = [];
    }));
  }
  function w0() {
    if (u0 !== null || h0 === "closed")
      return;
    const z0 = r0(c0++);
    E0(z0);
  }
  function y0() {
    h0 = "connecting";
    const z0 = d0;
    d0 = k0(), b0(z0);
  }
  function E0(z0) {
    u0 || (h0 = "connecting", u0 = setTimeout(y0, z0));
  }
  function b0(z0) {
    Object.values(a0).some((G0) => G0.ws === z0) || z0.close();
  }
  function O0() {
    Object.values(a0).forEach((z0) => {
      z0.type === "subscription" && z0.callbacks.complete();
    });
  }
  function S0(z0) {
    s0.some((G0) => G0.id === z0.op.id) || D0(z0.op, z0.callbacks);
  }
  function k0() {
    const z0 = typeof e0 == "function" ? e0() : e0, G0 = new n0(z0);
    clearTimeout(u0), u0 = null, G0.addEventListener("open", () => {
      /* istanbul ignore next -- @preserve */
      G0 === d0 && (c0 = 0, h0 = "open", i0?.(), g0());
    }), G0.addEventListener("error", () => {
      G0 === d0 && w0();
    });
    const K0 = (F0) => {
      if (F0.method === "reconnect" && G0 === d0) {
        h0 === "open" && o0?.(), y0();
        for (const H0 of Object.values(a0))
          H0.type === "subscription" && S0(H0);
      }
    }, U0 = (F0) => {
      const H0 = F0.id !== null && a0[F0.id];
      if (H0) {
        if (H0.callbacks.next?.(F0), H0.ws !== d0 && G0 === d0) {
          const P0 = H0.ws;
          H0.ws = d0, b0(P0);
        }
        "result" in F0 && F0.result.type === "stopped" && G0 === d0 && H0.callbacks.complete();
      }
    };
    return G0.addEventListener("message", ({ data: F0 }) => {
      const H0 = JSON.parse(F0);
      "method" in H0 ? K0(H0) : U0(H0), (G0 !== d0 || h0 === "closed") && b0(G0);
    }), G0.addEventListener("close", ({ code: F0 }) => {
      h0 === "open" && o0?.({
        code: F0
      }), d0 === G0 && w0();
      for (const [H0, P0] of Object.entries(a0))
        if (P0.ws === G0) {
          if (h0 === "closed") {
            delete a0[H0], P0.callbacks.complete?.();
            continue;
          }
          P0.type === "subscription" ? S0(P0) : (delete a0[H0], P0.callbacks.error?.(Dr$2.TRPCClientError.from(new $t$2("WebSocket closed prematurely"))));
        }
    }), G0;
  }
  function D0(z0, G0) {
    const { type: K0, input: U0, path: F0, id: H0 } = z0, P0 = {
      id: H0,
      method: K0,
      params: {
        input: U0,
        path: F0
      }
    };
    return a0[H0] = {
      ws: d0,
      type: K0,
      callbacks: G0,
      op: z0
    }, s0.push(P0), g0(), () => {
      const I0 = a0[H0]?.callbacks;
      delete a0[H0], s0 = s0.filter((f0) => f0.id !== H0), I0?.complete?.(), d0.readyState === n0.OPEN && z0.type === "subscription" && (s0.push({
        id: H0,
        method: "subscription.stop"
      }), g0());
    };
  }
  return {
    close: () => {
      h0 = "closed", o0?.(), O0(), b0(d0), clearTimeout(u0), u0 = null;
    },
    request: D0,
    getConnection() {
      return d0;
    }
  };
}
let $t$2 = class Km extends Error {
  constructor(e0) {
    super(e0), this.name = "TRPCWebSocketClosedError", Object.setPrototypeOf(this, Km.prototype);
  }
};
function Os$1(t0) {
  return (e0) => {
    const { client: n0 } = t0;
    return ({ op: r0 }) => Ts$1.observable((i0) => {
      const { type: o0, path: s0, id: a0, context: c0 } = r0, l0 = e0.transformer.serialize(r0.input), u0 = n0.request({
        type: o0,
        path: s0,
        input: l0,
        id: a0,
        context: c0
      }, {
        error(d0) {
          i0.error(d0), u0();
        },
        complete() {
          i0.complete();
        },
        next(d0) {
          const h0 = Es$1.transformResult(d0, e0);
          if (!h0.ok) {
            i0.error(Dr$2.TRPCClientError.from(h0.error));
            return;
          }
          i0.next({
            result: h0.result
          }), r0.type !== "subscription" && (u0(), i0.complete());
        }
      });
      return () => {
        u0();
      };
    });
  };
}
nt$2.createWSClient = Rs$1;
nt$2.wsLink = Os$1;
Object.defineProperty(S$3, "__esModule", { value: !0 });
var sr$2 = ge$3, Zr$2 = It$3, Ur$2 = _e$3, ir$2 = Rr$2, Ce$3 = W$3, qr$2 = jt$2, Mt$3 = rt$2, Ss$1 = At$3, Br$1 = nt$2;
let st$2 = class {
  $request({ type: e0, input: n0, path: r0, context: i0 = {} }) {
    return Zr$2.createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: e0,
        path: r0,
        input: n0,
        context: i0
      }
    }).pipe(sr$2.share());
  }
  requestAsPromise(e0) {
    const n0 = this.$request(e0), { promise: r0, abort: i0 } = sr$2.observableToPromise(n0);
    return new Promise((o0, s0) => {
      e0.signal?.addEventListener("abort", i0), r0.then((a0) => {
        o0(a0.result.data);
      }).catch((a0) => {
        s0(Ur$2.TRPCClientError.from(a0));
      });
    });
  }
  query(e0, n0, r0) {
    return this.requestAsPromise({
      type: "query",
      path: e0,
      input: n0,
      context: r0?.context,
      signal: r0?.signal
    });
  }
  mutation(e0, n0, r0) {
    return this.requestAsPromise({
      type: "mutation",
      path: e0,
      input: n0,
      context: r0?.context,
      signal: r0?.signal
    });
  }
  subscription(e0, n0, r0) {
    return this.$request({
      type: "subscription",
      path: e0,
      input: n0,
      context: r0?.context
    }).subscribe({
      next(i0) {
        i0.result.type === "started" ? r0.onStarted?.() : i0.result.type === "stopped" ? r0.onStopped?.() : r0.onData?.(i0.result.data);
      },
      error(i0) {
        r0.onError?.(i0);
      },
      complete() {
        r0.onComplete?.();
      }
    });
  }
  constructor(e0) {
    this.requestId = 0;
    const n0 = (() => {
      const r0 = e0.transformer;
      return r0 ? "input" in r0 ? e0.transformer : {
        input: r0,
        output: r0
      } : {
        input: {
          serialize: (i0) => i0,
          deserialize: (i0) => i0
        },
        output: {
          serialize: (i0) => i0,
          deserialize: (i0) => i0
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (r0) => n0.input.serialize(r0),
        deserialize: (r0) => n0.output.deserialize(r0)
      },
      combinedTransformer: n0
    }, this.links = e0.links.map((r0) => r0(this.runtime));
  }
};
function Ps$1(t0) {
  return new st$2(t0);
}
function Ns$1(t0) {
  return new st$2(t0);
}
const Ls$1 = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
}, Vr$2 = (t0) => Ls$1[t0];
function zr$2(t0) {
  return ir$2.createFlatProxy((e0) => t0.hasOwnProperty(e0) ? t0[e0] : e0 === "__untypedClient" ? t0 : ir$2.createRecursiveProxy(({ path: n0, args: r0 }) => {
    const i0 = [
      e0,
      ...n0
    ], o0 = Vr$2(i0.pop()), s0 = i0.join(".");
    return t0[o0](s0, ...r0);
  }));
}
function Is$1(t0) {
  const e0 = new st$2(t0);
  return zr$2(e0);
}
function js$1(t0) {
  return t0.__untypedClient;
}
function As$1(t0) {
  if (t0)
    return t0;
  if (typeof window < "u" && window.TextDecoder)
    return new window.TextDecoder();
  if (typeof globalThis < "u" && globalThis.TextDecoder)
    return new globalThis.TextDecoder();
  throw new Error("No TextDecoder implementation found");
}
async function $s$1(t0) {
  const e0 = t0.parse ?? JSON.parse, n0 = (r0) => {
    if (t0.signal?.aborted || !r0 || r0 === "}")
      return;
    const i0 = r0.indexOf(":"), o0 = r0.substring(2, i0 - 1), s0 = r0.substring(i0 + 1);
    t0.onSingle(Number(o0), e0(s0));
  };
  await Ms$1(t0.readableStream, n0, t0.textDecoder);
}
async function Ms$1(t0, e0, n0) {
  let r0 = "";
  const i0 = (o0) => {
    const s0 = n0.decode(o0).split(`
`);
    if (s0.length === 1)
      r0 += s0[0];
    else if (s0.length > 1) {
      e0(r0 + s0[0]);
      for (let a0 = 1; a0 < s0.length - 1; a0++)
        e0(s0[a0]);
      r0 = s0[s0.length - 1];
    }
  };
  "getReader" in t0 ? await Zs$1(t0, i0) : await Ds$1(t0, i0), e0(r0);
}
function Ds$1(t0, e0) {
  return new Promise((n0) => {
    t0.on("data", e0), t0.on("end", n0);
  });
}
async function Zs$1(t0, e0) {
  const n0 = t0.getReader();
  let r0 = await n0.read();
  for (; !r0.done; )
    e0(r0.value), r0 = await n0.read();
}
const Us$1 = (t0, e0) => {
  const n0 = t0.AbortController ? new t0.AbortController() : null, r0 = Ce$3.fetchHTTPResponse({
    ...t0,
    contentTypeHeader: "application/json",
    batchModeHeader: "stream",
    getUrl: Ce$3.getUrl,
    getBody: Ce$3.getBody
  }, n0), i0 = () => n0?.abort(), o0 = r0.then(async (s0) => {
    if (!s0.body)
      throw new Error("Received response without body");
    const a0 = {
      response: s0
    };
    return $s$1({
      readableStream: s0.body,
      onSingle: e0,
      parse: (c0) => ({
        json: JSON.parse(c0),
        meta: a0
      }),
      signal: n0?.signal,
      textDecoder: t0.textDecoder
    });
  });
  return {
    cancel: i0,
    promise: o0
  };
}, qs$1 = (t0) => {
  const e0 = As$1(t0.opts.textDecoder);
  return (n0, r0) => {
    const i0 = n0.map((c0) => c0.path).join(","), o0 = n0.map((c0) => c0.input), { cancel: s0, promise: a0 } = Us$1({
      ...t0,
      textDecoder: e0,
      path: i0,
      inputs: o0,
      headers() {
        return t0.opts.headers ? typeof t0.opts.headers == "function" ? t0.opts.headers({
          opList: n0
        }) : t0.opts.headers : {};
      }
    }, (c0, l0) => {
      r0(c0, l0);
    });
    return {
      /**
      * return an empty array because the batchLoader expects an array of results
      * but we've already called the `unitResolver` for each of them, there's
      * nothing left to do here.
      */
      promise: a0.then(() => []),
      cancel: s0
    };
  };
}, Bs$1 = qr$2.createHTTPBatchLink(qs$1), Vs$1 = (t0) => {
  if ("input" in t0) {
    if (!(t0.input instanceof FormData))
      throw new Error("Input is not FormData");
    return t0.input;
  }
}, zs$1 = (t0) => {
  if (t0.type !== "mutation")
    throw new Error("We only handle mutations with formdata");
  return Ce$3.httpRequest({
    ...t0,
    getUrl() {
      return `${t0.url}/${t0.path}`;
    },
    getBody: Vs$1
  });
}, Ws$1 = Mt$3.httpLinkFactory({
  requester: zs$1
});
S$3.splitLink = Zr$2.splitLink;
S$3.TRPCClientError = Ur$2.TRPCClientError;
S$3.getFetch = Ce$3.getFetch;
S$3.httpBatchLink = qr$2.httpBatchLink;
S$3.httpLink = Mt$3.httpLink;
S$3.httpLinkFactory = Mt$3.httpLinkFactory;
S$3.loggerLink = Ss$1.loggerLink;
S$3.createWSClient = Br$1.createWSClient;
S$3.wsLink = Br$1.wsLink;
S$3.TRPCUntypedClient = st$2;
S$3.clientCallTypeToProcedureType = Vr$2;
S$3.createTRPCClient = Ns$1;
S$3.createTRPCClientProxy = zr$2;
S$3.createTRPCProxyClient = Is$1;
S$3.createTRPCUntypedClient = Ps$1;
S$3.experimental_formDataLink = Ws$1;
S$3.getUntypedClient = js$1;
S$3.unstable_httpBatchStreamLink = Bs$1;
var re$4 = {}, Dt$3 = {};
function Hs$1(t0) {
  return t0;
}
function Fs$1(t0) {
  return t0.length === 0 ? Hs$1 : t0.length === 1 ? t0[0] : function(e0) {
    return t0.reduce((n0, r0) => r0(n0), e0);
  };
}
function Js$1(t0) {
  return typeof t0 == "object" && t0 !== null && "subscribe" in t0;
}
function Ys$1(t0) {
  const e0 = {
    subscribe(n0) {
      let r0 = null, i0 = !1, o0 = !1, s0 = !1;
      function a0() {
        if (r0 === null) {
          s0 = !0;
          return;
        }
        o0 || (o0 = !0, typeof r0 == "function" ? r0() : r0 && r0.unsubscribe());
      }
      return r0 = t0({
        next(c0) {
          i0 || n0.next?.(c0);
        },
        error(c0) {
          i0 || (i0 = !0, n0.error?.(c0), a0());
        },
        complete() {
          i0 || (i0 = !0, n0.complete?.(), a0());
        }
      }), s0 && a0(), {
        unsubscribe: a0
      };
    },
    pipe(...n0) {
      return Fs$1(n0)(e0);
    }
  };
  return e0;
}
Dt$3.isObservable = Js$1;
Dt$3.observable = Ys$1;
Object.defineProperty(re$4, "__esModule", { value: !0 });
var Wr$2 = Dt$3;
function Gs$1(t0) {
  return (e0) => {
    let n0 = 0, r0 = null;
    const i0 = [];
    function o0() {
      r0 || (r0 = e0.subscribe({
        next(a0) {
          for (const c0 of i0)
            c0.next?.(a0);
        },
        error(a0) {
          for (const c0 of i0)
            c0.error?.(a0);
        },
        complete() {
          for (const a0 of i0)
            a0.complete?.();
        }
      }));
    }
    function s0() {
      if (n0 === 0 && r0) {
        const a0 = r0;
        r0 = null, a0.unsubscribe();
      }
    }
    return {
      subscribe(a0) {
        return n0++, i0.push(a0), o0(), {
          unsubscribe() {
            n0--, s0();
            const c0 = i0.findIndex((l0) => l0 === a0);
            c0 > -1 && i0.splice(c0, 1);
          }
        };
      }
    };
  };
}
function Qs$1(t0) {
  return (e0) => ({
    subscribe(n0) {
      let r0 = 0;
      return e0.subscribe({
        next(i0) {
          n0.next?.(t0(i0, r0++));
        },
        error(i0) {
          n0.error?.(i0);
        },
        complete() {
          n0.complete?.();
        }
      });
    }
  });
}
function Xs$1(t0) {
  return (e0) => ({
    subscribe(n0) {
      return e0.subscribe({
        next(r0) {
          t0.next?.(r0), n0.next?.(r0);
        },
        error(r0) {
          t0.error?.(r0), n0.error?.(r0);
        },
        complete() {
          t0.complete?.(), n0.complete?.();
        }
      });
    }
  });
}
let Zt$2 = class Ym extends Error {
  constructor(e0) {
    super(e0), this.name = "ObservableAbortError", Object.setPrototypeOf(this, Ym.prototype);
  }
};
function Ks$1(t0) {
  let e0;
  return {
    promise: new Promise((n0, r0) => {
      let i0 = !1;
      function o0() {
        i0 || (i0 = !0, r0(new Zt$2("This operation was aborted.")), s0.unsubscribe());
      }
      const s0 = t0.subscribe({
        next(a0) {
          i0 = !0, n0(a0), o0();
        },
        error(a0) {
          i0 = !0, r0(a0), o0();
        },
        complete() {
          i0 = !0, o0();
        }
      });
      e0 = o0;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: e0
  };
}
re$4.isObservable = Wr$2.isObservable;
re$4.observable = Wr$2.observable;
re$4.map = Qs$1;
re$4.observableToPromise = Ks$1;
re$4.share = Gs$1;
re$4.tap = Xs$1;
var q$4 = {};
Object.defineProperty(q$4, "__esModule", { value: !0 });
q$4.isTRPCRequestWithId = q$4.isTRPCRequest = q$4.isTRPCResponse = q$4.isTRPCMessage = void 0;
function ar$2(t0) {
  return typeof t0 == "object" && t0 !== null && !Array.isArray(t0);
}
function ei$1(t0) {
  return t0 == null;
}
function Hr$2(t0) {
  return !!(ar$2(t0) && "trpc" in t0 && ar$2(t0.trpc));
}
q$4.isTRPCMessage = Hr$2;
function Ut$3(t0) {
  return Hr$2(t0) && "id" in t0.trpc && !ei$1(t0.trpc.id);
}
function ti$1(t0) {
  return Ut$3(t0) && ("error" in t0.trpc || "result" in t0.trpc);
}
q$4.isTRPCResponse = ti$1;
function Fr$1(t0) {
  return Ut$3(t0) && "method" in t0.trpc;
}
q$4.isTRPCRequest = Fr$1;
function ri$1(t0) {
  return Fr$1(t0) && Ut$3(t0);
}
q$4.isTRPCRequestWithId = ri$1;
Object.defineProperty(ye$3, "__esModule", { value: !0 });
ye$3.createBaseLink = void 0;
const yt$3 = S$3, ni$1 = re$4, si$1 = q$4, ii$1 = (t0) => (e0) => ({ op: n0 }) => (0, ni$1.observable)((r0) => {
  const i0 = [], { id: o0, type: s0, path: a0 } = n0;
  try {
    const c0 = e0.transformer.serialize(n0.input), l0 = () => {
      r0.error(new yt$3.TRPCClientError("Port disconnected prematurely"));
    };
    t0.addCloseListener(l0), i0.push(() => t0.removeCloseListener(l0));
    const u0 = (d0) => {
      if (!(0, si$1.isTRPCResponse)(d0))
        return;
      const { trpc: h0 } = d0;
      if (o0 === h0.id) {
        if ("error" in h0)
          return r0.error(yt$3.TRPCClientError.from(h0));
        r0.next({
          result: Object.assign(Object.assign({}, h0.result), (!h0.result.type || h0.result.type === "data") && {
            type: "data",
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            data: e0.transformer.deserialize(h0.result.data)
          })
        }), (s0 !== "subscription" || h0.result.type === "stopped") && r0.complete();
      }
    };
    t0.addMessageListener(u0), i0.push(() => t0.removeMessageListener(u0)), t0.postMessage({
      trpc: {
        id: o0,
        jsonrpc: void 0,
        method: s0,
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        params: { path: a0, input: c0 }
      }
    });
  } catch (c0) {
    r0.error(new yt$3.TRPCClientError(c0 instanceof Error ? c0.message : "Unknown error"));
  }
  return () => {
    s0 === "subscription" && t0.postMessage({
      trpc: {
        id: o0,
        jsonrpc: void 0,
        method: "subscription.stop"
      }
    }), i0.forEach((c0) => c0());
  };
});
ye$3.createBaseLink = ii$1;
Object.defineProperty(tt$2, "__esModule", { value: !0 });
tt$2.chromeLink = void 0;
const ai$1 = ye$3, oi$1 = (t0) => (0, ai$1.createBaseLink)({
  postMessage(e0) {
    t0.port.postMessage(e0);
  },
  addMessageListener(e0) {
    t0.port.onMessage.addListener(e0);
  },
  removeMessageListener(e0) {
    t0.port.onMessage.removeListener(e0);
  },
  addCloseListener(e0) {
    t0.port.onDisconnect.addListener(e0);
  },
  removeCloseListener(e0) {
    t0.port.onDisconnect.removeListener(e0);
  }
});
tt$2.chromeLink = oi$1;
var it$2 = {};
Object.defineProperty(it$2, "__esModule", { value: !0 });
it$2.windowLink = void 0;
const ci$1 = ye$3, ui$1 = (t0) => {
  var e0;
  const n0 = /* @__PURE__ */ new Map(), r0 = t0.window, i0 = (e0 = t0.postWindow) !== null && e0 !== void 0 ? e0 : r0;
  return (0, ci$1.createBaseLink)({
    postMessage(o0) {
      i0.postMessage(o0, {
        targetOrigin: t0.postOrigin
      });
    },
    addMessageListener(o0) {
      const s0 = (a0) => {
        o0(a0.data);
      };
      n0.set(o0, s0), r0.addEventListener("message", s0);
    },
    removeMessageListener(o0) {
      const s0 = n0.get(o0);
      s0 && r0.removeEventListener("message", s0);
    },
    addCloseListener(o0) {
      r0.addEventListener("beforeunload", o0);
    },
    removeCloseListener(o0) {
      r0.removeEventListener("beforeunload", o0);
    }
  });
};
it$2.windowLink = ui$1;
var at$2 = {}, ot$2 = {};
Object.defineProperty(ot$2, "__esModule", { value: !0 });
ot$2.TRPC_BROWSER_LOADED_EVENT = void 0;
ot$2.TRPC_BROWSER_LOADED_EVENT = "TRPC_BROWSER::POPUP_LOADED";
Object.defineProperty(at$2, "__esModule", { value: !0 });
at$2.popupLink = void 0;
const di$1 = ot$2, li$1 = ye$3, fi$1 = (t0) => {
  const e0 = /* @__PURE__ */ new Map(), n0 = /* @__PURE__ */ new Set();
  let r0 = null;
  async function i0(o0) {
    if (!r0 || r0.closed) {
      r0 = t0.createPopup(), await Promise.race([
        // wait til window is loaded (same origin)
        new Promise((s0) => {
          var a0;
          try {
            (a0 = r0?.addEventListener) === null || a0 === void 0 || a0.call(r0, "load", s0);
          } catch {
          }
        }),
        // this is needed for cross-origin popups as they don't have a load event
        new Promise((s0) => {
          o0.addEventListener("message", (a0) => {
            a0.data === di$1.TRPC_BROWSER_LOADED_EVENT && s0();
          });
        }),
        // expect the popup to load after 15s max, in case non of the above events fire
        new Promise((s0) => {
          console.warn("Could not detect if popup loading succeeded after 15s timeout, continuing anyway"), setTimeout(s0, 15e3);
        })
      ]);
      try {
        if (!r0.addEventListener)
          throw new Error("popupWindow.addEventListener is not a function");
        r0.addEventListener("beforeunload", () => {
          r0 = null;
        });
      } catch {
        const s0 = setInterval(() => {
          r0 && r0.closed && (r0 = null, n0.forEach((a0) => {
            a0();
          }), clearInterval(s0));
        }, 1e3);
      }
    }
    return r0;
  }
  return (0, li$1.createBaseLink)({
    async postMessage(o0) {
      return (await i0(t0.listenWindow)).postMessage(o0, {
        targetOrigin: t0.postOrigin
      });
    },
    addMessageListener(o0) {
      const s0 = (a0) => {
        o0(a0.data);
      };
      e0.set(o0, s0), t0.listenWindow.addEventListener("message", s0);
    },
    removeMessageListener(o0) {
      const s0 = e0.get(o0);
      s0 && t0.listenWindow.removeEventListener("message", s0);
    },
    addCloseListener(o0) {
      t0.listenWindow.addEventListener("beforeunload", o0), n0.add(o0);
    },
    removeCloseListener(o0) {
      t0.listenWindow.removeEventListener("beforeunload", o0), n0.delete(o0);
    }
  });
};
at$2.popupLink = fi$1;
(function(t0) {
  var e0 = q$5 && q$5.__createBinding || (Object.create ? function(r0, i0, o0, s0) {
    s0 === void 0 && (s0 = o0);
    var a0 = Object.getOwnPropertyDescriptor(i0, o0);
    (!a0 || ("get" in a0 ? !i0.__esModule : a0.writable || a0.configurable)) && (a0 = { enumerable: !0, get: function() {
      return i0[o0];
    } }), Object.defineProperty(r0, s0, a0);
  } : function(r0, i0, o0, s0) {
    s0 === void 0 && (s0 = o0), r0[s0] = i0[o0];
  }), n0 = q$5 && q$5.__exportStar || function(r0, i0) {
    for (var o0 in r0)
      o0 !== "default" && !Object.prototype.hasOwnProperty.call(i0, o0) && e0(i0, r0, o0);
  };
  Object.defineProperty(t0, "__esModule", { value: !0 }), n0(tt$2, t0), n0(it$2, t0), n0(at$2, t0);
})(vt$3);
var x$4;
(function(t0) {
  t0.assertEqual = (i0) => i0;
  function e0(i0) {
  }
  t0.assertIs = e0;
  function n0(i0) {
    throw new Error();
  }
  t0.assertNever = n0, t0.arrayToEnum = (i0) => {
    const o0 = {};
    for (const s0 of i0)
      o0[s0] = s0;
    return o0;
  }, t0.getValidEnumValues = (i0) => {
    const o0 = t0.objectKeys(i0).filter((a0) => typeof i0[i0[a0]] != "number"), s0 = {};
    for (const a0 of o0)
      s0[a0] = i0[a0];
    return t0.objectValues(s0);
  }, t0.objectValues = (i0) => t0.objectKeys(i0).map(function(o0) {
    return i0[o0];
  }), t0.objectKeys = typeof Object.keys == "function" ? (i0) => Object.keys(i0) : (i0) => {
    const o0 = [];
    for (const s0 in i0)
      Object.prototype.hasOwnProperty.call(i0, s0) && o0.push(s0);
    return o0;
  }, t0.find = (i0, o0) => {
    for (const s0 of i0)
      if (o0(s0))
        return s0;
  }, t0.isInteger = typeof Number.isInteger == "function" ? (i0) => Number.isInteger(i0) : (i0) => typeof i0 == "number" && isFinite(i0) && Math.floor(i0) === i0;
  function r0(i0, o0 = " | ") {
    return i0.map((s0) => typeof s0 == "string" ? `'${s0}'` : s0).join(o0);
  }
  t0.joinValues = r0, t0.jsonStringifyReplacer = (i0, o0) => typeof o0 == "bigint" ? o0.toString() : o0;
})(x$4 || (x$4 = {}));
var xt$3;
(function(t0) {
  t0.mergeShapes = (e0, n0) => ({
    ...e0,
    ...n0
    // second overwrites first
  });
})(xt$3 || (xt$3 = {}));
const h$1 = x$4.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Q$5 = (t0) => {
  switch (typeof t0) {
    case "undefined":
      return h$1.undefined;
    case "string":
      return h$1.string;
    case "number":
      return isNaN(t0) ? h$1.nan : h$1.number;
    case "boolean":
      return h$1.boolean;
    case "function":
      return h$1.function;
    case "bigint":
      return h$1.bigint;
    case "symbol":
      return h$1.symbol;
    case "object":
      return Array.isArray(t0) ? h$1.array : t0 === null ? h$1.null : t0.then && typeof t0.then == "function" && t0.catch && typeof t0.catch == "function" ? h$1.promise : typeof Map < "u" && t0 instanceof Map ? h$1.map : typeof Set < "u" && t0 instanceof Set ? h$1.set : typeof Date < "u" && t0 instanceof Date ? h$1.date : h$1.object;
    default:
      return h$1.unknown;
  }
}, f$2 = x$4.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), pi$1 = (t0) => JSON.stringify(t0, null, 2).replace(/"([^"]+)":/g, "$1:");
let A$4 = class Gm extends Error {
  constructor(e0) {
    super(), this.issues = [], this.addIssue = (r0) => {
      this.issues = [...this.issues, r0];
    }, this.addIssues = (r0 = []) => {
      this.issues = [...this.issues, ...r0];
    };
    const n0 = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n0) : this.__proto__ = n0, this.name = "ZodError", this.issues = e0;
  }
  get errors() {
    return this.issues;
  }
  format(e0) {
    const n0 = e0 || function(o0) {
      return o0.message;
    }, r0 = { _errors: [] }, i0 = (o0) => {
      for (const s0 of o0.issues)
        if (s0.code === "invalid_union")
          s0.unionErrors.map(i0);
        else if (s0.code === "invalid_return_type")
          i0(s0.returnTypeError);
        else if (s0.code === "invalid_arguments")
          i0(s0.argumentsError);
        else if (s0.path.length === 0)
          r0._errors.push(n0(s0));
        else {
          let a0 = r0, c0 = 0;
          for (; c0 < s0.path.length; ) {
            const l0 = s0.path[c0];
            c0 === s0.path.length - 1 ? (a0[l0] = a0[l0] || { _errors: [] }, a0[l0]._errors.push(n0(s0))) : a0[l0] = a0[l0] || { _errors: [] }, a0 = a0[l0], c0++;
          }
        }
    };
    return i0(this), r0;
  }
  static assert(e0) {
    if (!(e0 instanceof Gm))
      throw new Error(`Not a ZodError: ${e0}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, x$4.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e0 = (n0) => n0.message) {
    const n0 = {}, r0 = [];
    for (const i0 of this.issues)
      i0.path.length > 0 ? (n0[i0.path[0]] = n0[i0.path[0]] || [], n0[i0.path[0]].push(e0(i0))) : r0.push(e0(i0));
    return { formErrors: r0, fieldErrors: n0 };
  }
  get formErrors() {
    return this.flatten();
  }
};
A$4.create = (t0) => new A$4(t0);
const pe$2 = (t0, e0) => {
  let n0;
  switch (t0.code) {
    case f$2.invalid_type:
      t0.received === h$1.undefined ? n0 = "Required" : n0 = `Expected ${t0.expected}, received ${t0.received}`;
      break;
    case f$2.invalid_literal:
      n0 = `Invalid literal value, expected ${JSON.stringify(t0.expected, x$4.jsonStringifyReplacer)}`;
      break;
    case f$2.unrecognized_keys:
      n0 = `Unrecognized key(s) in object: ${x$4.joinValues(t0.keys, ", ")}`;
      break;
    case f$2.invalid_union:
      n0 = "Invalid input";
      break;
    case f$2.invalid_union_discriminator:
      n0 = `Invalid discriminator value. Expected ${x$4.joinValues(t0.options)}`;
      break;
    case f$2.invalid_enum_value:
      n0 = `Invalid enum value. Expected ${x$4.joinValues(t0.options)}, received '${t0.received}'`;
      break;
    case f$2.invalid_arguments:
      n0 = "Invalid function arguments";
      break;
    case f$2.invalid_return_type:
      n0 = "Invalid function return type";
      break;
    case f$2.invalid_date:
      n0 = "Invalid date";
      break;
    case f$2.invalid_string:
      typeof t0.validation == "object" ? "includes" in t0.validation ? (n0 = `Invalid input: must include "${t0.validation.includes}"`, typeof t0.validation.position == "number" && (n0 = `${n0} at one or more positions greater than or equal to ${t0.validation.position}`)) : "startsWith" in t0.validation ? n0 = `Invalid input: must start with "${t0.validation.startsWith}"` : "endsWith" in t0.validation ? n0 = `Invalid input: must end with "${t0.validation.endsWith}"` : x$4.assertNever(t0.validation) : t0.validation !== "regex" ? n0 = `Invalid ${t0.validation}` : n0 = "Invalid";
      break;
    case f$2.too_small:
      t0.type === "array" ? n0 = `Array must contain ${t0.exact ? "exactly" : t0.inclusive ? "at least" : "more than"} ${t0.minimum} element(s)` : t0.type === "string" ? n0 = `String must contain ${t0.exact ? "exactly" : t0.inclusive ? "at least" : "over"} ${t0.minimum} character(s)` : t0.type === "number" ? n0 = `Number must be ${t0.exact ? "exactly equal to " : t0.inclusive ? "greater than or equal to " : "greater than "}${t0.minimum}` : t0.type === "date" ? n0 = `Date must be ${t0.exact ? "exactly equal to " : t0.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t0.minimum))}` : n0 = "Invalid input";
      break;
    case f$2.too_big:
      t0.type === "array" ? n0 = `Array must contain ${t0.exact ? "exactly" : t0.inclusive ? "at most" : "less than"} ${t0.maximum} element(s)` : t0.type === "string" ? n0 = `String must contain ${t0.exact ? "exactly" : t0.inclusive ? "at most" : "under"} ${t0.maximum} character(s)` : t0.type === "number" ? n0 = `Number must be ${t0.exact ? "exactly" : t0.inclusive ? "less than or equal to" : "less than"} ${t0.maximum}` : t0.type === "bigint" ? n0 = `BigInt must be ${t0.exact ? "exactly" : t0.inclusive ? "less than or equal to" : "less than"} ${t0.maximum}` : t0.type === "date" ? n0 = `Date must be ${t0.exact ? "exactly" : t0.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t0.maximum))}` : n0 = "Invalid input";
      break;
    case f$2.custom:
      n0 = "Invalid input";
      break;
    case f$2.invalid_intersection_types:
      n0 = "Intersection results could not be merged";
      break;
    case f$2.not_multiple_of:
      n0 = `Number must be a multiple of ${t0.multipleOf}`;
      break;
    case f$2.not_finite:
      n0 = "Number must be finite";
      break;
    default:
      n0 = e0.defaultError, x$4.assertNever(t0);
  }
  return { message: n0 };
};
let Jr$2 = pe$2;
function hi$1(t0) {
  Jr$2 = t0;
}
function He$2() {
  return Jr$2;
}
const Fe$3 = (t0) => {
  const { data: e0, path: n0, errorMaps: r0, issueData: i0 } = t0, o0 = [...n0, ...i0.path || []], s0 = {
    ...i0,
    path: o0
  };
  if (i0.message !== void 0)
    return {
      ...i0,
      path: o0,
      message: i0.message
    };
  let a0 = "";
  const c0 = r0.filter((l0) => !!l0).slice().reverse();
  for (const l0 of c0)
    a0 = l0(s0, { data: e0, defaultError: a0 }).message;
  return {
    ...i0,
    path: o0,
    message: a0
  };
}, mi$1 = [];
function p$2(t0, e0) {
  const n0 = He$2(), r0 = Fe$3({
    issueData: e0,
    data: t0.data,
    path: t0.path,
    errorMaps: [
      t0.common.contextualErrorMap,
      t0.schemaErrorMap,
      n0,
      n0 === pe$2 ? void 0 : pe$2
      // then global default map
    ].filter((i0) => !!i0)
  });
  t0.common.issues.push(r0);
}
let L$4 = class Wm {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e0, n0) {
    const r0 = [];
    for (const i0 of n0) {
      if (i0.status === "aborted")
        return v$2;
      i0.status === "dirty" && e0.dirty(), r0.push(i0.value);
    }
    return { status: e0.value, value: r0 };
  }
  static async mergeObjectAsync(e0, n0) {
    const r0 = [];
    for (const i0 of n0) {
      const o0 = await i0.key, s0 = await i0.value;
      r0.push({
        key: o0,
        value: s0
      });
    }
    return Wm.mergeObjectSync(e0, r0);
  }
  static mergeObjectSync(e0, n0) {
    const r0 = {};
    for (const i0 of n0) {
      const { key: o0, value: s0 } = i0;
      if (o0.status === "aborted" || s0.status === "aborted")
        return v$2;
      o0.status === "dirty" && e0.dirty(), s0.status === "dirty" && e0.dirty(), o0.value !== "__proto__" && (typeof s0.value < "u" || i0.alwaysSet) && (r0[o0.value] = s0.value);
    }
    return { status: e0.value, value: r0 };
  }
};
const v$2 = Object.freeze({
  status: "aborted"
}), de$3 = (t0) => ({ status: "dirty", value: t0 }), I$2 = (t0) => ({ status: "valid", value: t0 }), kt$2 = (t0) => t0.status === "aborted", Tt$3 = (t0) => t0.status === "dirty", Re$3 = (t0) => t0.status === "valid", Oe$3 = (t0) => typeof Promise < "u" && t0 instanceof Promise;
function Je$2(t0, e0, n0, r0) {
  if (n0 === "a" && !r0)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e0 == "function" ? t0 !== e0 || !r0 : !e0.has(t0))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n0 === "m" ? r0 : n0 === "a" ? r0.call(t0) : r0 ? r0.value : e0.get(t0);
}
function Yr$2(t0, e0, n0, r0, i0) {
  if (r0 === "m")
    throw new TypeError("Private method is not writable");
  if (r0 === "a" && !i0)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e0 == "function" ? t0 !== e0 || !i0 : !e0.has(t0))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return r0 === "a" ? i0.call(t0, n0) : i0 ? i0.value = n0 : e0.set(t0, n0), n0;
}
var g$1;
(function(t0) {
  t0.errToObj = (e0) => typeof e0 == "string" ? { message: e0 } : e0 || {}, t0.toString = (e0) => typeof e0 == "string" ? e0 : e0?.message;
})(g$1 || (g$1 = {}));
var xe$2, ke$3;
let V$3 = class {
  constructor(e0, n0, r0, i0) {
    this._cachedPath = [], this.parent = e0, this.data = n0, this._path = r0, this._key = i0;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
const or$2 = (t0, e0) => {
  if (Re$3(e0))
    return { success: !0, data: e0.value };
  if (!t0.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n0 = new A$4(t0.common.issues);
      return this._error = n0, this._error;
    }
  };
};
function b$4(t0) {
  if (!t0)
    return {};
  const { errorMap: e0, invalid_type_error: n0, required_error: r0, description: i0 } = t0;
  if (e0 && (n0 || r0))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e0 ? { errorMap: e0, description: i0 } : { errorMap: (o0, s0) => {
    var a0, c0;
    const { message: l0 } = t0;
    return o0.code === "invalid_enum_value" ? { message: l0 ?? s0.defaultError } : typeof s0.data > "u" ? { message: (a0 = l0 ?? r0) !== null && a0 !== void 0 ? a0 : s0.defaultError } : o0.code !== "invalid_type" ? { message: s0.defaultError } : { message: (c0 = l0 ?? n0) !== null && c0 !== void 0 ? c0 : s0.defaultError };
  }, description: i0 };
}
let w$2 = class {
  constructor(e0) {
    this.spa = this.safeParseAsync, this._def = e0, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e0) {
    return Q$5(e0.data);
  }
  _getOrReturnCtx(e0, n0) {
    return n0 || {
      common: e0.parent.common,
      data: e0.data,
      parsedType: Q$5(e0.data),
      schemaErrorMap: this._def.errorMap,
      path: e0.path,
      parent: e0.parent
    };
  }
  _processInputParams(e0) {
    return {
      status: new L$4(),
      ctx: {
        common: e0.parent.common,
        data: e0.data,
        parsedType: Q$5(e0.data),
        schemaErrorMap: this._def.errorMap,
        path: e0.path,
        parent: e0.parent
      }
    };
  }
  _parseSync(e0) {
    const n0 = this._parse(e0);
    if (Oe$3(n0))
      throw new Error("Synchronous parse encountered promise.");
    return n0;
  }
  _parseAsync(e0) {
    const n0 = this._parse(e0);
    return Promise.resolve(n0);
  }
  parse(e0, n0) {
    const r0 = this.safeParse(e0, n0);
    if (r0.success)
      return r0.data;
    throw r0.error;
  }
  safeParse(e0, n0) {
    var r0;
    const i0 = {
      common: {
        issues: [],
        async: (r0 = n0?.async) !== null && r0 !== void 0 ? r0 : !1,
        contextualErrorMap: n0?.errorMap
      },
      path: n0?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e0,
      parsedType: Q$5(e0)
    }, o0 = this._parseSync({ data: e0, path: i0.path, parent: i0 });
    return or$2(i0, o0);
  }
  async parseAsync(e0, n0) {
    const r0 = await this.safeParseAsync(e0, n0);
    if (r0.success)
      return r0.data;
    throw r0.error;
  }
  async safeParseAsync(e0, n0) {
    const r0 = {
      common: {
        issues: [],
        contextualErrorMap: n0?.errorMap,
        async: !0
      },
      path: n0?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e0,
      parsedType: Q$5(e0)
    }, i0 = this._parse({ data: e0, path: r0.path, parent: r0 }), o0 = await (Oe$3(i0) ? i0 : Promise.resolve(i0));
    return or$2(r0, o0);
  }
  refine(e0, n0) {
    const r0 = (i0) => typeof n0 == "string" || typeof n0 > "u" ? { message: n0 } : typeof n0 == "function" ? n0(i0) : n0;
    return this._refinement((i0, o0) => {
      const s0 = e0(i0), a0 = () => o0.addIssue({
        code: f$2.custom,
        ...r0(i0)
      });
      return typeof Promise < "u" && s0 instanceof Promise ? s0.then((c0) => c0 ? !0 : (a0(), !1)) : s0 ? !0 : (a0(), !1);
    });
  }
  refinement(e0, n0) {
    return this._refinement((r0, i0) => e0(r0) ? !0 : (i0.addIssue(typeof n0 == "function" ? n0(r0, i0) : n0), !1));
  }
  _refinement(e0) {
    return new U$2({
      schema: this,
      typeName: _$2.ZodEffects,
      effect: { type: "refinement", refinement: e0 }
    });
  }
  superRefine(e0) {
    return this._refinement(e0);
  }
  optional() {
    return B$3.create(this, this._def);
  }
  nullable() {
    return te$3.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Z$3.create(this, this._def);
  }
  promise() {
    return me$3.create(this, this._def);
  }
  or(e0) {
    return Le$2.create([this, e0], this._def);
  }
  and(e0) {
    return Ie$1.create(this, e0, this._def);
  }
  transform(e0) {
    return new U$2({
      ...b$4(this._def),
      schema: this,
      typeName: _$2.ZodEffects,
      effect: { type: "transform", transform: e0 }
    });
  }
  default(e0) {
    const n0 = typeof e0 == "function" ? e0 : () => e0;
    return new De$2({
      ...b$4(this._def),
      innerType: this,
      defaultValue: n0,
      typeName: _$2.ZodDefault
    });
  }
  brand() {
    return new qt$2({
      typeName: _$2.ZodBranded,
      type: this,
      ...b$4(this._def)
    });
  }
  catch(e0) {
    const n0 = typeof e0 == "function" ? e0 : () => e0;
    return new Ze$2({
      ...b$4(this._def),
      innerType: this,
      catchValue: n0,
      typeName: _$2.ZodCatch
    });
  }
  describe(e0) {
    const n0 = this.constructor;
    return new n0({
      ...this._def,
      description: e0
    });
  }
  pipe(e0) {
    return Be$4.create(this, e0);
  }
  readonly() {
    return Ue$2.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const yi$1 = /^c[^\s-]{8,}$/i, gi$1 = /^[0-9a-z]+$/, _i$1 = /^[0-9A-HJKMNP-TV-Z]{26}$/, vi$1 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, bi$1 = /^[a-z0-9_-]{21}$/i, wi$1 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, xi$1 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, ki$1 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let gt$2;
const Ti$1 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Ei$1 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, Ci$1 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Gr$2 = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", Ri$1 = new RegExp(`^${Gr$2}$`);
function Qr$2(t0) {
  let e0 = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return t0.precision ? e0 = `${e0}\\.\\d{${t0.precision}}` : t0.precision == null && (e0 = `${e0}(\\.\\d+)?`), e0;
}
function Oi$1(t0) {
  return new RegExp(`^${Qr$2(t0)}$`);
}
function Xr$2(t0) {
  let e0 = `${Gr$2}T${Qr$2(t0)}`;
  const n0 = [];
  return n0.push(t0.local ? "Z?" : "Z"), t0.offset && n0.push("([+-]\\d{2}:?\\d{2})"), e0 = `${e0}(${n0.join("|")})`, new RegExp(`^${e0}$`);
}
function Si$1(t0, e0) {
  return !!((e0 === "v4" || !e0) && Ti$1.test(t0) || (e0 === "v6" || !e0) && Ei$1.test(t0));
}
let D$3 = class um extends w$2 {
  _parse(e0) {
    if (this._def.coerce && (e0.data = String(e0.data)), this._getType(e0) !== h$1.string) {
      const i0 = this._getOrReturnCtx(e0);
      return p$2(i0, {
        code: f$2.invalid_type,
        expected: h$1.string,
        received: i0.parsedType
      }), v$2;
    }
    const n0 = new L$4();
    let r0;
    for (const i0 of this._def.checks)
      if (i0.kind === "min")
        e0.data.length < i0.value && (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          code: f$2.too_small,
          minimum: i0.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i0.message
        }), n0.dirty());
      else if (i0.kind === "max")
        e0.data.length > i0.value && (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          code: f$2.too_big,
          maximum: i0.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i0.message
        }), n0.dirty());
      else if (i0.kind === "length") {
        const o0 = e0.data.length > i0.value, s0 = e0.data.length < i0.value;
        (o0 || s0) && (r0 = this._getOrReturnCtx(e0, r0), o0 ? p$2(r0, {
          code: f$2.too_big,
          maximum: i0.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i0.message
        }) : s0 && p$2(r0, {
          code: f$2.too_small,
          minimum: i0.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i0.message
        }), n0.dirty());
      } else if (i0.kind === "email")
        xi$1.test(e0.data) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          validation: "email",
          code: f$2.invalid_string,
          message: i0.message
        }), n0.dirty());
      else if (i0.kind === "emoji")
        gt$2 || (gt$2 = new RegExp(ki$1, "u")), gt$2.test(e0.data) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          validation: "emoji",
          code: f$2.invalid_string,
          message: i0.message
        }), n0.dirty());
      else if (i0.kind === "uuid")
        vi$1.test(e0.data) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          validation: "uuid",
          code: f$2.invalid_string,
          message: i0.message
        }), n0.dirty());
      else if (i0.kind === "nanoid")
        bi$1.test(e0.data) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          validation: "nanoid",
          code: f$2.invalid_string,
          message: i0.message
        }), n0.dirty());
      else if (i0.kind === "cuid")
        yi$1.test(e0.data) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          validation: "cuid",
          code: f$2.invalid_string,
          message: i0.message
        }), n0.dirty());
      else if (i0.kind === "cuid2")
        gi$1.test(e0.data) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          validation: "cuid2",
          code: f$2.invalid_string,
          message: i0.message
        }), n0.dirty());
      else if (i0.kind === "ulid")
        _i$1.test(e0.data) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          validation: "ulid",
          code: f$2.invalid_string,
          message: i0.message
        }), n0.dirty());
      else if (i0.kind === "url")
        try {
          new URL(e0.data);
        } catch {
          r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
            validation: "url",
            code: f$2.invalid_string,
            message: i0.message
          }), n0.dirty();
        }
      else
        i0.kind === "regex" ? (i0.regex.lastIndex = 0, i0.regex.test(e0.data) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          validation: "regex",
          code: f$2.invalid_string,
          message: i0.message
        }), n0.dirty())) : i0.kind === "trim" ? e0.data = e0.data.trim() : i0.kind === "includes" ? e0.data.includes(i0.value, i0.position) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          code: f$2.invalid_string,
          validation: { includes: i0.value, position: i0.position },
          message: i0.message
        }), n0.dirty()) : i0.kind === "toLowerCase" ? e0.data = e0.data.toLowerCase() : i0.kind === "toUpperCase" ? e0.data = e0.data.toUpperCase() : i0.kind === "startsWith" ? e0.data.startsWith(i0.value) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          code: f$2.invalid_string,
          validation: { startsWith: i0.value },
          message: i0.message
        }), n0.dirty()) : i0.kind === "endsWith" ? e0.data.endsWith(i0.value) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          code: f$2.invalid_string,
          validation: { endsWith: i0.value },
          message: i0.message
        }), n0.dirty()) : i0.kind === "datetime" ? Xr$2(i0).test(e0.data) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          code: f$2.invalid_string,
          validation: "datetime",
          message: i0.message
        }), n0.dirty()) : i0.kind === "date" ? Ri$1.test(e0.data) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          code: f$2.invalid_string,
          validation: "date",
          message: i0.message
        }), n0.dirty()) : i0.kind === "time" ? Oi$1(i0).test(e0.data) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          code: f$2.invalid_string,
          validation: "time",
          message: i0.message
        }), n0.dirty()) : i0.kind === "duration" ? wi$1.test(e0.data) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          validation: "duration",
          code: f$2.invalid_string,
          message: i0.message
        }), n0.dirty()) : i0.kind === "ip" ? Si$1(e0.data, i0.version) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          validation: "ip",
          code: f$2.invalid_string,
          message: i0.message
        }), n0.dirty()) : i0.kind === "base64" ? Ci$1.test(e0.data) || (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
          validation: "base64",
          code: f$2.invalid_string,
          message: i0.message
        }), n0.dirty()) : x$4.assertNever(i0);
    return { status: n0.value, value: e0.data };
  }
  _regex(e0, n0, r0) {
    return this.refinement((i0) => e0.test(i0), {
      validation: n0,
      code: f$2.invalid_string,
      ...g$1.errToObj(r0)
    });
  }
  _addCheck(e0) {
    return new um({
      ...this._def,
      checks: [...this._def.checks, e0]
    });
  }
  email(e0) {
    return this._addCheck({ kind: "email", ...g$1.errToObj(e0) });
  }
  url(e0) {
    return this._addCheck({ kind: "url", ...g$1.errToObj(e0) });
  }
  emoji(e0) {
    return this._addCheck({ kind: "emoji", ...g$1.errToObj(e0) });
  }
  uuid(e0) {
    return this._addCheck({ kind: "uuid", ...g$1.errToObj(e0) });
  }
  nanoid(e0) {
    return this._addCheck({ kind: "nanoid", ...g$1.errToObj(e0) });
  }
  cuid(e0) {
    return this._addCheck({ kind: "cuid", ...g$1.errToObj(e0) });
  }
  cuid2(e0) {
    return this._addCheck({ kind: "cuid2", ...g$1.errToObj(e0) });
  }
  ulid(e0) {
    return this._addCheck({ kind: "ulid", ...g$1.errToObj(e0) });
  }
  base64(e0) {
    return this._addCheck({ kind: "base64", ...g$1.errToObj(e0) });
  }
  ip(e0) {
    return this._addCheck({ kind: "ip", ...g$1.errToObj(e0) });
  }
  datetime(e0) {
    var n0, r0;
    return typeof e0 == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: e0
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof e0?.precision > "u" ? null : e0?.precision,
      offset: (n0 = e0?.offset) !== null && n0 !== void 0 ? n0 : !1,
      local: (r0 = e0?.local) !== null && r0 !== void 0 ? r0 : !1,
      ...g$1.errToObj(e0?.message)
    });
  }
  date(e0) {
    return this._addCheck({ kind: "date", message: e0 });
  }
  time(e0) {
    return typeof e0 == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e0
    }) : this._addCheck({
      kind: "time",
      precision: typeof e0?.precision > "u" ? null : e0?.precision,
      ...g$1.errToObj(e0?.message)
    });
  }
  duration(e0) {
    return this._addCheck({ kind: "duration", ...g$1.errToObj(e0) });
  }
  regex(e0, n0) {
    return this._addCheck({
      kind: "regex",
      regex: e0,
      ...g$1.errToObj(n0)
    });
  }
  includes(e0, n0) {
    return this._addCheck({
      kind: "includes",
      value: e0,
      position: n0?.position,
      ...g$1.errToObj(n0?.message)
    });
  }
  startsWith(e0, n0) {
    return this._addCheck({
      kind: "startsWith",
      value: e0,
      ...g$1.errToObj(n0)
    });
  }
  endsWith(e0, n0) {
    return this._addCheck({
      kind: "endsWith",
      value: e0,
      ...g$1.errToObj(n0)
    });
  }
  min(e0, n0) {
    return this._addCheck({
      kind: "min",
      value: e0,
      ...g$1.errToObj(n0)
    });
  }
  max(e0, n0) {
    return this._addCheck({
      kind: "max",
      value: e0,
      ...g$1.errToObj(n0)
    });
  }
  length(e0, n0) {
    return this._addCheck({
      kind: "length",
      value: e0,
      ...g$1.errToObj(n0)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(e0) {
    return this.min(1, g$1.errToObj(e0));
  }
  trim() {
    return new um({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new um({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new um({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e0) => e0.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e0) => e0.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e0) => e0.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e0) => e0.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e0) => e0.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e0) => e0.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e0) => e0.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e0) => e0.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e0) => e0.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e0) => e0.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e0) => e0.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e0) => e0.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e0) => e0.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((e0) => e0.kind === "base64");
  }
  get minLength() {
    let e0 = null;
    for (const n0 of this._def.checks)
      n0.kind === "min" && (e0 === null || n0.value > e0) && (e0 = n0.value);
    return e0;
  }
  get maxLength() {
    let e0 = null;
    for (const n0 of this._def.checks)
      n0.kind === "max" && (e0 === null || n0.value < e0) && (e0 = n0.value);
    return e0;
  }
};
D$3.create = (t0) => {
  var e0;
  return new D$3({
    checks: [],
    typeName: _$2.ZodString,
    coerce: (e0 = t0?.coerce) !== null && e0 !== void 0 ? e0 : !1,
    ...b$4(t0)
  });
};
function Pi$1(t0, e0) {
  const n0 = (t0.toString().split(".")[1] || "").length, r0 = (e0.toString().split(".")[1] || "").length, i0 = n0 > r0 ? n0 : r0, o0 = parseInt(t0.toFixed(i0).replace(".", "")), s0 = parseInt(e0.toFixed(i0).replace(".", ""));
  return o0 % s0 / Math.pow(10, i0);
}
let X$4 = class Lm extends w$2 {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e0) {
    if (this._def.coerce && (e0.data = Number(e0.data)), this._getType(e0) !== h$1.number) {
      const i0 = this._getOrReturnCtx(e0);
      return p$2(i0, {
        code: f$2.invalid_type,
        expected: h$1.number,
        received: i0.parsedType
      }), v$2;
    }
    let n0;
    const r0 = new L$4();
    for (const i0 of this._def.checks)
      i0.kind === "int" ? x$4.isInteger(e0.data) || (n0 = this._getOrReturnCtx(e0, n0), p$2(n0, {
        code: f$2.invalid_type,
        expected: "integer",
        received: "float",
        message: i0.message
      }), r0.dirty()) : i0.kind === "min" ? (i0.inclusive ? e0.data < i0.value : e0.data <= i0.value) && (n0 = this._getOrReturnCtx(e0, n0), p$2(n0, {
        code: f$2.too_small,
        minimum: i0.value,
        type: "number",
        inclusive: i0.inclusive,
        exact: !1,
        message: i0.message
      }), r0.dirty()) : i0.kind === "max" ? (i0.inclusive ? e0.data > i0.value : e0.data >= i0.value) && (n0 = this._getOrReturnCtx(e0, n0), p$2(n0, {
        code: f$2.too_big,
        maximum: i0.value,
        type: "number",
        inclusive: i0.inclusive,
        exact: !1,
        message: i0.message
      }), r0.dirty()) : i0.kind === "multipleOf" ? Pi$1(e0.data, i0.value) !== 0 && (n0 = this._getOrReturnCtx(e0, n0), p$2(n0, {
        code: f$2.not_multiple_of,
        multipleOf: i0.value,
        message: i0.message
      }), r0.dirty()) : i0.kind === "finite" ? Number.isFinite(e0.data) || (n0 = this._getOrReturnCtx(e0, n0), p$2(n0, {
        code: f$2.not_finite,
        message: i0.message
      }), r0.dirty()) : x$4.assertNever(i0);
    return { status: r0.value, value: e0.data };
  }
  gte(e0, n0) {
    return this.setLimit("min", e0, !0, g$1.toString(n0));
  }
  gt(e0, n0) {
    return this.setLimit("min", e0, !1, g$1.toString(n0));
  }
  lte(e0, n0) {
    return this.setLimit("max", e0, !0, g$1.toString(n0));
  }
  lt(e0, n0) {
    return this.setLimit("max", e0, !1, g$1.toString(n0));
  }
  setLimit(e0, n0, r0, i0) {
    return new Lm({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e0,
          value: n0,
          inclusive: r0,
          message: g$1.toString(i0)
        }
      ]
    });
  }
  _addCheck(e0) {
    return new Lm({
      ...this._def,
      checks: [...this._def.checks, e0]
    });
  }
  int(e0) {
    return this._addCheck({
      kind: "int",
      message: g$1.toString(e0)
    });
  }
  positive(e0) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: g$1.toString(e0)
    });
  }
  negative(e0) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: g$1.toString(e0)
    });
  }
  nonpositive(e0) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: g$1.toString(e0)
    });
  }
  nonnegative(e0) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: g$1.toString(e0)
    });
  }
  multipleOf(e0, n0) {
    return this._addCheck({
      kind: "multipleOf",
      value: e0,
      message: g$1.toString(n0)
    });
  }
  finite(e0) {
    return this._addCheck({
      kind: "finite",
      message: g$1.toString(e0)
    });
  }
  safe(e0) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: g$1.toString(e0)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: g$1.toString(e0)
    });
  }
  get minValue() {
    let e0 = null;
    for (const n0 of this._def.checks)
      n0.kind === "min" && (e0 === null || n0.value > e0) && (e0 = n0.value);
    return e0;
  }
  get maxValue() {
    let e0 = null;
    for (const n0 of this._def.checks)
      n0.kind === "max" && (e0 === null || n0.value < e0) && (e0 = n0.value);
    return e0;
  }
  get isInt() {
    return !!this._def.checks.find((e0) => e0.kind === "int" || e0.kind === "multipleOf" && x$4.isInteger(e0.value));
  }
  get isFinite() {
    let e0 = null, n0 = null;
    for (const r0 of this._def.checks) {
      if (r0.kind === "finite" || r0.kind === "int" || r0.kind === "multipleOf")
        return !0;
      r0.kind === "min" ? (n0 === null || r0.value > n0) && (n0 = r0.value) : r0.kind === "max" && (e0 === null || r0.value < e0) && (e0 = r0.value);
    }
    return Number.isFinite(n0) && Number.isFinite(e0);
  }
};
X$4.create = (t0) => new X$4({
  checks: [],
  typeName: _$2.ZodNumber,
  coerce: t0?.coerce || !1,
  ...b$4(t0)
});
let K$4 = class km extends w$2 {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e0) {
    if (this._def.coerce && (e0.data = BigInt(e0.data)), this._getType(e0) !== h$1.bigint) {
      const i0 = this._getOrReturnCtx(e0);
      return p$2(i0, {
        code: f$2.invalid_type,
        expected: h$1.bigint,
        received: i0.parsedType
      }), v$2;
    }
    let n0;
    const r0 = new L$4();
    for (const i0 of this._def.checks)
      i0.kind === "min" ? (i0.inclusive ? e0.data < i0.value : e0.data <= i0.value) && (n0 = this._getOrReturnCtx(e0, n0), p$2(n0, {
        code: f$2.too_small,
        type: "bigint",
        minimum: i0.value,
        inclusive: i0.inclusive,
        message: i0.message
      }), r0.dirty()) : i0.kind === "max" ? (i0.inclusive ? e0.data > i0.value : e0.data >= i0.value) && (n0 = this._getOrReturnCtx(e0, n0), p$2(n0, {
        code: f$2.too_big,
        type: "bigint",
        maximum: i0.value,
        inclusive: i0.inclusive,
        message: i0.message
      }), r0.dirty()) : i0.kind === "multipleOf" ? e0.data % i0.value !== BigInt(0) && (n0 = this._getOrReturnCtx(e0, n0), p$2(n0, {
        code: f$2.not_multiple_of,
        multipleOf: i0.value,
        message: i0.message
      }), r0.dirty()) : x$4.assertNever(i0);
    return { status: r0.value, value: e0.data };
  }
  gte(e0, n0) {
    return this.setLimit("min", e0, !0, g$1.toString(n0));
  }
  gt(e0, n0) {
    return this.setLimit("min", e0, !1, g$1.toString(n0));
  }
  lte(e0, n0) {
    return this.setLimit("max", e0, !0, g$1.toString(n0));
  }
  lt(e0, n0) {
    return this.setLimit("max", e0, !1, g$1.toString(n0));
  }
  setLimit(e0, n0, r0, i0) {
    return new km({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e0,
          value: n0,
          inclusive: r0,
          message: g$1.toString(i0)
        }
      ]
    });
  }
  _addCheck(e0) {
    return new km({
      ...this._def,
      checks: [...this._def.checks, e0]
    });
  }
  positive(e0) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: g$1.toString(e0)
    });
  }
  negative(e0) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: g$1.toString(e0)
    });
  }
  nonpositive(e0) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: g$1.toString(e0)
    });
  }
  nonnegative(e0) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: g$1.toString(e0)
    });
  }
  multipleOf(e0, n0) {
    return this._addCheck({
      kind: "multipleOf",
      value: e0,
      message: g$1.toString(n0)
    });
  }
  get minValue() {
    let e0 = null;
    for (const n0 of this._def.checks)
      n0.kind === "min" && (e0 === null || n0.value > e0) && (e0 = n0.value);
    return e0;
  }
  get maxValue() {
    let e0 = null;
    for (const n0 of this._def.checks)
      n0.kind === "max" && (e0 === null || n0.value < e0) && (e0 = n0.value);
    return e0;
  }
};
K$4.create = (t0) => {
  var e0;
  return new K$4({
    checks: [],
    typeName: _$2.ZodBigInt,
    coerce: (e0 = t0?.coerce) !== null && e0 !== void 0 ? e0 : !1,
    ...b$4(t0)
  });
};
let Se$4 = class extends w$2 {
  _parse(e0) {
    if (this._def.coerce && (e0.data = !!e0.data), this._getType(e0) !== h$1.boolean) {
      const n0 = this._getOrReturnCtx(e0);
      return p$2(n0, {
        code: f$2.invalid_type,
        expected: h$1.boolean,
        received: n0.parsedType
      }), v$2;
    }
    return I$2(e0.data);
  }
};
Se$4.create = (t0) => new Se$4({
  typeName: _$2.ZodBoolean,
  coerce: t0?.coerce || !1,
  ...b$4(t0)
});
let se$3 = class Vm extends w$2 {
  _parse(e0) {
    if (this._def.coerce && (e0.data = new Date(e0.data)), this._getType(e0) !== h$1.date) {
      const i0 = this._getOrReturnCtx(e0);
      return p$2(i0, {
        code: f$2.invalid_type,
        expected: h$1.date,
        received: i0.parsedType
      }), v$2;
    }
    if (isNaN(e0.data.getTime())) {
      const i0 = this._getOrReturnCtx(e0);
      return p$2(i0, {
        code: f$2.invalid_date
      }), v$2;
    }
    const n0 = new L$4();
    let r0;
    for (const i0 of this._def.checks)
      i0.kind === "min" ? e0.data.getTime() < i0.value && (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
        code: f$2.too_small,
        message: i0.message,
        inclusive: !0,
        exact: !1,
        minimum: i0.value,
        type: "date"
      }), n0.dirty()) : i0.kind === "max" ? e0.data.getTime() > i0.value && (r0 = this._getOrReturnCtx(e0, r0), p$2(r0, {
        code: f$2.too_big,
        message: i0.message,
        inclusive: !0,
        exact: !1,
        maximum: i0.value,
        type: "date"
      }), n0.dirty()) : x$4.assertNever(i0);
    return {
      status: n0.value,
      value: new Date(e0.data.getTime())
    };
  }
  _addCheck(e0) {
    return new Vm({
      ...this._def,
      checks: [...this._def.checks, e0]
    });
  }
  min(e0, n0) {
    return this._addCheck({
      kind: "min",
      value: e0.getTime(),
      message: g$1.toString(n0)
    });
  }
  max(e0, n0) {
    return this._addCheck({
      kind: "max",
      value: e0.getTime(),
      message: g$1.toString(n0)
    });
  }
  get minDate() {
    let e0 = null;
    for (const n0 of this._def.checks)
      n0.kind === "min" && (e0 === null || n0.value > e0) && (e0 = n0.value);
    return e0 != null ? new Date(e0) : null;
  }
  get maxDate() {
    let e0 = null;
    for (const n0 of this._def.checks)
      n0.kind === "max" && (e0 === null || n0.value < e0) && (e0 = n0.value);
    return e0 != null ? new Date(e0) : null;
  }
};
se$3.create = (t0) => new se$3({
  checks: [],
  coerce: t0?.coerce || !1,
  typeName: _$2.ZodDate,
  ...b$4(t0)
});
let Ye$2 = class extends w$2 {
  _parse(e0) {
    if (this._getType(e0) !== h$1.symbol) {
      const n0 = this._getOrReturnCtx(e0);
      return p$2(n0, {
        code: f$2.invalid_type,
        expected: h$1.symbol,
        received: n0.parsedType
      }), v$2;
    }
    return I$2(e0.data);
  }
};
Ye$2.create = (t0) => new Ye$2({
  typeName: _$2.ZodSymbol,
  ...b$4(t0)
});
let Pe$3 = class extends w$2 {
  _parse(e0) {
    if (this._getType(e0) !== h$1.undefined) {
      const n0 = this._getOrReturnCtx(e0);
      return p$2(n0, {
        code: f$2.invalid_type,
        expected: h$1.undefined,
        received: n0.parsedType
      }), v$2;
    }
    return I$2(e0.data);
  }
};
Pe$3.create = (t0) => new Pe$3({
  typeName: _$2.ZodUndefined,
  ...b$4(t0)
});
let Ne$3 = class extends w$2 {
  _parse(e0) {
    if (this._getType(e0) !== h$1.null) {
      const n0 = this._getOrReturnCtx(e0);
      return p$2(n0, {
        code: f$2.invalid_type,
        expected: h$1.null,
        received: n0.parsedType
      }), v$2;
    }
    return I$2(e0.data);
  }
};
Ne$3.create = (t0) => new Ne$3({
  typeName: _$2.ZodNull,
  ...b$4(t0)
});
let he$3 = class extends w$2 {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e0) {
    return I$2(e0.data);
  }
};
he$3.create = (t0) => new he$3({
  typeName: _$2.ZodAny,
  ...b$4(t0)
});
let ne$3 = class extends w$2 {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e0) {
    return I$2(e0.data);
  }
};
ne$3.create = (t0) => new ne$3({
  typeName: _$2.ZodUnknown,
  ...b$4(t0)
});
let Y$2 = class extends w$2 {
  _parse(e0) {
    const n0 = this._getOrReturnCtx(e0);
    return p$2(n0, {
      code: f$2.invalid_type,
      expected: h$1.never,
      received: n0.parsedType
    }), v$2;
  }
};
Y$2.create = (t0) => new Y$2({
  typeName: _$2.ZodNever,
  ...b$4(t0)
});
let Ge$2 = class extends w$2 {
  _parse(e0) {
    if (this._getType(e0) !== h$1.undefined) {
      const n0 = this._getOrReturnCtx(e0);
      return p$2(n0, {
        code: f$2.invalid_type,
        expected: h$1.void,
        received: n0.parsedType
      }), v$2;
    }
    return I$2(e0.data);
  }
};
Ge$2.create = (t0) => new Ge$2({
  typeName: _$2.ZodVoid,
  ...b$4(t0)
});
let Z$3 = class dm extends w$2 {
  _parse(e0) {
    const { ctx: n0, status: r0 } = this._processInputParams(e0), i0 = this._def;
    if (n0.parsedType !== h$1.array)
      return p$2(n0, {
        code: f$2.invalid_type,
        expected: h$1.array,
        received: n0.parsedType
      }), v$2;
    if (i0.exactLength !== null) {
      const s0 = n0.data.length > i0.exactLength.value, a0 = n0.data.length < i0.exactLength.value;
      (s0 || a0) && (p$2(n0, {
        code: s0 ? f$2.too_big : f$2.too_small,
        minimum: a0 ? i0.exactLength.value : void 0,
        maximum: s0 ? i0.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i0.exactLength.message
      }), r0.dirty());
    }
    if (i0.minLength !== null && n0.data.length < i0.minLength.value && (p$2(n0, {
      code: f$2.too_small,
      minimum: i0.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i0.minLength.message
    }), r0.dirty()), i0.maxLength !== null && n0.data.length > i0.maxLength.value && (p$2(n0, {
      code: f$2.too_big,
      maximum: i0.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i0.maxLength.message
    }), r0.dirty()), n0.common.async)
      return Promise.all([...n0.data].map((s0, a0) => i0.type._parseAsync(new V$3(n0, s0, n0.path, a0)))).then((s0) => L$4.mergeArray(r0, s0));
    const o0 = [...n0.data].map((s0, a0) => i0.type._parseSync(new V$3(n0, s0, n0.path, a0)));
    return L$4.mergeArray(r0, o0);
  }
  get element() {
    return this._def.type;
  }
  min(e0, n0) {
    return new dm({
      ...this._def,
      minLength: { value: e0, message: g$1.toString(n0) }
    });
  }
  max(e0, n0) {
    return new dm({
      ...this._def,
      maxLength: { value: e0, message: g$1.toString(n0) }
    });
  }
  length(e0, n0) {
    return new dm({
      ...this._def,
      exactLength: { value: e0, message: g$1.toString(n0) }
    });
  }
  nonempty(e0) {
    return this.min(1, e0);
  }
};
Z$3.create = (t0, e0) => new Z$3({
  type: t0,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: _$2.ZodArray,
  ...b$4(e0)
});
function ue$3(t0) {
  if (t0 instanceof C$4) {
    const e0 = {};
    for (const n0 in t0.shape) {
      const r0 = t0.shape[n0];
      e0[n0] = B$3.create(ue$3(r0));
    }
    return new C$4({
      ...t0._def,
      shape: () => e0
    });
  } else
    return t0 instanceof Z$3 ? new Z$3({
      ...t0._def,
      type: ue$3(t0.element)
    }) : t0 instanceof B$3 ? B$3.create(ue$3(t0.unwrap())) : t0 instanceof te$3 ? te$3.create(ue$3(t0.unwrap())) : t0 instanceof z$3 ? z$3.create(t0.items.map((e0) => ue$3(e0))) : t0;
}
let C$4 = class nm extends w$2 {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e0 = this._def.shape(), n0 = x$4.objectKeys(e0);
    return this._cached = { shape: e0, keys: n0 };
  }
  _parse(e0) {
    if (this._getType(e0) !== h$1.object) {
      const c0 = this._getOrReturnCtx(e0);
      return p$2(c0, {
        code: f$2.invalid_type,
        expected: h$1.object,
        received: c0.parsedType
      }), v$2;
    }
    const { status: n0, ctx: r0 } = this._processInputParams(e0), { shape: i0, keys: o0 } = this._getCached(), s0 = [];
    if (!(this._def.catchall instanceof Y$2 && this._def.unknownKeys === "strip"))
      for (const c0 in r0.data)
        o0.includes(c0) || s0.push(c0);
    const a0 = [];
    for (const c0 of o0) {
      const l0 = i0[c0], u0 = r0.data[c0];
      a0.push({
        key: { status: "valid", value: c0 },
        value: l0._parse(new V$3(r0, u0, r0.path, c0)),
        alwaysSet: c0 in r0.data
      });
    }
    if (this._def.catchall instanceof Y$2) {
      const c0 = this._def.unknownKeys;
      if (c0 === "passthrough")
        for (const l0 of s0)
          a0.push({
            key: { status: "valid", value: l0 },
            value: { status: "valid", value: r0.data[l0] }
          });
      else if (c0 === "strict")
        s0.length > 0 && (p$2(r0, {
          code: f$2.unrecognized_keys,
          keys: s0
        }), n0.dirty());
      else if (c0 !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c0 = this._def.catchall;
      for (const l0 of s0) {
        const u0 = r0.data[l0];
        a0.push({
          key: { status: "valid", value: l0 },
          value: c0._parse(
            new V$3(r0, u0, r0.path, l0)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: l0 in r0.data
        });
      }
    }
    return r0.common.async ? Promise.resolve().then(async () => {
      const c0 = [];
      for (const l0 of a0) {
        const u0 = await l0.key, d0 = await l0.value;
        c0.push({
          key: u0,
          value: d0,
          alwaysSet: l0.alwaysSet
        });
      }
      return c0;
    }).then((c0) => L$4.mergeObjectSync(n0, c0)) : L$4.mergeObjectSync(n0, a0);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e0) {
    return g$1.errToObj, new nm({
      ...this._def,
      unknownKeys: "strict",
      ...e0 !== void 0 ? {
        errorMap: (n0, r0) => {
          var i0, o0, s0, a0;
          const c0 = (s0 = (o0 = (i0 = this._def).errorMap) === null || o0 === void 0 ? void 0 : o0.call(i0, n0, r0).message) !== null && s0 !== void 0 ? s0 : r0.defaultError;
          return n0.code === "unrecognized_keys" ? {
            message: (a0 = g$1.errToObj(e0).message) !== null && a0 !== void 0 ? a0 : c0
          } : {
            message: c0
          };
        }
      } : {}
    });
  }
  strip() {
    return new nm({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new nm({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e0) {
    return new nm({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e0
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e0) {
    return new nm({
      unknownKeys: e0._def.unknownKeys,
      catchall: e0._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e0._def.shape()
      }),
      typeName: _$2.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e0, n0) {
    return this.augment({ [e0]: n0 });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e0) {
    return new nm({
      ...this._def,
      catchall: e0
    });
  }
  pick(e0) {
    const n0 = {};
    return x$4.objectKeys(e0).forEach((r0) => {
      e0[r0] && this.shape[r0] && (n0[r0] = this.shape[r0]);
    }), new nm({
      ...this._def,
      shape: () => n0
    });
  }
  omit(e0) {
    const n0 = {};
    return x$4.objectKeys(this.shape).forEach((r0) => {
      e0[r0] || (n0[r0] = this.shape[r0]);
    }), new nm({
      ...this._def,
      shape: () => n0
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return ue$3(this);
  }
  partial(e0) {
    const n0 = {};
    return x$4.objectKeys(this.shape).forEach((r0) => {
      const i0 = this.shape[r0];
      e0 && !e0[r0] ? n0[r0] = i0 : n0[r0] = i0.optional();
    }), new nm({
      ...this._def,
      shape: () => n0
    });
  }
  required(e0) {
    const n0 = {};
    return x$4.objectKeys(this.shape).forEach((r0) => {
      if (e0 && !e0[r0])
        n0[r0] = this.shape[r0];
      else {
        let i0 = this.shape[r0];
        for (; i0 instanceof B$3; )
          i0 = i0._def.innerType;
        n0[r0] = i0;
      }
    }), new nm({
      ...this._def,
      shape: () => n0
    });
  }
  keyof() {
    return Kr$2(x$4.objectKeys(this.shape));
  }
};
C$4.create = (t0, e0) => new C$4({
  shape: () => t0,
  unknownKeys: "strip",
  catchall: Y$2.create(),
  typeName: _$2.ZodObject,
  ...b$4(e0)
});
C$4.strictCreate = (t0, e0) => new C$4({
  shape: () => t0,
  unknownKeys: "strict",
  catchall: Y$2.create(),
  typeName: _$2.ZodObject,
  ...b$4(e0)
});
C$4.lazycreate = (t0, e0) => new C$4({
  shape: t0,
  unknownKeys: "strip",
  catchall: Y$2.create(),
  typeName: _$2.ZodObject,
  ...b$4(e0)
});
let Le$2 = class extends w$2 {
  _parse(e0) {
    const { ctx: n0 } = this._processInputParams(e0), r0 = this._def.options;
    function i0(o0) {
      for (const a0 of o0)
        if (a0.result.status === "valid")
          return a0.result;
      for (const a0 of o0)
        if (a0.result.status === "dirty")
          return n0.common.issues.push(...a0.ctx.common.issues), a0.result;
      const s0 = o0.map((a0) => new A$4(a0.ctx.common.issues));
      return p$2(n0, {
        code: f$2.invalid_union,
        unionErrors: s0
      }), v$2;
    }
    if (n0.common.async)
      return Promise.all(r0.map(async (o0) => {
        const s0 = {
          ...n0,
          common: {
            ...n0.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await o0._parseAsync({
            data: n0.data,
            path: n0.path,
            parent: s0
          }),
          ctx: s0
        };
      })).then(i0);
    {
      let o0;
      const s0 = [];
      for (const c0 of r0) {
        const l0 = {
          ...n0,
          common: {
            ...n0.common,
            issues: []
          },
          parent: null
        }, u0 = c0._parseSync({
          data: n0.data,
          path: n0.path,
          parent: l0
        });
        if (u0.status === "valid")
          return u0;
        u0.status === "dirty" && !o0 && (o0 = { result: u0, ctx: l0 }), l0.common.issues.length && s0.push(l0.common.issues);
      }
      if (o0)
        return n0.common.issues.push(...o0.ctx.common.issues), o0.result;
      const a0 = s0.map((c0) => new A$4(c0));
      return p$2(n0, {
        code: f$2.invalid_union,
        unionErrors: a0
      }), v$2;
    }
  }
  get options() {
    return this._def.options;
  }
};
Le$2.create = (t0, e0) => new Le$2({
  options: t0,
  typeName: _$2.ZodUnion,
  ...b$4(e0)
});
const J$2 = (t0) => t0 instanceof Ae$2 ? J$2(t0.schema) : t0 instanceof U$2 ? J$2(t0.innerType()) : t0 instanceof $e$3 ? [t0.value] : t0 instanceof ee$3 ? t0.options : t0 instanceof Me$4 ? x$4.objectValues(t0.enum) : t0 instanceof De$2 ? J$2(t0._def.innerType) : t0 instanceof Pe$3 ? [void 0] : t0 instanceof Ne$3 ? [null] : t0 instanceof B$3 ? [void 0, ...J$2(t0.unwrap())] : t0 instanceof te$3 ? [null, ...J$2(t0.unwrap())] : t0 instanceof qt$2 || t0 instanceof Ue$2 ? J$2(t0.unwrap()) : t0 instanceof Ze$2 ? J$2(t0._def.innerType) : [];
let ct$2 = class Qm extends w$2 {
  _parse(e0) {
    const { ctx: n0 } = this._processInputParams(e0);
    if (n0.parsedType !== h$1.object)
      return p$2(n0, {
        code: f$2.invalid_type,
        expected: h$1.object,
        received: n0.parsedType
      }), v$2;
    const r0 = this.discriminator, i0 = n0.data[r0], o0 = this.optionsMap.get(i0);
    return o0 ? n0.common.async ? o0._parseAsync({
      data: n0.data,
      path: n0.path,
      parent: n0
    }) : o0._parseSync({
      data: n0.data,
      path: n0.path,
      parent: n0
    }) : (p$2(n0, {
      code: f$2.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r0]
    }), v$2);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e0, n0, r0) {
    const i0 = /* @__PURE__ */ new Map();
    for (const o0 of n0) {
      const s0 = J$2(o0.shape[e0]);
      if (!s0.length)
        throw new Error(`A discriminator value for key \`${e0}\` could not be extracted from all schema options`);
      for (const a0 of s0) {
        if (i0.has(a0))
          throw new Error(`Discriminator property ${String(e0)} has duplicate value ${String(a0)}`);
        i0.set(a0, o0);
      }
    }
    return new Qm({
      typeName: _$2.ZodDiscriminatedUnion,
      discriminator: e0,
      options: n0,
      optionsMap: i0,
      ...b$4(r0)
    });
  }
};
function Et$3(t0, e0) {
  const n0 = Q$5(t0), r0 = Q$5(e0);
  if (t0 === e0)
    return { valid: !0, data: t0 };
  if (n0 === h$1.object && r0 === h$1.object) {
    const i0 = x$4.objectKeys(e0), o0 = x$4.objectKeys(t0).filter((a0) => i0.indexOf(a0) !== -1), s0 = { ...t0, ...e0 };
    for (const a0 of o0) {
      const c0 = Et$3(t0[a0], e0[a0]);
      if (!c0.valid)
        return { valid: !1 };
      s0[a0] = c0.data;
    }
    return { valid: !0, data: s0 };
  } else if (n0 === h$1.array && r0 === h$1.array) {
    if (t0.length !== e0.length)
      return { valid: !1 };
    const i0 = [];
    for (let o0 = 0; o0 < t0.length; o0++) {
      const s0 = t0[o0], a0 = e0[o0], c0 = Et$3(s0, a0);
      if (!c0.valid)
        return { valid: !1 };
      i0.push(c0.data);
    }
    return { valid: !0, data: i0 };
  } else
    return n0 === h$1.date && r0 === h$1.date && +t0 == +e0 ? { valid: !0, data: t0 } : { valid: !1 };
}
let Ie$1 = class extends w$2 {
  _parse(e0) {
    const { status: n0, ctx: r0 } = this._processInputParams(e0), i0 = (o0, s0) => {
      if (kt$2(o0) || kt$2(s0))
        return v$2;
      const a0 = Et$3(o0.value, s0.value);
      return a0.valid ? ((Tt$3(o0) || Tt$3(s0)) && n0.dirty(), { status: n0.value, value: a0.data }) : (p$2(r0, {
        code: f$2.invalid_intersection_types
      }), v$2);
    };
    return r0.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r0.data,
        path: r0.path,
        parent: r0
      }),
      this._def.right._parseAsync({
        data: r0.data,
        path: r0.path,
        parent: r0
      })
    ]).then(([o0, s0]) => i0(o0, s0)) : i0(this._def.left._parseSync({
      data: r0.data,
      path: r0.path,
      parent: r0
    }), this._def.right._parseSync({
      data: r0.data,
      path: r0.path,
      parent: r0
    }));
  }
};
Ie$1.create = (t0, e0, n0) => new Ie$1({
  left: t0,
  right: e0,
  typeName: _$2.ZodIntersection,
  ...b$4(n0)
});
let z$3 = class Zm extends w$2 {
  _parse(e0) {
    const { status: n0, ctx: r0 } = this._processInputParams(e0);
    if (r0.parsedType !== h$1.array)
      return p$2(r0, {
        code: f$2.invalid_type,
        expected: h$1.array,
        received: r0.parsedType
      }), v$2;
    if (r0.data.length < this._def.items.length)
      return p$2(r0, {
        code: f$2.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), v$2;
    !this._def.rest && r0.data.length > this._def.items.length && (p$2(r0, {
      code: f$2.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n0.dirty());
    const i0 = [...r0.data].map((o0, s0) => {
      const a0 = this._def.items[s0] || this._def.rest;
      return a0 ? a0._parse(new V$3(r0, o0, r0.path, s0)) : null;
    }).filter((o0) => !!o0);
    return r0.common.async ? Promise.all(i0).then((o0) => L$4.mergeArray(n0, o0)) : L$4.mergeArray(n0, i0);
  }
  get items() {
    return this._def.items;
  }
  rest(e0) {
    return new Zm({
      ...this._def,
      rest: e0
    });
  }
};
z$3.create = (t0, e0) => {
  if (!Array.isArray(t0))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new z$3({
    items: t0,
    typeName: _$2.ZodTuple,
    rest: null,
    ...b$4(e0)
  });
};
let je$3 = class jm extends w$2 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e0) {
    const { status: n0, ctx: r0 } = this._processInputParams(e0);
    if (r0.parsedType !== h$1.object)
      return p$2(r0, {
        code: f$2.invalid_type,
        expected: h$1.object,
        received: r0.parsedType
      }), v$2;
    const i0 = [], o0 = this._def.keyType, s0 = this._def.valueType;
    for (const a0 in r0.data)
      i0.push({
        key: o0._parse(new V$3(r0, a0, r0.path, a0)),
        value: s0._parse(new V$3(r0, r0.data[a0], r0.path, a0)),
        alwaysSet: a0 in r0.data
      });
    return r0.common.async ? L$4.mergeObjectAsync(n0, i0) : L$4.mergeObjectSync(n0, i0);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e0, n0, r0) {
    return n0 instanceof w$2 ? new jm({
      keyType: e0,
      valueType: n0,
      typeName: _$2.ZodRecord,
      ...b$4(r0)
    }) : new jm({
      keyType: D$3.create(),
      valueType: e0,
      typeName: _$2.ZodRecord,
      ...b$4(n0)
    });
  }
}, Qe$2 = class extends w$2 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e0) {
    const { status: n0, ctx: r0 } = this._processInputParams(e0);
    if (r0.parsedType !== h$1.map)
      return p$2(r0, {
        code: f$2.invalid_type,
        expected: h$1.map,
        received: r0.parsedType
      }), v$2;
    const i0 = this._def.keyType, o0 = this._def.valueType, s0 = [...r0.data.entries()].map(([a0, c0], l0) => ({
      key: i0._parse(new V$3(r0, a0, r0.path, [l0, "key"])),
      value: o0._parse(new V$3(r0, c0, r0.path, [l0, "value"]))
    }));
    if (r0.common.async) {
      const a0 = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c0 of s0) {
          const l0 = await c0.key, u0 = await c0.value;
          if (l0.status === "aborted" || u0.status === "aborted")
            return v$2;
          (l0.status === "dirty" || u0.status === "dirty") && n0.dirty(), a0.set(l0.value, u0.value);
        }
        return { status: n0.value, value: a0 };
      });
    } else {
      const a0 = /* @__PURE__ */ new Map();
      for (const c0 of s0) {
        const l0 = c0.key, u0 = c0.value;
        if (l0.status === "aborted" || u0.status === "aborted")
          return v$2;
        (l0.status === "dirty" || u0.status === "dirty") && n0.dirty(), a0.set(l0.value, u0.value);
      }
      return { status: n0.value, value: a0 };
    }
  }
};
Qe$2.create = (t0, e0, n0) => new Qe$2({
  valueType: e0,
  keyType: t0,
  typeName: _$2.ZodMap,
  ...b$4(n0)
});
let ie$3 = class Bm extends w$2 {
  _parse(e0) {
    const { status: n0, ctx: r0 } = this._processInputParams(e0);
    if (r0.parsedType !== h$1.set)
      return p$2(r0, {
        code: f$2.invalid_type,
        expected: h$1.set,
        received: r0.parsedType
      }), v$2;
    const i0 = this._def;
    i0.minSize !== null && r0.data.size < i0.minSize.value && (p$2(r0, {
      code: f$2.too_small,
      minimum: i0.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i0.minSize.message
    }), n0.dirty()), i0.maxSize !== null && r0.data.size > i0.maxSize.value && (p$2(r0, {
      code: f$2.too_big,
      maximum: i0.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i0.maxSize.message
    }), n0.dirty());
    const o0 = this._def.valueType;
    function s0(c0) {
      const l0 = /* @__PURE__ */ new Set();
      for (const u0 of c0) {
        if (u0.status === "aborted")
          return v$2;
        u0.status === "dirty" && n0.dirty(), l0.add(u0.value);
      }
      return { status: n0.value, value: l0 };
    }
    const a0 = [...r0.data.values()].map((c0, l0) => o0._parse(new V$3(r0, c0, r0.path, l0)));
    return r0.common.async ? Promise.all(a0).then((c0) => s0(c0)) : s0(a0);
  }
  min(e0, n0) {
    return new Bm({
      ...this._def,
      minSize: { value: e0, message: g$1.toString(n0) }
    });
  }
  max(e0, n0) {
    return new Bm({
      ...this._def,
      maxSize: { value: e0, message: g$1.toString(n0) }
    });
  }
  size(e0, n0) {
    return this.min(e0, n0).max(e0, n0);
  }
  nonempty(e0) {
    return this.min(1, e0);
  }
};
ie$3.create = (t0, e0) => new ie$3({
  valueType: t0,
  minSize: null,
  maxSize: null,
  typeName: _$2.ZodSet,
  ...b$4(e0)
});
let le$3 = class hm extends w$2 {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e0) {
    const { ctx: n0 } = this._processInputParams(e0);
    if (n0.parsedType !== h$1.function)
      return p$2(n0, {
        code: f$2.invalid_type,
        expected: h$1.function,
        received: n0.parsedType
      }), v$2;
    function r0(a0, c0) {
      return Fe$3({
        data: a0,
        path: n0.path,
        errorMaps: [
          n0.common.contextualErrorMap,
          n0.schemaErrorMap,
          He$2(),
          pe$2
        ].filter((l0) => !!l0),
        issueData: {
          code: f$2.invalid_arguments,
          argumentsError: c0
        }
      });
    }
    function i0(a0, c0) {
      return Fe$3({
        data: a0,
        path: n0.path,
        errorMaps: [
          n0.common.contextualErrorMap,
          n0.schemaErrorMap,
          He$2(),
          pe$2
        ].filter((l0) => !!l0),
        issueData: {
          code: f$2.invalid_return_type,
          returnTypeError: c0
        }
      });
    }
    const o0 = { errorMap: n0.common.contextualErrorMap }, s0 = n0.data;
    if (this._def.returns instanceof me$3) {
      const a0 = this;
      return I$2(async function(...c0) {
        const l0 = new A$4([]), u0 = await a0._def.args.parseAsync(c0, o0).catch((h0) => {
          throw l0.addIssue(r0(c0, h0)), l0;
        }), d0 = await Reflect.apply(s0, this, u0);
        return await a0._def.returns._def.type.parseAsync(d0, o0).catch((h0) => {
          throw l0.addIssue(i0(d0, h0)), l0;
        });
      });
    } else {
      const a0 = this;
      return I$2(function(...c0) {
        const l0 = a0._def.args.safeParse(c0, o0);
        if (!l0.success)
          throw new A$4([r0(c0, l0.error)]);
        const u0 = Reflect.apply(s0, this, l0.data), d0 = a0._def.returns.safeParse(u0, o0);
        if (!d0.success)
          throw new A$4([i0(u0, d0.error)]);
        return d0.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e0) {
    return new hm({
      ...this._def,
      args: z$3.create(e0).rest(ne$3.create())
    });
  }
  returns(e0) {
    return new hm({
      ...this._def,
      returns: e0
    });
  }
  implement(e0) {
    return this.parse(e0);
  }
  strictImplement(e0) {
    return this.parse(e0);
  }
  static create(e0, n0, r0) {
    return new hm({
      args: e0 || z$3.create([]).rest(ne$3.create()),
      returns: n0 || ne$3.create(),
      typeName: _$2.ZodFunction,
      ...b$4(r0)
    });
  }
}, Ae$2 = class extends w$2 {
  get schema() {
    return this._def.getter();
  }
  _parse(e0) {
    const { ctx: n0 } = this._processInputParams(e0);
    return this._def.getter()._parse({ data: n0.data, path: n0.path, parent: n0 });
  }
};
Ae$2.create = (t0, e0) => new Ae$2({
  getter: t0,
  typeName: _$2.ZodLazy,
  ...b$4(e0)
});
let $e$3 = class extends w$2 {
  _parse(e0) {
    if (e0.data !== this._def.value) {
      const n0 = this._getOrReturnCtx(e0);
      return p$2(n0, {
        received: n0.data,
        code: f$2.invalid_literal,
        expected: this._def.value
      }), v$2;
    }
    return { status: "valid", value: e0.data };
  }
  get value() {
    return this._def.value;
  }
};
$e$3.create = (t0, e0) => new $e$3({
  value: t0,
  typeName: _$2.ZodLiteral,
  ...b$4(e0)
});
function Kr$2(t0, e0) {
  return new ee$3({
    values: t0,
    typeName: _$2.ZodEnum,
    ...b$4(e0)
  });
}
let ee$3 = class Pm extends w$2 {
  constructor() {
    super(...arguments), xe$2.set(this, void 0);
  }
  _parse(e0) {
    if (typeof e0.data != "string") {
      const n0 = this._getOrReturnCtx(e0), r0 = this._def.values;
      return p$2(n0, {
        expected: x$4.joinValues(r0),
        received: n0.parsedType,
        code: f$2.invalid_type
      }), v$2;
    }
    if (Je$2(this, xe$2, "f") || Yr$2(this, xe$2, new Set(this._def.values), "f"), !Je$2(this, xe$2, "f").has(e0.data)) {
      const n0 = this._getOrReturnCtx(e0), r0 = this._def.values;
      return p$2(n0, {
        received: n0.data,
        code: f$2.invalid_enum_value,
        options: r0
      }), v$2;
    }
    return I$2(e0.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e0 = {};
    for (const n0 of this._def.values)
      e0[n0] = n0;
    return e0;
  }
  get Values() {
    const e0 = {};
    for (const n0 of this._def.values)
      e0[n0] = n0;
    return e0;
  }
  get Enum() {
    const e0 = {};
    for (const n0 of this._def.values)
      e0[n0] = n0;
    return e0;
  }
  extract(e0, n0 = this._def) {
    return Pm.create(e0, {
      ...this._def,
      ...n0
    });
  }
  exclude(e0, n0 = this._def) {
    return Pm.create(this.options.filter((r0) => !e0.includes(r0)), {
      ...this._def,
      ...n0
    });
  }
};
xe$2 = /* @__PURE__ */ new WeakMap();
ee$3.create = Kr$2;
let Me$4 = class extends w$2 {
  constructor() {
    super(...arguments), ke$3.set(this, void 0);
  }
  _parse(e0) {
    const n0 = x$4.getValidEnumValues(this._def.values), r0 = this._getOrReturnCtx(e0);
    if (r0.parsedType !== h$1.string && r0.parsedType !== h$1.number) {
      const i0 = x$4.objectValues(n0);
      return p$2(r0, {
        expected: x$4.joinValues(i0),
        received: r0.parsedType,
        code: f$2.invalid_type
      }), v$2;
    }
    if (Je$2(this, ke$3, "f") || Yr$2(this, ke$3, new Set(x$4.getValidEnumValues(this._def.values)), "f"), !Je$2(this, ke$3, "f").has(e0.data)) {
      const i0 = x$4.objectValues(n0);
      return p$2(r0, {
        received: r0.data,
        code: f$2.invalid_enum_value,
        options: i0
      }), v$2;
    }
    return I$2(e0.data);
  }
  get enum() {
    return this._def.values;
  }
};
ke$3 = /* @__PURE__ */ new WeakMap();
Me$4.create = (t0, e0) => new Me$4({
  values: t0,
  typeName: _$2.ZodNativeEnum,
  ...b$4(e0)
});
let me$3 = class extends w$2 {
  unwrap() {
    return this._def.type;
  }
  _parse(e0) {
    const { ctx: n0 } = this._processInputParams(e0);
    if (n0.parsedType !== h$1.promise && n0.common.async === !1)
      return p$2(n0, {
        code: f$2.invalid_type,
        expected: h$1.promise,
        received: n0.parsedType
      }), v$2;
    const r0 = n0.parsedType === h$1.promise ? n0.data : Promise.resolve(n0.data);
    return I$2(r0.then((i0) => this._def.type.parseAsync(i0, {
      path: n0.path,
      errorMap: n0.common.contextualErrorMap
    })));
  }
};
me$3.create = (t0, e0) => new me$3({
  type: t0,
  typeName: _$2.ZodPromise,
  ...b$4(e0)
});
let U$2 = class extends w$2 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === _$2.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e0) {
    const { status: n0, ctx: r0 } = this._processInputParams(e0), i0 = this._def.effect || null, o0 = {
      addIssue: (s0) => {
        p$2(r0, s0), s0.fatal ? n0.abort() : n0.dirty();
      },
      get path() {
        return r0.path;
      }
    };
    if (o0.addIssue = o0.addIssue.bind(o0), i0.type === "preprocess") {
      const s0 = i0.transform(r0.data, o0);
      if (r0.common.async)
        return Promise.resolve(s0).then(async (a0) => {
          if (n0.value === "aborted")
            return v$2;
          const c0 = await this._def.schema._parseAsync({
            data: a0,
            path: r0.path,
            parent: r0
          });
          return c0.status === "aborted" ? v$2 : c0.status === "dirty" || n0.value === "dirty" ? de$3(c0.value) : c0;
        });
      {
        if (n0.value === "aborted")
          return v$2;
        const a0 = this._def.schema._parseSync({
          data: s0,
          path: r0.path,
          parent: r0
        });
        return a0.status === "aborted" ? v$2 : a0.status === "dirty" || n0.value === "dirty" ? de$3(a0.value) : a0;
      }
    }
    if (i0.type === "refinement") {
      const s0 = (a0) => {
        const c0 = i0.refinement(a0, o0);
        if (r0.common.async)
          return Promise.resolve(c0);
        if (c0 instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a0;
      };
      if (r0.common.async === !1) {
        const a0 = this._def.schema._parseSync({
          data: r0.data,
          path: r0.path,
          parent: r0
        });
        return a0.status === "aborted" ? v$2 : (a0.status === "dirty" && n0.dirty(), s0(a0.value), { status: n0.value, value: a0.value });
      } else
        return this._def.schema._parseAsync({ data: r0.data, path: r0.path, parent: r0 }).then((a0) => a0.status === "aborted" ? v$2 : (a0.status === "dirty" && n0.dirty(), s0(a0.value).then(() => ({ status: n0.value, value: a0.value }))));
    }
    if (i0.type === "transform")
      if (r0.common.async === !1) {
        const s0 = this._def.schema._parseSync({
          data: r0.data,
          path: r0.path,
          parent: r0
        });
        if (!Re$3(s0))
          return s0;
        const a0 = i0.transform(s0.value, o0);
        if (a0 instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n0.value, value: a0 };
      } else
        return this._def.schema._parseAsync({ data: r0.data, path: r0.path, parent: r0 }).then((s0) => Re$3(s0) ? Promise.resolve(i0.transform(s0.value, o0)).then((a0) => ({ status: n0.value, value: a0 })) : s0);
    x$4.assertNever(i0);
  }
};
U$2.create = (t0, e0, n0) => new U$2({
  schema: t0,
  typeName: _$2.ZodEffects,
  effect: e0,
  ...b$4(n0)
});
U$2.createWithPreprocess = (t0, e0, n0) => new U$2({
  schema: e0,
  effect: { type: "preprocess", transform: t0 },
  typeName: _$2.ZodEffects,
  ...b$4(n0)
});
let B$3 = class extends w$2 {
  _parse(e0) {
    return this._getType(e0) === h$1.undefined ? I$2(void 0) : this._def.innerType._parse(e0);
  }
  unwrap() {
    return this._def.innerType;
  }
};
B$3.create = (t0, e0) => new B$3({
  innerType: t0,
  typeName: _$2.ZodOptional,
  ...b$4(e0)
});
let te$3 = class extends w$2 {
  _parse(e0) {
    return this._getType(e0) === h$1.null ? I$2(null) : this._def.innerType._parse(e0);
  }
  unwrap() {
    return this._def.innerType;
  }
};
te$3.create = (t0, e0) => new te$3({
  innerType: t0,
  typeName: _$2.ZodNullable,
  ...b$4(e0)
});
let De$2 = class extends w$2 {
  _parse(e0) {
    const { ctx: n0 } = this._processInputParams(e0);
    let r0 = n0.data;
    return n0.parsedType === h$1.undefined && (r0 = this._def.defaultValue()), this._def.innerType._parse({
      data: r0,
      path: n0.path,
      parent: n0
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
De$2.create = (t0, e0) => new De$2({
  innerType: t0,
  typeName: _$2.ZodDefault,
  defaultValue: typeof e0.default == "function" ? e0.default : () => e0.default,
  ...b$4(e0)
});
let Ze$2 = class extends w$2 {
  _parse(e0) {
    const { ctx: n0 } = this._processInputParams(e0), r0 = {
      ...n0,
      common: {
        ...n0.common,
        issues: []
      }
    }, i0 = this._def.innerType._parse({
      data: r0.data,
      path: r0.path,
      parent: {
        ...r0
      }
    });
    return Oe$3(i0) ? i0.then((o0) => ({
      status: "valid",
      value: o0.status === "valid" ? o0.value : this._def.catchValue({
        get error() {
          return new A$4(r0.common.issues);
        },
        input: r0.data
      })
    })) : {
      status: "valid",
      value: i0.status === "valid" ? i0.value : this._def.catchValue({
        get error() {
          return new A$4(r0.common.issues);
        },
        input: r0.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
Ze$2.create = (t0, e0) => new Ze$2({
  innerType: t0,
  typeName: _$2.ZodCatch,
  catchValue: typeof e0.catch == "function" ? e0.catch : () => e0.catch,
  ...b$4(e0)
});
let Xe$2 = class extends w$2 {
  _parse(e0) {
    if (this._getType(e0) !== h$1.nan) {
      const n0 = this._getOrReturnCtx(e0);
      return p$2(n0, {
        code: f$2.invalid_type,
        expected: h$1.nan,
        received: n0.parsedType
      }), v$2;
    }
    return { status: "valid", value: e0.data };
  }
};
Xe$2.create = (t0) => new Xe$2({
  typeName: _$2.ZodNaN,
  ...b$4(t0)
});
const Ni$1 = Symbol("zod_brand");
let qt$2 = class extends w$2 {
  _parse(e0) {
    const { ctx: n0 } = this._processInputParams(e0), r0 = n0.data;
    return this._def.type._parse({
      data: r0,
      path: n0.path,
      parent: n0
    });
  }
  unwrap() {
    return this._def.type;
  }
}, Be$4 = class qm extends w$2 {
  _parse(e0) {
    const { status: n0, ctx: r0 } = this._processInputParams(e0);
    if (r0.common.async)
      return (async () => {
        const i0 = await this._def.in._parseAsync({
          data: r0.data,
          path: r0.path,
          parent: r0
        });
        return i0.status === "aborted" ? v$2 : i0.status === "dirty" ? (n0.dirty(), de$3(i0.value)) : this._def.out._parseAsync({
          data: i0.value,
          path: r0.path,
          parent: r0
        });
      })();
    {
      const i0 = this._def.in._parseSync({
        data: r0.data,
        path: r0.path,
        parent: r0
      });
      return i0.status === "aborted" ? v$2 : i0.status === "dirty" ? (n0.dirty(), {
        status: "dirty",
        value: i0.value
      }) : this._def.out._parseSync({
        data: i0.value,
        path: r0.path,
        parent: r0
      });
    }
  }
  static create(e0, n0) {
    return new qm({
      in: e0,
      out: n0,
      typeName: _$2.ZodPipeline
    });
  }
}, Ue$2 = class extends w$2 {
  _parse(e0) {
    const n0 = this._def.innerType._parse(e0), r0 = (i0) => (Re$3(i0) && (i0.value = Object.freeze(i0.value)), i0);
    return Oe$3(n0) ? n0.then((i0) => r0(i0)) : r0(n0);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Ue$2.create = (t0, e0) => new Ue$2({
  innerType: t0,
  typeName: _$2.ZodReadonly,
  ...b$4(e0)
});
function en$1(t0, e0 = {}, n0) {
  return t0 ? he$3.create().superRefine((r0, i0) => {
    var o0, s0;
    if (!t0(r0)) {
      const a0 = typeof e0 == "function" ? e0(r0) : typeof e0 == "string" ? { message: e0 } : e0, c0 = (s0 = (o0 = a0.fatal) !== null && o0 !== void 0 ? o0 : n0) !== null && s0 !== void 0 ? s0 : !0, l0 = typeof a0 == "string" ? { message: a0 } : a0;
      i0.addIssue({ code: "custom", ...l0, fatal: c0 });
    }
  }) : he$3.create();
}
const Li$1 = {
  object: C$4.lazycreate
};
var _$2;
(function(t0) {
  t0.ZodString = "ZodString", t0.ZodNumber = "ZodNumber", t0.ZodNaN = "ZodNaN", t0.ZodBigInt = "ZodBigInt", t0.ZodBoolean = "ZodBoolean", t0.ZodDate = "ZodDate", t0.ZodSymbol = "ZodSymbol", t0.ZodUndefined = "ZodUndefined", t0.ZodNull = "ZodNull", t0.ZodAny = "ZodAny", t0.ZodUnknown = "ZodUnknown", t0.ZodNever = "ZodNever", t0.ZodVoid = "ZodVoid", t0.ZodArray = "ZodArray", t0.ZodObject = "ZodObject", t0.ZodUnion = "ZodUnion", t0.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t0.ZodIntersection = "ZodIntersection", t0.ZodTuple = "ZodTuple", t0.ZodRecord = "ZodRecord", t0.ZodMap = "ZodMap", t0.ZodSet = "ZodSet", t0.ZodFunction = "ZodFunction", t0.ZodLazy = "ZodLazy", t0.ZodLiteral = "ZodLiteral", t0.ZodEnum = "ZodEnum", t0.ZodEffects = "ZodEffects", t0.ZodNativeEnum = "ZodNativeEnum", t0.ZodOptional = "ZodOptional", t0.ZodNullable = "ZodNullable", t0.ZodDefault = "ZodDefault", t0.ZodCatch = "ZodCatch", t0.ZodPromise = "ZodPromise", t0.ZodBranded = "ZodBranded", t0.ZodPipeline = "ZodPipeline", t0.ZodReadonly = "ZodReadonly";
})(_$2 || (_$2 = {}));
const Ii$1 = (t0, e0 = {
  message: `Input not instance of ${t0.name}`
}) => en$1((n0) => n0 instanceof t0, e0), tn$1 = D$3.create, rn$1 = X$4.create, ji$1 = Xe$2.create, Ai$1 = K$4.create, nn$1 = Se$4.create, $i$1 = se$3.create, Mi$1 = Ye$2.create, Di$1 = Pe$3.create, Zi$1 = Ne$3.create, Ui$1 = he$3.create, qi$1 = ne$3.create, Bi$1 = Y$2.create, Vi$1 = Ge$2.create, zi$1 = Z$3.create, Wi$1 = C$4.create, Hi$1 = C$4.strictCreate, Fi$1 = Le$2.create, Ji$1 = ct$2.create, Yi$1 = Ie$1.create, Gi$1 = z$3.create, Qi$1 = je$3.create, Xi$1 = Qe$2.create, Ki$1 = ie$3.create, ea$1 = le$3.create, ta$1 = Ae$2.create, ra$1 = $e$3.create, na$1 = ee$3.create, sa$1 = Me$4.create, ia$1 = me$3.create, cr$2 = U$2.create, aa$1 = B$3.create, oa$1 = te$3.create, ca$1 = U$2.createWithPreprocess, ua$1 = Be$4.create, da$1 = () => tn$1().optional(), la$1 = () => rn$1().optional(), fa$1 = () => nn$1().optional(), pa$1 = {
  string: (t0) => D$3.create({ ...t0, coerce: !0 }),
  number: (t0) => X$4.create({ ...t0, coerce: !0 }),
  boolean: (t0) => Se$4.create({
    ...t0,
    coerce: !0
  }),
  bigint: (t0) => K$4.create({ ...t0, coerce: !0 }),
  date: (t0) => se$3.create({ ...t0, coerce: !0 })
}, ha$1 = v$2;
var d$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: pe$2,
  setErrorMap: hi$1,
  getErrorMap: He$2,
  makeIssue: Fe$3,
  EMPTY_PATH: mi$1,
  addIssueToContext: p$2,
  ParseStatus: L$4,
  INVALID: v$2,
  DIRTY: de$3,
  OK: I$2,
  isAborted: kt$2,
  isDirty: Tt$3,
  isValid: Re$3,
  isAsync: Oe$3,
  get util() {
    return x$4;
  },
  get objectUtil() {
    return xt$3;
  },
  ZodParsedType: h$1,
  getParsedType: Q$5,
  ZodType: w$2,
  datetimeRegex: Xr$2,
  ZodString: D$3,
  ZodNumber: X$4,
  ZodBigInt: K$4,
  ZodBoolean: Se$4,
  ZodDate: se$3,
  ZodSymbol: Ye$2,
  ZodUndefined: Pe$3,
  ZodNull: Ne$3,
  ZodAny: he$3,
  ZodUnknown: ne$3,
  ZodNever: Y$2,
  ZodVoid: Ge$2,
  ZodArray: Z$3,
  ZodObject: C$4,
  ZodUnion: Le$2,
  ZodDiscriminatedUnion: ct$2,
  ZodIntersection: Ie$1,
  ZodTuple: z$3,
  ZodRecord: je$3,
  ZodMap: Qe$2,
  ZodSet: ie$3,
  ZodFunction: le$3,
  ZodLazy: Ae$2,
  ZodLiteral: $e$3,
  ZodEnum: ee$3,
  ZodNativeEnum: Me$4,
  ZodPromise: me$3,
  ZodEffects: U$2,
  ZodTransformer: U$2,
  ZodOptional: B$3,
  ZodNullable: te$3,
  ZodDefault: De$2,
  ZodCatch: Ze$2,
  ZodNaN: Xe$2,
  BRAND: Ni$1,
  ZodBranded: qt$2,
  ZodPipeline: Be$4,
  ZodReadonly: Ue$2,
  custom: en$1,
  Schema: w$2,
  ZodSchema: w$2,
  late: Li$1,
  get ZodFirstPartyTypeKind() {
    return _$2;
  },
  coerce: pa$1,
  any: Ui$1,
  array: zi$1,
  bigint: Ai$1,
  boolean: nn$1,
  date: $i$1,
  discriminatedUnion: Ji$1,
  effect: cr$2,
  enum: na$1,
  function: ea$1,
  instanceof: Ii$1,
  intersection: Yi$1,
  lazy: ta$1,
  literal: ra$1,
  map: Xi$1,
  nan: ji$1,
  nativeEnum: sa$1,
  never: Bi$1,
  null: Zi$1,
  nullable: oa$1,
  number: rn$1,
  object: Wi$1,
  oboolean: fa$1,
  onumber: la$1,
  optional: aa$1,
  ostring: da$1,
  pipeline: ua$1,
  preprocess: ca$1,
  promise: ia$1,
  record: Qi$1,
  set: Ki$1,
  strictObject: Hi$1,
  string: tn$1,
  symbol: Mi$1,
  transformer: cr$2,
  tuple: Gi$1,
  undefined: Di$1,
  union: Fi$1,
  unknown: qi$1,
  void: Vi$1,
  NEVER: ha$1,
  ZodIssueCode: f$2,
  quotelessJson: pi$1,
  ZodError: A$4
});
const sn$1 = /^0x[0-9a-f]+$/i, an$1 = /^\d+$/, ma$1 = d$1.string().min(1, "The short string cannot be empty").max(31, "The short string cannot exceed 31 characters").refine(
  (t0) => !sn$1.test(t0),
  "The shortString should not be a hex string"
).refine(
  (t0) => !an$1.test(t0),
  "The shortString should not be an integer string"
), M$4 = d$1.union([
  d$1.string().regex(
    sn$1,
    "Only hex, integers and bigint are supported in calldata"
  ),
  d$1.string().regex(
    an$1,
    "Only hex, integers and bigint are supported in calldata"
  ),
  ma$1,
  d$1.number().int("Only hex, integers and bigint are supported in calldata"),
  d$1.bigint()
]), qe$2 = d$1.object({
  contractAddress: d$1.string(),
  entrypoint: d$1.string(),
  calldata: d$1.array(M$4.or(d$1.array(M$4))).optional()
}), Ct$2 = d$1.array(qe$2).nonempty(), on$2 = d$1.object({
  types: d$1.record(
    d$1.array(
      d$1.union([
        d$1.object({
          name: d$1.string(),
          type: d$1.literal("merkletree"),
          contains: d$1.string()
        }),
        d$1.object({
          name: d$1.string(),
          type: d$1.literal("enum"),
          contains: d$1.string()
        }),
        d$1.object({
          name: d$1.string(),
          type: d$1.string()
        })
      ])
    )
  ),
  primaryType: d$1.string(),
  domain: d$1.record(d$1.unknown()),
  message: d$1.record(d$1.unknown()).or(d$1.object({}))
}), Rt$3 = d$1.object({
  type: d$1.literal("ERC20"),
  options: d$1.object({
    address: d$1.string(),
    symbol: d$1.string().optional(),
    decimals: d$1.number().optional(),
    image: d$1.string().optional(),
    name: d$1.string().optional()
  })
}), ya$1 = d$1.union([
  d$1.object({
    id: d$1.string(),
    chain_id: d$1.string(),
    chain_name: d$1.string(),
    rpc_urls: d$1.array(d$1.string()).optional(),
    native_currency: Rt$3.optional(),
    block_explorer_url: d$1.array(d$1.string()).optional()
  }),
  d$1.object({
    id: d$1.string(),
    chainId: d$1.string(),
    chainName: d$1.string(),
    rpcUrls: d$1.array(d$1.string()).optional(),
    nativeCurrency: Rt$3.optional(),
    blockExplorerUrl: d$1.array(d$1.string()).optional()
  }).transform((t0) => ({
    id: t0.id,
    chain_id: t0.chainId,
    chain_name: t0.chainName,
    rpc_urls: t0.rpcUrls,
    native_currency: t0.nativeCurrency,
    block_explorer_url: t0.blockExplorerUrl
  }))
]), _t$2 = {
  enable: d$1.tuple([
    d$1.object({
      starknetVersion: d$1.union([d$1.literal("v3"), d$1.literal("v4"), d$1.literal("v5")]).optional()
    }).optional()
  ]).or(d$1.tuple([])),
  addStarknetChain: d$1.tuple([ya$1]),
  switchStarknetChain: d$1.tuple([
    d$1.object({
      chainId: d$1.string()
    })
  ]),
  watchAsset: d$1.tuple([Rt$3]),
  requestAccounts: d$1.tuple([
    d$1.object({
      silent_mode: d$1.boolean().optional()
    })
  ]),
  execute: d$1.tuple([
    Ct$2.or(qe$2),
    d$1.object({
      nonce: M$4.optional(),
      maxFee: M$4.optional(),
      version: M$4.optional()
    }).optional()
  ]),
  signMessage: d$1.tuple([on$2])
};
d$1.tuple([
  Ct$2.or(qe$2),
  d$1.object({
    nonce: M$4.optional(),
    maxFee: M$4.optional(),
    version: M$4.optional()
  }).optional()
]).or(
  d$1.tuple([
    Ct$2.or(qe$2),
    d$1.array(d$1.any()).optional(),
    d$1.object({
      nonce: M$4.optional(),
      maxFee: M$4.optional(),
      version: M$4.optional()
    }).optional()
  ])
);
const cn$1 = d$1.object({
  contract_address: d$1.string(),
  entry_point: d$1.string(),
  calldata: d$1.array(M$4).optional()
}).transform(({ contract_address: t0, entry_point: e0, calldata: n0 }) => ({
  contractAddress: t0,
  entrypoint: e0,
  calldata: n0 || []
})), ga$1 = d$1.array(cn$1).nonempty(), _a$1 = {
  ZERO: 0,
  ONE: 1
}, va$1 = d$1.object({
  address: d$1.string(),
  class_hash: d$1.string(),
  salt: d$1.string(),
  calldata: d$1.array(d$1.string()),
  sigdata: d$1.array(d$1.string()).optional(),
  //version: z.literal([0, 1]),
  version: d$1.nativeEnum(_a$1)
  // allow only 0 | 1, workaround since zod doesn't support literals as numbers
}), ba$1 = d$1.object({
  callbackData: d$1.string().optional(),
  approvalRequests: d$1.array(
    d$1.object({
      tokenAddress: d$1.string(),
      amount: d$1.string(),
      spender: d$1.string()
    })
  ),
  sessionTypedData: on$2
}), wa$1 = d$1.object({
  account: d$1.string().array().optional(),
  chainId: d$1.string().optional(),
  signature: d$1.string().array().optional(),
  approvalTransactionHash: d$1.string().optional(),
  deploymentPayload: d$1.any().optional(),
  approvalRequestsCalls: d$1.array(qe$2).optional(),
  errorCode: d$1.enum([
    "USER_REJECTED",
    "ACCOUNT_NOT_DEPLOYED",
    "NOT_ENOUGH_BALANCE",
    "NOT_ENOUGH_BALANCE_DEPLOYMENT",
    "GENERIC_ERROR"
  ]).optional()
}), O$2 = Kn$1.create({
  isServer: !1,
  allowOutsideOfServer: !0
});
O$2.router({
  authorize: O$2.procedure.output(d$1.boolean()).mutation(async () => !0),
  connect: O$2.procedure.mutation(async () => ""),
  connectWebwallet: O$2.procedure.input(
    d$1.object({
      theme: d$1.enum(["light", "dark", "auto"]).optional()
    })
  ).output(
    d$1.object({
      account: d$1.string().array().optional(),
      chainId: d$1.string().optional()
    })
  ).mutation(async () => ({})),
  connectWebwalletSSO: O$2.procedure.input(
    d$1.object({ token: d$1.string(), authorizedPartyId: d$1.string().optional() })
  ).output(
    d$1.object({
      account: d$1.string().array().optional(),
      chainId: d$1.string().optional()
    })
  ).mutation(async () => ({})),
  connectAndSignSession: O$2.procedure.input(ba$1).output(wa$1).mutation(async () => ({})),
  enable: O$2.procedure.output(d$1.string()).mutation(async () => ""),
  execute: O$2.procedure.input(_t$2.execute).output(d$1.string()).mutation(async () => ""),
  signMessage: O$2.procedure.input(_t$2.signMessage).output(d$1.string().array()).mutation(async () => []),
  getLoginStatus: O$2.procedure.output(
    d$1.object({
      isLoggedIn: d$1.boolean(),
      hasSession: d$1.boolean().optional(),
      isPreauthorized: d$1.boolean().optional()
    })
  ).mutation(async () => ({
    isLoggedIn: !0
  })),
  // RPC Messages
  requestAccounts: O$2.procedure.input(d$1.object({ silent_mode: d$1.boolean().optional() })).output(d$1.string().array()).mutation(async () => []),
  requestChainId: O$2.procedure.output(d$1.string()).mutation(async () => ""),
  signTypedData: O$2.procedure.input(_t$2.signMessage).output(d$1.string().array()).mutation(async () => []),
  getPermissions: O$2.procedure.output(d$1.array(d$1.enum([A$5.ACCOUNTS]))).mutation(async () => [A$5.ACCOUNTS]),
  addInvokeTransaction: O$2.procedure.input(cn$1.or(ga$1)).output(d$1.string()).mutation(async (t0) => ""),
  addStarknetChain: O$2.procedure.mutation((t0) => {
    throw Error("not implemented");
  }),
  switchStarknetChain: O$2.procedure.mutation((t0) => {
    throw Error("not implemented");
  }),
  watchAsset: O$2.procedure.mutation((t0) => {
    throw Error("not implemented");
  }),
  updateModal: O$2.procedure.subscription(async () => {
  }),
  deploymentData: O$2.procedure.output(va$1).mutation(async () => ({
    address: "",
    calldata: [],
    version: 0,
    class_hash: "",
    salt: ""
  }))
});
var c$3 = Object.defineProperty, x$3 = (t0, e0, n0) => e0 in t0 ? c$3(t0, e0, { enumerable: !0, configurable: !0, writable: !0, value: n0 }) : t0[e0] = n0, T$2 = (t0, e0, n0) => (x$3(t0, typeof e0 != "symbol" ? e0 + "" : e0, n0), n0);
const b$3 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iOCIgZmlsbD0iYmxhY2siLz4KPHBhdGggZD0iTTE4LjQwMTggNy41NTU1NkgxMy41OTgyQzEzLjQzNzcgNy41NTU1NiAxMy4zMDkxIDcuNjg3NDcgMTMuMzA1NiA3Ljg1MTQzQzEzLjIwODUgMTIuNDYwMyAxMC44NDg0IDE2LjgzNDcgNi43ODYwOCAxOS45MzMxQzYuNjU3MTEgMjAuMDMxNCA2LjYyNzczIDIwLjIxNjIgNi43MjIwMiAyMC4zNDkzTDkuNTMyNTMgMjQuMzE5NkM5LjYyODE1IDI0LjQ1NDggOS44MTQ0NCAyNC40ODUzIDkuOTQ1NTggMjQuMzg2QzEyLjQ4NTYgMjIuNDYxMyAxNC41Mjg3IDIwLjEzOTUgMTYgMTcuNTY2QzE3LjQ3MTMgMjAuMTM5NSAxOS41MTQ1IDIyLjQ2MTMgMjIuMDU0NSAyNC4zODZDMjIuMTg1NiAyNC40ODUzIDIyLjM3MTkgMjQuNDU0OCAyMi40Njc2IDI0LjMxOTZMMjUuMjc4MSAyMC4zNDkzQzI1LjM3MjMgMjAuMjE2MiAyNS4zNDI5IDIwLjAzMTQgMjUuMjE0IDE5LjkzMzFDMjEuMTUxNiAxNi44MzQ3IDE4Ljc5MTUgMTIuNDYwMyAxOC42OTQ2IDcuODUxNDNDMTguNjkxMSA3LjY4NzQ3IDE4LjU2MjMgNy41NTU1NiAxOC40MDE4IDcuNTU1NTZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMjQuNzIzNiAxMC40OTJMMjQuMjIzMSA4LjkyNDM5QzI0LjEyMTMgOC42MDYxNCAyMy44NzM0IDguMzU4MjQgMjMuNTU3NyA4LjI2MDIzTDIyLjAwMzkgNy43NzU5NUMyMS43ODk1IDcuNzA5MDYgMjEuNzg3MyA3LjQwMTc3IDIyLjAwMTEgNy4zMzIwMUwyMy41NDY5IDYuODI0NjZDMjMuODYwOSA2LjcyMTQ2IDI0LjEwNiA2LjQ2OTUyIDI0LjIwMjcgNi4xNTAxMUwyNC42Nzk4IDQuNTc1MDJDMjQuNzQ1OCA0LjM1NzA5IDI1LjA0ODkgNC4zNTQ3NyAyNS4xMTgzIDQuNTcxNTZMMjUuNjE4OCA2LjEzOTE1QzI1LjcyMDYgNi40NTc0IDI1Ljk2ODYgNi43MDUzMSAyNi4yODQyIDYuODAzOUwyNy44MzggNy4yODc2MUMyOC4wNTI0IDcuMzU0NSAyOC4wNTQ3IDcuNjYxNzkgMjcuODQwOCA3LjczMjEzTDI2LjI5NSA4LjIzOTQ4QzI1Ljk4MTEgOC4zNDIxIDI1LjczNiA4LjU5NDA0IDI1LjYzOTMgOC45MTQwMkwyNS4xNjIxIDEwLjQ4ODVDMjUuMDk2MSAxMC43MDY1IDI0Ljc5MyAxMC43MDg4IDI0LjcyMzYgMTAuNDkyWiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+Cg==", Q$4 = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0iYmxhY2siPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+", S$2 = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0id2hpdGUiPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+Cg==", w$1 = {
  argentX: {
    dark: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTIzLjgxMyA1Ljk2NjFIMTYuMTE5MUMxNS44NjIgNS45NjYxIDE1LjY1NiA2LjE4NTMzIDE1LjY1MDQgNi40NTc4MkMxNS40OTQ5IDE0LjExNzQgMTEuNzE0NyAyMS4zODcyIDUuMjA4MTcgMjYuNTM2NUM1LjAwMTYgMjYuNjk5OCA0Ljk1NDU0IDI3LjAwNyA1LjEwNTU2IDI3LjIyODJMOS42MDcxNSAzMy44MjY1QzkuNzYwMjkgMzQuMDUxMSAxMC4wNTg3IDM0LjEwMTcgMTAuMjY4NyAzMy45MzY4QzE0LjMzNzEgMzAuNzM4MSAxNy42MDk1IDI2Ljg3OTUgMTkuOTY2MSAyMi42MDI1QzIyLjMyMjYgMjYuODc5NSAyNS41OTUyIDMwLjczODEgMjkuNjYzNiAzMy45MzY4QzI5Ljg3MzQgMzQuMTAxNyAzMC4xNzE4IDM0LjA1MTEgMzAuMzI1MiAzMy44MjY1TDM0LjgyNjggMjcuMjI4MkMzNC45Nzc2IDI3LjAwNyAzNC45MzA1IDI2LjY5OTggMzQuNzI0MSAyNi41MzY1QzI4LjIxNzQgMjEuMzg3MiAyNC40MzcyIDE0LjExNzQgMjQuMjgxOSA2LjQ1NzgyQzI0LjI3NjMgNi4xODUzMyAyNC4wNzAxIDUuOTY2MSAyMy44MTMgNS45NjYxWiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTM0LjU4OTQgMTAuNzg2NEwzMy43NjI4IDguMjE1ODFDMzMuNTk0NyA3LjY5Mzk1IDMzLjE4NTIgNy4yODc0NCAzMi42NjQgNy4xMjY3MkwzMC4wOTgxIDYuMzMyNTlDMjkuNzQ0IDYuMjIyOTEgMjkuNzQwMiA1LjcxOTAyIDMwLjA5MzQgNS42MDQ2M0wzMi42NDYxIDQuNzcyNjdDMzMuMTY0NiA0LjYwMzQ1IDMzLjU2OTQgNC4xOTAzMiAzMy43MjkxIDMuNjY2NTZMMzQuNTE3IDEuMDgzNzJDMzQuNjI2IDAuNzI2MzYgMzUuMTI2NiAwLjcyMjU3MSAzNS4yNDEyIDEuMDc4MDZMMzYuMDY3NyAzLjY0ODU4QzM2LjIzNTggNC4xNzA0NSAzNi42NDUzIDQuNTc2OTggMzcuMTY2NSA0LjczODY0TDM5LjczMjQgNS41MzE4M0M0MC4wODY1IDUuNjQxNSA0MC4wOTAzIDYuMTQ1NCAzOS43MzcyIDYuMjYwNzRMMzcuMTg0NCA3LjA5MjY5QzM2LjY2NTkgNy4yNjA5NiAzNi4yNjExIDcuNjc0MSAzNi4xMDE1IDguMTk4ODFMMzUuMzEzNSAxMC43ODA3QzM1LjIwNDUgMTEuMTM4MSAzNC43MDM5IDExLjE0MTggMzQuNTg5NCAxMC43ODY0WiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+Cg==",
    light: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDEiIHZpZXdCb3g9IjAgMCA0MCA0MSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTIzLjgxMyA2LjQ2NjFIMTYuMTE5MUMxNS44NjIgNi40NjYxIDE1LjY1NiA2LjY4NTMzIDE1LjY1MDQgNi45NTc4MkMxNS40OTQ5IDE0LjYxNzQgMTEuNzE0NyAyMS44ODcyIDUuMjA4MTcgMjcuMDM2NUM1LjAwMTYgMjcuMTk5OCA0Ljk1NDU0IDI3LjUwNyA1LjEwNTU2IDI3LjcyODJMOS42MDcxNSAzNC4zMjY1QzkuNzYwMjkgMzQuNTUxMSAxMC4wNTg3IDM0LjYwMTcgMTAuMjY4NyAzNC40MzY4QzE0LjMzNzEgMzEuMjM4MSAxNy42MDk1IDI3LjM3OTUgMTkuOTY2MSAyMy4xMDI1QzIyLjMyMjYgMjcuMzc5NSAyNS41OTUyIDMxLjIzODEgMjkuNjYzNiAzNC40MzY4QzI5Ljg3MzQgMzQuNjAxNyAzMC4xNzE4IDM0LjU1MTEgMzAuMzI1MiAzNC4zMjY1TDM0LjgyNjggMjcuNzI4MkMzNC45Nzc2IDI3LjUwNyAzNC45MzA1IDI3LjE5OTggMzQuNzI0MSAyNy4wMzY1QzI4LjIxNzQgMjEuODg3MiAyNC40MzcyIDE0LjYxNzQgMjQuMjgxOSA2Ljk1NzgyQzI0LjI3NjMgNi42ODUzMyAyNC4wNzAxIDYuNDY2MSAyMy44MTMgNi40NjYxWiIgZmlsbD0iYmxhY2siLz4KPHBhdGggZD0iTTM0LjU4OTQgMTEuMjg2NEwzMy43NjI4IDguNzE1ODFDMzMuNTk0NyA4LjE5Mzk1IDMzLjE4NTIgNy43ODc0NCAzMi42NjQgNy42MjY3MkwzMC4wOTgxIDYuODMyNTlDMjkuNzQ0IDYuNzIyOTEgMjkuNzQwMiA2LjIxOTAyIDMwLjA5MzQgNi4xMDQ2M0wzMi42NDYxIDUuMjcyNjdDMzMuMTY0NiA1LjEwMzQ1IDMzLjU2OTQgNC42OTAzMiAzMy43MjkxIDQuMTY2NTZMMzQuNTE3IDEuNTgzNzJDMzQuNjI2IDEuMjI2MzYgMzUuMTI2NiAxLjIyMjU3IDM1LjI0MTIgMS41NzgwNkwzNi4wNjc3IDQuMTQ4NThDMzYuMjM1OCA0LjY3MDQ1IDM2LjY0NTMgNS4wNzY5OCAzNy4xNjY1IDUuMjM4NjRMMzkuNzMyNCA2LjAzMTgzQzQwLjA4NjUgNi4xNDE1IDQwLjA5MDMgNi42NDU0IDM5LjczNzIgNi43NjA3NEwzNy4xODQ0IDcuNTkyNjlDMzYuNjY1OSA3Ljc2MDk2IDM2LjI2MTEgOC4xNzQxIDM2LjEwMTUgOC42OTg4MUwzNS4zMTM1IDExLjI4MDdDMzUuMjA0NSAxMS42MzgxIDM0LjcwMzkgMTEuNjQxOCAzNC41ODk0IDExLjI4NjRaIiBmaWxsPSJibGFjayIvPgo8L3N2Zz4K"
  },
  braavos: {
    dark: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAwIiBoZWlnaHQ9IjUwMCIgdmlld0JveD0iMCAwIDUwMCA1MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0zMjMuNDQgNDEuMzg4NkMzMjQuMTk4IDQyLjY3MjggMzIzLjE5NSA0NC4yNjAzIDMyMS43MDQgNDQuMjYwM0MyOTEuNTEgNDQuMjYwMyAyNjYuOTY1IDY4LjE2NTYgMjY2LjM4OSA5Ny44NzFDMjU2LjA1IDk1Ljk0MDcgMjQ1LjMzNyA5NS43OTU2IDIzNC43NTQgOTcuNTc4N0MyMzQuMDIzIDY4LjAwOSAyMDkuNTQgNDQuMjYwMyAxNzkuNDQ1IDQ0LjI2MDNDMTc3Ljk1MyA0NC4yNjAzIDE3Ni45NDkgNDIuNjcxNiAxNzcuNzA3IDQxLjM4NjVDMTkyLjMyMyAxNi42MzMgMjE5LjQ4MyAwIDI1MC41NzMgMEMyODEuNjY0IDAgMzA4LjgyNCAxNi42MzM5IDMyMy40NCA0MS4zODg2WiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik00MTguNzU2IDIyNi44OTRDNDI2LjM3IDIyOS4yIDQzMy41ODEgMjIyLjUxNyA0MzEuMDM2IDIxNC45NzlDNDA0LjUwNyAxMzYuNDAxIDMxNi41MzUgMTA0LjM1OCAyNTAuMTU5IDEwNC4zNThDMTgzLjY3NCAxMDQuMzU4IDkzLjczOTEgMTM3LjQxOCA2OS4zMDUxIDIxNS4zMzFDNjYuOTU3NCAyMjIuODE4IDc0LjE0NjUgMjI5LjI3NSA4MS42NDc5IDIyNi45NzdMMjQ0LjI1IDE3Ny4xNTFDMjQ3LjU2OSAxNzYuMTM0IDI1MS4xMTYgMTc2LjEyOCAyNTQuNDM5IDE3Ny4xMzVMNDE4Ljc1NiAyMjYuODk0WiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik02OS43MTY1IDIzOS40MjZMMjQ0LjM3IDE4Ni40NTZDMjQ3LjY2OSAxODUuNDU2IDI1MS4xOTEgMTg1LjQ1MyAyNTQuNDkyIDE4Ni40NDhMNDMwLjIzMiAyMzkuNDUyQzQ0NC43NiAyNDMuODMzIDQ1NC43MDEgMjU3LjIxNiA0NTQuNzAxIDI3Mi4zOVY0MzAuNDgxQzQ1NC4wMjggNDY5LjA3IDQxOS4zNjIgNTAwIDM4MC43ODYgNTAwSDMxNi43MTJDMzEwLjM3OSA1MDAgMzA1LjI1IDQ5NC44NzcgMzA1LjI1IDQ4OC41NDNWNDMzLjExNUMzMDUuMjUgNDExLjI4OSAzMTguMTY3IDM5MS41MzUgMzM4LjE1NSAzODIuNzkyQzM2NC45NDkgMzcxLjA3MSAzOTYuNjQ2IDM1NS4yMTggNDAyLjYwOCAzMjMuNDA2QzQwNC41MzIgMzEzLjEzOCAzOTcuODM3IDMwMy4yMzQgMzg3LjU5NSAzMDEuMTk4QzM2MS42OTkgMjk2LjA1MSAzMzIuOTg5IDI5OC4wMzkgMzA4LjcxMSAzMDguODk4QzI4MS4xNSAzMjEuMjI1IDI3My45NCAzNDEuNzMxIDI3MS4yNzEgMzY5LjI3TDI2OC4wMzYgMzk4LjkzOEMyNjcuMDQ3IDQwOC4wMDUgMjU4LjU0NiA0MTQuOTUyIDI0OS40MjkgNDE0Ljk1MkMyMzkuOTk4IDQxNC45NTIgMjMyLjkyNiA0MDcuNzY5IDIzMS45MDMgMzk4LjM4OEwyMjguNzI4IDM2OS4yN0MyMjYuNDQyIDM0NS42ODEgMjIyLjI5OCAzMjIuNzY3IDE5Ny45MTIgMzExLjg2QzE3MC4wOTUgMjk5LjQxOSAxNDIuMTQxIDI5NS4yODcgMTEyLjQwNCAzMDEuMTk4QzEwMi4xNjIgMzAzLjIzNCA5NS40NjcgMzEzLjEzOCA5Ny4zOTEzIDMyMy40MDZDMTAzLjQwNSAzNTUuNDk1IDEzNC44NTQgMzcwLjk4NSAxNjEuODQ0IDM4Mi43OTJDMTgxLjgzMyAzOTEuNTM1IDE5NC43NSA0MTEuMjg5IDE5NC43NSA0MzMuMTE1VjQ4OC41MzNDMTk0Ljc1IDQ5NC44NjcgMTg5LjYyMiA1MDAgMTgzLjI4OSA1MDBIMTE5LjIxNEM4MC42Mzc0IDUwMCA0NS45NzE2IDQ2OS4wNyA0NS4yOTc5IDQzMC40ODFWMjcyLjM0OUM0NS4yOTc5IDI1Ny4xOTQgNTUuMjE0MiAyNDMuODI0IDY5LjcxNjUgMjM5LjQyNloiIGZpbGw9InVybCgjcGFpbnQyX2xpbmVhcl8yMzI0XzYxODY5KSIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDJfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4=",
    light: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAwIiBoZWlnaHQ9IjUwMCIgdmlld0JveD0iMCAwIDUwMCA1MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0zMjMuNDQgNDEuMzg4NkMzMjQuMTk4IDQyLjY3MjggMzIzLjE5NSA0NC4yNjAzIDMyMS43MDQgNDQuMjYwM0MyOTEuNTEgNDQuMjYwMyAyNjYuOTY1IDY4LjE2NTYgMjY2LjM4OSA5Ny44NzFDMjU2LjA1IDk1Ljk0MDcgMjQ1LjMzNyA5NS43OTU2IDIzNC43NTQgOTcuNTc4N0MyMzQuMDIzIDY4LjAwOSAyMDkuNTQgNDQuMjYwMyAxNzkuNDQ1IDQ0LjI2MDNDMTc3Ljk1MyA0NC4yNjAzIDE3Ni45NDkgNDIuNjcxNiAxNzcuNzA3IDQxLjM4NjVDMTkyLjMyMyAxNi42MzMgMjE5LjQ4MyAwIDI1MC41NzMgMEMyODEuNjY0IDAgMzA4LjgyNCAxNi42MzM5IDMyMy40NCA0MS4zODg2WiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik00MTguNzU2IDIyNi44OTRDNDI2LjM3IDIyOS4yIDQzMy41ODEgMjIyLjUxNyA0MzEuMDM2IDIxNC45NzlDNDA0LjUwNyAxMzYuNDAxIDMxNi41MzUgMTA0LjM1OCAyNTAuMTU5IDEwNC4zNThDMTgzLjY3NCAxMDQuMzU4IDkzLjczOTEgMTM3LjQxOCA2OS4zMDUxIDIxNS4zMzFDNjYuOTU3NCAyMjIuODE4IDc0LjE0NjUgMjI5LjI3NSA4MS42NDc5IDIyNi45NzdMMjQ0LjI1IDE3Ny4xNTFDMjQ3LjU2OSAxNzYuMTM0IDI1MS4xMTYgMTc2LjEyOCAyNTQuNDM5IDE3Ny4xMzVMNDE4Ljc1NiAyMjYuODk0WiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik02OS43MTY1IDIzOS40MjZMMjQ0LjM3IDE4Ni40NTZDMjQ3LjY2OSAxODUuNDU2IDI1MS4xOTEgMTg1LjQ1MyAyNTQuNDkyIDE4Ni40NDhMNDMwLjIzMiAyMzkuNDUyQzQ0NC43NiAyNDMuODMzIDQ1NC43MDEgMjU3LjIxNiA0NTQuNzAxIDI3Mi4zOVY0MzAuNDgxQzQ1NC4wMjggNDY5LjA3IDQxOS4zNjIgNTAwIDM4MC43ODYgNTAwSDMxNi43MTJDMzEwLjM3OSA1MDAgMzA1LjI1IDQ5NC44NzcgMzA1LjI1IDQ4OC41NDNWNDMzLjExNUMzMDUuMjUgNDExLjI4OSAzMTguMTY3IDM5MS41MzUgMzM4LjE1NSAzODIuNzkyQzM2NC45NDkgMzcxLjA3MSAzOTYuNjQ2IDM1NS4yMTggNDAyLjYwOCAzMjMuNDA2QzQwNC41MzIgMzEzLjEzOCAzOTcuODM3IDMwMy4yMzQgMzg3LjU5NSAzMDEuMTk4QzM2MS42OTkgMjk2LjA1MSAzMzIuOTg5IDI5OC4wMzkgMzA4LjcxMSAzMDguODk4QzI4MS4xNSAzMjEuMjI1IDI3My45NCAzNDEuNzMxIDI3MS4yNzEgMzY5LjI3TDI2OC4wMzYgMzk4LjkzOEMyNjcuMDQ3IDQwOC4wMDUgMjU4LjU0NiA0MTQuOTUyIDI0OS40MjkgNDE0Ljk1MkMyMzkuOTk4IDQxNC45NTIgMjMyLjkyNiA0MDcuNzY5IDIzMS45MDMgMzk4LjM4OEwyMjguNzI4IDM2OS4yN0MyMjYuNDQyIDM0NS42ODEgMjIyLjI5OCAzMjIuNzY3IDE5Ny45MTIgMzExLjg2QzE3MC4wOTUgMjk5LjQxOSAxNDIuMTQxIDI5NS4yODcgMTEyLjQwNCAzMDEuMTk4QzEwMi4xNjIgMzAzLjIzNCA5NS40NjcgMzEzLjEzOCA5Ny4zOTEzIDMyMy40MDZDMTAzLjQwNSAzNTUuNDk1IDEzNC44NTQgMzcwLjk4NSAxNjEuODQ0IDM4Mi43OTJDMTgxLjgzMyAzOTEuNTM1IDE5NC43NSA0MTEuMjg5IDE5NC43NSA0MzMuMTE1VjQ4OC41MzNDMTk0Ljc1IDQ5NC44NjcgMTg5LjYyMiA1MDAgMTgzLjI4OSA1MDBIMTE5LjIxNEM4MC42Mzc0IDUwMCA0NS45NzE2IDQ2OS4wNyA0NS4yOTc5IDQzMC40ODFWMjcyLjM0OUM0NS4yOTc5IDI1Ny4xOTQgNTUuMjE0MiAyNDMuODI0IDY5LjcxNjUgMjM5LjQyNloiIGZpbGw9InVybCgjcGFpbnQyX2xpbmVhcl8yMzI0XzYxODY5KSIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDJfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4="
  },
  keplr: {
    dark: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAACPfSURBVHgBzV0L0B9VdT9nvy/vB6nVOg4GEx/VER3A1iqo9aMzFgWtoOhgsYaHYNV2lNEqxAdfmKHTakuDTge1FJK2tqOtGqoWFWti8TFSxGDriFSbIK+qgB95h+Tb09397+49r3t3/99/LT0zm//e9917fud3zr27SRB+EbKd1gAcOhFg/kSYmjoBiJ4JhMsB6LHFJetS+wfoAowOQOKnumGVUfSX+23Ba0uRfFaGsh6pNKDqP2PzQN5TbNxqjAeqi2CuWLuvAuU74eT1O+AXIAhDSaX0g+fBFL6ymHShfFhT5RvdknNLzsTIb+cChmzb2OJqJY8aQG9gaAUXaXLbOH0gL4mXmXHC/HYUv1thEWyDk9bPwQAyOQC2H1wHGb29uNtQdLcmFJBv2AsFAPVQJDQPlFBYFACpso7+kFm17g/9sUgr3QFWNI3VtQWO0KaCGXbDBLJwAFSKz2cLjtvglhNFGmr6NomgxEQdT1kYK8N0uzBwH3bosHJo3EKkD1ZG0X6ctAFEW6cAAiwYCAsDwM2HL4e8tHpa45a7NN2UUaxBmFAPmpdt+rGDq0zdrpP2I6yRig06ANHNHuAwjxlzFp67fhOMKeMBoLT6Kby+GHMGmklySVosJAO+ajK9LX6Uxl51eyqZp/tYvVcPbRklynQ7au913aaeBwLRz+6CDU4dhw2yvhVh++EzIcPvBOXXc+SXJz3LMVYeEblOYxKZMx/kF4V70aZPv+q+7ceUmaivHTu0hDSWqzwRWa4rAsTtcOuuM6Gn9APAzYfeVszsM8UAazoVCgDj1DELneqrBgrq/ilyKUFwFE2R8cX8UABD1OmaOx87pkw137gxoP9ssq91xfUZ+Pddl0MP6QbAVwt/Pw+boY+MCQzsquNY6VhCHUoGNeY4fUKjVLR9JdIC8IkxkTrqkerVPsNsHxCk17RUPtFstJw6tE2RfNAPl35Cs7XrSHcGhWPHADBWIJj25XJ8ipbJcUmlZR01Fs+bh0vg+eujBhwHQOnzoaD9pFAi25ZhD2XzPKmHNAAQyC/zHbCelFNGicBPpxP8jZFA0El37xyaHA8oqm8uBGfB89Zv84p8AJTRPuD24m4dpKSLAdhPPGKv8wx4+1l8dO/vtVWL1PvQKMIIxOtFo3VKKy9y4JNmkboflef2N5K5gglO8nYHfgxAhfJHwQQkL9EmXgfHqNcnLkBSwWAPEUFfrG3Xs6k8b+dg66N6RpS7DNMvAp+vwTXrB2Lt7dqugWm4HhyxANhe+P2U5fcBQy0mYh+nntOmL0BcoMREK8vNr8uiCgnKkAEixIO5Zo41IOKKrgPNWFvw1liuVDWHvNi+f/NHs6BErmdJ/Tnugt5Clhl5mVPdUnCkLnMhfVwC8hUz5c69qifm4vYBLrWT285Jq7aUdAOM4ut02ycAkLECilgGb1+1naNcugLJAPPF1iFlid7FxmjH6VO3R99d2zdOwa2k+gNpNVGGcObc5vPRExZvKFwxjahLil1olGf7qd0DgWIXjM+5Hbusg2syxMvVU9RSWv/R/tbvWyUflMZoQ9YwE6vfhxHK1ensy3HC6FlypG56ixZnBDJ1bf/2OwPeU8Qyeh6n5kDrGxZoGSA7CrMiqPEubjFdF5tTnzbGkrkoy+L5HgslGSbyPG4QR85YTp7PABi10sbqTTBIym8T2jnpvsV8EEwQ6EhG8Ha+ZtXHHHjk8M+hr1D7R1TQK1ftumIAtI1Nuo+Vpw+GAHod8rR5qXSqX5mOWzixcpanrIM8RhL9yP6UzM0fLljg1PVzIwY4cujMTovuQBVQD2tnc+zy2ynG6NoGdjJBbO5QWxdoa4aoj9fHwl46jIMBX6Tqt8+j/DwEixcswNsTJNYSwxVkzaIlcF55UwEAc9wwFgA8ZUQnYOt2AcN1b4mybvCh7IN6UH8zLx2ggVcnnY66BqpnxdcILDCaZ3Dn3/RK/nNJAGN7EUy9slkTwBsPeXZhJE3JuoicNn47jJhllwvoVe5RuaJ5Mz7avgCHTZutnBqzy0U0eXblKGIlRuaOHMnXT8ONB2d6Bo+9JeaeTJ2By9pyXslbQ8RRAUU6oI68sdOlpkikkSQIRxoPL4dadmgUSqHzURH5ukaOiqQS1kxPw4nTWfkFL/WDTEr6xR5xBY6v9NGqoFeJEu08BdcrHoDLFr7KQ9np2Glv/EKRSAYoCJQED0GDX2Q5wOYKajAuoW55N5UXAKA8m1mI+jvbUL+6CwGEKFdKQlHDmYRrNWBAgYMzAbZWG5IIZIASGpGTZ+eFdXEPGsf6yZs1wEUnTBeJYzrbmZyOwWgMBRZy7YlL4A1rp2Eh8m8PzsNp39yfrOMqE5i76FK0l1d0+tHjV8Hrj10KQ8h39x2Bk2/5WRisZCQ2HrXKU7GCmKDM6SpCmC9cQA7rus25n3TFEgMNY8U8mErEXIK2UOZvEdK0vvEpKwZT/l2H5uGc2x8S7KDHQzFPaDOC21LlvDCqF1xTmt06sX1JAMk0h8nqDAaICOOgp2BWiB20GZvfZU9bARufuhyGkFL5p9/6INx9KHdezTb7EwfhdQxAKV9LXqaQddOdf3Uu0ndKMIEet58eYIsKBeuIWT7P8sow0UazxGW/unw45R8slP/tB+HHxW87mAoMUbOBmZ4T/Y4h0ykAjSPj+Pxx23aOrQOvUmKgAMdVeaxXBwicJc5duwQ2Pm0Y5T98lODlheXfUyi/sXxyqF9s/2KULgJhgLRPlDKNOSxIJqJ/VGUTMIDxgaQsGsaZq7Q03u7Zx0zDNSesgiGkVP4ZtxSWfyAHHnsYP68WBhNl4NQEVZMzc3M3PZSv71O3nYAecxIXULdHM5Zfry1DVpHS8z5u+RR8/uTOzVJvOffbP4fv7Tka37K2WU5+m9Of+jFxNz3pKeBCqX9S2hd9eXSfGqu1NpTbKrS3xy2fhs+dshqOWTTMjN/63T3w9QcfsSwIvrI9RWOPOn3FBoEdgj0QM57SaTIwELjbz9Y1CDfgLzKKotFN2efaFVPwuResLkDQ/2/QpWTj9/bCP9x9UG4x7UwgrsT+9E88Va0DgbfJmx4jXpAt3WETZThem7HEYYCkwgnc7TLPO2YxwudeOJzy//TO/fDRXQeqIcLcmoHNDE0ZueWx9s7alm8BHYabyAXELDpeFmk3qRsa0wWkqLdRzmdfdMxgyv/AD/bDBwsA8LDDzmYhjFDXEeBN1FUgL2V6nMVfqL+vymI0HWPDvlK6gJx3qG4JBPLdOSj5y+euLKL+KRhCKuXfsb+eQ+phVZlQFgoqT0vsYcnNMjFAWslxIupL8UNbP+/DuoDE+CY+GMm7j18Gr3vSYhhCPvajg/Bn39+/YIvXRI9Obuvr2fOknILGz1guIAkOitdDb2ToZpQ+gqxrFJEPq2OsyVJ++QDvKpT/rmcugyHkE3cdgvfdvq+w/BBUsgFHWzyMW7ws8IHbMoMoGy+oFgzQ2/r1AkdamMlBhDUmdQEx9xJJe2UXP31pBYAh5BsPHIG33bqX+fwI9VcgAIguQKVQC4aktH0mK7V3CwsCo0EXQ2sPl4A0iebNsGYMce9F/rWc8+QlcOVJwxzxfm9uHs7/+sMOKBNb0Ja71cKaJrVyqWMr1rms4el7BoHUL6p3wJqyxDZvoF2ATuvAS4OgzH72L0/Blc8ZxvLv3p/Dq3fMwd4jsfUKGvLjIzU5cpuCH9WS2vz3k+4gMNKZmx1jBow9sGy3YMnB3eM2/jIGwrUrM9j6opWweoBTvlL5Z29/GPYeptbvV2M5oAuTJVtu6tQZ3ikOF17f61MUBul2AWQjUlccJccUjBEqXpDUMYAOsqIgqBf3uJUIn3nJquK0b/K9fqn813zlYbh3/zx7nsaeO/bwVRWKzlvWg3jMYILM2GgouhrvbWDKr8diRHTyqudldDEBA3Dl60+/YiA4rrD8T79k5WDKf+2/KuXrSL2OzsEtr6HClIuReiEvZjYUtf5Yi44YgEwSI/Vic9KBHjpbtElZoF1bh/Kb8Zo6q4sj3utnVlT0P6nsKXz9a7/8MNyzb/RaF1Nb3fYolsRcRb0u6mfZsnM1mhc7RCTxMigR+EWsWhUn66EpmEB4n6RcDFusMvtDL1wOz3rM5Kd8lfJvKix/b171G+iVfV6uwc7+hORxjZ/y2k26hNYFJIIC36ezQxVj3Y5FMCsQljuBYP1dBbbjgutTr3j+MnjpcYtgCLlo+174/oPz7nd8Md9vlOvRvicC1F3BHiWTuotpo8y+lBz17baOuCWHIYaIATzLZ+l3PGcpXHT8EhhC3vn1/fCt+4+MLF8xdgAitidzdcpnBU37VP+BDnNG1lNm9tAea1MwQI/V96iM2j9kFTYzTET/VXpCy9f9mMOeOv8dv7a0AsAQcsUtB+BT/3UYmtM9d0wBCt/3G8OJWQ7PoQ7r9PrukM6DID53t8wJUPSzSLTKv7SZ6r+XlG35OQDJeV307MUVAIaQq79zELb85yFBx9jhkxF4XT5pv36b79I7hngnsRGId2wXeox3AayOg2jZ3qe9NOoXLsiBxeZ52vpFsOmUYU75rr7tYAWACtA84FV/d6/ZiiaftfmXP7hleOuRUmaXtWtdu9ba4xzAt/IIgiMTEqDRwdoA4sUAzyqOeDfPDKf8D912cOTzXcrn/5SL3RLz8wkNDLHArnVTXNkOQHoDopZ+L4NUoOi5q0AK4UmNFXj5zQNOIDoGWLsqg2tftgJWL5mcYq7/j8Pw4VsPyrknAk7sEfwhv0kCo+4PIK3sCbbWvT8KxWYkPQEFDr5Ioh6SzUfmRhYq5ZB5mFep/E+eWZzyrZpc+Z/6wSNw5TcOmICPK5UrQdO8LjfH5R7tq/VzrR57Wjp248EFAEZHBp+2sQuNZA5kmroY67OntBZZXE88plD+WYXyV0+u/HKPf+lX9tf/hg60IBBKM0qH5FYU2bt6Ga+Q7ENXaOqxcUU+RMSNA6TEXYBAIEVHCdbAKK8pY/my7uhmcjXV/RYgXr0U4dozVgym/Ndv2xuOqVvF1kzAx3Zjgjgz+FtVBxie23DcgJOMZzq69oNAdFpRpLhRpqH80BxVQ5zAZxmprf+q314Gxz9u8vP98mj39z69F/YVr3UzV3HsX/5Cct2BOYl0QCHSAO62D2MKj+QDqDFNphX/HIBsD+gkRgMpCxeKl44sgITES5pJdwOXzyyF054y+RHvvXtq5R+i4JoSikT2Sdc4ls/7AkgDw+tL5IsOrIi+HVExgKVx25NUZJXWflDeKP9PJg8mAMDJa6eqa1Iplf+GT+2F+/bkYlGxy7qhiQ9AKCpm+e5a6TYAFgiNLaWAwCcVEV083ee7PI9SxL+pKw291a4J/PjHJej3+2hIpfx/rJWP2u+Dq1hUAPHKYuWectHz95ohmnyAxOt3nQFJSW4DvUFa6zZ5jdhPoMVJnWEFGuxAaCGyp/D1Gz7JLF9t9bjiW4tnrBVYQIqXj2OUJ9Ns/FT9UC+OgvRBkLZstRuwL3sUMJyI37iDR1v5nyiUP1e/0/don8Ac77b1HIYw7Vm5Trf16zw3Jqg7cllAVJaCrJ5fOJL4OUCkN49iWlZwJsb/QUSJ9kS88X8k77nxAPzgJ/PGvyOApG6eX2Y0ZcyHx2IFnQaQykHzKhj6uwMAP45ICgpg9NoGJg9/qP3D+RKHVD0Ir0b5xB8FFii/3r3jf45WZwiefxfWD5D09a2ylQFYJkD/lbhj+bFX596HIcbae4Oh/MeiSwCoC+ehOl4dXaq83raN8qm6qkWkum19VS9F2nqhHa/flj8KAFhVvCfY8rpVcOzqrJpDVs8nq+fE58fvm3q6LMtZ+ypd/8PMObtYm0zUleNnTV7RJiN5NX1lug/TNugCKX6FD0I0XLR/Nwl1IoaqTPh6aJnC97OPAgIKObY4Ov7wq1bCBX8/2vsLyua/nrU7ZdzCOXUbt8AeV7AF4Ni7gSrfNXXGEInlzaqOaut1Lb2x3PaqmYFknbYNYw3OAMgYAdu6MGIEePTk6Y+fgut+d1X15jBlKfwKLIDqitfNTFsYWXRj2YRifQwLGUu2rICCLSRDGJZoruiDardQKT0ovqH7AJYRMCTdw0jBRKG+6P/R3QI2UoLg2nNXVZ+Me/Ru6D8HV+GZqhdLY94oXbqczOmrAUqj6Ky9wKX+Biyesl2AejGAVToJpQsrdhTfx+pFjPD/BARXnb0y6ddDmVQAt9A4CLiF2jqZUlxbt7LuiDUbhTuxQtclqZ7EFVN6UHRQPHDFp6zeAwUsXO64fx6+f/88DCG//qRpmH3FingQSMFydVnMelv3kPt1Mt13zkDCrTfX1uwFh77VZ6kL60geGmW2SrRKh1ZxdX2+EMzqgS2Asfq2HiubgAH2FMHbH358P9z78xyGkFecsBhmf2eFQ//oAEJZsirLcnQZRLKDVbi2+Ma6W4t2ACKAwi8OQkIDnGgMwJXeBnQ0UiJnAREcEsn8PFg9VzaqsknjgPsemofzrt07GAheXoDg8lesgNjauL7U/MYBwxnFA4Z2N0gWSJnDKC1QuILreIFfgrmiMYB4QMkQyJQIudoViLYUKJ9NPjBFzQiTSN3vfQ/lcP6AIDjjxMXwxt9c5isuB0PPoUzuCDKKW73IF+5EKY8snTcMk+UIOr7IHHCaqwEEKL/fXto1kKN4kooP9yRcBOigESQoJpEqfqjHvv/BHC74WHG2PxAI3jizFN744hoE4ARtpC8UytTKDb4bbKDYKLTD/4vtn1Kmr/AI9bcuIMEAMuADq/hcKr5hA7sbgPb8AEw+THwQxK3y/oIJLhwQBBcWILhwZpmlaQDDbD6FB+WiVm4uleqCh7T/t0wQ+mt2DfJswmOFpAuoJj8PMuBzjoa14jkbiLgh4iJaMMEE4ix6yQSX/M0+2Nvvf8PrlAsKEJRXbHdQLS4gWKrnQZhVbuMyLBMEV4COq8hUfCAOkhQr6CNhuwtw6B+aq6Z/swVkwDCgYFRv3EDbnkLw1/Q7gQj3U4995z1H4eKP7B0MBOefurS6hPVQ3OJH1tVY97juAMUOQlpveMfgsgCrZ+g+V+8mmnMA7xI+us3jAJFlwbrDwZBemPZUkEAywaQAaINNuRO5896j8KZr9gwGgvMKAJw3sxQs7aNRBDr5zfsDz2K5xWdkAWb8PmmLtkfBaOo4l97zy32+WlhB7aBiAgpRPXGrp+BCCMwZwKT/VFz7QiaXTNMo6M575+GqGw7AULLht5bC2ScvERQe/LwCgYkDwFV8AIV1IXrHIGMIeXCURRSOFGeF6DeB3jvm8L6awLwbbxO1IpDi79Rrv88/rVqwKOtqxuFf4Hz+lsNV3vvPWQFDyFtOXwb7DxLcdNsjclwIz1jFBM380CsPec1bRPkmEsX3EqFMfQdQj1Gl1bcCqdiqKRt9ENIRhYlPt7gy63RYeFIgYACpG9h8GMAFKCWwqxnjXwoQlD75vQOB4I9evbwa98u3HbEgYArwlOoqGqSSuUq08k1Z8wdZVXaotvx7ARRVgPtRaGPFlYRTPPcLWoKAFNbOWsGEboDCLyI4ChldJRM84ZcyuPC0Yf7W8DvPXl6A6iB8+duP+B+PAgchGoYSytfMIfItSMI9CmPUdUDUtyVj/YcRozIydc1XsvyvSCtAhIVijDCJ/gmES0GS8x39/f2Qvu4Lo7/pe8FAIHjTy5fCrvvmYdf981bxag58vaq/VAJ6DR2GwKBgzRyhTp0v1hE7rb8sN+8C+Nl+CN5U9C+2exBe9DSBIIA5OWy2Z+L7AD7egoVE0Kd3MPyVdpN3/Y0H4fovHoQhZMVShD+5eAU85QlTIZKv14ef3aMO3kgHfF4gh87BUNgpiLMBE+SpMckPDjPgR778DEAp0L4QIrGft9E/2F0EA5moN4FUFuPswVGN1cydg2DLF4YDwR9ftAKe3IIAROQtlQRW+Y1CnQMgpLB70DsFAYhcbTnNhe6VgTr4QXbxMv5CSCyuOCCSdTWrCOXzwyeYQJwxtNXJvADaLQUItt44EAiWIVx5cQCBVnQzPn9LGBSrLdwHiGYC8W0Ce2bzIanaRsqTQHVUKA6EnPyWEbhbiB3wcErWboIrblIhClSfx6xf543qlwD44i2PwBBSguDSDcvgV4pAs6F1CQKb1m8BAzBip4XOsS8HRf1hiKdwvRajgyClcO9wJ5z1M0bglt+Ape2HjJsQ4NBtJwSBfDAC8ckZgXNULK8P/N0++NJAICiVf8XvL69+o0xAMYrW1oxuHXtSKNmAuxOPETgzRF4Hg/kuwGUEQanE3AUYyvfoH5irmESQHMYhAP1No11gaOf7wb/dBzd9azgQbHrzcni8AAE6vtuCI+4KGDu0v5HXx8S/J9Ag0i6gUaa6+CLqKF+k2Y7A+9QLybbnjDGY8sm3LB6feGXBHQB85J/2w3/fM8z3hY8rlH/5m2NM4LgCBxwyKPR3ArZfZweQg/92MHd2AeaNoFIoGAVDS/tim9fSv1YEmLyJ4wBHuT4o1GtrVbb/AMG7rt4zHAgeg/D+N6fdgWUCT9mJdC4BYdmAMYL7QQhJWnQ/BqnuLUBQvDACNx7gfr/px7y9m1AaBRrQUowVKFJGcKAAwaWbhwXBe9/CQeBTsssE0AUGSCievx2044W3gWLhyFI8W9SUu/B//X5MX0NI2SfUDwksluFj1L8tG2hg1HXKFz1Xfmwv/OShHIaQEgTveesyWLlMWXvzbsADI3QEgDCqk0HcDRhXQDYYzbQC2rNzT8kqyPKULH99cBhWmEQobukcCLbMAUEe8n76QA7v+Ys98NMHhwHBYwsQXFaAoDw0atY46grAugV7VuDFDd5BkWQY831g6xdzbalkYwLQ0T65jBC7tCsRY00g2DGmPgrWtN+CEzgQAH5WgOC9m4cDwXHHZnDpHywdgUAoawSKkVVbKpdWa1nD21FkAhTy7IAbo38OIBTmpzllBn9PCTYg8W2gYJIJpH351GHt0IJPPhN/Bg2KBgTvK5jgZwOC4N0tCOxcpc9mbAGS8vl2L27pum/rCvxPwtj+3rNYewIYgjmP8mOAGWQXQBHaB3DB5oOEDGB4+oECBO+/au9gIFhbgOCcVy1ulZUBRIErlaqVz+YLUMcUGJgEAngyVSfUjVI+WMv3joUTlwSBBdEg7wIgNhc+jlIsOCAweSSA8ECh/A9cs6/aJQwhp/zGFJx/7hJB+RiNA/wj5fBMXf4fAWPvBLQFxZSoF9ZjBzfqhyYPJO3za0JxT/rEAkllgqNgrvSYm7jr7nnYVDDBUCA4+XlTsOHcxc6cOX2jejaUVk/xj0hjShduwQv8YoEaZwYc81fcK2VMJFx5RBBnJRJj6zwNertLGN2XILjiz/fCUFKC4DWvXhQUCRbEbkxAUvkcIPotoa3DyooH3u1ZPTp5niLdxQa58CiYILKrmFTacSnQOTgWLhSsqB+00lUf9f2PCxB8dMtwXxqfOjMNp58+zeicWzFjBYi4AbIuhFt9iAVQX7vLfyZubqTRkbDP/UIe+xYJeT7VeaoMdV/8vv58zC1boAhKbC8KH03Vcxt9ikWj7/NI1eV56PTJ84o/bv7GI1X64vOH+V/HGwB88fPzzazDuoJe28AEIVXfI69X35G/xsVT7y6Cw/nbMWL1bcPmXm8RAaJM4ZWjYgnk/S9YSLKO+vXdQqQNYxFxD4xB2P3XChB8/JPDfFBSyssKELz0jGlh8dbaI+cCAGaL6AWGgiHy/OGseKW406VwABsQ6bRSZnpRWT1w6i5QAm0z5bDf0RheGdk0gOMinGdjc/7STYdh22cPw1Dy0tOnAgj0BZHL1LUHQ55rAMId0zngzoyU1slShvnyl6Vj4rkCYBNvZM/+HO776Xy0fUr27a8nQe0foAiwnjuNbuqfoHRFp8hA1bqFhIso/rjhnw9V9y84ZbEaPS6YSD/1aRncRPVXxsjmRz71hzz2J/rz4HmLpvKduG5m15psesmuIr3Gq9Tmad+CctHMwOoX0VlkZGlWnqGth6pepTjeDmsKFG0w5LM8Xcek2X1m8oMSwj3KOl66XYtYHQBQ9SUArLLl3yaSoOe/tsZINl2TYbZ7x/q5Auw7Y9G/jgOi9B6heoz1BX7fyPLRqR/GIvC3dqB2IHo8SrsCfWYAcm7YsQayL5AuVdM58XroUH1sO4c9KV+eBag2O8o5jf5PJMpvcM8DYLSlEucAwO75r8oX5wcQ+gvbNCetFRgBA0/LQyevPjlgIqU4smNqcLC2QnnqXgNDKpqxB0HEv7vKkuWij0h9J1+u7fzWFgB5fmRLkTmnAxyMKMSz+CgLEFtQ3Z/pvwnmNIiYYsAfpwGDzzAeOLwzgcAC4OQZxUMcCEbJntJArrWsLykf1TomlQ8g3IB3wdKpbdAAYOQG8q3tbBxlcaoW9M7y3bYAUQWio0itqFGaAiM5fcrfUE8zhQUPBwaFcfXYoMbQz9z2EQGCkzdqg37dpr+YwgEiSsZ2HVNXcQC0ZXYzzpV12/9mK4fpzRA5yxcW2Ty5dgcgT/hSCtMg8KzaWnejFP4iSS2+AA654IjRLweB159v5WT6cEHi5MVo35ajVTQHQ9sO3efyrnmETc10WgDs3vGE3QUMtoIW9RDIHyhxL3wmB4UBiV3wuHWrcYAilg2tQtH0TfLZmOW3z8jrseqBtkkCBdSCewpI5ZEcW5eDUqqpp0ACrL1mkuJ4ecvsR3B380ziP9qbh/lZ5LEAG7BdDAUE9PIBXEsWymFWaRgF4sxh5iP6CGNxANq5BK0KyoUwL48BWrCQbMfn4wJB5RlWaMvQdRVCycz6gXwlx/sAODIVrL8UAYAiFthdLObVYmYeGNRDg14MDwzk1ImAJSjOWSmlKM/ivb5QK1gwB5m6fLymHJ3n5n256+PVB3BZIZRhWDOSoNd169rmAgDDMDnRJm79AMqgGnnqi+/eXjSYMf9tCWvRDtKkEUUdrMsWknYPfrC2glRdVi+L5MfSmXfAg/WHGTwPMHIwNHrDljoQAq8viNeXOwFO8+weffp39LZ7419l61URuP/X6jQePb/4Ea6glZYOQ3r0GywWDa3ruvIXY1Zt6vboUyccJmiExwg8NhCflEFiTvwZmoS2fgLr35Xlo1fGWFNavQoKHRfguITdeARPBUdcANxRuALK6Hyehx4Q2H0zIVB5DTVDT1Dwh5V9gPXtjrjBHuhFjIHYWg9XgrwnoTTpEqxitSEZZXvP0tZBoVT3eVQ7nl/M9JLLtkjqbyT6vy3/aMdx24jwEr3OGEO/p8iExQswgO3Tt2w2XlUWwKTHG6XJmQdZVmjmq8qE8kDuNjQQBUCbbK1wXYc/k2KF6DMDuFs/DyB15U0b/xq3QUSS/932D29+4uZiDTeBY/3Jew8kGkg8EWMHSPQtWIHMYsu+nc7IB2mUaUi2bccin/lilg9OHjplmkUA4pauJew0aNNl107NQkI6/7/1H35t7SyWINCKid0n8jymAFL5dabew7t9eQN6IHRcDjptkfz+uFW7lqyUjo5yXZ9f5aFsCw6LJIwHI78EdMll16WVX0onAEq5swBBcUpwVtHtbnM6qBYee1ovn2y8rnr6SD+h3BschOLCHC3di04pbX1cXJB6Fh5bm4iSfdqHliF0//XvHOV41sbrpjZDD+kFgFLuvHn9tmxq/tQRCEA+gHgKiitIC7N+jNVXykqCBqQ7kP6QlKJ5G9uXl5e8F2mPUfw2xuJTcwMHyBwQ5SveHE/auCXu87v67yXPeOFds8XG+fK2E2STQp7HPoRo6tS/sX08r8t/Rx9moO3D1BmN2/ccoK0H3pkAqnbe3r9Jh7Lmr3G19I7+fj9jtXg5APoflMTv54qA9+rLtnRTvpbeDMDljq89qQDA/PoCclurjJTlQsQ3R9jBixMMPZtxpBWhx0LuL7kW6QpnmQgbua5Al3fWw7Y8ZZ2BBXDLI4QnLUT5vJ8FyzNmdq3DPJstrOaVxZzX8M/DpNWjYgeInvjpOpmyWvAYAsPiZq61g3P6J63bsoG1/Axi+d5p3uhhsohFC+aA0IanQbSDJrf8imvrPGSbZyP7+74yMQAaKb8tXA5TZxYdbiiumapzAQAIx8WuYiDqBlpqb8vRAoClFwYApSg256BYHwCZUOSkAJC/DAAFzcPO4u6Go5BtKRQ/BwPIYADQ8qyZXTMZZCcW+4UXF6OsyZDWFQ+8DqKKWTgAMhcI4wHAKLatE+wuCoC6LK5cDwCoACbKdxd9FgrGncUrnNtHv9M7h1I6l/8FAVO2ym5DPSIAAAAASUVORK5CYII=",
    light: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAACPfSURBVHgBzV0L0B9VdT9nvy/vB6nVOg4GEx/VER3A1iqo9aMzFgWtoOhgsYaHYNV2lNEqxAdfmKHTakuDTge1FJK2tqOtGqoWFWti8TFSxGDriFSbIK+qgB95h+Tb09397+49r3t3/99/LT0zm//e9917fud3zr27SRB+EbKd1gAcOhFg/kSYmjoBiJ4JhMsB6LHFJetS+wfoAowOQOKnumGVUfSX+23Ba0uRfFaGsh6pNKDqP2PzQN5TbNxqjAeqi2CuWLuvAuU74eT1O+AXIAhDSaX0g+fBFL6ymHShfFhT5RvdknNLzsTIb+cChmzb2OJqJY8aQG9gaAUXaXLbOH0gL4mXmXHC/HYUv1thEWyDk9bPwQAyOQC2H1wHGb29uNtQdLcmFJBv2AsFAPVQJDQPlFBYFACpso7+kFm17g/9sUgr3QFWNI3VtQWO0KaCGXbDBLJwAFSKz2cLjtvglhNFGmr6NomgxEQdT1kYK8N0uzBwH3bosHJo3EKkD1ZG0X6ctAFEW6cAAiwYCAsDwM2HL4e8tHpa45a7NN2UUaxBmFAPmpdt+rGDq0zdrpP2I6yRig06ANHNHuAwjxlzFp67fhOMKeMBoLT6Kby+GHMGmklySVosJAO+ajK9LX6Uxl51eyqZp/tYvVcPbRklynQ7au913aaeBwLRz+6CDU4dhw2yvhVh++EzIcPvBOXXc+SXJz3LMVYeEblOYxKZMx/kF4V70aZPv+q+7ceUmaivHTu0hDSWqzwRWa4rAsTtcOuuM6Gn9APAzYfeVszsM8UAazoVCgDj1DELneqrBgrq/ilyKUFwFE2R8cX8UABD1OmaOx87pkw137gxoP9ssq91xfUZ+Pddl0MP6QbAVwt/Pw+boY+MCQzsquNY6VhCHUoGNeY4fUKjVLR9JdIC8IkxkTrqkerVPsNsHxCk17RUPtFstJw6tE2RfNAPl35Cs7XrSHcGhWPHADBWIJj25XJ8ipbJcUmlZR01Fs+bh0vg+eujBhwHQOnzoaD9pFAi25ZhD2XzPKmHNAAQyC/zHbCelFNGicBPpxP8jZFA0El37xyaHA8oqm8uBGfB89Zv84p8AJTRPuD24m4dpKSLAdhPPGKv8wx4+1l8dO/vtVWL1PvQKMIIxOtFo3VKKy9y4JNmkboflef2N5K5gglO8nYHfgxAhfJHwQQkL9EmXgfHqNcnLkBSwWAPEUFfrG3Xs6k8b+dg66N6RpS7DNMvAp+vwTXrB2Lt7dqugWm4HhyxANhe+P2U5fcBQy0mYh+nntOmL0BcoMREK8vNr8uiCgnKkAEixIO5Zo41IOKKrgPNWFvw1liuVDWHvNi+f/NHs6BErmdJ/Tnugt5Clhl5mVPdUnCkLnMhfVwC8hUz5c69qifm4vYBLrWT285Jq7aUdAOM4ut02ycAkLECilgGb1+1naNcugLJAPPF1iFlid7FxmjH6VO3R99d2zdOwa2k+gNpNVGGcObc5vPRExZvKFwxjahLil1olGf7qd0DgWIXjM+5Hbusg2syxMvVU9RSWv/R/tbvWyUflMZoQ9YwE6vfhxHK1ensy3HC6FlypG56ixZnBDJ1bf/2OwPeU8Qyeh6n5kDrGxZoGSA7CrMiqPEubjFdF5tTnzbGkrkoy+L5HgslGSbyPG4QR85YTp7PABi10sbqTTBIym8T2jnpvsV8EEwQ6EhG8Ha+ZtXHHHjk8M+hr1D7R1TQK1ftumIAtI1Nuo+Vpw+GAHod8rR5qXSqX5mOWzixcpanrIM8RhL9yP6UzM0fLljg1PVzIwY4cujMTovuQBVQD2tnc+zy2ynG6NoGdjJBbO5QWxdoa4aoj9fHwl46jIMBX6Tqt8+j/DwEixcswNsTJNYSwxVkzaIlcF55UwEAc9wwFgA8ZUQnYOt2AcN1b4mybvCh7IN6UH8zLx2ggVcnnY66BqpnxdcILDCaZ3Dn3/RK/nNJAGN7EUy9slkTwBsPeXZhJE3JuoicNn47jJhllwvoVe5RuaJ5Mz7avgCHTZutnBqzy0U0eXblKGIlRuaOHMnXT8ONB2d6Bo+9JeaeTJ2By9pyXslbQ8RRAUU6oI68sdOlpkikkSQIRxoPL4dadmgUSqHzURH5ukaOiqQS1kxPw4nTWfkFL/WDTEr6xR5xBY6v9NGqoFeJEu08BdcrHoDLFr7KQ9np2Glv/EKRSAYoCJQED0GDX2Q5wOYKajAuoW55N5UXAKA8m1mI+jvbUL+6CwGEKFdKQlHDmYRrNWBAgYMzAbZWG5IIZIASGpGTZ+eFdXEPGsf6yZs1wEUnTBeJYzrbmZyOwWgMBRZy7YlL4A1rp2Eh8m8PzsNp39yfrOMqE5i76FK0l1d0+tHjV8Hrj10KQ8h39x2Bk2/5WRisZCQ2HrXKU7GCmKDM6SpCmC9cQA7rus25n3TFEgMNY8U8mErEXIK2UOZvEdK0vvEpKwZT/l2H5uGc2x8S7KDHQzFPaDOC21LlvDCqF1xTmt06sX1JAMk0h8nqDAaICOOgp2BWiB20GZvfZU9bARufuhyGkFL5p9/6INx9KHdezTb7EwfhdQxAKV9LXqaQddOdf3Uu0ndKMIEet58eYIsKBeuIWT7P8sow0UazxGW/unw45R8slP/tB+HHxW87mAoMUbOBmZ4T/Y4h0ykAjSPj+Pxx23aOrQOvUmKgAMdVeaxXBwicJc5duwQ2Pm0Y5T98lODlheXfUyi/sXxyqF9s/2KULgJhgLRPlDKNOSxIJqJ/VGUTMIDxgaQsGsaZq7Q03u7Zx0zDNSesgiGkVP4ZtxSWfyAHHnsYP68WBhNl4NQEVZMzc3M3PZSv71O3nYAecxIXULdHM5Zfry1DVpHS8z5u+RR8/uTOzVJvOffbP4fv7Tka37K2WU5+m9Of+jFxNz3pKeBCqX9S2hd9eXSfGqu1NpTbKrS3xy2fhs+dshqOWTTMjN/63T3w9QcfsSwIvrI9RWOPOn3FBoEdgj0QM57SaTIwELjbz9Y1CDfgLzKKotFN2efaFVPwuResLkDQ/2/QpWTj9/bCP9x9UG4x7UwgrsT+9E88Va0DgbfJmx4jXpAt3WETZThem7HEYYCkwgnc7TLPO2YxwudeOJzy//TO/fDRXQeqIcLcmoHNDE0ZueWx9s7alm8BHYabyAXELDpeFmk3qRsa0wWkqLdRzmdfdMxgyv/AD/bDBwsA8LDDzmYhjFDXEeBN1FUgL2V6nMVfqL+vymI0HWPDvlK6gJx3qG4JBPLdOSj5y+euLKL+KRhCKuXfsb+eQ+phVZlQFgoqT0vsYcnNMjFAWslxIupL8UNbP+/DuoDE+CY+GMm7j18Gr3vSYhhCPvajg/Bn39+/YIvXRI9Obuvr2fOknILGz1guIAkOitdDb2ToZpQ+gqxrFJEPq2OsyVJ++QDvKpT/rmcugyHkE3cdgvfdvq+w/BBUsgFHWzyMW7ws8IHbMoMoGy+oFgzQ2/r1AkdamMlBhDUmdQEx9xJJe2UXP31pBYAh5BsPHIG33bqX+fwI9VcgAIguQKVQC4aktH0mK7V3CwsCo0EXQ2sPl4A0iebNsGYMce9F/rWc8+QlcOVJwxzxfm9uHs7/+sMOKBNb0Ja71cKaJrVyqWMr1rms4el7BoHUL6p3wJqyxDZvoF2ATuvAS4OgzH72L0/Blc8ZxvLv3p/Dq3fMwd4jsfUKGvLjIzU5cpuCH9WS2vz3k+4gMNKZmx1jBow9sGy3YMnB3eM2/jIGwrUrM9j6opWweoBTvlL5Z29/GPYeptbvV2M5oAuTJVtu6tQZ3ikOF17f61MUBul2AWQjUlccJccUjBEqXpDUMYAOsqIgqBf3uJUIn3nJquK0b/K9fqn813zlYbh3/zx7nsaeO/bwVRWKzlvWg3jMYILM2GgouhrvbWDKr8diRHTyqudldDEBA3Dl60+/YiA4rrD8T79k5WDKf+2/KuXrSL2OzsEtr6HClIuReiEvZjYUtf5Yi44YgEwSI/Vic9KBHjpbtElZoF1bh/Kb8Zo6q4sj3utnVlT0P6nsKXz9a7/8MNyzb/RaF1Nb3fYolsRcRb0u6mfZsnM1mhc7RCTxMigR+EWsWhUn66EpmEB4n6RcDFusMvtDL1wOz3rM5Kd8lfJvKix/b171G+iVfV6uwc7+hORxjZ/y2k26hNYFJIIC36ezQxVj3Y5FMCsQljuBYP1dBbbjgutTr3j+MnjpcYtgCLlo+174/oPz7nd8Md9vlOvRvicC1F3BHiWTuotpo8y+lBz17baOuCWHIYaIATzLZ+l3PGcpXHT8EhhC3vn1/fCt+4+MLF8xdgAitidzdcpnBU37VP+BDnNG1lNm9tAea1MwQI/V96iM2j9kFTYzTET/VXpCy9f9mMOeOv8dv7a0AsAQcsUtB+BT/3UYmtM9d0wBCt/3G8OJWQ7PoQ7r9PrukM6DID53t8wJUPSzSLTKv7SZ6r+XlG35OQDJeV307MUVAIaQq79zELb85yFBx9jhkxF4XT5pv36b79I7hngnsRGId2wXeox3AayOg2jZ3qe9NOoXLsiBxeZ52vpFsOmUYU75rr7tYAWACtA84FV/d6/ZiiaftfmXP7hleOuRUmaXtWtdu9ba4xzAt/IIgiMTEqDRwdoA4sUAzyqOeDfPDKf8D912cOTzXcrn/5SL3RLz8wkNDLHArnVTXNkOQHoDopZ+L4NUoOi5q0AK4UmNFXj5zQNOIDoGWLsqg2tftgJWL5mcYq7/j8Pw4VsPyrknAk7sEfwhv0kCo+4PIK3sCbbWvT8KxWYkPQEFDr5Ioh6SzUfmRhYq5ZB5mFep/E+eWZzyrZpc+Z/6wSNw5TcOmICPK5UrQdO8LjfH5R7tq/VzrR57Wjp248EFAEZHBp+2sQuNZA5kmroY67OntBZZXE88plD+WYXyV0+u/HKPf+lX9tf/hg60IBBKM0qH5FYU2bt6Ga+Q7ENXaOqxcUU+RMSNA6TEXYBAIEVHCdbAKK8pY/my7uhmcjXV/RYgXr0U4dozVgym/Ndv2xuOqVvF1kzAx3Zjgjgz+FtVBxie23DcgJOMZzq69oNAdFpRpLhRpqH80BxVQ5zAZxmprf+q314Gxz9u8vP98mj39z69F/YVr3UzV3HsX/5Cct2BOYl0QCHSAO62D2MKj+QDqDFNphX/HIBsD+gkRgMpCxeKl44sgITES5pJdwOXzyyF054y+RHvvXtq5R+i4JoSikT2Sdc4ls/7AkgDw+tL5IsOrIi+HVExgKVx25NUZJXWflDeKP9PJg8mAMDJa6eqa1Iplf+GT+2F+/bkYlGxy7qhiQ9AKCpm+e5a6TYAFgiNLaWAwCcVEV083ee7PI9SxL+pKw291a4J/PjHJej3+2hIpfx/rJWP2u+Dq1hUAPHKYuWectHz95ohmnyAxOt3nQFJSW4DvUFa6zZ5jdhPoMVJnWEFGuxAaCGyp/D1Gz7JLF9t9bjiW4tnrBVYQIqXj2OUJ9Ns/FT9UC+OgvRBkLZstRuwL3sUMJyI37iDR1v5nyiUP1e/0/don8Ac77b1HIYw7Vm5Trf16zw3Jqg7cllAVJaCrJ5fOJL4OUCkN49iWlZwJsb/QUSJ9kS88X8k77nxAPzgJ/PGvyOApG6eX2Y0ZcyHx2IFnQaQykHzKhj6uwMAP45ICgpg9NoGJg9/qP3D+RKHVD0Ir0b5xB8FFii/3r3jf45WZwiefxfWD5D09a2ylQFYJkD/lbhj+bFX596HIcbae4Oh/MeiSwCoC+ehOl4dXaq83raN8qm6qkWkum19VS9F2nqhHa/flj8KAFhVvCfY8rpVcOzqrJpDVs8nq+fE58fvm3q6LMtZ+ypd/8PMObtYm0zUleNnTV7RJiN5NX1lug/TNugCKX6FD0I0XLR/Nwl1IoaqTPh6aJnC97OPAgIKObY4Ov7wq1bCBX8/2vsLyua/nrU7ZdzCOXUbt8AeV7AF4Ni7gSrfNXXGEInlzaqOaut1Lb2x3PaqmYFknbYNYw3OAMgYAdu6MGIEePTk6Y+fgut+d1X15jBlKfwKLIDqitfNTFsYWXRj2YRifQwLGUu2rICCLSRDGJZoruiDardQKT0ovqH7AJYRMCTdw0jBRKG+6P/R3QI2UoLg2nNXVZ+Me/Ru6D8HV+GZqhdLY94oXbqczOmrAUqj6Ky9wKX+Biyesl2AejGAVToJpQsrdhTfx+pFjPD/BARXnb0y6ddDmVQAt9A4CLiF2jqZUlxbt7LuiDUbhTuxQtclqZ7EFVN6UHRQPHDFp6zeAwUsXO64fx6+f/88DCG//qRpmH3FingQSMFydVnMelv3kPt1Mt13zkDCrTfX1uwFh77VZ6kL60geGmW2SrRKh1ZxdX2+EMzqgS2Asfq2HiubgAH2FMHbH358P9z78xyGkFecsBhmf2eFQ//oAEJZsirLcnQZRLKDVbi2+Ma6W4t2ACKAwi8OQkIDnGgMwJXeBnQ0UiJnAREcEsn8PFg9VzaqsknjgPsemofzrt07GAheXoDg8lesgNjauL7U/MYBwxnFA4Z2N0gWSJnDKC1QuILreIFfgrmiMYB4QMkQyJQIudoViLYUKJ9NPjBFzQiTSN3vfQ/lcP6AIDjjxMXwxt9c5isuB0PPoUzuCDKKW73IF+5EKY8snTcMk+UIOr7IHHCaqwEEKL/fXto1kKN4kooP9yRcBOigESQoJpEqfqjHvv/BHC74WHG2PxAI3jizFN744hoE4ARtpC8UytTKDb4bbKDYKLTD/4vtn1Kmr/AI9bcuIMEAMuADq/hcKr5hA7sbgPb8AEw+THwQxK3y/oIJLhwQBBcWILhwZpmlaQDDbD6FB+WiVm4uleqCh7T/t0wQ+mt2DfJswmOFpAuoJj8PMuBzjoa14jkbiLgh4iJaMMEE4ix6yQSX/M0+2Nvvf8PrlAsKEJRXbHdQLS4gWKrnQZhVbuMyLBMEV4COq8hUfCAOkhQr6CNhuwtw6B+aq6Z/swVkwDCgYFRv3EDbnkLw1/Q7gQj3U4995z1H4eKP7B0MBOefurS6hPVQ3OJH1tVY97juAMUOQlpveMfgsgCrZ+g+V+8mmnMA7xI+us3jAJFlwbrDwZBemPZUkEAywaQAaINNuRO5896j8KZr9gwGgvMKAJw3sxQs7aNRBDr5zfsDz2K5xWdkAWb8PmmLtkfBaOo4l97zy32+WlhB7aBiAgpRPXGrp+BCCMwZwKT/VFz7QiaXTNMo6M575+GqGw7AULLht5bC2ScvERQe/LwCgYkDwFV8AIV1IXrHIGMIeXCURRSOFGeF6DeB3jvm8L6awLwbbxO1IpDi79Rrv88/rVqwKOtqxuFf4Hz+lsNV3vvPWQFDyFtOXwb7DxLcdNsjclwIz1jFBM380CsPec1bRPkmEsX3EqFMfQdQj1Gl1bcCqdiqKRt9ENIRhYlPt7gy63RYeFIgYACpG9h8GMAFKCWwqxnjXwoQlD75vQOB4I9evbwa98u3HbEgYArwlOoqGqSSuUq08k1Z8wdZVXaotvx7ARRVgPtRaGPFlYRTPPcLWoKAFNbOWsGEboDCLyI4ChldJRM84ZcyuPC0Yf7W8DvPXl6A6iB8+duP+B+PAgchGoYSytfMIfItSMI9CmPUdUDUtyVj/YcRozIydc1XsvyvSCtAhIVijDCJ/gmES0GS8x39/f2Qvu4Lo7/pe8FAIHjTy5fCrvvmYdf981bxag58vaq/VAJ6DR2GwKBgzRyhTp0v1hE7rb8sN+8C+Nl+CN5U9C+2exBe9DSBIIA5OWy2Z+L7AD7egoVE0Kd3MPyVdpN3/Y0H4fovHoQhZMVShD+5eAU85QlTIZKv14ef3aMO3kgHfF4gh87BUNgpiLMBE+SpMckPDjPgR778DEAp0L4QIrGft9E/2F0EA5moN4FUFuPswVGN1cydg2DLF4YDwR9ftAKe3IIAROQtlQRW+Y1CnQMgpLB70DsFAYhcbTnNhe6VgTr4QXbxMv5CSCyuOCCSdTWrCOXzwyeYQJwxtNXJvADaLQUItt44EAiWIVx5cQCBVnQzPn9LGBSrLdwHiGYC8W0Ce2bzIanaRsqTQHVUKA6EnPyWEbhbiB3wcErWboIrblIhClSfx6xf543qlwD44i2PwBBSguDSDcvgV4pAs6F1CQKb1m8BAzBip4XOsS8HRf1hiKdwvRajgyClcO9wJ5z1M0bglt+Ape2HjJsQ4NBtJwSBfDAC8ckZgXNULK8P/N0++NJAICiVf8XvL69+o0xAMYrW1oxuHXtSKNmAuxOPETgzRF4Hg/kuwGUEQanE3AUYyvfoH5irmESQHMYhAP1No11gaOf7wb/dBzd9azgQbHrzcni8AAE6vtuCI+4KGDu0v5HXx8S/J9Ag0i6gUaa6+CLqKF+k2Y7A+9QLybbnjDGY8sm3LB6feGXBHQB85J/2w3/fM8z3hY8rlH/5m2NM4LgCBxwyKPR3ArZfZweQg/92MHd2AeaNoFIoGAVDS/tim9fSv1YEmLyJ4wBHuT4o1GtrVbb/AMG7rt4zHAgeg/D+N6fdgWUCT9mJdC4BYdmAMYL7QQhJWnQ/BqnuLUBQvDACNx7gfr/px7y9m1AaBRrQUowVKFJGcKAAwaWbhwXBe9/CQeBTsssE0AUGSCievx2044W3gWLhyFI8W9SUu/B//X5MX0NI2SfUDwksluFj1L8tG2hg1HXKFz1Xfmwv/OShHIaQEgTveesyWLlMWXvzbsADI3QEgDCqk0HcDRhXQDYYzbQC2rNzT8kqyPKULH99cBhWmEQobukcCLbMAUEe8n76QA7v+Ys98NMHhwHBYwsQXFaAoDw0atY46grAugV7VuDFDd5BkWQY831g6xdzbalkYwLQ0T65jBC7tCsRY00g2DGmPgrWtN+CEzgQAH5WgOC9m4cDwXHHZnDpHywdgUAoawSKkVVbKpdWa1nD21FkAhTy7IAbo38OIBTmpzllBn9PCTYg8W2gYJIJpH351GHt0IJPPhN/Bg2KBgTvK5jgZwOC4N0tCOxcpc9mbAGS8vl2L27pum/rCvxPwtj+3rNYewIYgjmP8mOAGWQXQBHaB3DB5oOEDGB4+oECBO+/au9gIFhbgOCcVy1ulZUBRIErlaqVz+YLUMcUGJgEAngyVSfUjVI+WMv3joUTlwSBBdEg7wIgNhc+jlIsOCAweSSA8ECh/A9cs6/aJQwhp/zGFJx/7hJB+RiNA/wj5fBMXf4fAWPvBLQFxZSoF9ZjBzfqhyYPJO3za0JxT/rEAkllgqNgrvSYm7jr7nnYVDDBUCA4+XlTsOHcxc6cOX2jejaUVk/xj0hjShduwQv8YoEaZwYc81fcK2VMJFx5RBBnJRJj6zwNertLGN2XILjiz/fCUFKC4DWvXhQUCRbEbkxAUvkcIPotoa3DyooH3u1ZPTp5niLdxQa58CiYILKrmFTacSnQOTgWLhSsqB+00lUf9f2PCxB8dMtwXxqfOjMNp58+zeicWzFjBYi4AbIuhFt9iAVQX7vLfyZubqTRkbDP/UIe+xYJeT7VeaoMdV/8vv58zC1boAhKbC8KH03Vcxt9ikWj7/NI1eV56PTJ84o/bv7GI1X64vOH+V/HGwB88fPzzazDuoJe28AEIVXfI69X35G/xsVT7y6Cw/nbMWL1bcPmXm8RAaJM4ZWjYgnk/S9YSLKO+vXdQqQNYxFxD4xB2P3XChB8/JPDfFBSyssKELz0jGlh8dbaI+cCAGaL6AWGgiHy/OGseKW406VwABsQ6bRSZnpRWT1w6i5QAm0z5bDf0RheGdk0gOMinGdjc/7STYdh22cPw1Dy0tOnAgj0BZHL1LUHQ55rAMId0zngzoyU1slShvnyl6Vj4rkCYBNvZM/+HO776Xy0fUr27a8nQe0foAiwnjuNbuqfoHRFp8hA1bqFhIso/rjhnw9V9y84ZbEaPS6YSD/1aRncRPVXxsjmRz71hzz2J/rz4HmLpvKduG5m15psesmuIr3Gq9Tmad+CctHMwOoX0VlkZGlWnqGth6pepTjeDmsKFG0w5LM8Xcek2X1m8oMSwj3KOl66XYtYHQBQ9SUArLLl3yaSoOe/tsZINl2TYbZ7x/q5Auw7Y9G/jgOi9B6heoz1BX7fyPLRqR/GIvC3dqB2IHo8SrsCfWYAcm7YsQayL5AuVdM58XroUH1sO4c9KV+eBag2O8o5jf5PJMpvcM8DYLSlEucAwO75r8oX5wcQ+gvbNCetFRgBA0/LQyevPjlgIqU4smNqcLC2QnnqXgNDKpqxB0HEv7vKkuWij0h9J1+u7fzWFgB5fmRLkTmnAxyMKMSz+CgLEFtQ3Z/pvwnmNIiYYsAfpwGDzzAeOLwzgcAC4OQZxUMcCEbJntJArrWsLykf1TomlQ8g3IB3wdKpbdAAYOQG8q3tbBxlcaoW9M7y3bYAUQWio0itqFGaAiM5fcrfUE8zhQUPBwaFcfXYoMbQz9z2EQGCkzdqg37dpr+YwgEiSsZ2HVNXcQC0ZXYzzpV12/9mK4fpzRA5yxcW2Ty5dgcgT/hSCtMg8KzaWnejFP4iSS2+AA654IjRLweB159v5WT6cEHi5MVo35ajVTQHQ9sO3efyrnmETc10WgDs3vGE3QUMtoIW9RDIHyhxL3wmB4UBiV3wuHWrcYAilg2tQtH0TfLZmOW3z8jrseqBtkkCBdSCewpI5ZEcW5eDUqqpp0ACrL1mkuJ4ecvsR3B380ziP9qbh/lZ5LEAG7BdDAUE9PIBXEsWymFWaRgF4sxh5iP6CGNxANq5BK0KyoUwL48BWrCQbMfn4wJB5RlWaMvQdRVCycz6gXwlx/sAODIVrL8UAYAiFthdLObVYmYeGNRDg14MDwzk1ImAJSjOWSmlKM/ivb5QK1gwB5m6fLymHJ3n5n256+PVB3BZIZRhWDOSoNd169rmAgDDMDnRJm79AMqgGnnqi+/eXjSYMf9tCWvRDtKkEUUdrMsWknYPfrC2glRdVi+L5MfSmXfAg/WHGTwPMHIwNHrDljoQAq8viNeXOwFO8+weffp39LZ7419l61URuP/X6jQePb/4Ea6glZYOQ3r0GywWDa3ruvIXY1Zt6vboUyccJmiExwg8NhCflEFiTvwZmoS2fgLr35Xlo1fGWFNavQoKHRfguITdeARPBUdcANxRuALK6Hyehx4Q2H0zIVB5DTVDT1Dwh5V9gPXtjrjBHuhFjIHYWg9XgrwnoTTpEqxitSEZZXvP0tZBoVT3eVQ7nl/M9JLLtkjqbyT6vy3/aMdx24jwEr3OGEO/p8iExQswgO3Tt2w2XlUWwKTHG6XJmQdZVmjmq8qE8kDuNjQQBUCbbK1wXYc/k2KF6DMDuFs/DyB15U0b/xq3QUSS/932D29+4uZiDTeBY/3Jew8kGkg8EWMHSPQtWIHMYsu+nc7IB2mUaUi2bccin/lilg9OHjplmkUA4pauJew0aNNl107NQkI6/7/1H35t7SyWINCKid0n8jymAFL5dabew7t9eQN6IHRcDjptkfz+uFW7lqyUjo5yXZ9f5aFsCw6LJIwHI78EdMll16WVX0onAEq5swBBcUpwVtHtbnM6qBYee1ovn2y8rnr6SD+h3BschOLCHC3di04pbX1cXJB6Fh5bm4iSfdqHliF0//XvHOV41sbrpjZDD+kFgFLuvHn9tmxq/tQRCEA+gHgKiitIC7N+jNVXykqCBqQ7kP6QlKJ5G9uXl5e8F2mPUfw2xuJTcwMHyBwQ5SveHE/auCXu87v67yXPeOFds8XG+fK2E2STQp7HPoRo6tS/sX08r8t/Rx9moO3D1BmN2/ccoK0H3pkAqnbe3r9Jh7Lmr3G19I7+fj9jtXg5APoflMTv54qA9+rLtnRTvpbeDMDljq89qQDA/PoCclurjJTlQsQ3R9jBixMMPZtxpBWhx0LuL7kW6QpnmQgbua5Al3fWw7Y8ZZ2BBXDLI4QnLUT5vJ8FyzNmdq3DPJstrOaVxZzX8M/DpNWjYgeInvjpOpmyWvAYAsPiZq61g3P6J63bsoG1/Axi+d5p3uhhsohFC+aA0IanQbSDJrf8imvrPGSbZyP7+74yMQAaKb8tXA5TZxYdbiiumapzAQAIx8WuYiDqBlpqb8vRAoClFwYApSg256BYHwCZUOSkAJC/DAAFzcPO4u6Go5BtKRQ/BwPIYADQ8qyZXTMZZCcW+4UXF6OsyZDWFQ+8DqKKWTgAMhcI4wHAKLatE+wuCoC6LK5cDwCoACbKdxd9FgrGncUrnNtHv9M7h1I6l/8FAVO2ym5DPSIAAAAASUVORK5CYII="
  },
  metamask: {
    dark: "data:image/svg+xml;utf8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMTIiIGhlaWdodD0iMTg5IiB2aWV3Qm94PSIwIDAgMjEyIDE4OSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cG9seWdvbiBmaWxsPSIjQ0RCREIyIiBwb2ludHM9IjYwLjc1IDE3My4yNSA4OC4zMTMgMTgwLjU2MyA4OC4zMTMgMTcxIDkwLjU2MyAxNjguNzUgMTA2LjMxMyAxNjguNzUgMTA2LjMxMyAxODAgMTA2LjMxMyAxODcuODc1IDg5LjQzOCAxODcuODc1IDY4LjYyNSAxNzguODc1Ii8+PHBvbHlnb24gZmlsbD0iI0NEQkRCMiIgcG9pbnRzPSIxMDUuNzUgMTczLjI1IDEzMi43NSAxODAuNTYzIDEzMi43NSAxNzEgMTM1IDE2OC43NSAxNTAuNzUgMTY4Ljc1IDE1MC43NSAxODAgMTUwLjc1IDE4Ny44NzUgMTMzLjg3NSAxODcuODc1IDExMy4wNjMgMTc4Ljg3NSIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMjU2LjUgMCkiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjkwLjU2MyAxNTIuNDM4IDg4LjMxMyAxNzEgOTEuMTI1IDE2OC43NSAxMjAuMzc1IDE2OC43NSAxMjMuNzUgMTcxIDEyMS41IDE1Mi40MzggMTE3IDE0OS42MjUgOTQuNSAxNTAuMTg4Ii8+PHBvbHlnb24gZmlsbD0iI0Y4OUMzNSIgcG9pbnRzPSI3NS4zNzUgMjcgODguODc1IDU4LjUgOTUuMDYzIDE1MC4xODggMTE3IDE1MC4xODggMTIzLjc1IDU4LjUgMTM2LjEyNSAyNyIvPjxwb2x5Z29uIGZpbGw9IiNGODlEMzUiIHBvaW50cz0iMTYuMzEzIDk2LjE4OCAuNTYzIDE0MS43NSAzOS45MzggMTM5LjUgNjUuMjUgMTM5LjUgNjUuMjUgMTE5LjgxMyA2NC4xMjUgNzkuMzEzIDU4LjUgODMuODEzIi8+PHBvbHlnb24gZmlsbD0iI0Q4N0MzMCIgcG9pbnRzPSI0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi4zNzUgODcuMTg4IDEyNiA2NS4yNSAxMjAuMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VBOEQzQSIgcG9pbnRzPSI0Ni4xMjUgMTAxLjgxMyA2NS4yNSAxMTkuODEzIDY1LjI1IDEzNy44MTMiLz48cG9seWdvbiBmaWxsPSIjRjg5RDM1IiBwb2ludHM9IjY1LjI1IDEyMC4zNzUgODcuNzUgMTI2IDk1LjA2MyAxNTAuMTg4IDkwIDE1MyA2NS4yNSAxMzguMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSI2NS4yNSAxMzguMzc1IDYwLjc1IDE3My4yNSA5MC41NjMgMTUyLjQzOCIvPjxwb2x5Z29uIGZpbGw9IiNFQThFM0EiIHBvaW50cz0iOTIuMjUgMTAyLjM3NSA5NS4wNjMgMTUwLjE4OCA4Ni42MjUgMTI1LjcxOSIvPjxwb2x5Z29uIGZpbGw9IiNEODdDMzAiIHBvaW50cz0iMzkuMzc1IDEzOC45MzggNjUuMjUgMTM4LjM3NSA2MC43NSAxNzMuMjUiLz48cG9seWdvbiBmaWxsPSIjRUI4RjM1IiBwb2ludHM9IjEyLjkzOCAxODguNDM4IDYwLjc1IDE3My4yNSAzOS4zNzUgMTM4LjkzOCAuNTYzIDE0MS43NSIvPjxwb2x5Z29uIGZpbGw9IiNFODgyMUUiIHBvaW50cz0iODguODc1IDU4LjUgNjQuNjg4IDc4Ljc1IDQ2LjEyNSAxMDEuMjUgOTIuMjUgMTAyLjkzOCIvPjxwb2x5Z29uIGZpbGw9IiNERkNFQzMiIHBvaW50cz0iNjAuNzUgMTczLjI1IDkwLjU2MyAxNTIuNDM4IDg4LjMxMyAxNzAuNDM4IDg4LjMxMyAxODAuNTYzIDY4LjA2MyAxNzYuNjI1Ii8+PHBvbHlnb24gZmlsbD0iI0RGQ0VDMyIgcG9pbnRzPSIxMjEuNSAxNzMuMjUgMTUwLjc1IDE1Mi40MzggMTQ4LjUgMTcwLjQzOCAxNDguNSAxODAuNTYzIDEyOC4yNSAxNzYuNjI1IiB0cmFuc2Zvcm09Im1hdHJpeCgtMSAwIDAgMSAyNzIuMjUgMCkiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjcwLjMxMyAxMTIuNSA2NC4xMjUgMTI1LjQzOCA4Ni4wNjMgMTE5LjgxMyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMTUwLjE4OCAwKSIvPjxwb2x5Z29uIGZpbGw9IiNFODhGMzUiIHBvaW50cz0iMTIuMzc1IC41NjMgODguODc1IDU4LjUgNzUuOTM4IDI3Ii8+PHBhdGggZmlsbD0iIzhFNUEzMCIgZD0iTTEyLjM3NTAwMDIsMC41NjI1MDAwMDggTDIuMjUwMDAwMDMsMzEuNTAwMDAwNSBMNy44NzUwMDAxMiw2NS4yNTAwMDEgTDMuOTM3NTAwMDYsNjcuNTAwMDAxIEw5LjU2MjUwMDE0LDcyLjU2MjUgTDUuMDYyNTAwMDgsNzYuNTAwMDAxMSBMMTEuMjUsODIuMTI1MDAxMiBMNy4zMTI1MDAxMSw4NS41MDAwMDEzIEwxNi4zMTI1MDAyLDk2Ljc1MDAwMTQgTDU4LjUwMDAwMDksODMuODEyNTAxMiBDNzkuMTI1MDAxMiw2Ny4zMTI1MDA0IDg5LjI1MDAwMTMsNTguODc1MDAwMyA4OC44NzUwMDEzLDU4LjUwMDAwMDkgQzg4LjUwMDAwMTMsNTguMTI1MDAwOSA2My4wMDAwMDA5LDM4LjgxMjUwMDYgMTIuMzc1MDAwMiwwLjU2MjUwMDAwOCBaIi8+PGcgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMjExLjUgMCkiPjxwb2x5Z29uIGZpbGw9IiNGODlEMzUiIHBvaW50cz0iMTYuMzEzIDk2LjE4OCAuNTYzIDE0MS43NSAzOS45MzggMTM5LjUgNjUuMjUgMTM5LjUgNjUuMjUgMTE5LjgxMyA2NC4xMjUgNzkuMzEzIDU4LjUgODMuODEzIi8+PHBvbHlnb24gZmlsbD0iI0Q4N0MzMCIgcG9pbnRzPSI0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi4zNzUgODcuMTg4IDEyNiA2NS4yNSAxMjAuMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VBOEQzQSIgcG9pbnRzPSI0Ni4xMjUgMTAxLjgxMyA2NS4yNSAxMTkuODEzIDY1LjI1IDEzNy44MTMiLz48cG9seWdvbiBmaWxsPSIjRjg5RDM1IiBwb2ludHM9IjY1LjI1IDEyMC4zNzUgODcuNzUgMTI2IDk1LjA2MyAxNTAuMTg4IDkwIDE1MyA2NS4yNSAxMzguMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSI2NS4yNSAxMzguMzc1IDYwLjc1IDE3My4yNSA5MCAxNTMiLz48cG9seWdvbiBmaWxsPSIjRUE4RTNBIiBwb2ludHM9IjkyLjI1IDEwMi4zNzUgOTUuMDYzIDE1MC4xODggODYuNjI1IDEyNS43MTkiLz48cG9seWdvbiBmaWxsPSIjRDg3QzMwIiBwb2ludHM9IjM5LjM3NSAxMzguOTM4IDY1LjI1IDEzOC4zNzUgNjAuNzUgMTczLjI1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSIxMi45MzggMTg4LjQzOCA2MC43NSAxNzMuMjUgMzkuMzc1IDEzOC45MzggLjU2MyAxNDEuNzUiLz48cG9seWdvbiBmaWxsPSIjRTg4MjFFIiBwb2ludHM9Ijg4Ljg3NSA1OC41IDY0LjY4OCA3OC43NSA0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi45MzgiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjcwLjMxMyAxMTIuNSA2NC4xMjUgMTI1LjQzOCA4Ni4wNjMgMTE5LjgxMyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMTUwLjE4OCAwKSIvPjxwb2x5Z29uIGZpbGw9IiNFODhGMzUiIHBvaW50cz0iMTIuMzc1IC41NjMgODguODc1IDU4LjUgNzUuOTM4IDI3Ii8+PHBhdGggZmlsbD0iIzhFNUEzMCIgZD0iTTEyLjM3NTAwMDIsMC41NjI1MDAwMDggTDIuMjUwMDAwMDMsMzEuNTAwMDAwNSBMNy44NzUwMDAxMiw2NS4yNTAwMDEgTDMuOTM3NTAwMDYsNjcuNTAwMDAxIEw5LjU2MjUwMDE0LDcyLjU2MjUgTDUuMDYyNTAwMDgsNzYuNTAwMDAxMSBMMTEuMjUsODIuMTI1MDAxMiBMNy4zMTI1MDAxMSw4NS41MDAwMDEzIEwxNi4zMTI1MDAyLDk2Ljc1MDAwMTQgTDU4LjUwMDAwMDksODMuODEyNTAxMiBDNzkuMTI1MDAxMiw2Ny4zMTI1MDA0IDg5LjI1MDAwMTMsNTguODc1MDAwMyA4OC44NzUwMDEzLDU4LjUwMDAwMDkgQzg4LjUwMDAwMTMsNTguMTI1MDAwOSA2My4wMDAwMDA5LDM4LjgxMjUwMDYgMTIuMzc1MDAwMiwwLjU2MjUwMDAwOCBaIi8+PC9nPjwvZz48L3N2Zz4=",
    light: "data:image/svg+xml;utf8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMTIiIGhlaWdodD0iMTg5IiB2aWV3Qm94PSIwIDAgMjEyIDE4OSI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cG9seWdvbiBmaWxsPSIjQ0RCREIyIiBwb2ludHM9IjYwLjc1IDE3My4yNSA4OC4zMTMgMTgwLjU2MyA4OC4zMTMgMTcxIDkwLjU2MyAxNjguNzUgMTA2LjMxMyAxNjguNzUgMTA2LjMxMyAxODAgMTA2LjMxMyAxODcuODc1IDg5LjQzOCAxODcuODc1IDY4LjYyNSAxNzguODc1Ii8+PHBvbHlnb24gZmlsbD0iI0NEQkRCMiIgcG9pbnRzPSIxMDUuNzUgMTczLjI1IDEzMi43NSAxODAuNTYzIDEzMi43NSAxNzEgMTM1IDE2OC43NSAxNTAuNzUgMTY4Ljc1IDE1MC43NSAxODAgMTUwLjc1IDE4Ny44NzUgMTMzLjg3NSAxODcuODc1IDExMy4wNjMgMTc4Ljg3NSIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMjU2LjUgMCkiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjkwLjU2MyAxNTIuNDM4IDg4LjMxMyAxNzEgOTEuMTI1IDE2OC43NSAxMjAuMzc1IDE2OC43NSAxMjMuNzUgMTcxIDEyMS41IDE1Mi40MzggMTE3IDE0OS42MjUgOTQuNSAxNTAuMTg4Ii8+PHBvbHlnb24gZmlsbD0iI0Y4OUMzNSIgcG9pbnRzPSI3NS4zNzUgMjcgODguODc1IDU4LjUgOTUuMDYzIDE1MC4xODggMTE3IDE1MC4xODggMTIzLjc1IDU4LjUgMTM2LjEyNSAyNyIvPjxwb2x5Z29uIGZpbGw9IiNGODlEMzUiIHBvaW50cz0iMTYuMzEzIDk2LjE4OCAuNTYzIDE0MS43NSAzOS45MzggMTM5LjUgNjUuMjUgMTM5LjUgNjUuMjUgMTE5LjgxMyA2NC4xMjUgNzkuMzEzIDU4LjUgODMuODEzIi8+PHBvbHlnb24gZmlsbD0iI0Q4N0MzMCIgcG9pbnRzPSI0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi4zNzUgODcuMTg4IDEyNiA2NS4yNSAxMjAuMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VBOEQzQSIgcG9pbnRzPSI0Ni4xMjUgMTAxLjgxMyA2NS4yNSAxMTkuODEzIDY1LjI1IDEzNy44MTMiLz48cG9seWdvbiBmaWxsPSIjRjg5RDM1IiBwb2ludHM9IjY1LjI1IDEyMC4zNzUgODcuNzUgMTI2IDk1LjA2MyAxNTAuMTg4IDkwIDE1MyA2NS4yNSAxMzguMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSI2NS4yNSAxMzguMzc1IDYwLjc1IDE3My4yNSA5MC41NjMgMTUyLjQzOCIvPjxwb2x5Z29uIGZpbGw9IiNFQThFM0EiIHBvaW50cz0iOTIuMjUgMTAyLjM3NSA5NS4wNjMgMTUwLjE4OCA4Ni42MjUgMTI1LjcxOSIvPjxwb2x5Z29uIGZpbGw9IiNEODdDMzAiIHBvaW50cz0iMzkuMzc1IDEzOC45MzggNjUuMjUgMTM4LjM3NSA2MC43NSAxNzMuMjUiLz48cG9seWdvbiBmaWxsPSIjRUI4RjM1IiBwb2ludHM9IjEyLjkzOCAxODguNDM4IDYwLjc1IDE3My4yNSAzOS4zNzUgMTM4LjkzOCAuNTYzIDE0MS43NSIvPjxwb2x5Z29uIGZpbGw9IiNFODgyMUUiIHBvaW50cz0iODguODc1IDU4LjUgNjQuNjg4IDc4Ljc1IDQ2LjEyNSAxMDEuMjUgOTIuMjUgMTAyLjkzOCIvPjxwb2x5Z29uIGZpbGw9IiNERkNFQzMiIHBvaW50cz0iNjAuNzUgMTczLjI1IDkwLjU2MyAxNTIuNDM4IDg4LjMxMyAxNzAuNDM4IDg4LjMxMyAxODAuNTYzIDY4LjA2MyAxNzYuNjI1Ii8+PHBvbHlnb24gZmlsbD0iI0RGQ0VDMyIgcG9pbnRzPSIxMjEuNSAxNzMuMjUgMTUwLjc1IDE1Mi40MzggMTQ4LjUgMTcwLjQzOCAxNDguNSAxODAuNTYzIDEyOC4yNSAxNzYuNjI1IiB0cmFuc2Zvcm09Im1hdHJpeCgtMSAwIDAgMSAyNzIuMjUgMCkiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjcwLjMxMyAxMTIuNSA2NC4xMjUgMTI1LjQzOCA4Ni4wNjMgMTE5LjgxMyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMTUwLjE4OCAwKSIvPjxwb2x5Z29uIGZpbGw9IiNFODhGMzUiIHBvaW50cz0iMTIuMzc1IC41NjMgODguODc1IDU4LjUgNzUuOTM4IDI3Ii8+PHBhdGggZmlsbD0iIzhFNUEzMCIgZD0iTTEyLjM3NTAwMDIsMC41NjI1MDAwMDggTDIuMjUwMDAwMDMsMzEuNTAwMDAwNSBMNy44NzUwMDAxMiw2NS4yNTAwMDEgTDMuOTM3NTAwMDYsNjcuNTAwMDAxIEw5LjU2MjUwMDE0LDcyLjU2MjUgTDUuMDYyNTAwMDgsNzYuNTAwMDAxMSBMMTEuMjUsODIuMTI1MDAxMiBMNy4zMTI1MDAxMSw4NS41MDAwMDEzIEwxNi4zMTI1MDAyLDk2Ljc1MDAwMTQgTDU4LjUwMDAwMDksODMuODEyNTAxMiBDNzkuMTI1MDAxMiw2Ny4zMTI1MDA0IDg5LjI1MDAwMTMsNTguODc1MDAwMyA4OC44NzUwMDEzLDU4LjUwMDAwMDkgQzg4LjUwMDAwMTMsNTguMTI1MDAwOSA2My4wMDAwMDA5LDM4LjgxMjUwMDYgMTIuMzc1MDAwMiwwLjU2MjUwMDAwOCBaIi8+PGcgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMjExLjUgMCkiPjxwb2x5Z29uIGZpbGw9IiNGODlEMzUiIHBvaW50cz0iMTYuMzEzIDk2LjE4OCAuNTYzIDE0MS43NSAzOS45MzggMTM5LjUgNjUuMjUgMTM5LjUgNjUuMjUgMTE5LjgxMyA2NC4xMjUgNzkuMzEzIDU4LjUgODMuODEzIi8+PHBvbHlnb24gZmlsbD0iI0Q4N0MzMCIgcG9pbnRzPSI0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi4zNzUgODcuMTg4IDEyNiA2NS4yNSAxMjAuMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VBOEQzQSIgcG9pbnRzPSI0Ni4xMjUgMTAxLjgxMyA2NS4yNSAxMTkuODEzIDY1LjI1IDEzNy44MTMiLz48cG9seWdvbiBmaWxsPSIjRjg5RDM1IiBwb2ludHM9IjY1LjI1IDEyMC4zNzUgODcuNzUgMTI2IDk1LjA2MyAxNTAuMTg4IDkwIDE1MyA2NS4yNSAxMzguMzc1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSI2NS4yNSAxMzguMzc1IDYwLjc1IDE3My4yNSA5MCAxNTMiLz48cG9seWdvbiBmaWxsPSIjRUE4RTNBIiBwb2ludHM9IjkyLjI1IDEwMi4zNzUgOTUuMDYzIDE1MC4xODggODYuNjI1IDEyNS43MTkiLz48cG9seWdvbiBmaWxsPSIjRDg3QzMwIiBwb2ludHM9IjM5LjM3NSAxMzguOTM4IDY1LjI1IDEzOC4zNzUgNjAuNzUgMTczLjI1Ii8+PHBvbHlnb24gZmlsbD0iI0VCOEYzNSIgcG9pbnRzPSIxMi45MzggMTg4LjQzOCA2MC43NSAxNzMuMjUgMzkuMzc1IDEzOC45MzggLjU2MyAxNDEuNzUiLz48cG9seWdvbiBmaWxsPSIjRTg4MjFFIiBwb2ludHM9Ijg4Ljg3NSA1OC41IDY0LjY4OCA3OC43NSA0Ni4xMjUgMTAxLjI1IDkyLjI1IDEwMi45MzgiLz48cG9seWdvbiBmaWxsPSIjMzkzOTM5IiBwb2ludHM9IjcwLjMxMyAxMTIuNSA2NC4xMjUgMTI1LjQzOCA4Ni4wNjMgMTE5LjgxMyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIDEgMTUwLjE4OCAwKSIvPjxwb2x5Z29uIGZpbGw9IiNFODhGMzUiIHBvaW50cz0iMTIuMzc1IC41NjMgODguODc1IDU4LjUgNzUuOTM4IDI3Ii8+PHBhdGggZmlsbD0iIzhFNUEzMCIgZD0iTTEyLjM3NTAwMDIsMC41NjI1MDAwMDggTDIuMjUwMDAwMDMsMzEuNTAwMDAwNSBMNy44NzUwMDAxMiw2NS4yNTAwMDEgTDMuOTM3NTAwMDYsNjcuNTAwMDAxIEw5LjU2MjUwMDE0LDcyLjU2MjUgTDUuMDYyNTAwMDgsNzYuNTAwMDAxMSBMMTEuMjUsODIuMTI1MDAxMiBMNy4zMTI1MDAxMSw4NS41MDAwMDEzIEwxNi4zMTI1MDAyLDk2Ljc1MDAwMTQgTDU4LjUwMDAwMDksODMuODEyNTAxMiBDNzkuMTI1MDAxMiw2Ny4zMTI1MDA0IDg5LjI1MDAwMTMsNTguODc1MDAwMyA4OC44NzUwMDEzLDU4LjUwMDAwMDkgQzg4LjUwMDAwMTMsNTguMTI1MDAwOSA2My4wMDAwMDA5LDM4LjgxMjUwMDYgMTIuMzc1MDAwMiwwLjU2MjUwMDAwOCBaIi8+PC9nPjwvZz48L3N2Zz4="
  },
  fordefi: {
    dark: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzNDk0XzY2MjU0KSI+CjxwYXRoIGQ9Ik0xMC44NzY5IDE1LjYzNzhIMS41VjE4LjM5OUMxLjUgMTkuODAxMyAyLjYzNDQ3IDIwLjkzOCA0LjAzMzkyIDIwLjkzOEg4LjI0OTkyTDEwLjg3NjkgMTUuNjM3OFoiIGZpbGw9IiM3OTk0RkYiLz4KPHBhdGggZD0iTTEuNSA5Ljc3NTUxSDE5LjA1MTZMMTcuMDEzOSAxMy44NzExSDEuNVY5Ljc3NTUxWiIgZmlsbD0iIzQ4NkRGRiIvPgo8cGF0aCBkPSJNNy42NTk5NiAzSDEuNTI0NDFWOC4wMDcwNEgyMi40NjEyVjNIMTYuMzI1NlY2LjczOTQ0SDE1LjA2MDZWM0g4LjkyNTAyVjYuNzM5NDRINy42NTk5NlYzWiIgZmlsbD0iIzVDRDFGQSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzNDk0XzY2MjU0Ij4KPHJlY3Qgd2lkdGg9IjIxIiBoZWlnaHQ9IjE4IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS41IDMpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==",
    light: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEzNDk0XzY2MjU0KSI+CjxwYXRoIGQ9Ik0xMC44NzY5IDE1LjYzNzhIMS41VjE4LjM5OUMxLjUgMTkuODAxMyAyLjYzNDQ3IDIwLjkzOCA0LjAzMzkyIDIwLjkzOEg4LjI0OTkyTDEwLjg3NjkgMTUuNjM3OFoiIGZpbGw9IiM3OTk0RkYiLz4KPHBhdGggZD0iTTEuNSA5Ljc3NTUxSDE5LjA1MTZMMTcuMDEzOSAxMy44NzExSDEuNVY5Ljc3NTUxWiIgZmlsbD0iIzQ4NkRGRiIvPgo8cGF0aCBkPSJNNy42NTk5NiAzSDEuNTI0NDFWOC4wMDcwNEgyMi40NjEyVjNIMTYuMzI1NlY2LjczOTQ0SDE1LjA2MDZWM0g4LjkyNTAyVjYuNzM5NDRINy42NTk5NlYzWiIgZmlsbD0iIzVDRDFGQSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEzNDk0XzY2MjU0Ij4KPHJlY3Qgd2lkdGg9IjIxIiBoZWlnaHQ9IjE4IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS41IDMpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg=="
  }
};
let L$3 = class Um extends M$5 {
  constructor({ options: e0 }) {
    super(), T$2(this, "_wallet"), T$2(this, "_options"), this._options = e0;
  }
  static getInjectedWallet(e0) {
    return globalThis?.[`starknet_${e0}`];
  }
  static isWalletInjected(e0) {
    return !!Um.getInjectedWallet(e0);
  }
  get id() {
    return this._options.id;
  }
  get name() {
    return this.ensureWallet(), this._options.id.toLowerCase() === "argentx" ? "Ready Wallet (formerly Argent)" : this._options.name ?? this._wallet?.name ?? this._options.id;
  }
  get icon() {
    this.ensureWallet();
    const e0 = {
      dark: w$1[this.id]?.dark || S$2,
      light: w$1[this.id]?.light || Q$4
    };
    return this._options.icon || this._wallet?.icon || e0;
  }
  available() {
    return this.ensureWallet(), this._wallet !== void 0;
  }
  async chainId() {
    this.ensureWallet();
    const e0 = await this.isLocked();
    if (!this._wallet || e0)
      throw new S$4();
    try {
      const n0 = await this.request({ type: "wallet_requestChainId" });
      return BigInt(n0);
    } catch {
      throw new R$1();
    }
  }
  async ready() {
    return this.ensureWallet(), this._wallet ? (await this.request({
      type: "wallet_getPermissions"
    }))?.includes(A$5.ACCOUNTS) : !1;
  }
  async account(e0) {
    if (this.ensureWallet(), await this.isLocked() || !this._wallet)
      throw new S$4();
    const n0 = await this.request({
      type: "wallet_requestAccounts",
      params: { silent_mode: !0 }
    });
    return new WalletAccount(e0, this._wallet, void 0, n0[0]);
  }
  async connect(e0 = {}) {
    if (this.ensureWallet(), !this._wallet)
      throw new R$1();
    this._options.shouldEmit && this.emit("connectionStatus", "init");
    let n0;
    try {
      n0 = await this.request({
        type: "wallet_requestAccounts"
      });
    } catch {
      throw this._options.shouldEmit && this.emit("connectionStatus", "fail"), new T$3();
    }
    if (!n0)
      throw this._options.shouldEmit && this.emit("connectionStatus", "fail"), new T$3();
    this._wallet.on("accountsChanged", async (o0) => {
      await this.onAccountsChanged(o0);
    }), this._wallet.on("networkChanged", (o0, s0) => {
      this.onNetworkChanged(o0, s0);
    }), await this.onAccountsChanged(n0);
    const [r0] = n0, i0 = await this.chainId();
    return this.emit("connect", { account: r0, chainId: i0 }), this._options.shouldEmit && this.emit("connectionStatus", "success"), {
      account: r0,
      chainId: i0
    };
  }
  async disconnect() {
    if (this.ensureWallet(), !this._wallet)
      throw new R$1();
    W$4(), this.emit("disconnect");
    try {
      await this.request({
        type: "wallet_disconnect"
      });
    } catch {
    }
    this._wallet = void 0;
  }
  async request(e0) {
    if (this.ensureWallet(), !this._wallet)
      throw new S$4();
    try {
      return await this._wallet.request(e0);
    } catch {
      throw new T$3();
    }
  }
  async isLocked() {
    return (await this.request({
      type: "wallet_requestAccounts",
      params: { silent_mode: !0 }
    })).length === 0;
  }
  ensureWallet() {
    const e0 = Um.getInjectedWallet(this._options.id);
    e0 && (this._wallet = e0);
  }
  async onAccountsChanged(e0) {
    if (!e0)
      this.emit("disconnect");
    else {
      const [n0] = e0;
      if (n0) {
        const r0 = await this.chainId();
        this.emit("change", { account: n0, chainId: r0 });
      } else
        this.emit("disconnect");
    }
  }
  onNetworkChanged(e0, n0) {
    if (e0) {
      const r0 = BigInt(e0), [i0] = n0 || [];
      this.emit("change", { chainId: r0, account: i0 });
    } else
      this.emit("change", {});
  }
  get wallet() {
    if (!this._wallet)
      throw new S$4();
    return this._wallet;
  }
}, p$1 = class extends L$3 {
  constructor(e0) {
    super({ options: { id: "argentX", ...e0 } });
  }
};
var Q$3 = Object.defineProperty, X$3 = (t0, e0, n0) => e0 in t0 ? Q$3(t0, e0, { enumerable: !0, configurable: !0, writable: !0, value: n0 }) : t0[e0] = n0, A$3 = (t0, e0, n0) => (X$3(t0, typeof e0 != "symbol" ? e0 + "" : e0, n0), n0);
const ee$2 = {
  mainnet: "https://starknet-mainnet.public.blastapi.io",
  testnet: "https://starknet-sepolia.public.blastapi.io"
}, te$2 = {
  mainnet: "https://rpc.starknet.lava.build",
  testnet: "https://rpc.starknet-sepolia.lava.build"
}, x$2 = [ee$2, te$2];
function re$3() {
  const t0 = Math.floor(Math.random() * x$2.length);
  return x$2[t0];
}
const se$2 = () => Object.keys(localStorage).some(
  (t0) => t0 === "walletconnect" || t0.startsWith("wc@2:")
), T$1 = () => {
  if (se$2()) {
    delete localStorage.walletconnect;
    for (const t0 in localStorage)
      t0.startsWith("wc@2:") && delete localStorage[t0];
  }
}, L$2 = "f2e613881f7a0e811295cdd57999e31b", I$1 = `<svg
    width="32"
    height="32"
    viewBox="0 0 32 32"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <rect width="32" height="32" rx="8" fill="#FF875B" />
    <path
      d="M18.316 8H13.684C13.5292 8 13.4052 8.1272 13.4018 8.28531C13.3082 12.7296 11.0323 16.9477 7.11513 19.9355C6.99077 20.0303 6.96243 20.2085 7.05335 20.3369L9.76349 24.1654C9.85569 24.2957 10.0353 24.3251 10.1618 24.2294C12.6111 22.3734 14.5812 20.1345 16 17.6529C17.4187 20.1345 19.389 22.3734 21.8383 24.2294C21.9646 24.3251 22.1443 24.2957 22.2366 24.1654L24.9467 20.3369C25.0375 20.2085 25.0092 20.0303 24.885 19.9355C20.9676 16.9477 18.6918 12.7296 18.5983 8.28531C18.5949 8.1272 18.4708 8 18.316 8Z"
      fill="white"
    />
  </svg>`;
function ie$2() {
  if (!(typeof window > "u"))
    return window?.starknet_argentX;
}
const q$3 = () => {
  if (typeof window > "u")
    return !1;
  const t0 = ie$2();
  return t0 ? t0.isInAppBrowser : !1;
};
var ne$2 = typeof global == "object" && global && global.Object === Object && global;
const oe$2 = ne$2;
var ae$2 = typeof self == "object" && self && self.Object === Object && self, ce$3 = oe$2 || ae$2 || Function("return this")();
const de$2 = ce$3;
var le$2 = de$2.Symbol;
const k$1 = le$2;
var z$2 = Object.prototype, ue$2 = z$2.hasOwnProperty, fe$3 = z$2.toString, _$1 = k$1 ? k$1.toStringTag : void 0;
function he$2(t0) {
  var e0 = ue$2.call(t0, _$1), n0 = t0[_$1];
  try {
    t0[_$1] = void 0;
    var r0 = !0;
  } catch {
  }
  var i0 = fe$3.call(t0);
  return r0 && (e0 ? t0[_$1] = n0 : delete t0[_$1]), i0;
}
var ge$2 = Object.prototype, me$2 = ge$2.toString;
function we$2(t0) {
  return me$2.call(t0);
}
var be$2 = "[object Null]", pe$1 = "[object Undefined]", W$2 = k$1 ? k$1.toStringTag : void 0;
function ve$2(t0) {
  return t0 == null ? t0 === void 0 ? pe$1 : be$2 : W$2 && W$2 in Object(t0) ? he$2(t0) : we$2(t0);
}
function Me$3(t0) {
  return t0 != null && typeof t0 == "object";
}
var ye$2 = Array.isArray;
const Se$3 = ye$2;
var Be$3 = "[object String]";
function N$3(t0) {
  return typeof t0 == "string" || !Se$3(t0) && Me$3(t0) && ve$2(t0) == Be$3;
}
function C$3(t0) {
  return t0.isCompoundConnector;
}
function S$1(t0, e0 = !1) {
  return C$3(t0) ? e0 ? t0.fallbackConnector : t0.connector : t0;
}
function Fe$2(t0, e0) {
  const n0 = t0.find((r0) => r0 ? S$1(r0)?.id === e0 : !1);
  return n0 ? S$1(n0) : null;
}
const _e$2 = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
}, D$2 = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
}, u$1 = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
}, m$2 = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
}, M$3 = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class s {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(e0, n0) {
    const r0 = n0.match(e0);
    return r0 && r0.length > 0 && r0[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(e0, n0) {
    const r0 = n0.match(e0);
    return r0 && r0.length > 1 && r0[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(e0, n0, r0) {
    if (e0.test(n0))
      return r0;
  }
  static getWindowsVersionName(e0) {
    switch (e0) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(e0) {
    const n0 = e0.split(".").splice(0, 2).map((r0) => parseInt(r0, 10) || 0);
    if (n0.push(0), n0[0] === 10)
      switch (n0[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(e0) {
    const n0 = e0.split(".").splice(0, 2).map((r0) => parseInt(r0, 10) || 0);
    if (n0.push(0), !(n0[0] === 1 && n0[1] < 5)) {
      if (n0[0] === 1 && n0[1] < 6)
        return "Cupcake";
      if (n0[0] === 1 && n0[1] >= 6)
        return "Donut";
      if (n0[0] === 2 && n0[1] < 2)
        return "Eclair";
      if (n0[0] === 2 && n0[1] === 2)
        return "Froyo";
      if (n0[0] === 2 && n0[1] > 2)
        return "Gingerbread";
      if (n0[0] === 3)
        return "Honeycomb";
      if (n0[0] === 4 && n0[1] < 1)
        return "Ice Cream Sandwich";
      if (n0[0] === 4 && n0[1] < 4)
        return "Jelly Bean";
      if (n0[0] === 4 && n0[1] >= 4)
        return "KitKat";
      if (n0[0] === 5)
        return "Lollipop";
      if (n0[0] === 6)
        return "Marshmallow";
      if (n0[0] === 7)
        return "Nougat";
      if (n0[0] === 8)
        return "Oreo";
      if (n0[0] === 9)
        return "Pie";
    }
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(e0) {
    return e0.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(e0, n0, r0 = !1) {
    const i0 = s.getVersionPrecision(e0), o0 = s.getVersionPrecision(n0);
    let s0 = Math.max(i0, o0), a0 = 0;
    const c0 = s.map([e0, n0], (l0) => {
      const u0 = s0 - s.getVersionPrecision(l0), d0 = l0 + new Array(u0 + 1).join(".0");
      return s.map(d0.split("."), (h0) => new Array(20 - h0.length).join("0") + h0).reverse();
    });
    for (r0 && (a0 = s0 - Math.min(i0, o0)), s0 -= 1; s0 >= a0; ) {
      if (c0[0][s0] > c0[1][s0])
        return 1;
      if (c0[0][s0] === c0[1][s0]) {
        if (s0 === a0)
          return 0;
        s0 -= 1;
      } else if (c0[0][s0] < c0[1][s0])
        return -1;
    }
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(e0, n0) {
    const r0 = [];
    let i0;
    if (Array.prototype.map)
      return Array.prototype.map.call(e0, n0);
    for (i0 = 0; i0 < e0.length; i0 += 1)
      r0.push(n0(e0[i0]));
    return r0;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(e0, n0) {
    let r0, i0;
    if (Array.prototype.find)
      return Array.prototype.find.call(e0, n0);
    for (r0 = 0, i0 = e0.length; r0 < i0; r0 += 1) {
      const o0 = e0[r0];
      if (n0(o0, r0))
        return o0;
    }
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(e0, ...n0) {
    const r0 = e0;
    let i0, o0;
    if (Object.assign)
      return Object.assign(e0, ...n0);
    for (i0 = 0, o0 = n0.length; i0 < o0; i0 += 1) {
      const s0 = n0[i0];
      typeof s0 == "object" && s0 !== null && Object.keys(s0).forEach((a0) => {
        r0[a0] = s0[a0];
      });
    }
    return e0;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(e0) {
    return _e$2[e0];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(e0) {
    return D$2[e0] || "";
  }
}
const o$2 = /version\/(\d+(\.?_?\d+)+)/i, ke$2 = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(t0) {
      const e0 = {
        name: "Googlebot"
      }, n0 = s.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, t0) || s.getFirstMatch(o$2, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(t0) {
      const e0 = {
        name: "Opera"
      }, n0 = s.getFirstMatch(o$2, t0) || s.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(t0) {
      const e0 = {
        name: "Opera"
      }, n0 = s.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, t0) || s.getFirstMatch(o$2, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(t0) {
      const e0 = {
        name: "Samsung Internet for Android"
      }, n0 = s.getFirstMatch(o$2, t0) || s.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/Whale/i],
    describe(t0) {
      const e0 = {
        name: "NAVER Whale Browser"
      }, n0 = s.getFirstMatch(o$2, t0) || s.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(t0) {
      const e0 = {
        name: "MZ Browser"
      }, n0 = s.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, t0) || s.getFirstMatch(o$2, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/focus/i],
    describe(t0) {
      const e0 = {
        name: "Focus"
      }, n0 = s.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, t0) || s.getFirstMatch(o$2, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/swing/i],
    describe(t0) {
      const e0 = {
        name: "Swing"
      }, n0 = s.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, t0) || s.getFirstMatch(o$2, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/coast/i],
    describe(t0) {
      const e0 = {
        name: "Opera Coast"
      }, n0 = s.getFirstMatch(o$2, t0) || s.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(t0) {
      const e0 = {
        name: "Opera Touch"
      }, n0 = s.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, t0) || s.getFirstMatch(o$2, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/yabrowser/i],
    describe(t0) {
      const e0 = {
        name: "Yandex Browser"
      }, n0 = s.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, t0) || s.getFirstMatch(o$2, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(t0) {
      const e0 = {
        name: "UC Browser"
      }, n0 = s.getFirstMatch(o$2, t0) || s.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(t0) {
      const e0 = {
        name: "Maxthon"
      }, n0 = s.getFirstMatch(o$2, t0) || s.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/epiphany/i],
    describe(t0) {
      const e0 = {
        name: "Epiphany"
      }, n0 = s.getFirstMatch(o$2, t0) || s.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/puffin/i],
    describe(t0) {
      const e0 = {
        name: "Puffin"
      }, n0 = s.getFirstMatch(o$2, t0) || s.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/sleipnir/i],
    describe(t0) {
      const e0 = {
        name: "Sleipnir"
      }, n0 = s.getFirstMatch(o$2, t0) || s.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/k-meleon/i],
    describe(t0) {
      const e0 = {
        name: "K-Meleon"
      }, n0 = s.getFirstMatch(o$2, t0) || s.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/micromessenger/i],
    describe(t0) {
      const e0 = {
        name: "WeChat"
      }, n0 = s.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, t0) || s.getFirstMatch(o$2, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(t0) {
      const e0 = {
        name: /qqbrowserlite/i.test(t0) ? "QQ Browser Lite" : "QQ Browser"
      }, n0 = s.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, t0) || s.getFirstMatch(o$2, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/msie|trident/i],
    describe(t0) {
      const e0 = {
        name: "Internet Explorer"
      }, n0 = s.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/\sedg\//i],
    describe(t0) {
      const e0 = {
        name: "Microsoft Edge"
      }, n0 = s.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(t0) {
      const e0 = {
        name: "Microsoft Edge"
      }, n0 = s.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/vivaldi/i],
    describe(t0) {
      const e0 = {
        name: "Vivaldi"
      }, n0 = s.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/seamonkey/i],
    describe(t0) {
      const e0 = {
        name: "SeaMonkey"
      }, n0 = s.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/sailfish/i],
    describe(t0) {
      const e0 = {
        name: "Sailfish"
      }, n0 = s.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/silk/i],
    describe(t0) {
      const e0 = {
        name: "Amazon Silk"
      }, n0 = s.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/phantom/i],
    describe(t0) {
      const e0 = {
        name: "PhantomJS"
      }, n0 = s.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/slimerjs/i],
    describe(t0) {
      const e0 = {
        name: "SlimerJS"
      }, n0 = s.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(t0) {
      const e0 = {
        name: "BlackBerry"
      }, n0 = s.getFirstMatch(o$2, t0) || s.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(t0) {
      const e0 = {
        name: "WebOS Browser"
      }, n0 = s.getFirstMatch(o$2, t0) || s.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/bada/i],
    describe(t0) {
      const e0 = {
        name: "Bada"
      }, n0 = s.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/tizen/i],
    describe(t0) {
      const e0 = {
        name: "Tizen"
      }, n0 = s.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, t0) || s.getFirstMatch(o$2, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/qupzilla/i],
    describe(t0) {
      const e0 = {
        name: "QupZilla"
      }, n0 = s.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, t0) || s.getFirstMatch(o$2, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(t0) {
      const e0 = {
        name: "Firefox"
      }, n0 = s.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/electron/i],
    describe(t0) {
      const e0 = {
        name: "Electron"
      }, n0 = s.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(t0) {
      const e0 = {
        name: "Miui"
      }, n0 = s.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/chromium/i],
    describe(t0) {
      const e0 = {
        name: "Chromium"
      }, n0 = s.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, t0) || s.getFirstMatch(o$2, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(t0) {
      const e0 = {
        name: "Chrome"
      }, n0 = s.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  {
    test: [/GSA/i],
    describe(t0) {
      const e0 = {
        name: "Google Search"
      }, n0 = s.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  /* Android Browser */
  {
    test(t0) {
      const e0 = !t0.test(/like android/i), n0 = t0.test(/android/i);
      return e0 && n0;
    },
    describe(t0) {
      const e0 = {
        name: "Android Browser"
      }, n0 = s.getFirstMatch(o$2, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(t0) {
      const e0 = {
        name: "PlayStation 4"
      }, n0 = s.getFirstMatch(o$2, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(t0) {
      const e0 = {
        name: "Safari"
      }, n0 = s.getFirstMatch(o$2, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(t0) {
      const e0 = /^(.*)\/(.*) /, n0 = /^(.*)\/(.*)[ \t]\((.*)/, r0 = t0.search("\\(") !== -1 ? n0 : e0;
      return {
        name: s.getFirstMatch(r0, t0),
        version: s.getSecondMatch(r0, t0)
      };
    }
  }
], Ae$1 = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(t0) {
      const e0 = s.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, t0);
      return {
        name: m$2.Roku,
        version: e0
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(t0) {
      const e0 = s.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, t0);
      return {
        name: m$2.WindowsPhone,
        version: e0
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(t0) {
      const e0 = s.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, t0), n0 = s.getWindowsVersionName(e0);
      return {
        name: m$2.Windows,
        version: e0,
        versionName: n0
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(t0) {
      const e0 = {
        name: m$2.iOS
      }, n0 = s.getSecondMatch(/(Version\/)(\d[\d.]+)/, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(t0) {
      const e0 = s.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, t0).replace(/[_\s]/g, "."), n0 = s.getMacOSVersionName(e0), r0 = {
        name: m$2.MacOS,
        version: e0
      };
      return n0 && (r0.versionName = n0), r0;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(t0) {
      const e0 = s.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, t0).replace(/[_\s]/g, ".");
      return {
        name: m$2.iOS,
        version: e0
      };
    }
  },
  /* Android */
  {
    test(t0) {
      const e0 = !t0.test(/like android/i), n0 = t0.test(/android/i);
      return e0 && n0;
    },
    describe(t0) {
      const e0 = s.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, t0), n0 = s.getAndroidVersionName(e0), r0 = {
        name: m$2.Android,
        version: e0
      };
      return n0 && (r0.versionName = n0), r0;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(t0) {
      const e0 = s.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, t0), n0 = {
        name: m$2.WebOS
      };
      return e0 && e0.length && (n0.version = e0), n0;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(t0) {
      const e0 = s.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, t0) || s.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, t0) || s.getFirstMatch(/\bbb(\d+)/i, t0);
      return {
        name: m$2.BlackBerry,
        version: e0
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(t0) {
      const e0 = s.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, t0);
      return {
        name: m$2.Bada,
        version: e0
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(t0) {
      const e0 = s.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, t0);
      return {
        name: m$2.Tizen,
        version: e0
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: m$2.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: m$2.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(t0) {
      const e0 = s.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, t0);
      return {
        name: m$2.PlayStation4,
        version: e0
      };
    }
  }
], Oe$2 = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(t0) {
      const e0 = s.getFirstMatch(/(can-l01)/i, t0) && "Nova", n0 = {
        type: u$1.mobile,
        vendor: "Huawei"
      };
      return e0 && (n0.model = e0), n0;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: u$1.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: u$1.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: u$1.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: u$1.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: u$1.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: u$1.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(t0) {
      const e0 = t0.test(/ipod|iphone/i), n0 = t0.test(/like (ipod|iphone)/i);
      return e0 && !n0;
    },
    describe(t0) {
      const e0 = s.getFirstMatch(/(ipod|iphone)/i, t0);
      return {
        type: u$1.mobile,
        vendor: "Apple",
        model: e0
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: u$1.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: u$1.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(t0) {
      return t0.getBrowserName(!0) === "blackberry";
    },
    describe() {
      return {
        type: u$1.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(t0) {
      return t0.getBrowserName(!0) === "bada";
    },
    describe() {
      return {
        type: u$1.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(t0) {
      return t0.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: u$1.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(t0) {
      const e0 = Number(String(t0.getOSVersion()).split(".")[0]);
      return t0.getOSName(!0) === "android" && e0 >= 3;
    },
    describe() {
      return {
        type: u$1.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(t0) {
      return t0.getOSName(!0) === "android";
    },
    describe() {
      return {
        type: u$1.mobile
      };
    }
  },
  /* desktop */
  {
    test(t0) {
      return t0.getOSName(!0) === "macos";
    },
    describe() {
      return {
        type: u$1.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(t0) {
      return t0.getOSName(!0) === "windows";
    },
    describe() {
      return {
        type: u$1.desktop
      };
    }
  },
  /* Linux */
  {
    test(t0) {
      return t0.getOSName(!0) === "linux";
    },
    describe() {
      return {
        type: u$1.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(t0) {
      return t0.getOSName(!0) === "playstation 4";
    },
    describe() {
      return {
        type: u$1.tv
      };
    }
  },
  /* Roku */
  {
    test(t0) {
      return t0.getOSName(!0) === "roku";
    },
    describe() {
      return {
        type: u$1.tv
      };
    }
  }
], Ne$2 = [
  /* EdgeHTML */
  {
    test(t0) {
      return t0.getBrowserName(!0) === "microsoft edge";
    },
    describe(t0) {
      if (/\sedg\//i.test(t0))
        return {
          name: M$3.Blink
        };
      const e0 = s.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, t0);
      return {
        name: M$3.EdgeHTML,
        version: e0
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(t0) {
      const e0 = {
        name: M$3.Trident
      }, n0 = s.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  /* Presto */
  {
    test(t0) {
      return t0.test(/presto/i);
    },
    describe(t0) {
      const e0 = {
        name: M$3.Presto
      }, n0 = s.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  /* Gecko */
  {
    test(t0) {
      const e0 = t0.test(/gecko/i), n0 = t0.test(/like gecko/i);
      return e0 && !n0;
    },
    describe(t0) {
      const e0 = {
        name: M$3.Gecko
      }, n0 = s.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: M$3.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(t0) {
      const e0 = {
        name: M$3.WebKit
      }, n0 = s.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, t0);
      return n0 && (e0.version = n0), e0;
    }
  }
];
let j$3 = class {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(e0, n0 = !1) {
    if (e0 == null || e0 === "")
      throw new Error("UserAgent parameter can't be empty");
    this._ua = e0, this.parsedResult = {}, n0 !== !0 && this.parse();
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(e0) {
    return e0.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const e0 = s.find(ke$2, (n0) => {
      if (typeof n0.test == "function")
        return n0.test(this);
      if (n0.test instanceof Array)
        return n0.test.some((r0) => this.test(r0));
      throw new Error("Browser's test function is not valid");
    });
    return e0 && (this.parsedResult.browser = e0.describe(this.getUA())), this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(e0) {
    return e0 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const e0 = s.find(Ae$1, (n0) => {
      if (typeof n0.test == "function")
        return n0.test(this);
      if (n0.test instanceof Array)
        return n0.test.some((r0) => this.test(r0));
      throw new Error("Browser's test function is not valid");
    });
    return e0 && (this.parsedResult.os = e0.describe(this.getUA())), this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS  macOS, Windows, Linux, etc.
   */
  getOSName(e0) {
    const { name: n0 } = this.getOS();
    return e0 ? String(n0).toLowerCase() || "" : n0 || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(e0 = !1) {
    const { type: n0 } = this.getPlatform();
    return e0 ? String(n0).toLowerCase() || "" : n0 || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const e0 = s.find(Oe$2, (n0) => {
      if (typeof n0.test == "function")
        return n0.test(this);
      if (n0.test instanceof Array)
        return n0.test.some((r0) => this.test(r0));
      throw new Error("Browser's test function is not valid");
    });
    return e0 && (this.parsedResult.platform = e0.describe(this.getUA())), this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(e0) {
    return e0 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const e0 = s.find(Ne$2, (n0) => {
      if (typeof n0.test == "function")
        return n0.test(this);
      if (n0.test instanceof Array)
        return n0.test.some((r0) => this.test(r0));
      throw new Error("Browser's test function is not valid");
    });
    return e0 && (this.parsedResult.engine = e0.describe(this.getUA())), this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return s.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(e0) {
    const n0 = {};
    let r0 = 0;
    const i0 = {};
    let o0 = 0;
    if (Object.keys(e0).forEach((s0) => {
      const a0 = e0[s0];
      typeof a0 == "string" ? (i0[s0] = a0, o0 += 1) : typeof a0 == "object" && (n0[s0] = a0, r0 += 1);
    }), r0 > 0) {
      const s0 = Object.keys(n0), a0 = s.find(s0, (l0) => this.isOS(l0));
      if (a0) {
        const l0 = this.satisfies(n0[a0]);
        if (l0 !== void 0)
          return l0;
      }
      const c0 = s.find(
        s0,
        (l0) => this.isPlatform(l0)
      );
      if (c0) {
        const l0 = this.satisfies(n0[c0]);
        if (l0 !== void 0)
          return l0;
      }
    }
    if (o0 > 0) {
      const s0 = Object.keys(i0), a0 = s.find(s0, (c0) => this.isBrowser(c0, !0));
      if (a0 !== void 0)
        return this.compareVersion(i0[a0]);
    }
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(e0, n0 = !1) {
    const r0 = this.getBrowserName().toLowerCase();
    let i0 = e0.toLowerCase();
    const o0 = s.getBrowserTypeByAlias(i0);
    return n0 && o0 && (i0 = o0.toLowerCase()), i0 === r0;
  }
  compareVersion(e0) {
    let n0 = [0], r0 = e0, i0 = !1;
    const o0 = this.getBrowserVersion();
    if (typeof o0 == "string")
      return e0[0] === ">" || e0[0] === "<" ? (r0 = e0.substr(1), e0[1] === "=" ? (i0 = !0, r0 = e0.substr(2)) : n0 = [], e0[0] === ">" ? n0.push(1) : n0.push(-1)) : e0[0] === "=" ? r0 = e0.substr(1) : e0[0] === "~" && (i0 = !0, r0 = e0.substr(1)), n0.indexOf(
        s.compareVersions(o0, r0, i0)
      ) > -1;
  }
  isOS(e0) {
    return this.getOSName(!0) === String(e0).toLowerCase();
  }
  isPlatform(e0) {
    return this.getPlatformType(!0) === String(e0).toLowerCase();
  }
  isEngine(e0) {
    return this.getEngineName(!0) === String(e0).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(e0, n0 = !1) {
    return this.isBrowser(e0, n0) || this.isOS(e0) || this.isPlatform(e0);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(e0 = []) {
    return e0.some((n0) => this.is(n0));
  }
};
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
let Ce$2 = class {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(e0, n0 = !1) {
    if (typeof e0 != "string")
      throw new Error("UserAgent should be a string");
    return new j$3(e0, n0);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(e0) {
    return new j$3(e0).getResult();
  }
  static get BROWSER_MAP() {
    return D$2;
  }
  static get ENGINE_MAP() {
    return M$3;
  }
  static get OS_MAP() {
    return m$2;
  }
  static get PLATFORMS_MAP() {
    return u$1;
  }
};
const V$2 = typeof window < "u" ? window : null;
function Pe$2() {
  if (!V$2)
    return null;
  switch (Ce$2.getParser(V$2.navigator.userAgent).getBrowserName()?.toLowerCase()) {
    case "firefox":
      return "firefox";
    case "microsoft edge":
      return "edge";
    case "android browser":
    case "chrome":
    case "chromium":
    case "electron":
    case "opera":
    case "vivaldi":
      return "chrome";
    default:
      return null;
  }
}
function G$2(t0, e0, n0) {
  let r0 = n0;
  r0 || (r0 = Pe$2());
  const i0 = S$1(
    t0
  ), o0 = C$3(t0), s0 = e0?.find(
    (a0) => a0.id === (i0.id === "argentMobile" ? "argentX" : i0.id)
  )?.downloads;
  return {
    name: o0 ? t0.name : i0.name,
    id: i0.id,
    icon: o0 ? t0.icon : i0.icon,
    connector: t0,
    installed: !0,
    title: "title" in i0 && N$3(i0.title) ? i0.title : void 0,
    subtitle: "subtitle" in i0 && N$3(i0.subtitle) ? i0.subtitle : void 0,
    download: s0?.[r0],
    downloads: s0
  };
}
const Ve$2 = ({
  availableConnectors: t0,
  installedWallets: e0,
  discoveryWallets: n0,
  storeVersion: r0,
  customOrder: i0
}) => {
  if (q$3())
    return [];
  const o0 = e0.map(
    (s0) => Fe$2(t0, s0.id)
  );
  return (i0 ? t0 : [
    ...t0.filter(
      (s0) => o0.includes(S$1(s0))
    ),
    ...t0.filter(
      (s0) => !o0.includes(S$1(s0))
    )
  ]).map((s0) => {
    const a0 = C$3(s0), c0 = S$1(s0), l0 = e0.find((d0) => d0.id === c0?.id);
    if (l0) {
      let d0, h0;
      a0 ? (d0 = s0.icon, h0 = s0.name) : (d0 = l0.id === "argentX" ? { light: b$3, dark: b$3 } : N$3(l0.icon) ? { light: l0.icon, dark: l0.icon } : l0.icon, h0 = l0.id === "argentX" ? "Ready Wallet (formerly Argent)" : l0.name);
      const g0 = n0.find(
        (w0) => w0.id === (l0.id === "argentMobile" ? "argentX" : c0?.id)
      )?.downloads;
      return {
        name: h0,
        id: l0.id,
        icon: d0,
        connector: s0,
        installed: !0,
        download: g0?.[r0],
        downloads: g0
      };
    }
    const u0 = n0.filter(
      (d0) => !!d0.downloads[r0]
    ).find((d0) => d0.id === c0?.id);
    if (u0) {
      const { downloads: d0 } = u0, h0 = u0.id === "argentX" ? b$3 : u0.icon;
      return {
        name: u0.name,
        id: u0.id,
        icon: { light: h0, dark: h0 },
        connector: s0,
        installed: !1,
        download: d0[r0],
        downloads: d0
      };
    }
    return !c0 || !c0.id || !c0.name ? null : G$2(s0, n0);
  }).filter((s0) => s0 !== null);
};
let Re$2 = class extends M$5 {
  constructor(e0) {
    super(), A$3(this, "_wallet", null), A$3(this, "_options"), this._options = e0;
  }
  available() {
    return !0;
  }
  async ready() {
    if (!this._wallet)
      return !1;
    try {
      return (await this._wallet.request({
        type: "wallet_getPermissions"
      })).includes(A$5.ACCOUNTS);
    } catch {
      return !1;
    }
  }
  get id() {
    return "argentMobile";
  }
  get name() {
    return "Ready (formerly Argent)";
  }
  get icon() {
    return {
      dark: I$1,
      light: I$1
    };
  }
  get wallet() {
    if (!this._wallet)
      throw new S$4();
    return this._wallet;
  }
  async connect(e0 = {}) {
    if (await this.ensureWallet({ onlyQRCode: e0?.onlyQRCode }), !this._wallet)
      throw new R$1();
    const n0 = await this._wallet.request({
      type: "wallet_requestAccounts"
    }), r0 = await this.chainId();
    return {
      account: n0[0],
      chainId: r0
    };
  }
  async disconnect() {
    if (await this._wallet.disable(), T$1(), !this.available() && !this._wallet)
      throw new R$1();
    this._wallet = null;
  }
  async account(e0) {
    if (!this._wallet)
      throw new S$4();
    const n0 = await this._wallet.request({
      type: "wallet_requestAccounts",
      params: { silent_mode: !0 }
    });
    return new WalletAccount(e0, this._wallet, void 0, n0[0]);
  }
  async chainId() {
    if (!this._wallet)
      throw new S$4();
    const e0 = await this._wallet.request({
      type: "wallet_requestChainId"
    }), n0 = Ra$1(e0);
    return BigInt(n0);
  }
  async request(e0) {
    if (!this._wallet)
      throw new S$4();
    try {
      return await this._wallet.request(e0);
    } catch {
      throw new T$3();
    }
  }
  // needed, methods required by starknet-react. Otherwise an exception is throwd
  async initEventListener(e0) {
    if (!this._wallet)
      throw new S$4();
    this._wallet.on("accountsChanged", e0);
  }
  // needed, methods required by starknet-react. Otherwise an exception is throwd
  async removeEventListener(e0) {
    if (!this._wallet)
      throw new S$4();
    this._wallet.off("accountsChanged", e0), this._wallet = null;
  }
  async ensureWallet(e0) {
    const { getStarknetWindowObject: n0 } = await import("./index-13155a46-75a5461c.js"), { chainId: r0, projectId: i0, dappName: o0, description: s0, url: a0, icons: c0, rpcUrl: l0 } = this._options, u0 = re$3(), d0 = l0 ?? (!r0 || r0 === constants.NetworkName.SN_MAIN ? u0.mainnet : u0.testnet), h0 = (await main.getDiscoveryWallets()).map((E0) => E0.id.toLowerCase() === "argentx" ? {
      ...E0,
      name: "Ready Wallet (formerly Argent)"
    } : E0), g0 = {
      onlyQRCode: e0?.onlyQRCode,
      chainId: r0 ?? constants.NetworkName.SN_MAIN,
      name: o0,
      projectId: i0 ?? L$2,
      description: s0,
      url: a0,
      icons: c0,
      rpcUrl: d0,
      modalWallet: G$2(this, h0)
    };
    i0 === L$2 && (console.log("========= NOTICE ========="), console.log(
      "While your application will continue to function, we highly recommended"
    ), console.log("signing up for your own API keys."), console.log(
      "Go to WalletConnect Cloud (https://cloud.walletconnect.com) and create a new account."
    ), console.log(
      "Once your account is created, create a new project and collect the Project ID"
    ), console.log("=========================="));
    const w0 = await n0(g0);
    if (!w0)
      throw new T$3();
    this._wallet = w0;
    const y0 = this._wallet;
    await y0.enable(), y0.client.on("session_delete", () => {
      T$1(), this._wallet = null, W$4(), document.dispatchEvent(new Event("wallet_disconnected"));
    });
  }
}, n$3 = class extends L$3 {
  constructor(e0) {
    super({ options: { id: "braavos", ...e0 } });
  }
};
var vr$1 = Object.defineProperty, yr$1 = (t0, e0, n0) => e0 in t0 ? vr$1(t0, e0, { enumerable: !0, configurable: !0, writable: !0, value: n0 }) : t0[e0] = n0, Bt$2 = (t0, e0, n0) => (yr$1(t0, typeof e0 != "symbol" ? e0 + "" : e0, n0), n0), Q$2 = /* @__PURE__ */ ((t0) => (t0.walletList = "walletList", t0.connecting = "connecting", t0.success = "success", t0.loginFailure = "loginFailure", t0.requestFailure = "requestFailure", t0.qrCode = "qrCode", t0.download = "download", t0.approval = "approval", t0))(Q$2 || {});
const $r$1 = `@import"https://fonts.googleapis.com/css2?family=Barlow:wght@500;600&display=swap";.visible{visibility:visible}.static{position:static}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.inset-0{inset:0}.left-0{left:0}.right-0{right:0}.top-0{top:0}.z-\\[9998\\]{z-index:9998}.z-\\[9999\\]{z-index:9999}.mx-6{margin-left:1.5rem;margin-right:1.5rem}.mb-4{margin-bottom:1rem}.ml-\\[-32px\\]{margin-left:-32px}.block{display:block}.inline-block{display:inline-block}.inline{display:inline}.flex{display:flex}.inline-flex{display:inline-flex}.table{display:table}.hidden{display:none}.h-8{height:2rem}.h-\\[245px\\]{height:245px}.h-\\[32px\\]{height:32px}.h-\\[60px\\]{height:60px}.h-full{height:100%}.min-h-12{min-height:3rem}.min-h-8{min-height:2rem}.min-h-\\[570px\\]{min-height:570px}.w-8{width:2rem}.w-full{width:100%}.min-w-\\[140px\\]{min-width:140px}.max-w-\\[240px\\]{max-width:240px}.max-w-\\[32px\\]{max-width:32px}.max-w-\\[380px\\]{max-width:380px}.flex-shrink{flex-shrink:1}.flex-grow{flex-grow:1}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.cursor-pointer{cursor:pointer}.resize{resize:both}.flex-row{flex-direction:row}.flex-row-reverse{flex-direction:row-reverse}.flex-col{flex-direction:column}.items-end{align-items:flex-end}.items-center{align-items:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-1{gap:.25rem}.gap-2{gap:.5rem}.gap-3{gap:.75rem}.gap-4{gap:1rem}.gap-8{gap:2rem}.overflow-hidden{overflow:hidden}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.rounded{border-radius:.25rem}.rounded-3xl{border-radius:1.5rem}.rounded-\\[12px\\]{border-radius:12px}.rounded-full{border-radius:9999px}.rounded-xl{border-radius:.75rem}.border{border-width:1px}.border-stroke-default{border-color:var(--color-stroke-default)}.border-stroke-focused{border-color:var(--color-stroke-focused)}.bg-black\\/25{background-color:#00000040}.bg-button-secondary{background-color:var(--color-button-secondary)}.bg-surface-default{background-color:var(--color-surface-default)}.bg-surface-elevated{background-color:var(--color-surface-elevated)}.bg-surface-elevated-web{background-color:var(--color-surface-elevated-web)}.stroke-brand{stroke:var(--color-text-brand)}.stroke-danger{stroke:var(--color-text-danger)}.stroke-subtle{stroke:var(--color-text-subtle)}.p-2{padding:.5rem}.p-5{padding:1.25rem}.p-6{padding:1.5rem}.px-3{padding-left:.75rem;padding-right:.75rem}.px-4{padding-left:1rem;padding-right:1rem}.py-3{padding-top:.75rem;padding-bottom:.75rem}.text-left{text-align:left}.text-center{text-align:center}.text-\\[13px\\]{font-size:13px}.text-\\[15px\\]{font-size:15px}.text-\\[24px\\]{font-size:24px}.text-b3{font-size:.8125rem;line-height:.875rem;font-weight:600}.text-h4{font-size:1.375rem;line-height:1.5625rem;font-weight:700}.text-h5,.text-heading5{font-size:1.125rem;line-height:1.375rem;font-weight:600}.text-l1{font-size:.875rem;line-height:1.125rem;font-weight:400}.text-l2{font-size:.75rem;line-height:1rem;font-weight:400}.text-p3{font-size:1rem;line-height:1.3125rem;font-weight:400}.font-\\[400\\]{font-weight:400}.font-bold{font-weight:700}.font-semibold{font-weight:600}.capitalize{text-transform:capitalize}.text-brand{color:var(--color-text-brand)}.text-danger{color:var(--color-text-danger)}.text-danger-accessible{color:var(--color-text-danger-accessible)}.text-info{color:var(--color-text-info)}.text-info-accessible{color:var(--color-text-info-accessible)}.text-link{color:var(--color-text-link)}.text-primary{color:var(--color-text-primary)}.text-secondary{color:var(--color-text-secondary)}.text-secondary-web{color:var(--color-text-secondary-web)}.text-stable{color:var(--color-text-stable)}.text-subtle{color:var(--color-text-subtle)}.text-success{color:var(--color-text-success)}.text-success-accessible{color:var(--color-text-success-accessible)}.text-warning{color:var(--color-text-warning)}.text-warning-accessible{color:var(--color-text-warning-accessible)}.underline{text-decoration-line:underline}.line-through{text-decoration-line:line-through}.accent-brand{accent-color:var(--color-text-brand)}.shadow{--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1);--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-list-item{--tw-shadow: 0px 4px 12px 0px rgba(0, 0, 0, .06);--tw-shadow-colored: 0px 4px 12px 0px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-modal{--tw-shadow: 0px 4px 20px rgba(0, 0, 0, .5);--tw-shadow-colored: 0px 4px 20px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline{outline-style:solid}.blur{--tw-blur: blur(8px);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.drop-shadow{--tw-drop-shadow: drop-shadow(0 1px 2px rgb(0 0 0 / .1)) drop-shadow(0 1px 1px rgb(0 0 0 / .06));filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.backdrop-blur-sm{--tw-backdrop-blur: blur(4px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.ease-in{transition-timing-function:cubic-bezier(.4,0,1,1)}.ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}.ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}.container{width:100%}@media (min-width: 640px){.container{max-width:640px}}@media (min-width: 768px){.container{max-width:768px}}@media (min-width: 1024px){.container{max-width:1024px}}@media (min-width: 1280px){.container{max-width:1280px}}@media (min-width: 1536px){.container{max-width:1536px}}*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }:root,:host{--color-50: 255, 255, 255, .5;--color-400: 140 140 140;--color-800: 38 38 38;--color-900: 31 31 31;--color-accessible-orange: 243 106 61;--color-black-100: 0 0 0;--color-black-50: 0, 0, 0, .5;--color-black-30: 0, 0, 0, .3;--color-black-6: 0, 0, 0, .06;--color-black-4: 0, 0, 0, .04;--color-black-12: 0, 0, 0, .12;--color-black-0: 0, 0, 0, 0;--color-deprecated-accent-accessible-green: 2 161 122;--color-deprecated-accent-accessible-yellow: 255 171 0;--color-deprecated-accent-green: 44 211 169;--color-deprecated-accent-hot-pink: 255 91 129;--color-deprecated-accent-yellow: 255 191 61;--color-deprecated-black: 0 0 0;--color-deprecated-neutrals-100: 249 249 249;--color-deprecated-neutrals-200: 240 240 240;--color-deprecated-neutrals-300: 191 191 191;--color-deprecated-neutrals-500: 102 102 102;--color-deprecated-neutrals-600: 89 89 89;--color-deprecated-neutrals-700: 64 64 64;--color-deprecated-neutrals-1000: 15 15 15;--color-deprecated-primary-orange: 255 135 91;--color-deprecated-white: 255 255 255;--color-neutrals-100: 249 249 249;--color-neutrals-200: 240 240 240;--color-neutrals-300: 191 191 191;--color-neutrals-400: 140 140 140;--color-neutrals-500: 102 102 102;--color-neutrals-600: 89 89 89;--color-neutrals-700: 64 64 64;--color-neutrals-800: 46 46 46;--color-neutrals-900: 36 36 36;--color-neutrals-1000: 23 23 23;--color-primary-blue-200: 203 241 255;--color-primary-blue-400: 41 197 255;--color-primary-blue-600: 0 157 214;--color-primary-blue-800: 0 120 164;--color-primary-blue-1000: 7 49 68;--color-primary-green-200: 206 255 243;--color-primary-green-400: 44 211 169;--color-primary-green-600: 2 161 122;--color-primary-green-800: 10 77 59;--color-primary-green-1000: 4 36 16;--color-primary-orange-200: 255 203 184;--color-primary-orange-400: 255 135 91;--color-primary-orange-600: 243 106 61;--color-primary-orange-800: 128 56 32;--color-primary-orange-1000: 55 23 9;--color-primary-orange-300: 255 158 122;--color-primary-orange-18: 255, 135, 91, .18;--color-primary-orange-6: 255, 135, 91, .06;--color-primary-red-200: 255 221 225;--color-primary-red-400: 233 95 114;--color-primary-red-600: 219 59 78;--color-primary-red-800: 99 9 21;--color-primary-red-1000: 51 1 5;--color-primary-red-dark: 193 32 38;--color-primary-yellow-200: 252 239 211;--color-primary-yellow-400: 255 191 61;--color-primary-yellow-600: 255 171 0;--color-primary-yellow-800: 241 159 0;--color-primary-yellow-1000: 63 45 12;--color-secondary-clementine: 255 168 92;--color-secondary-coral: 255 103 92;--color-secondary-hot-pink: 255 91 129;--color-secondary-sky-blue: 41 197 255;--color-white-100: 255 255 255;--color-white-50: 255, 255, 255, .5;--color-white-30: 255, 255, 255, .3;--color-white-12: 255, 255, 255, .12;--color-white-6: 255, 255, 255, .06;--color-white-18: 255, 255, 255, .18;--color-white-0: 255, 255, 255, 0;--color-accent-blue: rgba(var(--color-primary-blue-600));--color-accent-brand: rgba(var(--color-primary-orange-400));--color-accent-coral: rgba(var(--color-secondary-coral));--color-accent-green: rgba(var(--color-primary-green-400));--color-accent-hot-pink: rgba(var(--color-secondary-hot-pink));--color-accent-orange: rgba(var(--color-secondary-clementine));--color-accent-red: rgba(var(--color-primary-red-600));--color-accent-sky-blue: rgba(var(--color-secondary-sky-blue));--color-accent-yellow: rgba(var(--color-primary-yellow-400));--color-button-danger: rgba(var(--color-primary-red-600));--color-button-danger-hover: rgba(var(--color-primary-red-400));--color-button-info: rgba(var(--color-primary-blue-800));--color-button-info-hover: rgba(var(--color-primary-blue-600));--color-button-pressed-overlay: rgba(var(--color-black-12));--color-button-primary: rgba(var(--color-primary-orange-400));--color-button-primary-hover: rgba(var(--color-primary-orange-300));--color-button-secondary: rgba(var(--color-black-6));--color-button-secondary-hover: rgba(var(--color-black-12));--color-button-tertiary: rgba(var(--color-black-0));--color-button-tertiary-hover: rgba(var(--color-primary-orange-6));--color-button-tertiary-pressed: rgba(var(--color-primary-orange-18));--color-button-warning: rgba(var(--color-primary-yellow-800));--color-button-warning-hover: rgba(var(--color-primary-yellow-400));--color-icon-adaptive: rgba(var(--color-white-100));--color-icon-background: rgba(var(--color-black-6));--color-icon-background-brand: rgba(var(--color-primary-orange-400));--color-icon-brand: rgba(var(--color-primary-orange-600));--color-icon-danger: rgba(var(--color-primary-red-600));--color-icon-default: rgba(var(--color-neutrals-700));--color-icon-info: rgba(var(--color-primary-blue-600));--color-icon-secondary: rgba(var(--color-neutrals-400));--color-icon-stable: rgba(var(--color-white-100));--color-icon-subtle: rgba(var(--color-neutrals-300));--color-icon-success: rgba(var(--color-primary-green-600));--color-icon-warning: rgba(var(--color-primary-yellow-800));--color-ios-icon: rgb(80, 85, 92);--color-ios-keyboard-button: rgb(0, 122, 255);--color-ios-primary: rgb(0, 122, 255);--color-ios-surface-dark: rgb(172, 180, 190);--color-ios-surface-default: rgba(210, 213, 219, .9);--color-ios-surface-elevated: rgb(255, 255, 255);--color-ios-text: rgb(0, 0, 0);--color-ios-text-inverted: rgb(255, 255, 255);--color-shadow-default: rgba(var(--color-black-6));--color-shadow-strong: rgba(var(--color-black-30));--color-stroke-brand: rgba(var(--color-primary-orange-600));--color-stroke-danger: rgba(var(--color-primary-red-600));--color-stroke-default: rgba(var(--color-neutrals-200));--color-stroke-default-web: rgba(var(--color-neutrals-200));--color-stroke-focused: rgba(var(--color-black-30));--color-stroke-subtle: rgba(var(--color-black-6));--color-surface-brand: rgba(var(--color-primary-orange-400));--color-surface-danger-default: rgba(var(--color-primary-red-200));--color-surface-danger-vibrant: rgba(var(--color-primary-red-600));--color-surface-default: rgba(var(--color-neutrals-100));--color-surface-default-web: rgba(var(--color-neutrals-100));--color-surface-elevated: rgba(var(--color-white-100));--color-surface-elevated-web: rgba(var(--color-neutrals-200));--color-surface-info-default: rgba(var(--color-primary-blue-200));--color-surface-info-vibrant: rgba(var(--color-primary-blue-400));--color-surface-input: rgba(var(--color-black-4));--color-surface-inverted: rgba(var(--color-black-100));--color-surface-match-mode: rgba(var(--color-white-100));--color-surface-pressed-overlay: rgba(var(--color-black-12));--color-surface-stable-dark: rgba(var(--color-black-100));--color-surface-stable-light: rgba(var(--color-white-100));--color-surface-success-default: rgba(var(--color-primary-green-200));--color-surface-success-vibrant: rgba(var(--color-primary-green-400));--color-surface-sunken: rgba(var(--color-neutrals-200));--color-surface-text: rgba(var(--color-primary-orange-200));--color-surface-transparent: rgba(var(--color-black-6));--color-surface-warning-default: rgba(var(--color-primary-yellow-200));--color-surface-warning-vibrant: rgba(var(--color-primary-yellow-800));--color-text-brand: rgba(var(--color-primary-orange-600));--color-text-danger: rgba(var(--color-primary-red-600));--color-text-danger-accessible: rgba(var(--color-primary-red-1000));--color-text-info: rgba(var(--color-primary-blue-600));--color-text-info-accessible: rgba(var(--color-primary-blue-1000));--color-text-link: rgba(var(--color-primary-blue-600));--color-text-primary: rgba(var(--color-neutrals-700));--color-text-secondary: rgba(var(--color-neutrals-400));--color-text-secondary-web: rgba(var(--color-neutrals-500));--color-text-stable: rgba(var(--color-white-100));--color-text-subtle: rgba(var(--color-neutrals-300));--color-text-success: rgba(var(--color-primary-green-600));--color-text-success-accessible: rgba(var(--color-primary-green-1000));--color-text-warning: rgba(var(--color-primary-yellow-800));--color-text-warning-accessible: rgba(var(--color-primary-yellow-1000))}.dark{--color-accent-blue: rgba(var(--color-primary-blue-600));--color-accent-brand: rgba(var(--color-primary-orange-600));--color-accent-coral: rgba(var(--color-secondary-coral));--color-accent-green: rgba(var(--color-primary-green-600));--color-accent-hot-pink: rgba(var(--color-secondary-hot-pink));--color-accent-orange: rgba(var(--color-secondary-clementine));--color-accent-red: rgba(var(--color-primary-red-dark));--color-accent-sky-blue: rgba(var(--color-primary-blue-400));--color-accent-yellow: rgba(var(--color-primary-yellow-600));--color-button-danger: rgba(var(--color-primary-red-600));--color-button-danger-hover: rgba(var(--color-primary-red-400));--color-button-info: rgba(var(--color-primary-blue-800));--color-button-info-hover: rgba(var(--color-primary-blue-600));--color-button-pressed-overlay: rgba(var(--color-black-12));--color-button-primary: rgba(var(--color-primary-orange-600));--color-button-primary-hover: rgba(var(--color-primary-orange-400));--color-button-secondary: rgba(var(--color-white-12));--color-button-secondary-hover: rgba(var(--color-white-18));--color-button-tertiary: rgba(var(--color-white-0));--color-button-tertiary-hover: rgba(var(--color-primary-orange-6));--color-button-tertiary-pressed: rgba(var(--color-primary-orange-18));--color-button-warning: rgba(var(--color-primary-yellow-600));--color-button-warning-hover: rgba(var(--color-primary-yellow-400));--color-icon-adaptive: rgba(var(--color-neutrals-1000));--color-icon-background: rgba(var(--color-white-12));--color-icon-background-brand: rgba(var(--color-primary-orange-600));--color-icon-brand: rgba(var(--color-primary-orange-400));--color-icon-danger: rgba(var(--color-primary-red-400));--color-icon-default: rgba(var(--color-white-100));--color-icon-info: rgba(var(--color-primary-blue-400));--color-icon-secondary: rgba(var(--color-neutrals-400));--color-icon-stable: rgba(var(--color-white-100));--color-icon-subtle: rgba(var(--color-neutrals-500));--color-icon-success: rgba(var(--color-primary-green-400));--color-icon-warning: rgba(var(--color-primary-yellow-600));--color-ios-icon: rgb(231, 231, 231);--color-ios-keyboard-button: rgb(36, 36, 36);--color-ios-primary: rgb(0, 122, 255);--color-ios-surface-dark: rgb(36, 36, 36);--color-ios-surface-default: rgba(32, 32, 32, .92);--color-ios-surface-elevated: rgb(67, 67, 67);--color-ios-text: rgb(255, 255, 255);--color-ios-text-inverted: rgb(255, 255, 255);--color-shadow-default: rgba(var(--color-black-30));--color-shadow-strong: rgba(var(--color-black-100));--color-stroke-brand: rgba(var(--color-primary-orange-600));--color-stroke-danger: rgba(var(--color-primary-red-400));--color-stroke-default: rgba(var(--color-black-100));--color-stroke-default-web: rgba(var(--color-neutrals-700));--color-stroke-focused: rgba(var(--color-white-30));--color-stroke-subtle: rgba(var(--color-white-12));--color-surface-brand: rgba(var(--color-primary-orange-600));--color-surface-danger-default: rgba(var(--color-primary-red-1000));--color-surface-danger-vibrant: rgba(var(--color-primary-red-600));--color-surface-default: rgba(var(--color-neutrals-1000));--color-surface-default-web: rgba(var(--color-black-100));--color-surface-elevated: rgba(var(--color-neutrals-900));--color-surface-elevated-web: rgba(var(--color-neutrals-900));--color-surface-info-default: rgba(var(--color-primary-blue-1000));--color-surface-info-vibrant: rgba(var(--color-primary-blue-400));--color-surface-input: rgba(var(--color-white-12));--color-surface-inverted: rgba(var(--color-white-100));--color-surface-match-mode: rgba(var(--color-black-100));--color-surface-pressed-overlay: rgba(var(--color-white-18));--color-surface-stable-dark: rgba(var(--color-black-100));--color-surface-stable-light: rgba(var(--color-white-100));--color-surface-success-default: rgba(var(--color-primary-green-800));--color-surface-success-vibrant: rgba(var(--color-primary-green-600));--color-surface-sunken: rgba(var(--color-black-100));--color-surface-text: rgba(var(--color-primary-orange-800));--color-surface-transparent: rgba(var(--color-white-12));--color-surface-warning-default: rgba(var(--color-primary-yellow-1000));--color-surface-warning-vibrant: rgba(var(--color-primary-yellow-600));--color-text-brand: rgba(var(--color-primary-orange-400));--color-text-danger: rgba(var(--color-primary-red-400));--color-text-danger-accessible: rgba(var(--color-primary-red-200));--color-text-info: rgba(var(--color-primary-blue-400));--color-text-info-accessible: rgba(var(--color-primary-blue-200));--color-text-link: rgba(var(--color-primary-blue-400));--color-text-primary: rgba(var(--color-white-100));--color-text-secondary: rgba(var(--color-neutrals-400));--color-text-secondary-web: rgba(var(--color-neutrals-300));--color-text-stable: rgba(var(--color-white-100));--color-text-subtle: rgba(var(--color-neutrals-500));--color-text-success: rgba(var(--color-primary-green-400));--color-text-success-accessible: rgba(var(--color-primary-green-200));--color-text-warning: rgba(var(--color-primary-yellow-600));--color-text-warning-accessible: rgba(var(--color-primary-yellow-200))}.modal-font{font-family:Barlow,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-webkit-text-size-adjust:100%;-moz-text-size-adjust:100%;text-size-adjust:100%;font-feature-settings:"kern"}.l2{color:#8c8c8c;font-size:12px;font-weight:500;line-height:14px;letter-spacing:0;text-align:left}.p{margin:0}.hover\\:bg-button-secondary-hover:hover{background-color:var(--color-button-secondary-hover)}.focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\\:ring-2:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\\:ring-neutral-200:focus{--tw-ring-opacity: 1;--tw-ring-color: rgb(229 229 229 / var(--tw-ring-opacity))}.dark\\:shadow-none:is(.dark *){--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.dark\\:focus\\:ring-neutral-700:focus:is(.dark *){--tw-ring-opacity: 1;--tw-ring-color: rgb(64 64 64 / var(--tw-ring-opacity))}
`, wl$1 = () => {
  const t0 = "starknetkit-modal-container", e0 = document.getElementById(t0);
  if (e0) {
    if (e0.shadowRoot)
      return e0.shadowRoot;
    e0.remove();
  }
  const n0 = document.createElement("div");
  n0.id = t0, document.body.appendChild(n0);
  const r0 = n0.attachShadow({ mode: "open" }), i0 = document.createElement("style");
  return i0.textContent = $r$1, r0.appendChild(i0), r0;
};
function B$2() {
}
function xt$2(t0, e0) {
  for (const n0 in e0)
    t0[n0] = e0[n0];
  return (
    /** @type {T & S} */
    t0
  );
}
function cr$1(t0) {
  return t0();
}
function It$2() {
  return /* @__PURE__ */ Object.create(null);
}
function ke$1(t0) {
  t0.forEach(cr$1);
}
function me$1(t0) {
  return typeof t0 == "function";
}
function U$1(t0, e0) {
  return t0 != t0 ? e0 == e0 : t0 !== e0 || t0 && typeof t0 == "object" || typeof t0 == "function";
}
let vt$2;
function Er$1(t0, e0) {
  return t0 === e0 ? !0 : (vt$2 || (vt$2 = document.createElement("a")), vt$2.href = e0, t0 === vt$2.href);
}
function Nr$1(t0) {
  return Object.keys(t0).length === 0;
}
function we$1(t0, e0, n0, r0) {
  if (t0) {
    const i0 = fr$1(t0, e0, n0, r0);
    return t0[0](i0);
  }
}
function fr$1(t0, e0, n0, r0) {
  return t0[1] && r0 ? xt$2(n0.ctx.slice(), t0[1](r0(e0))) : n0.ctx;
}
function be$1(t0, e0, n0, r0) {
  if (t0[2] && r0) {
    const i0 = t0[2](r0(n0));
    if (e0.dirty === void 0)
      return i0;
    if (typeof i0 == "object") {
      const o0 = [], s0 = Math.max(e0.dirty.length, i0.length);
      for (let a0 = 0; a0 < s0; a0 += 1)
        o0[a0] = e0.dirty[a0] | i0[a0];
      return o0;
    }
    return e0.dirty | i0;
  }
  return e0.dirty;
}
function Ce$1(t0, e0, n0, r0, i0, o0) {
  if (i0) {
    const s0 = fr$1(e0, n0, r0, o0);
    t0.p(s0, i0);
  }
}
function _e$1(t0) {
  if (t0.ctx.length > 32) {
    const e0 = [], n0 = t0.ctx.length / 32;
    for (let r0 = 0; r0 < n0; r0++)
      e0[r0] = -1;
    return e0;
  }
  return -1;
}
function i$4(t0, e0) {
  t0.appendChild(e0);
}
function Zr$1(t0, e0, n0) {
  const r0 = Ar$1(t0);
  if (!r0.getElementById(e0)) {
    const i0 = x$1("style");
    i0.id = e0, i0.textContent = n0, zr$1(r0, i0);
  }
}
function Ar$1(t0) {
  if (!t0)
    return document;
  const e0 = t0.getRootNode ? t0.getRootNode() : t0.ownerDocument;
  return e0 && /** @type {ShadowRoot} */
  e0.host ? (
    /** @type {ShadowRoot} */
    e0
  ) : t0.ownerDocument;
}
function zr$1(t0, e0) {
  return i$4(
    /** @type {Document} */
    t0.head || t0,
    e0
  ), e0.sheet;
}
function $$1(t0, e0, n0) {
  t0.insertBefore(e0, n0 || null);
}
function M$2(t0) {
  t0.parentNode && t0.parentNode.removeChild(t0);
}
function Or$1(t0, e0) {
  for (let n0 = 0; n0 < t0.length; n0 += 1)
    t0[n0] && t0[n0].d(e0);
}
function x$1(t0) {
  return document.createElement(t0);
}
function c$2(t0) {
  return document.createElementNS("http://www.w3.org/2000/svg", t0);
}
function X$2(t0) {
  return document.createTextNode(t0);
}
function K$3() {
  return X$2(" ");
}
function ye$1() {
  return X$2("");
}
function $e$2(t0, e0, n0, r0) {
  return t0.addEventListener(e0, n0, r0), () => t0.removeEventListener(e0, n0, r0);
}
function t$2(t0, e0, n0) {
  n0 == null ? t0.removeAttribute(e0) : t0.getAttribute(e0) !== n0 && t0.setAttribute(e0, n0);
}
const Ur$1 = ["width", "height"];
function Gr$1(t0, e0) {
  const n0 = Object.getOwnPropertyDescriptors(t0.__proto__);
  for (const r0 in e0)
    e0[r0] == null ? t0.removeAttribute(r0) : r0 === "style" ? t0.style.cssText = e0[r0] : r0 === "__value" ? t0.value = t0[r0] = e0[r0] : n0[r0] && n0[r0].set && Ur$1.indexOf(r0) === -1 ? t0[r0] = e0[r0] : t$2(t0, r0, e0[r0]);
}
function Ir$1(t0, e0) {
  Object.keys(e0).forEach((n0) => {
    Wr$1(t0, n0, e0[n0]);
  });
}
function Wr$1(t0, e0, n0) {
  const r0 = e0.toLowerCase();
  r0 in t0 ? t0[r0] = typeof t0[r0] == "boolean" && n0 === "" ? !0 : n0 : e0 in t0 ? t0[e0] = typeof t0[e0] == "boolean" && n0 === "" ? !0 : n0 : t$2(t0, e0, n0);
}
function Ee$1(t0) {
  return /-/.test(t0) ? Ir$1 : Gr$1;
}
function jr$1(t0) {
  return Array.from(t0.childNodes);
}
function ge$1(t0, e0) {
  e0 = "" + e0, t0.data !== e0 && (t0.data = /** @type {string} */
  e0);
}
function xe$1(t0, e0, n0, r0) {
  n0 == null ? t0.style.removeProperty(e0) : t0.style.setProperty(e0, n0, r0 ? "important" : "");
}
function Wt$1(t0, e0) {
  return new t0(e0);
}
let je$2;
function We$2(t0) {
  je$2 = t0;
}
function Dr$1() {
  if (!je$2)
    throw new Error("Function called outside component initialization");
  return je$2;
}
function Vr$1(t0) {
  Dr$1().$$.on_mount.push(t0);
}
const Me$2 = [], Nt$2 = [];
let Se$2 = [];
const jt$1 = [], Rr$1 = /* @__PURE__ */ Promise.resolve();
let Zt$1 = !1;
function Tr$1() {
  Zt$1 || (Zt$1 = !0, Rr$1.then(ur$1));
}
function At$2(t0) {
  Se$2.push(t0);
}
const Mt$2 = /* @__PURE__ */ new Set();
let Be$2 = 0;
function ur$1() {
  if (Be$2 !== 0)
    return;
  const t0 = je$2;
  do {
    try {
      for (; Be$2 < Me$2.length; ) {
        const e0 = Me$2[Be$2];
        Be$2++, We$2(e0), Hr$1(e0.$$);
      }
    } catch (e0) {
      throw Me$2.length = 0, Be$2 = 0, e0;
    }
    for (We$2(null), Me$2.length = 0, Be$2 = 0; Nt$2.length; )
      Nt$2.pop()();
    for (let e0 = 0; e0 < Se$2.length; e0 += 1) {
      const n0 = Se$2[e0];
      Mt$2.has(n0) || (Mt$2.add(n0), n0());
    }
    Se$2.length = 0;
  } while (Me$2.length);
  for (; jt$1.length; )
    jt$1.pop()();
  Zt$1 = !1, Mt$2.clear(), We$2(t0);
}
function Hr$1(t0) {
  if (t0.fragment !== null) {
    t0.update(), ke$1(t0.before_update);
    const e0 = t0.dirty;
    t0.dirty = [-1], t0.fragment && t0.fragment.p(t0.ctx, e0), t0.after_update.forEach(At$2);
  }
}
function Kr$1(t0) {
  const e0 = [], n0 = [];
  Se$2.forEach((r0) => t0.indexOf(r0) === -1 ? e0.push(r0) : n0.push(r0)), n0.forEach((r0) => r0()), Se$2 = e0;
}
const yt$2 = /* @__PURE__ */ new Set();
let ve$1;
function ce$2() {
  ve$1 = {
    r: 0,
    c: [],
    p: ve$1
    // parent group
  };
}
function fe$2() {
  ve$1.r || ke$1(ve$1.c), ve$1 = ve$1.p;
}
function b$2(t0, e0) {
  t0 && t0.i && (yt$2.delete(t0), t0.i(e0));
}
function C$2(t0, e0, n0, r0) {
  if (t0 && t0.o) {
    if (yt$2.has(t0))
      return;
    yt$2.add(t0), ve$1.c.push(() => {
      yt$2.delete(t0), r0 && (n0 && t0.d(1), r0());
    }), t0.o(e0);
  } else
    r0 && r0();
}
function Dt$2(t0) {
  return t0?.length !== void 0 ? t0 : Array.from(t0);
}
function zt$1(t0, e0) {
  const n0 = {}, r0 = {}, i0 = { $$scope: 1 };
  let o0 = t0.length;
  for (; o0--; ) {
    const s0 = t0[o0], a0 = e0[o0];
    if (a0) {
      for (const c0 in s0)
        c0 in a0 || (r0[c0] = 1);
      for (const c0 in a0)
        i0[c0] || (n0[c0] = a0[c0], i0[c0] = 1);
      t0[o0] = a0;
    } else
      for (const c0 in s0)
        i0[c0] = 1;
  }
  for (const s0 in r0)
    s0 in n0 || (n0[s0] = void 0);
  return n0;
}
function A$2(t0) {
  t0 && t0.c();
}
function N$2(t0, e0, n0) {
  const { fragment: r0, after_update: i0 } = t0.$$;
  r0 && r0.m(e0, n0), At$2(() => {
    const o0 = t0.$$.on_mount.map(cr$1).filter(me$1);
    t0.$$.on_destroy ? t0.$$.on_destroy.push(...o0) : ke$1(o0), t0.$$.on_mount = [];
  }), i0.forEach(At$2);
}
function Z$2(t0, e0) {
  const n0 = t0.$$;
  n0.fragment !== null && (Kr$1(n0.after_update), ke$1(n0.on_destroy), n0.fragment && n0.fragment.d(e0), n0.on_destroy = n0.fragment = null, n0.ctx = []);
}
function Pr$1(t0, e0) {
  t0.$$.dirty[0] === -1 && (Me$2.push(t0), Tr$1(), t0.$$.dirty.fill(0)), t0.$$.dirty[e0 / 31 | 0] |= 1 << e0 % 31;
}
function W$1(t0, e0, n0, r0, i0, o0, s0 = null, a0 = [-1]) {
  const c0 = je$2;
  We$2(t0);
  const l0 = t0.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: o0,
    update: B$2,
    not_equal: i0,
    bound: It$2(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(e0.context || (c0 ? c0.$$.context : [])),
    // everything else
    callbacks: It$2(),
    dirty: a0,
    skip_bound: !1,
    root: e0.target || c0.$$.root
  };
  s0 && s0(l0.root);
  let u0 = !1;
  if (l0.ctx = n0 ? n0(t0, e0.props || {}, (d0, h0, ...g0) => {
    const w0 = g0.length ? g0[0] : h0;
    return l0.ctx && i0(l0.ctx[d0], l0.ctx[d0] = w0) && (!l0.skip_bound && l0.bound[d0] && l0.bound[d0](w0), u0 && Pr$1(t0, d0)), h0;
  }) : [], l0.update(), u0 = !0, ke$1(l0.before_update), l0.fragment = r0 ? r0(l0.ctx) : !1, e0.target) {
    if (e0.hydrate) {
      const d0 = jr$1(e0.target);
      l0.fragment && l0.fragment.l(d0), d0.forEach(M$2);
    } else
      l0.fragment && l0.fragment.c();
    e0.intro && b$2(t0.$$.fragment), N$2(t0, e0.target, e0.anchor), ur$1();
  }
  We$2(c0);
}
let j$2 = class {
  constructor() {
    Bt$2(this, "$$"), Bt$2(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    Z$2(this, 1), this.$destroy = B$2;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(e0, n0) {
    if (!me$1(n0))
      return B$2;
    const r0 = this.$$.callbacks[e0] || (this.$$.callbacks[e0] = []);
    return r0.push(n0), () => {
      const i0 = r0.indexOf(n0);
      i0 !== -1 && r0.splice(i0, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(e0) {
    this.$$set && !Nr$1(e0) && (this.$$.skip_bound = !0, this.$$set(e0), this.$$.skip_bound = !1);
  }
};
const qr$1 = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(qr$1);
function St$2(t0) {
  let e0, n0, r0, i0, o0;
  const s0 = (
    /*#slots*/
    t0[7].default
  ), a0 = we$1(
    s0,
    t0,
    /*$$scope*/
    t0[6],
    null
  );
  let c0 = [
    { href: (
      /*href*/
      t0[0]
    ) },
    {
      class: n0 = `
    p-2 cursor-pointer text-primary rounded-full bg-surface-elevated-web
		focus:outline-none focus:ring-2 focus:ring-neutral-200 dark:focus:ring-neutral-700
		transition-colors ${/*className*/
      t0[2]}
  `
    },
    { rel: "noreferrer noopener" },
    { target: "_blank" },
    { role: "button" },
    { tabindex: "0" },
    { "aria-label": (
      /*ariaLabel*/
      t0[1]
    ) }
  ], l0 = {};
  for (let u0 = 0; u0 < c0.length; u0 += 1)
    l0 = xt$2(l0, c0[u0]);
  return {
    c() {
      e0 = x$1(
        /*as*/
        t0[3]
      ), a0 && a0.c(), Ee$1(
        /*as*/
        t0[3]
      )(e0, l0);
    },
    m(u0, d0) {
      $$1(u0, e0, d0), a0 && a0.m(e0, null), r0 = !0, i0 || (o0 = [
        $e$2(e0, "click", function() {
          me$1(
            /*handleClick*/
            t0[4]
          ) && t0[4].apply(this, arguments);
        }),
        $e$2(e0, "keyup", function() {
          me$1(
            /*handleKeyup*/
            t0[5]
          ) && t0[5].apply(this, arguments);
        })
      ], i0 = !0);
    },
    p(u0, d0) {
      t0 = u0, a0 && a0.p && (!r0 || d0 & /*$$scope*/
      64) && Ce$1(
        a0,
        s0,
        t0,
        /*$$scope*/
        t0[6],
        r0 ? be$1(
          s0,
          /*$$scope*/
          t0[6],
          d0,
          null
        ) : _e$1(
          /*$$scope*/
          t0[6]
        ),
        null
      ), Ee$1(
        /*as*/
        t0[3]
      )(e0, l0 = zt$1(c0, [
        (!r0 || d0 & /*href*/
        1) && { href: (
          /*href*/
          t0[0]
        ) },
        (!r0 || d0 & /*className*/
        4 && n0 !== (n0 = `
    p-2 cursor-pointer text-primary rounded-full bg-surface-elevated-web
		focus:outline-none focus:ring-2 focus:ring-neutral-200 dark:focus:ring-neutral-700
		transition-colors ${/*className*/
        t0[2]}
  `)) && { class: n0 },
        { rel: "noreferrer noopener" },
        { target: "_blank" },
        { role: "button" },
        { tabindex: "0" },
        (!r0 || d0 & /*ariaLabel*/
        2) && { "aria-label": (
          /*ariaLabel*/
          t0[1]
        ) }
      ]));
    },
    i(u0) {
      r0 || (b$2(a0, u0), r0 = !0);
    },
    o(u0) {
      C$2(a0, u0), r0 = !1;
    },
    d(u0) {
      u0 && M$2(e0), a0 && a0.d(u0), i0 = !1, ke$1(o0);
    }
  };
}
function Xr$1(t0) {
  let e0 = (
    /*as*/
    t0[3]
  ), n0, r0, i0 = (
    /*as*/
    t0[3] && St$2(t0)
  );
  return {
    c() {
      i0 && i0.c(), n0 = ye$1();
    },
    m(o0, s0) {
      i0 && i0.m(o0, s0), $$1(o0, n0, s0), r0 = !0;
    },
    p(o0, [s0]) {
      o0[3] ? e0 ? U$1(
        e0,
        /*as*/
        o0[3]
      ) ? (i0.d(1), i0 = St$2(o0), e0 = /*as*/
      o0[3], i0.c(), i0.m(n0.parentNode, n0)) : i0.p(o0, s0) : (i0 = St$2(o0), e0 = /*as*/
      o0[3], i0.c(), i0.m(n0.parentNode, n0)) : e0 && (i0.d(1), i0 = null, e0 = /*as*/
      o0[3]);
    },
    i(o0) {
      r0 || (b$2(i0, o0), r0 = !0);
    },
    o(o0) {
      C$2(i0, o0), r0 = !1;
    },
    d(o0) {
      o0 && M$2(n0), i0 && i0.d(o0);
    }
  };
}
function Qr$1(t0, e0, n0) {
  let { $$slots: r0 = {}, $$scope: i0 } = e0, { href: o0 = "" } = e0, { ariaLabel: s0 } = e0, { className: a0 } = e0, { as: c0 = "button" } = e0, { handleClick: l0 = (d0) => console.log("click", d0) } = e0, { handleKeyup: u0 = (d0) => console.log("keyup", d0) } = e0;
  return t0.$$set = (d0) => {
    "href" in d0 && n0(0, o0 = d0.href), "ariaLabel" in d0 && n0(1, s0 = d0.ariaLabel), "className" in d0 && n0(2, a0 = d0.className), "as" in d0 && n0(3, c0 = d0.as), "handleClick" in d0 && n0(4, l0 = d0.handleClick), "handleKeyup" in d0 && n0(5, u0 = d0.handleKeyup), "$$scope" in d0 && n0(6, i0 = d0.$$scope);
  }, [o0, s0, a0, c0, l0, u0, i0, r0];
}
let dr$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, Qr$1, Xr$1, U$1, {
      href: 0,
      ariaLabel: 1,
      className: 2,
      as: 3,
      handleClick: 4,
      handleKeyup: 5
    });
  }
};
function Yr$1(t0) {
  let e0, n0;
  return {
    c() {
      e0 = c$2("svg"), n0 = c$2("path"), t$2(n0, "d", "M9.77275 3.02275C9.99242 2.80308 9.99242 2.44692 9.77275 2.22725C9.55308 2.00758 9.19692 2.00758 8.97725 2.22725L6 5.20451L3.02275 2.22725C2.80308 2.00758 2.44692 2.00758 2.22725 2.22725C2.00758 2.44692 2.00758 2.80308 2.22725 3.02275L5.20451 6L2.22725 8.97725C2.00758 9.19692 2.00758 9.55308 2.22725 9.77275C2.44692 9.99242 2.80308 9.99242 3.02275 9.77275L6 6.79549L8.97725 9.77275C9.19692 9.99242 9.55308 9.99242 9.77275 9.77275C9.99242 9.55308 9.99242 9.19692 9.77275 8.97725L6.79549 6L9.77275 3.02275Z"), t$2(n0, "fill", "currentColor"), t$2(e0, "width", "12"), t$2(e0, "height", "12"), t$2(e0, "viewBox", "0 0 12 12"), t$2(e0, "fill", "none"), t$2(e0, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(r0, i0) {
      $$1(r0, e0, i0), i$4(e0, n0);
    },
    p: B$2,
    i: B$2,
    o: B$2,
    d(r0) {
      r0 && M$2(e0);
    }
  };
}
let Jr$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, null, Yr$1, U$1, {});
  }
};
function e1(t0) {
  let e0, n0;
  return {
    c() {
      e0 = c$2("svg"), n0 = c$2("path"), t$2(n0, "fill-rule", "evenodd"), t$2(n0, "clip-rule", "evenodd"), t$2(n0, "d", "M8.55383 1.24376C8.83406 1.54808 8.81134 2.01905 8.50309 2.2957L4.37567 6L8.50309 9.7043C8.81134 9.98095 8.83406 10.4519 8.55383 10.7562C8.2736 11.0606 7.79654 11.083 7.48828 10.8063L2.74691 6.55102C2.58965 6.40989 2.5 6.20981 2.5 6C2.5 5.79019 2.58965 5.59012 2.74691 5.44898L7.48828 1.19367C7.79654 0.917013 8.2736 0.93944 8.55383 1.24376Z"), t$2(n0, "fill", "currentColor"), t$2(e0, "xmlns", "http://www.w3.org/2000/svg"), t$2(e0, "width", "12"), t$2(e0, "height", "12"), t$2(e0, "viewBox", "0 0 12 12"), t$2(e0, "fill", "none");
    },
    m(r0, i0) {
      $$1(r0, e0, i0), i$4(e0, n0);
    },
    p: B$2,
    i: B$2,
    o: B$2,
    d(r0) {
      r0 && M$2(e0);
    }
  };
}
class t1 extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, null, e1, U$1, {});
  }
}
function Vt$1(t0) {
  let e0, n0;
  return e0 = new dr$1({
    props: {
      handleClick: (
        /*handleBack*/
        t0[4]
      ),
      handleKeyup: (
        /*func*/
        t0[6]
      ),
      ariaLabel: "Go back",
      className: "absolute top-0 left-0",
      $$slots: { default: [r1] },
      $$scope: { ctx: t0 }
    }
  }), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    p(r0, i0) {
      const o0 = {};
      i0 & /*handleBack*/
      16 && (o0.handleClick = /*handleBack*/
      r0[4]), i0 & /*handleBack*/
      16 && (o0.handleKeyup = /*func*/
      r0[6]), i0 & /*$$scope*/
      256 && (o0.$$scope = { dirty: i0, ctx: r0 }), e0.$set(o0);
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function r1(t0) {
  let e0, n0;
  return e0 = new t1({}), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function Rt$2(t0) {
  let e0, n0;
  return {
    c() {
      e0 = x$1("h1"), n0 = X$2(
        /*title*/
        t0[0]
      ), t$2(e0, "class", "text-[24px] text-primary font-semibold max-w-[240px] overflow-hidden whitespace-nowrap text-ellipsis");
    },
    m(r0, i0) {
      $$1(r0, e0, i0), i$4(e0, n0);
    },
    p(r0, i0) {
      i0 & /*title*/
      1 && ge$1(
        n0,
        /*title*/
        r0[0]
      );
    },
    d(r0) {
      r0 && M$2(e0);
    }
  };
}
function Tt$2(t0) {
  let e0, n0;
  return e0 = new dr$1({
    props: {
      handleClick: (
        /*handleClose*/
        t0[5]
      ),
      handleKeyup: (
        /*func_1*/
        t0[7]
      ),
      ariaLabel: "Close",
      className: "absolute top-0 right-0",
      $$slots: { default: [o1] },
      $$scope: { ctx: t0 }
    }
  }), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    p(r0, i0) {
      const o0 = {};
      i0 & /*handleClose*/
      32 && (o0.handleClick = /*handleClose*/
      r0[5]), i0 & /*handleClose*/
      32 && (o0.handleKeyup = /*func_1*/
      r0[7]), i0 & /*$$scope*/
      256 && (o0.$$scope = { dirty: i0, ctx: r0 }), e0.$set(o0);
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function o1(t0) {
  let e0, n0;
  return e0 = new Jr$1({}), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function l1(t0) {
  let e0, n0, r0, i0, o0, s0, a0, c0, l0 = (
    /*showBackButton*/
    t0[2] && Vt$1(t0)
  ), u0 = !!/*title*/
  t0[0] && Rt$2(t0), d0 = (
    /*showCloseButton*/
    t0[3] && Tt$2(t0)
  );
  return {
    c() {
      e0 = x$1("header"), l0 && l0.c(), n0 = K$3(), r0 = x$1("hgroup"), i0 = x$1("h2"), o0 = X$2(
        /*subtitle*/
        t0[1]
      ), s0 = K$3(), u0 && u0.c(), a0 = K$3(), d0 && d0.c(), t$2(i0, "class", "text-p3 text-secondary font-semibold"), t$2(e0, "class", "flex items-center justify-center flex-col relative");
    },
    m(h0, g0) {
      $$1(h0, e0, g0), l0 && l0.m(e0, null), i$4(e0, n0), i$4(e0, r0), i$4(r0, i0), i$4(i0, o0), i$4(r0, s0), u0 && u0.m(r0, null), i$4(e0, a0), d0 && d0.m(e0, null), c0 = !0;
    },
    p(h0, [g0]) {
      h0[2] ? l0 ? (l0.p(h0, g0), g0 & /*showBackButton*/
      4 && b$2(l0, 1)) : (l0 = Vt$1(h0), l0.c(), b$2(l0, 1), l0.m(e0, n0)) : l0 && (ce$2(), C$2(l0, 1, 1, () => {
        l0 = null;
      }), fe$2()), (!c0 || g0 & /*subtitle*/
      2) && ge$1(
        o0,
        /*subtitle*/
        h0[1]
      ), /*title*/
      h0[0] ? u0 ? u0.p(h0, g0) : (u0 = Rt$2(h0), u0.c(), u0.m(r0, null)) : u0 && (u0.d(1), u0 = null), /*showCloseButton*/
      h0[3] ? d0 ? (d0.p(h0, g0), g0 & /*showCloseButton*/
      8 && b$2(d0, 1)) : (d0 = Tt$2(h0), d0.c(), b$2(d0, 1), d0.m(e0, null)) : d0 && (ce$2(), C$2(d0, 1, 1, () => {
        d0 = null;
      }), fe$2());
    },
    i(h0) {
      c0 || (b$2(l0), b$2(d0), c0 = !0);
    },
    o(h0) {
      C$2(l0), C$2(d0), c0 = !1;
    },
    d(h0) {
      h0 && M$2(e0), l0 && l0.d(), u0 && u0.d(), d0 && d0.d();
    }
  };
}
function a1(t0, e0, n0) {
  let { title: r0 } = e0, { subtitle: i0 = "Connect to" } = e0, { showBackButton: o0 = !0 } = e0, { showCloseButton: s0 = !0 } = e0, { handleBack: a0 = () => {
  } } = e0, { handleClose: c0 = () => {
  } } = e0;
  const l0 = (d0) => {
    d0.key === "Enter" && a0();
  }, u0 = (d0) => {
    d0.key === "Enter" && c0();
  };
  return t0.$$set = (d0) => {
    "title" in d0 && n0(0, r0 = d0.title), "subtitle" in d0 && n0(1, i0 = d0.subtitle), "showBackButton" in d0 && n0(2, o0 = d0.showBackButton), "showCloseButton" in d0 && n0(3, s0 = d0.showCloseButton), "handleBack" in d0 && n0(4, a0 = d0.handleBack), "handleClose" in d0 && n0(5, c0 = d0.handleClose);
  }, [
    r0,
    i0,
    o0,
    s0,
    a0,
    c0,
    l0,
    u0
  ];
}
class n1 extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, a1, l1, U$1, {
      title: 0,
      subtitle: 1,
      showBackButton: 2,
      showCloseButton: 3,
      handleBack: 4,
      handleClose: 5
    });
  }
}
function $t$1(t0) {
  let e0, n0, r0, i0, o0;
  const s0 = (
    /*#slots*/
    t0[7].default
  ), a0 = we$1(
    s0,
    t0,
    /*$$scope*/
    t0[6],
    null
  );
  let c0 = [
    { href: (
      /*href*/
      t0[0]
    ) },
    { rel: "noreferrer noopener" },
    { target: "_blank" },
    { role: "button" },
    { "aria-label": (
      /*ariaLabel*/
      t0[1]
    ) },
    { tabindex: "0" },
    {
      class: n0 = `
		flex justify-center items-center w-full px-3 h-[60px] rounded-[12px] cursor-pointer shadow-list-item
		dark:shadow-none bg-surface-elevated focus:outline-none focus:ring-2 text-primary
		focus:ring-neutral-200 dark:focus:ring-neutral-700 transition-colors ${/*className*/
      t0[2]}
	`
    }
  ], l0 = {};
  for (let u0 = 0; u0 < c0.length; u0 += 1)
    l0 = xt$2(l0, c0[u0]);
  return {
    c() {
      e0 = x$1(
        /*as*/
        t0[3]
      ), a0 && a0.c(), Ee$1(
        /*as*/
        t0[3]
      )(e0, l0);
    },
    m(u0, d0) {
      $$1(u0, e0, d0), a0 && a0.m(e0, null), r0 = !0, i0 || (o0 = [
        $e$2(e0, "click", function() {
          me$1(
            /*handleClick*/
            t0[4]
          ) && t0[4].apply(this, arguments);
        }),
        $e$2(e0, "keyup", function() {
          me$1(
            /*handleKeyup*/
            t0[5]
          ) && t0[5].apply(this, arguments);
        })
      ], i0 = !0);
    },
    p(u0, d0) {
      t0 = u0, a0 && a0.p && (!r0 || d0 & /*$$scope*/
      64) && Ce$1(
        a0,
        s0,
        t0,
        /*$$scope*/
        t0[6],
        r0 ? be$1(
          s0,
          /*$$scope*/
          t0[6],
          d0,
          null
        ) : _e$1(
          /*$$scope*/
          t0[6]
        ),
        null
      ), Ee$1(
        /*as*/
        t0[3]
      )(e0, l0 = zt$1(c0, [
        (!r0 || d0 & /*href*/
        1) && { href: (
          /*href*/
          t0[0]
        ) },
        { rel: "noreferrer noopener" },
        { target: "_blank" },
        { role: "button" },
        (!r0 || d0 & /*ariaLabel*/
        2) && { "aria-label": (
          /*ariaLabel*/
          t0[1]
        ) },
        { tabindex: "0" },
        (!r0 || d0 & /*className*/
        4 && n0 !== (n0 = `
		flex justify-center items-center w-full px-3 h-[60px] rounded-[12px] cursor-pointer shadow-list-item
		dark:shadow-none bg-surface-elevated focus:outline-none focus:ring-2 text-primary
		focus:ring-neutral-200 dark:focus:ring-neutral-700 transition-colors ${/*className*/
        t0[2]}
	`)) && { class: n0 }
      ]));
    },
    i(u0) {
      r0 || (b$2(a0, u0), r0 = !0);
    },
    o(u0) {
      C$2(a0, u0), r0 = !1;
    },
    d(u0) {
      u0 && M$2(e0), a0 && a0.d(u0), i0 = !1, ke$1(o0);
    }
  };
}
function i1(t0) {
  let e0 = (
    /*as*/
    t0[3]
  ), n0, r0, i0 = (
    /*as*/
    t0[3] && $t$1(t0)
  );
  return {
    c() {
      i0 && i0.c(), n0 = ye$1();
    },
    m(o0, s0) {
      i0 && i0.m(o0, s0), $$1(o0, n0, s0), r0 = !0;
    },
    p(o0, [s0]) {
      o0[3] ? e0 ? U$1(
        e0,
        /*as*/
        o0[3]
      ) ? (i0.d(1), i0 = $t$1(o0), e0 = /*as*/
      o0[3], i0.c(), i0.m(n0.parentNode, n0)) : i0.p(o0, s0) : (i0 = $t$1(o0), e0 = /*as*/
      o0[3], i0.c(), i0.m(n0.parentNode, n0)) : e0 && (i0.d(1), i0 = null, e0 = /*as*/
      o0[3]);
    },
    i(o0) {
      r0 || (b$2(i0, o0), r0 = !0);
    },
    o(o0) {
      C$2(i0, o0), r0 = !1;
    },
    d(o0) {
      o0 && M$2(n0), i0 && i0.d(o0);
    }
  };
}
function s1(t0, e0, n0) {
  let { $$slots: r0 = {}, $$scope: i0 } = e0, { href: o0 = "" } = e0, { ariaLabel: s0 = "" } = e0, { className: a0 = "" } = e0, { as: c0 = "button" } = e0, { handleClick: l0 = (d0) => console.log("click", d0) } = e0, { handleKeyup: u0 = (d0) => console.log("keyup", d0) } = e0;
  return t0.$$set = (d0) => {
    "href" in d0 && n0(0, o0 = d0.href), "ariaLabel" in d0 && n0(1, s0 = d0.ariaLabel), "className" in d0 && n0(2, a0 = d0.className), "as" in d0 && n0(3, c0 = d0.as), "handleClick" in d0 && n0(4, l0 = d0.handleClick), "handleKeyup" in d0 && n0(5, u0 = d0.handleKeyup), "$$scope" in d0 && n0(6, i0 = d0.$$scope);
  }, [o0, s0, a0, c0, l0, u0, i0, r0];
}
let Ot$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, s1, i1, U$1, {
      href: 0,
      ariaLabel: 1,
      className: 2,
      as: 3,
      handleClick: 4,
      handleKeyup: 5
    });
  }
};
function c1(t0) {
  let e0, n0;
  return {
    c() {
      e0 = x$1("img"), Er$1(e0.src, n0 = /*renderIcon*/
      t0[0]) || t$2(e0, "src", n0), t$2(e0, "class", "w-8 h-8 rounded"), t$2(e0, "alt", "");
    },
    m(r0, i0) {
      $$1(r0, e0, i0);
    },
    p: B$2,
    d(r0) {
      r0 && M$2(e0);
    }
  };
}
function f1(t0) {
  let e0;
  return {
    c() {
      e0 = x$1("div"), t$2(e0, "class", "flex flex-shrink items-center max-w-[32px]"), xe$1(e0, "position", "relative");
    },
    m(n0, r0) {
      $$1(n0, e0, r0), e0.innerHTML = /*renderIcon*/
      t0[0];
    },
    p: B$2,
    d(n0) {
      n0 && M$2(e0);
    }
  };
}
function u1(t0) {
  let e0;
  function n0(i0, o0) {
    return (
      /*renderIcon*/
      i0[0].trimStart()?.startsWith("<svg") ? f1 : c1
    );
  }
  let r0 = n0(t0)(t0);
  return {
    c() {
      r0.c(), e0 = ye$1();
    },
    m(i0, o0) {
      r0.m(i0, o0), $$1(i0, e0, o0);
    },
    p(i0, [o0]) {
      r0.p(i0, o0);
    },
    i: B$2,
    o: B$2,
    d(i0) {
      i0 && M$2(e0), r0.d(i0);
    }
  };
}
function d1(t0, e0, n0) {
  let { theme: r0 } = e0, { icon: i0 } = e0;
  const o0 = typeof i0 == "string" ? i0 : r0 === "dark" ? i0.dark : i0.light;
  return t0.$$set = (s0) => {
    "theme" in s0 && n0(1, r0 = s0.theme), "icon" in s0 && n0(2, i0 = s0.icon);
  }, [o0, r0, i0];
}
let pr$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, d1, u1, U$1, { theme: 1, icon: 2 });
  }
};
function Ht$2(t0) {
  let e0, n0 = (
    /*wallet*/
    t0[0].subtitle + ""
  ), r0;
  return {
    c() {
      e0 = x$1("p"), r0 = X$2(n0), t$2(e0, "class", "text-l2 text-subtle"), xe$1(e0, "text-align", "center");
    },
    m(i0, o0) {
      $$1(i0, e0, o0), i$4(e0, r0);
    },
    p(i0, o0) {
      o0 & /*wallet*/
      1 && n0 !== (n0 = /*wallet*/
      i0[0].subtitle + "") && ge$1(r0, n0);
    },
    d(i0) {
      i0 && M$2(e0);
    }
  };
}
function p1(t0) {
  let e0, n0, r0, i0, o0 = (
    /*wallet*/
    (t0[0].title ?? /*wallet*/
    t0[0].name) + ""
  ), s0, a0, c0, l0, u0, d0 = (
    /*wallet*/
    t0[0].subtitle && Ht$2(t0)
  );
  return l0 = new pr$1({
    props: {
      icon: (
        /*wallet*/
        t0[0].icon
      ),
      theme: (
        /*theme*/
        t0[1]
      )
    }
  }), {
    c() {
      e0 = x$1("div"), n0 = x$1("div"), r0 = x$1("div"), i0 = x$1("p"), s0 = X$2(o0), a0 = K$3(), d0 && d0.c(), c0 = K$3(), A$2(l0.$$.fragment), t$2(i0, "class", "font-semibold text-[15px] text-primary"), t$2(r0, "class", "ml-[-32px]"), t$2(n0, "class", "flex flex-grow flex-col justify-center items-center"), t$2(e0, "class", "w-full flex flex-row-reverse justify-between");
    },
    m(h0, g0) {
      $$1(h0, e0, g0), i$4(e0, n0), i$4(n0, r0), i$4(r0, i0), i$4(i0, s0), i$4(r0, a0), d0 && d0.m(r0, null), i$4(e0, c0), N$2(l0, e0, null), u0 = !0;
    },
    p(h0, g0) {
      (!u0 || g0 & /*wallet*/
      1) && o0 !== (o0 = /*wallet*/
      (h0[0].title ?? /*wallet*/
      h0[0].name) + "") && ge$1(s0, o0), /*wallet*/
      h0[0].subtitle ? d0 ? d0.p(h0, g0) : (d0 = Ht$2(h0), d0.c(), d0.m(r0, null)) : d0 && (d0.d(1), d0 = null);
      const w0 = {};
      g0 & /*wallet*/
      1 && (w0.icon = /*wallet*/
      h0[0].icon), g0 & /*theme*/
      2 && (w0.theme = /*theme*/
      h0[1]), l0.$set(w0);
    },
    i(h0) {
      u0 || (b$2(l0.$$.fragment, h0), u0 = !0);
    },
    o(h0) {
      C$2(l0.$$.fragment, h0), u0 = !1;
    },
    d(h0) {
      h0 && M$2(e0), d0 && d0.d(), Z$2(l0);
    }
  };
}
function h1(t0) {
  let e0, n0;
  return e0 = new Ot$1({
    props: {
      handleClick: (
        /*func*/
        t0[3]
      ),
      handleKeyup: (
        /*func_1*/
        t0[4]
      ),
      $$slots: { default: [p1] },
      $$scope: { ctx: t0 }
    }
  }), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    p(r0, [i0]) {
      const o0 = {};
      i0 & /*callback, wallet*/
      5 && (o0.handleClick = /*func*/
      r0[3]), i0 & /*callback, wallet*/
      5 && (o0.handleKeyup = /*func_1*/
      r0[4]), i0 & /*$$scope, wallet, theme*/
      35 && (o0.$$scope = { dirty: i0, ctx: r0 }), e0.$set(o0);
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function g1(t0, e0, n0) {
  let { wallet: r0 } = e0, { theme: i0 } = e0, { callback: o0 = async () => {
  } } = e0;
  const s0 = () => o0(r0), a0 = (c0) => {
    c0.key === "Enter" && o0(r0);
  };
  return t0.$$set = (c0) => {
    "wallet" in c0 && n0(0, r0 = c0.wallet), "theme" in c0 && n0(1, i0 = c0.theme), "callback" in c0 && n0(2, o0 = c0.callback);
  }, [r0, i0, o0, s0, a0];
}
class m1 extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, g1, h1, U$1, { wallet: 0, theme: 1, callback: 2 });
  }
}
function Kt$1(t0, e0, n0) {
  const r0 = t0.slice();
  return r0[3] = e0[n0], r0;
}
function Pt$2(t0) {
  let e0, n0, r0;
  return n0 = new m1({
    props: {
      wallet: (
        /*wallet*/
        t0[3]
      ),
      theme: (
        /*theme*/
        t0[0]
      ),
      callback: (
        /*callback*/
        t0[1]
      )
    }
  }), {
    c() {
      e0 = x$1("li"), A$2(n0.$$.fragment);
    },
    m(i0, o0) {
      $$1(i0, e0, o0), N$2(n0, e0, null), r0 = !0;
    },
    p(i0, o0) {
      const s0 = {};
      o0 & /*walletList*/
      4 && (s0.wallet = /*wallet*/
      i0[3]), o0 & /*theme*/
      1 && (s0.theme = /*theme*/
      i0[0]), o0 & /*callback*/
      2 && (s0.callback = /*callback*/
      i0[1]), n0.$set(s0);
    },
    i(i0) {
      r0 || (b$2(n0.$$.fragment, i0), r0 = !0);
    },
    o(i0) {
      C$2(n0.$$.fragment, i0), r0 = !1;
    },
    d(i0) {
      i0 && M$2(e0), Z$2(n0);
    }
  };
}
function w1(t0) {
  let e0, n0, r0, i0 = Dt$2(
    /*walletList*/
    t0[2]
  ), o0 = [];
  for (let a0 = 0; a0 < i0.length; a0 += 1)
    o0[a0] = Pt$2(Kt$1(t0, i0, a0));
  const s0 = (a0) => C$2(o0[a0], 1, 1, () => {
    o0[a0] = null;
  });
  return {
    c() {
      e0 = x$1("section"), n0 = x$1("ul");
      for (let a0 = 0; a0 < o0.length; a0 += 1)
        o0[a0].c();
      t$2(n0, "class", "flex flex-col gap-3");
    },
    m(a0, c0) {
      $$1(a0, e0, c0), i$4(e0, n0);
      for (let l0 = 0; l0 < o0.length; l0 += 1)
        o0[l0] && o0[l0].m(n0, null);
      r0 = !0;
    },
    p(a0, [c0]) {
      if (c0 & /*walletList, theme, callback*/
      7) {
        i0 = Dt$2(
          /*walletList*/
          a0[2]
        );
        let l0;
        for (l0 = 0; l0 < i0.length; l0 += 1) {
          const u0 = Kt$1(a0, i0, l0);
          o0[l0] ? (o0[l0].p(u0, c0), b$2(o0[l0], 1)) : (o0[l0] = Pt$2(u0), o0[l0].c(), b$2(o0[l0], 1), o0[l0].m(n0, null));
        }
        for (ce$2(), l0 = i0.length; l0 < o0.length; l0 += 1)
          s0(l0);
        fe$2();
      }
    },
    i(a0) {
      if (!r0) {
        for (let c0 = 0; c0 < i0.length; c0 += 1)
          b$2(o0[c0]);
        r0 = !0;
      }
    },
    o(a0) {
      o0 = o0.filter(Boolean);
      for (let c0 = 0; c0 < o0.length; c0 += 1)
        C$2(o0[c0]);
      r0 = !1;
    },
    d(a0) {
      a0 && M$2(e0), Or$1(o0, a0);
    }
  };
}
function b1(t0, e0, n0) {
  let { theme: r0 } = e0, { callback: i0 = async () => {
  } } = e0, { walletList: o0 } = e0;
  return t0.$$set = (s0) => {
    "theme" in s0 && n0(0, r0 = s0.theme), "callback" in s0 && n0(1, i0 = s0.callback), "walletList" in s0 && n0(2, o0 = s0.walletList);
  }, [r0, i0, o0];
}
class C1 extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, b1, w1, U$1, { theme: 0, callback: 1, walletList: 2 });
  }
}
function _1(t0) {
  let e0, n0;
  return {
    c() {
      e0 = x$1("hr"), t$2(e0, "class", n0 = `border-stroke-default w-full ${/*className*/
      t0[0]}`);
    },
    m(r0, i0) {
      $$1(r0, e0, i0);
    },
    p(r0, [i0]) {
      i0 & /*className*/
      1 && n0 !== (n0 = `border-stroke-default w-full ${/*className*/
      r0[0]}`) && t$2(e0, "class", n0);
    },
    i: B$2,
    o: B$2,
    d(r0) {
      r0 && M$2(e0);
    }
  };
}
function k1(t0, e0, n0) {
  let { className: r0 = "" } = e0;
  return t0.$$set = (i0) => {
    "className" in i0 && n0(0, r0 = i0.className);
  }, [r0];
}
let Ut$2 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, k1, _1, U$1, { className: 0 });
  }
};
function v1$1(t0) {
  let e0;
  return {
    c() {
      e0 = x$1("div"), e0.innerHTML = '<span class="text-primary">Connect to Ready mobile instead</span> <svg xmlns="http://www.w3.org/2000/svg" width="27" height="48" viewBox="0 0 27 48" fill="none"><path d="M10.9682 45.7174L3.14321 13.0668C2.75958 11.4692 3.43225 9.79803 4.82488 8.91515L15.5876 2.07812C16.2077 1.68398 16.9539 1.72077 17.5162 2.06761C16.3548 0.81687 14.8098 0.795849 14.1319 1.33714L2.86994 8.48948C1.26184 9.50899 0.484071 11.4377 0.925509 13.2875L8.40368 44.5034C8.78205 46.0905 12.014 47.6303 13.3751 46.7264V46.7159C12.4449 47.2782 11.2257 46.779 10.9682 45.7069V45.7174Z" fill="#8C8C8C" stroke="#0F0F0F" stroke-width="0.262761" stroke-miterlimit="10"></path><path d="M12.8282 43.2841L14.0632 46.164L13.3748 46.7315C12.0137 47.6354 8.78696 46.0957 8.40333 44.5086L7.67285 41.4658L12.8282 43.2841Z" fill="#0F0F0F" stroke="#0F0F0F" stroke-width="0.315313" stroke-miterlimit="10"></path><path d="M26.0828 35.1019L18.3313 3.18697C18.037 1.97827 16.6391 1.41596 15.5881 2.07812L4.82542 8.91515C3.43805 9.79802 2.76012 11.4639 3.14375 13.0668L10.9635 45.7174C11.2263 46.8105 12.4928 47.3097 13.4335 46.6896L24.3958 39.4111C25.8095 38.4705 26.4822 36.752 26.0828 35.1019Z" fill="#8C8C8C" stroke="#0F0F0F" stroke-width="0.262761" stroke-miterlimit="10"></path><path d="M25.3354 34.6552L18.1252 4.10667C17.852 2.95052 16.5644 2.40398 15.6027 3.03986L14.2627 3.92274L13.7739 5.66747C13.6846 5.98803 13.4849 6.26131 13.2064 6.44524L8.79724 9.39867C8.4031 9.66143 7.90386 9.70872 7.47293 9.51954L6.44291 9.0781L5.72294 9.55632C4.44593 10.3972 3.83106 11.9895 4.18842 13.524L11.4669 44.782C11.7139 45.8278 12.8805 46.3113 13.7424 45.7174L23.8061 38.7858C25.1042 37.8924 25.719 36.2423 25.3459 34.6657L25.3354 34.6552Z" fill="#FF875B" stroke="#0F0F0F" stroke-width="0.315313" stroke-miterlimit="10"></path><path d="M9.23809 7.71168C9.26962 7.80627 9.37998 7.82729 9.48508 7.75372L12.6802 5.60434C12.7854 5.53602 12.8432 5.39938 12.8116 5.30479C12.7801 5.2102 12.6697 5.18917 12.5646 5.26275L9.36947 7.41213C9.26436 7.48045 9.20655 7.61708 9.23809 7.71168Z" fill="#0F0F0F"></path><path d="M8.51836 8.563C8.68127 8.55249 8.80214 8.38432 8.78637 8.19513C8.77061 8.00069 8.62872 7.85354 8.47106 7.86406C8.30815 7.87457 8.18728 8.04273 8.20304 8.23192C8.21881 8.42636 8.3607 8.57351 8.51836 8.563Z" fill="#0F0F0F"></path><path d="M8.93919 33.951L10.6629 8.14795L8.79204 9.39869C8.4452 9.62992 8.01427 9.69298 7.62013 9.57737L6.46924 23.3723L8.93393 33.9563L8.93919 33.951Z" fill="#FFCBB8"></path><path d="M5.69775 20.0089L5.97103 21.1755L7.01681 9.31975L6.68048 9.17261L5.69775 20.0036V20.0089Z" fill="#FFCBB8"></path><path d="M25.3354 34.6552L18.1252 4.10667C17.852 2.95052 16.5644 2.40398 15.6027 3.03986L14.2627 3.92274L13.7739 5.66747C13.6846 5.98803 13.4849 6.26131 13.2064 6.44524L8.79724 9.39867C8.4031 9.66143 7.90385 9.70872 7.47293 9.51954L6.44291 9.0781L5.72294 9.55632C4.44593 10.3972 3.83106 11.9895 4.18842 13.524L11.4669 44.782C11.7139 45.8278 12.8805 46.3113 13.7424 45.7174L23.8061 38.7858C25.1042 37.8924 25.719 36.2423 25.3459 34.6657L25.3354 34.6552Z" stroke="#0F0F0F" stroke-width="0.262761" stroke-miterlimit="10"></path><path d="M7.28408 39.5635L9.71724 40.2257L3.94702 16.4038L1.56641 15.9729L7.28408 39.5688V39.5635Z" fill="#0F0F0F" stroke="#0F0F0F" stroke-width="0.315313" stroke-miterlimit="10"></path><path d="M2.99527 13.1299C2.6747 11.7741 3.01629 10.3447 4.1304 9.25683L2.51705 8.94678C1.32411 9.93476 0.824868 11.4167 1.00355 12.8514L2.99527 13.1299Z" fill="#F8F8F8"></path><path d="M14.7094 20.855L13.5585 21.4804C13.5217 21.5014 13.5007 21.5592 13.5165 21.6065C13.9422 23.0149 13.7898 24.6492 13.0698 26.1207C13.0488 26.168 13.0593 26.2258 13.0961 26.2573L14.2207 27.0929C14.2575 27.1192 14.31 27.1087 14.3363 27.0614C14.783 26.147 15.0563 25.1748 15.1509 24.2026C15.7867 24.7911 16.5487 25.2273 17.3948 25.4796C17.4369 25.4901 17.4789 25.4585 17.4894 25.406L17.7259 23.8347C17.7312 23.7821 17.7049 23.7296 17.6629 23.7191C16.3385 23.3092 15.3033 22.2949 14.8145 20.9075C14.7988 20.8602 14.7515 20.834 14.7147 20.855H14.7094Z" fill="white"></path></svg>', t$2(e0, "class", "flex flex-row-reverse items-center gap-2");
    },
    m(n0, r0) {
      $$1(n0, e0, r0);
    },
    p: B$2,
    d(n0) {
      n0 && M$2(e0);
    }
  };
}
function y1(t0) {
  let e0, n0, r0, i0, o0;
  return n0 = new Ut$2({}), i0 = new Ot$1({
    props: {
      handleClick: (
        /*handleClick*/
        t0[0]
      ),
      handleKeyup: (
        /*func*/
        t0[1]
      ),
      $$slots: { default: [v1$1] },
      $$scope: { ctx: t0 }
    }
  }), {
    c() {
      e0 = x$1("footer"), A$2(n0.$$.fragment), r0 = K$3(), A$2(i0.$$.fragment), t$2(e0, "class", "flex flex-col gap-4 w-full");
    },
    m(s0, a0) {
      $$1(s0, e0, a0), N$2(n0, e0, null), i$4(e0, r0), N$2(i0, e0, null), o0 = !0;
    },
    p(s0, [a0]) {
      const c0 = {};
      a0 & /*handleClick*/
      1 && (c0.handleClick = /*handleClick*/
      s0[0]), a0 & /*handleClick*/
      1 && (c0.handleKeyup = /*func*/
      s0[1]), a0 & /*$$scope*/
      4 && (c0.$$scope = { dirty: a0, ctx: s0 }), i0.$set(c0);
    },
    i(s0) {
      o0 || (b$2(n0.$$.fragment, s0), b$2(i0.$$.fragment, s0), o0 = !0);
    },
    o(s0) {
      C$2(n0.$$.fragment, s0), C$2(i0.$$.fragment, s0), o0 = !1;
    },
    d(s0) {
      s0 && M$2(e0), Z$2(n0), Z$2(i0);
    }
  };
}
function x1(t0, e0, n0) {
  let { handleClick: r0 = () => {
  } } = e0;
  const i0 = (o0) => {
    o0.key === "Enter" && r0();
  };
  return t0.$$set = (o0) => {
    "handleClick" in o0 && n0(0, r0 = o0.handleClick);
  }, [r0, i0];
}
let hr$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, x1, y1, U$1, { handleClick: 0 });
  }
};
function qt$1(t0) {
  let e0, n0;
  return e0 = new hr$1({
    props: { handleClick: (
      /*handleFallback*/
      t0[2]
    ) }
  }), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    p(r0, i0) {
      const o0 = {};
      i0 & /*handleFallback*/
      4 && (o0.handleClick = /*handleFallback*/
      r0[2]), e0.$set(o0);
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function F1(t0) {
  let e0, n0, r0, i0, o0, s0, a0, c0, l0, u0;
  const d0 = (
    /*#slots*/
    t0[4].default
  ), h0 = we$1(
    d0,
    t0,
    /*$$scope*/
    t0[3],
    null
  );
  let g0 = (
    /*showFallback*/
    t0[1] && qt$1(t0)
  );
  return {
    c() {
      e0 = x$1("section"), n0 = x$1("div"), r0 = x$1("div"), h0 && h0.c(), i0 = K$3(), o0 = x$1("h3"), s0 = X$2("Connecting to "), a0 = X$2(
        /*walletName*/
        t0[0]
      ), c0 = X$2("..."), l0 = K$3(), g0 && g0.c(), t$2(r0, "class", "bg-button-secondary rounded-full p-5"), t$2(o0, "class", "text-primary text-h4 font-bold"), t$2(n0, "class", "flex flex-col h-full justify-center items-center gap-4 w-full flex-grow"), t$2(e0, "class", "flex flex-col justify-center items-center flex-grow");
    },
    m(w0, y0) {
      $$1(w0, e0, y0), i$4(e0, n0), i$4(n0, r0), h0 && h0.m(r0, null), i$4(n0, i0), i$4(n0, o0), i$4(o0, s0), i$4(o0, a0), i$4(o0, c0), i$4(e0, l0), g0 && g0.m(e0, null), u0 = !0;
    },
    p(w0, [y0]) {
      h0 && h0.p && (!u0 || y0 & /*$$scope*/
      8) && Ce$1(
        h0,
        d0,
        w0,
        /*$$scope*/
        w0[3],
        u0 ? be$1(
          d0,
          /*$$scope*/
          w0[3],
          y0,
          null
        ) : _e$1(
          /*$$scope*/
          w0[3]
        ),
        null
      ), (!u0 || y0 & /*walletName*/
      1) && ge$1(
        a0,
        /*walletName*/
        w0[0]
      ), /*showFallback*/
      w0[1] ? g0 ? (g0.p(w0, y0), y0 & /*showFallback*/
      2 && b$2(g0, 1)) : (g0 = qt$1(w0), g0.c(), b$2(g0, 1), g0.m(e0, null)) : g0 && (ce$2(), C$2(g0, 1, 1, () => {
        g0 = null;
      }), fe$2());
    },
    i(w0) {
      u0 || (b$2(h0, w0), b$2(g0), u0 = !0);
    },
    o(w0) {
      C$2(h0, w0), C$2(g0), u0 = !1;
    },
    d(w0) {
      w0 && M$2(e0), h0 && h0.d(w0), g0 && g0.d();
    }
  };
}
function L1(t0, e0, n0) {
  let { $$slots: r0 = {}, $$scope: i0 } = e0, { walletName: o0 = "" } = e0, { showFallback: s0 = !1 } = e0, { handleFallback: a0 = async () => {
  } } = e0;
  return t0.$$set = (c0) => {
    "walletName" in c0 && n0(0, o0 = c0.walletName), "showFallback" in c0 && n0(1, s0 = c0.showFallback), "handleFallback" in c0 && n0(2, a0 = c0.handleFallback), "$$scope" in c0 && n0(3, i0 = c0.$$scope);
  }, [o0, s0, a0, i0, r0];
}
class B1 extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, L1, F1, U$1, {
      walletName: 0,
      showFallback: 1,
      handleFallback: 2
    });
  }
}
function M1(t0) {
  let e0;
  return {
    c() {
      e0 = x$1("section"), e0.innerHTML = '<div class="flex flex-col h-full justify-center items-center gap-8 w-full flex-grow"><div><svg width="140" height="141" viewBox="0 0 140 141" fill="none" xmlns="http://www.w3.org/2000/svg"><mask id="mask0_82_210" style="mask-type:alpha" maskUnits="userSpaceOnUse" x="0" y="0" width="140" height="141"><path d="M69.9639 140.094C108.42 140.094 139.595 108.92 139.595 70.4639C139.595 32.008 108.42 0.833313 69.9639 0.833313C31.508 0.833313 0.333344 32.008 0.333344 70.4639C0.333344 108.92 31.508 140.094 69.9639 140.094Z" fill="#BFBFBF"></path></mask><g mask="url(#mask0_82_210)"><path d="M69.9639 140.094C108.42 140.094 139.595 108.92 139.595 70.4639C139.595 32.008 108.42 0.833313 69.9639 0.833313C31.508 0.833313 0.333344 32.008 0.333344 70.4639C0.333344 108.92 31.508 140.094 69.9639 140.094Z" fill="#BFBFBF" fill-opacity="0.2"></path><circle opacity="0.5" cx="69.6835" cy="70.1833" r="28.5" stroke="#FF7A52" stroke-width="0.633333"></circle><circle opacity="0.4" cx="69.6835" cy="70.1833" r="36.1" stroke="#FF7A52" stroke-width="0.633333"></circle><circle opacity="0.2" cx="69.6834" cy="70.1833" r="50.0333" stroke="#FF7A52" stroke-width="0.633333"></circle><path d="M71.63 64.1667H68.3704C68.2614 64.1667 68.1742 64.2607 68.1718 64.3775C68.1059 67.6613 66.5044 70.7781 63.7479 72.9857C63.6603 73.0557 63.6404 73.1874 63.7044 73.2823L65.6115 76.1111C65.6764 76.2074 65.8028 76.2291 65.8918 76.1584C67.6154 74.7871 69.0018 73.1327 70.0002 71.2991C70.9985 73.1327 72.385 74.7871 74.1086 76.1584C74.1975 76.2291 74.3239 76.2074 74.3889 76.1111L76.296 73.2823C76.3599 73.1874 76.34 73.0557 76.2525 72.9857C73.4959 70.7781 71.8944 67.6613 71.8286 64.3775C71.8262 64.2607 71.7389 64.1667 71.63 64.1667Z" fill="#FF875B"></path><path d="M42.2656 41.1541L97.3366 41.1541C102.578 41.1541 106.827 45.4032 106.827 50.6448L106.827 170.156C106.827 175.398 102.578 179.647 97.3366 179.647L42.2656 179.647C37.0241 179.647 32.775 175.398 32.775 170.156L32.775 50.6447C32.775 45.4032 37.0241 41.1541 42.2656 41.1541Z" fill="#FF875B" stroke="black" stroke-width="3.51504"></path><path d="M44.6111 139.224L38.2837 139.224L31.9568 139.224L32.6599 47.1296L37.5617 41.0012L94.5247 40.803L44.6111 139.224Z" fill="white" fill-opacity="0.3"></path><path d="M42.266 41.1541L97.337 41.1541C102.578 41.1541 106.828 45.4032 106.828 50.6448L106.828 170.156C106.828 175.398 102.578 179.647 97.3369 179.647L42.2659 179.647C37.0244 179.647 32.7753 175.398 32.7753 170.156L32.7753 50.6447C32.7753 45.4032 37.0244 41.1541 42.266 41.1541Z" stroke="black" stroke-width="3.51504"></path><path d="M53.6909 39.3966L87.1044 39.3966L87.1044 40.9326C87.1044 44.0387 84.5865 46.5567 81.4804 46.5567L59.3149 46.5567C56.2088 46.5567 53.6909 44.0387 53.6909 40.9326L53.6909 39.3966Z" fill="black"></path><path d="M73.0967 82.5333H66.9034C66.6965 82.5333 66.5307 82.7164 66.5262 82.9439C66.401 89.3387 63.3581 95.4081 58.1207 99.7072C57.9544 99.8436 57.9165 100.1 58.0381 100.285L61.6616 105.793C61.7849 105.981 62.0251 106.023 62.1942 105.886C65.469 103.215 68.1031 99.9935 70 96.4228C71.897 99.9935 74.5312 103.215 77.8061 105.886C77.975 106.023 78.2152 105.981 78.3386 105.793L81.9622 100.285C82.0836 100.1 82.0457 99.8436 81.8796 99.7072C76.642 95.4081 73.5991 89.3387 73.4741 82.9439C73.4696 82.7164 73.3036 82.5333 73.0967 82.5333Z" fill="white"></path></g></svg></div> <hgroup class="flex flex-col gap-1"><h3 class="text-primary text-h4 font-bold">Approve the transaction</h3> <h4 class="text-primary text-p3">Open Ready on your phone to <br/> approve the transaction</h4></hgroup></div>', t$2(e0, "class", "flex flex-col justify-center items-center flex-grow");
    },
    m(n0, r0) {
      $$1(n0, e0, r0);
    },
    p: B$2,
    i: B$2,
    o: B$2,
    d(n0) {
      n0 && M$2(e0);
    }
  };
}
function S1(t0) {
  return [];
}
class $1 extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, S1, M1, U$1, {});
  }
}
var Xt$1 = globalThis && globalThis.__spreadArray || function(t0, e0, n0) {
  if (n0 || arguments.length === 2)
    for (var r0 = 0, i0 = e0.length, o0; r0 < i0; r0++)
      (o0 || !(r0 in e0)) && (o0 || (o0 = Array.prototype.slice.call(e0, 0, r0)), o0[r0] = e0[r0]);
  return t0.concat(o0 || Array.prototype.slice.call(e0));
}, E1 = (
  /** @class */
  function() {
    function t0(e0, n0, r0) {
      this.name = e0, this.version = n0, this.os = r0, this.type = "browser";
    }
    return t0;
  }()
), N1 = (
  /** @class */
  function() {
    function t0(e0) {
      this.version = e0, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return t0;
  }()
), Z1 = (
  /** @class */
  function() {
    function t0(e0, n0, r0, i0) {
      this.name = e0, this.version = n0, this.os = r0, this.bot = i0, this.type = "bot-device";
    }
    return t0;
  }()
), A1 = (
  /** @class */
  function() {
    function t0() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return t0;
  }()
), z1 = (
  /** @class */
  function() {
    function t0() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return t0;
  }()
), O1 = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, U1 = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, Qt$2 = 3, G1 = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", O1]
], Yt$1 = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function I1(t0) {
  return t0 ? Jt$1(t0) : typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new z1() : typeof navigator < "u" ? Jt$1(navigator.userAgent) : D1();
}
function W1(t0) {
  return t0 !== "" && G1.reduce(function(e0, n0) {
    var r0 = n0[0], i0 = n0[1];
    if (e0)
      return e0;
    var o0 = i0.exec(t0);
    return !!o0 && [r0, o0];
  }, !1);
}
function Jt$1(t0) {
  var e0 = W1(t0);
  if (!e0)
    return null;
  var n0 = e0[0], r0 = e0[1];
  if (n0 === "searchbot")
    return new A1();
  var i0 = r0[1] && r0[1].split(".").join("_").split("_").slice(0, 3);
  i0 ? i0.length < Qt$2 && (i0 = Xt$1(Xt$1([], i0, !0), V1(Qt$2 - i0.length), !0)) : i0 = [];
  var o0 = i0.join("."), s0 = j1(t0), a0 = U1.exec(t0);
  return a0 && a0[1] ? new Z1(n0, o0, s0, a0[1]) : new E1(n0, o0, s0);
}
function j1(t0) {
  for (var e0 = 0, n0 = Yt$1.length; e0 < n0; e0++) {
    var r0 = Yt$1[e0], i0 = r0[0], o0 = r0[1], s0 = o0.exec(t0);
    if (s0)
      return i0;
  }
  return null;
}
function D1() {
  var t0 = typeof process < "u" && process.version;
  return t0 ? new N1(process.version.slice(1)) : null;
}
function V1(t0) {
  for (var e0 = [], n0 = 0; n0 < t0; n0++)
    e0.push("0");
  return e0;
}
const R1 = () => {
  const t0 = I1()?.os?.toLowerCase();
  return t0?.includes("android") ? "android" : t0?.toLowerCase().includes("ios") || t0?.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 ? "ios" : "desktop";
};
function T1(t0) {
  let e0, n0, r0, i0, o0, s0, a0, c0, l0, u0, d0, h0, g0, w0, y0, E0, b0, O0, S0, k0, D0, z0, G0, K0, U0, F0, H0;
  return {
    c() {
      e0 = c$2("svg"), n0 = c$2("path"), r0 = c$2("path"), i0 = c$2("path"), o0 = c$2("path"), s0 = c$2("defs"), a0 = c$2("linearGradient"), c0 = c$2("stop"), l0 = c$2("stop"), u0 = c$2("stop"), d0 = c$2("stop"), h0 = c$2("stop"), g0 = c$2("stop"), w0 = c$2("linearGradient"), y0 = c$2("stop"), E0 = c$2("stop"), b0 = c$2("stop"), O0 = c$2("stop"), S0 = c$2("linearGradient"), k0 = c$2("stop"), D0 = c$2("stop"), z0 = c$2("linearGradient"), G0 = c$2("stop"), K0 = c$2("stop"), U0 = c$2("stop"), F0 = c$2("stop"), H0 = c$2("stop"), t$2(n0, "d", "M0.467777 0.822764C0.216151 1.08602 0.0705566 1.49585 0.0705566 2.02664V20.9585C0.0705566 21.4892 0.216151 21.8991 0.467777 22.1623L0.529877 22.2201L11.1456 11.6156V11.3652L0.529877 0.760742L0.467777 0.822764Z"), t$2(n0, "fill", "url(#paint0_linear_6328_20701)"), t$2(r0, "d", "M14.6806 15.1527L11.146 11.6161V11.3657L14.6849 7.8291L14.7642 7.87512L18.9551 10.2582C20.1512 10.9345 20.1512 12.0474 18.9551 12.728L14.7642 15.1067L14.6806 15.1527Z"), t$2(r0, "fill", "url(#paint1_linear_6328_20701)"), t$2(i0, "d", "M14.7646 15.1065L11.1464 11.4907L0.468628 22.1626C0.865912 22.58 1.51368 22.6302 2.25039 22.2129L14.7646 15.1065Z"), t$2(i0, "fill", "url(#paint2_linear_6328_20701)"), t$2(o0, "d", "M14.7646 7.87514L2.25039 0.768742C1.51368 0.355689 0.865912 0.405984 0.468628 0.823338L11.1464 11.4909L14.7646 7.87514Z"), t$2(o0, "fill", "url(#paint3_linear_6328_20701)"), t$2(c0, "stop-color", "#00A0FF"), t$2(l0, "offset", "0.0066"), t$2(l0, "stop-color", "#00A1FF"), t$2(u0, "offset", "0.2601"), t$2(u0, "stop-color", "#00BEFF"), t$2(d0, "offset", "0.5122"), t$2(d0, "stop-color", "#00D2FF"), t$2(h0, "offset", "0.7604"), t$2(h0, "stop-color", "#00DFFF"), t$2(g0, "offset", "1"), t$2(g0, "stop-color", "#00E3FF"), t$2(a0, "id", "paint0_linear_6328_20701"), t$2(a0, "x1", "10.2031"), t$2(a0, "y1", "21.1557"), t$2(a0, "x2", "-4.16375"), t$2(a0, "y2", "6.77945"), t$2(a0, "gradientUnits", "userSpaceOnUse"), t$2(y0, "stop-color", "#FFE000"), t$2(E0, "offset", "0.4087"), t$2(E0, "stop-color", "#FFBD00"), t$2(b0, "offset", "0.7754"), t$2(b0, "stop-color", "#FFA500"), t$2(O0, "offset", "1"), t$2(O0, "stop-color", "#FF9C00"), t$2(w0, "id", "paint1_linear_6328_20701"), t$2(w0, "x1", "20.5126"), t$2(w0, "y1", "11.4897"), t$2(w0, "x2", "-0.214967"), t$2(w0, "y2", "11.4897"), t$2(w0, "gradientUnits", "userSpaceOnUse"), t$2(k0, "stop-color", "#FF3A44"), t$2(D0, "offset", "1"), t$2(D0, "stop-color", "#C31162"), t$2(S0, "id", "paint2_linear_6328_20701"), t$2(S0, "x1", "12.7972"), t$2(S0, "y1", "9.52511"), t$2(S0, "x2", "-6.68541"), t$2(S0, "y2", "-9.97016"), t$2(S0, "gradientUnits", "userSpaceOnUse"), t$2(G0, "stop-color", "#32A071"), t$2(K0, "offset", "0.0685"), t$2(K0, "stop-color", "#2DA771"), t$2(U0, "offset", "0.4762"), t$2(U0, "stop-color", "#15CF74"), t$2(F0, "offset", "0.8009"), t$2(F0, "stop-color", "#06E775"), t$2(H0, "offset", "1"), t$2(H0, "stop-color", "#00F076"), t$2(z0, "id", "paint3_linear_6328_20701"), t$2(z0, "x1", "-2.2192"), t$2(z0, "y1", "28.4614"), t$2(z0, "x2", "6.48066"), t$2(z0, "y2", "19.756"), t$2(z0, "gradientUnits", "userSpaceOnUse"), t$2(e0, "xmlns", "http://www.w3.org/2000/svg"), t$2(e0, "width", "20"), t$2(e0, "height", "23"), t$2(e0, "viewBox", "0 0 20 23"), t$2(e0, "fill", "none");
    },
    m(P0, I0) {
      $$1(P0, e0, I0), i$4(e0, n0), i$4(e0, r0), i$4(e0, i0), i$4(e0, o0), i$4(e0, s0), i$4(s0, a0), i$4(a0, c0), i$4(a0, l0), i$4(a0, u0), i$4(a0, d0), i$4(a0, h0), i$4(a0, g0), i$4(s0, w0), i$4(w0, y0), i$4(w0, E0), i$4(w0, b0), i$4(w0, O0), i$4(s0, S0), i$4(S0, k0), i$4(S0, D0), i$4(s0, z0), i$4(z0, G0), i$4(z0, K0), i$4(z0, U0), i$4(z0, F0), i$4(z0, H0);
    },
    p: B$2,
    i: B$2,
    o: B$2,
    d(P0) {
      P0 && M$2(e0);
    }
  };
}
let gr$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, null, T1, U$1, {});
  }
};
function H1(t0) {
  let e0, n0, r0, i0, o0, s0, a0, c0, l0;
  return {
    c() {
      e0 = c$2("svg"), n0 = c$2("mask"), r0 = c$2("path"), i0 = c$2("g"), o0 = c$2("path"), s0 = c$2("path"), a0 = c$2("path"), c0 = c$2("path"), l0 = c$2("path"), t$2(r0, "d", "M0.147583 10.7547C0.147583 4.81908 4.97505 0.00732422 10.93 0.00732422C16.885 0.00732422 21.7125 4.81908 21.7125 10.7547C21.7125 16.6903 16.885 21.502 10.93 21.502C4.97505 21.502 0.147583 16.6903 0.147583 10.7547Z"), t$2(r0, "fill", "#F1F1F1"), t$2(n0, "id", "mask0_6328_20691"), xe$1(n0, "mask-type", "alpha"), t$2(n0, "maskUnits", "userSpaceOnUse"), t$2(n0, "x", "0"), t$2(n0, "y", "0"), t$2(
        n0,
        "width",
        /*size*/
        t0[0]
      ), t$2(
        n0,
        "height",
        /*size*/
        t0[0]
      ), t$2(o0, "d", "M1.85962 0.00787449V13.1973H6.68474L10.9296 5.86942H21.712V0.00787449H1.85962ZM1.85962 0.00787449V13.1973H6.68474L10.9296 5.86942H21.712V0.00787449H1.85962Z"), t$2(o0, "fill", "#EA4335"), t$2(s0, "d", "M0.147583 21.502H10.4107L15.1749 16.7533V13.1981L6.68507 13.1967L0.147583 2.02082V21.502ZM0.147583 21.502H10.4107L15.1749 16.7533V13.1981L6.68507 13.1967L0.147583 2.02082V21.502Z"), t$2(s0, "fill", "#34A853"), t$2(a0, "d", "M10.9289 5.86867L15.1738 13.1965L10.411 21.502H21.7113V5.86867H10.9289ZM10.9289 5.86867L15.1738 13.1965L10.411 21.502H21.7113V5.86867H10.9289Z"), t$2(a0, "fill", "#FBBC05"), t$2(c0, "d", "M10.9297 5.86791C13.6369 5.86791 15.8314 8.05549 15.8314 10.7537C15.8314 13.4521 13.6369 15.6396 10.9297 15.6396C8.22245 15.6396 6.02795 13.4521 6.02795 10.7537C6.02795 8.05549 8.22245 5.86791 10.9297 5.86791Z"), t$2(c0, "fill", "#F1F1F1"), t$2(l0, "d", "M10.9286 6.84588C13.0943 6.84588 14.8499 8.59581 14.8499 10.7545C14.8499 12.9132 13.0943 14.6631 10.9286 14.6631C8.76284 14.6631 7.0072 12.9132 7.0072 10.7545C7.0072 8.59581 8.76284 6.84588 10.9286 6.84588Z"), t$2(l0, "fill", "#4285F4"), t$2(i0, "mask", "url(#mask0_6328_20691)"), t$2(e0, "xmlns", "http://www.w3.org/2000/svg"), t$2(
        e0,
        "width",
        /*size*/
        t0[0]
      ), t$2(
        e0,
        "height",
        /*size*/
        t0[0]
      ), t$2(e0, "viewBox", "0 0 22 22"), t$2(e0, "fill", "none");
    },
    m(u0, d0) {
      $$1(u0, e0, d0), i$4(e0, n0), i$4(n0, r0), i$4(e0, i0), i$4(i0, o0), i$4(i0, s0), i$4(i0, a0), i$4(i0, c0), i$4(i0, l0);
    },
    p(u0, [d0]) {
      d0 & /*size*/
      1 && t$2(
        n0,
        "width",
        /*size*/
        u0[0]
      ), d0 & /*size*/
      1 && t$2(
        n0,
        "height",
        /*size*/
        u0[0]
      ), d0 & /*size*/
      1 && t$2(
        e0,
        "width",
        /*size*/
        u0[0]
      ), d0 & /*size*/
      1 && t$2(
        e0,
        "height",
        /*size*/
        u0[0]
      );
    },
    i: B$2,
    o: B$2,
    d(u0) {
      u0 && M$2(e0);
    }
  };
}
function K1(t0, e0, n0) {
  let { size: r0 = "22" } = e0;
  return t0.$$set = (i0) => {
    "size" in i0 && n0(0, r0 = i0.size);
  }, [r0];
}
let mr$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, K1, H1, U$1, { size: 0 });
  }
};
function P1(t0) {
  let e0, n0, r0;
  return {
    c() {
      e0 = c$2("svg"), n0 = c$2("path"), r0 = c$2("path"), t$2(n0, "d", "M17.71 13.7971C17.6815 10.6387 20.296 9.10219 20.4156 9.03069C18.9349 6.87185 16.6399 6.57692 15.8334 6.5534C13.9059 6.35052 12.0362 7.70675 11.0543 7.70675C10.0528 7.70675 8.54067 6.573 6.91107 6.60632C4.814 6.63862 2.85216 7.8528 1.77619 9.7382C-0.444353 13.5825 1.21174 19.2319 3.33916 22.3392C4.40337 23.8611 5.64695 25.5603 7.27459 25.5005C8.86703 25.4349 9.46182 24.4853 11.3835 24.4853C13.2875 24.4853 13.8461 25.5005 15.5061 25.4623C17.2151 25.4349 18.2911 23.9336 19.318 22.398C20.5479 20.6537 21.0418 18.9359 21.0614 18.8477C21.0212 18.834 17.7423 17.5826 17.71 13.7971Z"), t$2(n0, "fill", "currentColor"), t$2(r0, "d", "M14.5762 4.5089C15.4327 3.43787 16.0187 1.98066 15.856 0.501953C14.6164 0.55683 13.0662 1.3594 12.1734 2.40697C11.3836 3.33007 10.678 4.8431 10.8603 6.26597C12.2528 6.36984 13.6825 5.56332 14.5762 4.5089Z"), t$2(r0, "fill", "currentColor"), t$2(e0, "xmlns", "http://www.w3.org/2000/svg"), t$2(e0, "width", "22"), t$2(e0, "height", "26"), t$2(e0, "viewBox", "0 0 22 26"), t$2(e0, "fill", "none");
    },
    m(i0, o0) {
      $$1(i0, e0, o0), i$4(e0, n0), i$4(e0, r0);
    },
    p: B$2,
    i: B$2,
    o: B$2,
    d(i0) {
      i0 && M$2(e0);
    }
  };
}
let wr$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, null, P1, U$1, {});
  }
};
function q1(t0) {
  let e0, n0, r0, i0, o0, s0, a0, c0, l0, u0;
  return o0 = new mr$1({}), a0 = new wr$1({}), l0 = new gr$1({}), {
    c() {
      e0 = x$1("div"), n0 = x$1("p"), n0.textContent = "Get it", r0 = K$3(), i0 = x$1("div"), A$2(o0.$$.fragment), s0 = K$3(), A$2(a0.$$.fragment), c0 = K$3(), A$2(l0.$$.fragment), t$2(n0, "class", "font-semibold text-p3 text-primary"), t$2(i0, "class", "flex gap-3 items-end"), xe$1(i0, "position", "relative"), t$2(e0, "class", "flex flex-row-reverse justify-center items-center gap-2");
    },
    m(d0, h0) {
      $$1(d0, e0, h0), i$4(e0, n0), i$4(e0, r0), i$4(e0, i0), N$2(o0, i0, null), i$4(i0, s0), N$2(a0, i0, null), i$4(i0, c0), N$2(l0, i0, null), u0 = !0;
    },
    p: B$2,
    i(d0) {
      u0 || (b$2(o0.$$.fragment, d0), b$2(a0.$$.fragment, d0), b$2(l0.$$.fragment, d0), u0 = !0);
    },
    o(d0) {
      C$2(o0.$$.fragment, d0), C$2(a0.$$.fragment, d0), C$2(l0.$$.fragment, d0), u0 = !1;
    },
    d(d0) {
      d0 && M$2(e0), Z$2(o0), Z$2(a0), Z$2(l0);
    }
  };
}
function X1(t0) {
  let e0, n0, r0, i0, o0, s0, a0, c0, l0, u0;
  return n0 = new Ut$2({}), l0 = new Ot$1({
    props: {
      handleClick: (
        /*handleClick*/
        t0[1]
      ),
      handleKeyup: (
        /*func*/
        t0[2]
      ),
      $$slots: { default: [q1] },
      $$scope: { ctx: t0 }
    }
  }), {
    c() {
      e0 = x$1("footer"), A$2(n0.$$.fragment), r0 = K$3(), i0 = x$1("p"), o0 = X$2("Don't have "), s0 = X$2(
        /*walletName*/
        t0[0]
      ), a0 = X$2("?"), c0 = K$3(), A$2(l0.$$.fragment), t$2(i0, "class", "text-h5 text-primary"), t$2(e0, "class", "flex flex-col gap-4");
    },
    m(d0, h0) {
      $$1(d0, e0, h0), N$2(n0, e0, null), i$4(e0, r0), i$4(e0, i0), i$4(i0, o0), i$4(i0, s0), i$4(i0, a0), i$4(e0, c0), N$2(l0, e0, null), u0 = !0;
    },
    p(d0, [h0]) {
      (!u0 || h0 & /*walletName*/
      1) && ge$1(
        s0,
        /*walletName*/
        d0[0]
      );
      const g0 = {};
      h0 & /*handleClick*/
      2 && (g0.handleClick = /*handleClick*/
      d0[1]), h0 & /*handleClick*/
      2 && (g0.handleKeyup = /*func*/
      d0[2]), h0 & /*$$scope*/
      8 && (g0.$$scope = { dirty: h0, ctx: d0 }), l0.$set(g0);
    },
    i(d0) {
      u0 || (b$2(n0.$$.fragment, d0), b$2(l0.$$.fragment, d0), u0 = !0);
    },
    o(d0) {
      C$2(n0.$$.fragment, d0), C$2(l0.$$.fragment, d0), u0 = !1;
    },
    d(d0) {
      d0 && M$2(e0), Z$2(n0), Z$2(l0);
    }
  };
}
function Q1(t0, e0, n0) {
  let { walletName: r0 = "" } = e0, { handleClick: i0 = () => {
  } } = e0;
  const o0 = (s0) => {
    s0.key === "Enter" && i0();
  };
  return t0.$$set = (s0) => {
    "walletName" in s0 && n0(0, r0 = s0.walletName), "handleClick" in s0 && n0(1, i0 = s0.handleClick);
  }, [r0, i0, o0];
}
class Y1 extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, Q1, X1, U$1, { walletName: 0, handleClick: 1 });
  }
}
function J1(t0) {
  Zr$1(t0, "svelte-roekpq", "@keyframes svelte-roekpq-dash{0%{stroke-dashoffset:187}50%{stroke-dashoffset:46.75;transform:rotate(135deg)}100%{stroke-dashoffset:187;transform:rotate(450deg)}}@keyframes svelte-roekpq-rotator{0%{transform:rotate(0deg)}100%{transform:rotate(270deg)}}.spinner.svelte-roekpq.svelte-roekpq{color:#ff875b;animation:svelte-roekpq-rotator 1.4s linear infinite}.spinner.svelte-roekpq circle.svelte-roekpq{stroke:currentColor;stroke-dasharray:187;stroke-dashoffset:0;transform-origin:center;animation:svelte-roekpq-dash 1.4s ease-in-out infinite}");
}
function eo$1(t0) {
  let e0;
  return {
    c() {
      e0 = x$1("h3"), e0.innerHTML = "Connect Ready mobile by<br/>scanning QR code:", t$2(e0, "class", "mb-4 text-h5 text-primary font-semibold");
    },
    m(n0, r0) {
      $$1(n0, e0, r0);
    },
    d(n0) {
      n0 && M$2(e0);
    }
  };
}
function to$1(t0) {
  let e0;
  return {
    c() {
      e0 = x$1("h3"), e0.textContent = "Connecting to Ready mobile...", t$2(e0, "class", "mb-4 text-h5 text-primary font-semibold");
    },
    m(n0, r0) {
      $$1(n0, e0, r0);
    },
    d(n0) {
      n0 && M$2(e0);
    }
  };
}
function ro$1(t0) {
  let e0, n0, r0, i0, o0, s0, a0;
  function c0(u0, d0) {
    return (
      /*isMobile*/
      u0[1] ? to$1 : eo$1
    );
  }
  let l0 = c0(t0)(t0);
  return s0 = new Y1({
    props: {
      walletName: "Ready",
      handleClick: (
        /*handleInstallClick*/
        t0[0]
      )
    }
  }), {
    c() {
      e0 = x$1("section"), n0 = x$1("div"), l0.c(), r0 = K$3(), i0 = x$1("div"), i0.innerHTML = '<svg class="spinner svelte-roekpq" viewBox="0 0 66 66" width="100px" height="100px" xmlns="http://www.w3.org/2000/svg"><circle fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30" class="svelte-roekpq"></circle></svg>', o0 = K$3(), A$2(s0.$$.fragment), t$2(i0, "class", "w-full flex justify-center items-center qr-code-slot h-[245px]"), t$2(e0, "class", "flex flex-col gap-4");
    },
    m(u0, d0) {
      $$1(u0, e0, d0), i$4(e0, n0), l0.m(n0, null), i$4(n0, r0), i$4(n0, i0), i$4(e0, o0), N$2(s0, e0, null), a0 = !0;
    },
    p(u0, [d0]) {
      const h0 = {};
      d0 & /*handleInstallClick*/
      1 && (h0.handleClick = /*handleInstallClick*/
      u0[0]), s0.$set(h0);
    },
    i(u0) {
      a0 || (b$2(s0.$$.fragment, u0), a0 = !0);
    },
    o(u0) {
      C$2(s0.$$.fragment, u0), a0 = !1;
    },
    d(u0) {
      u0 && M$2(e0), l0.d(), Z$2(s0);
    }
  };
}
function oo$1(t0, e0, n0) {
  const r0 = R1(), i0 = ["android", "ios"].includes(r0);
  let { handleInstallClick: o0 = () => {
  } } = e0;
  return t0.$$set = (s0) => {
    "handleInstallClick" in s0 && n0(0, o0 = s0.handleInstallClick);
  }, [o0, i0, r0];
}
let lo$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, oo$1, ro$1, U$1, { device: 2, handleInstallClick: 0 }, J1);
  }
  get device() {
    return this.$$.ctx[2];
  }
};
function ao$1(t0) {
  let e0, n0;
  return {
    c() {
      e0 = c$2("svg"), n0 = c$2("path"), t$2(n0, "d", "M37.5407 29.0784L23.8767 5.34867C23.4809 4.67181 22.9148 4.11038 22.2347 3.72021C21.5546 3.33005 20.7842 3.12476 20.0001 3.12476C19.216 3.12476 18.4456 3.33005 17.7655 3.72021C17.0854 4.11038 16.5193 4.67181 16.1235 5.34867L2.45947 29.0784C2.07544 29.7352 1.87305 30.4823 1.87305 31.2432C1.87305 32.0041 2.07544 32.7512 2.45947 33.408C2.85086 34.0883 3.41618 34.6521 4.09741 35.0418C4.77865 35.4314 5.55128 35.6328 6.33604 35.6252H33.6642C34.4484 35.6322 35.2204 35.4306 35.901 35.041C36.5817 34.6514 37.1465 34.0878 37.5376 33.408C37.9221 32.7515 38.125 32.0045 38.1256 31.2436C38.1261 30.4828 37.9243 29.7355 37.5407 29.0784ZM34.2907 31.5315C34.2272 31.6398 34.1356 31.7289 34.0255 31.7894C33.9155 31.8499 33.7912 31.8795 33.6657 31.8752H6.33604C6.21055 31.8795 6.08624 31.8499 5.97622 31.7894C5.86621 31.7289 5.77458 31.6398 5.71104 31.5315C5.65713 31.4438 5.6286 31.343 5.6286 31.2401C5.6286 31.1372 5.65713 31.0363 5.71104 30.9487L19.3751 7.21898C19.4428 7.11483 19.5354 7.02925 19.6445 6.96999C19.7537 6.91074 19.8759 6.87971 20.0001 6.87971C20.1243 6.87971 20.2465 6.91074 20.3557 6.96999C20.4648 7.02925 20.5574 7.11483 20.6251 7.21898L34.2876 30.9487C34.342 31.036 34.3711 31.1367 34.3716 31.2396C34.3722 31.3425 34.3442 31.4436 34.2907 31.5315ZM18.1251 21.2502V16.2502C18.1251 15.753 18.3226 15.276 18.6743 14.9244C19.0259 14.5728 19.5028 14.3752 20.0001 14.3752C20.4974 14.3752 20.9743 14.5728 21.3259 14.9244C21.6776 15.276 21.8751 15.753 21.8751 16.2502V21.2502C21.8751 21.7475 21.6776 22.2244 21.3259 22.5761C20.9743 22.9277 20.4974 23.1252 20.0001 23.1252C19.5028 23.1252 19.0259 22.9277 18.6743 22.5761C18.3226 22.2244 18.1251 21.7475 18.1251 21.2502ZM22.5001 27.5002C22.5001 27.9947 22.3535 28.478 22.0788 28.8892C21.8041 29.3003 21.4136 29.6207 20.9568 29.8099C20.5 29.9991 19.9973 30.0487 19.5124 29.9522C19.0274 29.8557 18.582 29.6176 18.2323 29.268C17.8827 28.9184 17.6446 28.4729 17.5481 27.988C17.4517 27.503 17.5012 27.0003 17.6904 26.5435C17.8796 26.0867 18.2001 25.6963 18.6112 25.4216C19.0223 25.1469 19.5056 25.0002 20.0001 25.0002C20.6631 25.0002 21.299 25.2636 21.7679 25.7325C22.2367 26.2013 22.5001 26.8372 22.5001 27.5002Z"), t$2(n0, "fill", "#DB3B4E"), t$2(e0, "xmlns", "http://www.w3.org/2000/svg"), t$2(e0, "width", "40"), t$2(e0, "height", "40"), t$2(e0, "viewBox", "0 0 40 40"), t$2(e0, "fill", "none");
    },
    m(r0, i0) {
      $$1(r0, e0, i0), i$4(e0, n0);
    },
    p: B$2,
    i: B$2,
    o: B$2,
    d(r0) {
      r0 && M$2(e0);
    }
  };
}
let br$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, null, ao$1, U$1, {});
  }
};
function Et$2(t0) {
  let e0, n0, r0, i0;
  const o0 = (
    /*#slots*/
    t0[6].default
  ), s0 = we$1(
    o0,
    t0,
    /*$$scope*/
    t0[5],
    null
  );
  let a0 = [
    { class: (
      /*className*/
      t0[0]
    ) },
    { href: (
      /*href*/
      t0[1]
    ) },
    { rel: "noreferrer noopener" },
    { target: "_blank" },
    { role: "button" },
    { tabindex: "0" }
  ], c0 = {};
  for (let l0 = 0; l0 < a0.length; l0 += 1)
    c0 = xt$2(c0, a0[l0]);
  return {
    c() {
      e0 = x$1(
        /*as*/
        t0[2]
      ), s0 && s0.c(), Ee$1(
        /*as*/
        t0[2]
      )(e0, c0);
    },
    m(l0, u0) {
      $$1(l0, e0, u0), s0 && s0.m(e0, null), n0 = !0, r0 || (i0 = [
        $e$2(e0, "click", function() {
          me$1(
            /*handleClick*/
            t0[3]
          ) && t0[3].apply(this, arguments);
        }),
        $e$2(e0, "keyup", function() {
          me$1(
            /*handleKeyup*/
            t0[4]
          ) && t0[4].apply(this, arguments);
        })
      ], r0 = !0);
    },
    p(l0, u0) {
      t0 = l0, s0 && s0.p && (!n0 || u0 & /*$$scope*/
      32) && Ce$1(
        s0,
        o0,
        t0,
        /*$$scope*/
        t0[5],
        n0 ? be$1(
          o0,
          /*$$scope*/
          t0[5],
          u0,
          null
        ) : _e$1(
          /*$$scope*/
          t0[5]
        ),
        null
      ), Ee$1(
        /*as*/
        t0[2]
      )(e0, c0 = zt$1(a0, [
        (!n0 || u0 & /*className*/
        1) && { class: (
          /*className*/
          t0[0]
        ) },
        (!n0 || u0 & /*href*/
        2) && { href: (
          /*href*/
          t0[1]
        ) },
        { rel: "noreferrer noopener" },
        { target: "_blank" },
        { role: "button" },
        { tabindex: "0" }
      ]));
    },
    i(l0) {
      n0 || (b$2(s0, l0), n0 = !0);
    },
    o(l0) {
      C$2(s0, l0), n0 = !1;
    },
    d(l0) {
      l0 && M$2(e0), s0 && s0.d(l0), r0 = !1, ke$1(i0);
    }
  };
}
function no$1(t0) {
  let e0 = (
    /*as*/
    t0[2]
  ), n0, r0, i0 = (
    /*as*/
    t0[2] && Et$2(t0)
  );
  return {
    c() {
      i0 && i0.c(), n0 = ye$1();
    },
    m(o0, s0) {
      i0 && i0.m(o0, s0), $$1(o0, n0, s0), r0 = !0;
    },
    p(o0, [s0]) {
      o0[2] ? e0 ? U$1(
        e0,
        /*as*/
        o0[2]
      ) ? (i0.d(1), i0 = Et$2(o0), e0 = /*as*/
      o0[2], i0.c(), i0.m(n0.parentNode, n0)) : i0.p(o0, s0) : (i0 = Et$2(o0), e0 = /*as*/
      o0[2], i0.c(), i0.m(n0.parentNode, n0)) : e0 && (i0.d(1), i0 = null, e0 = /*as*/
      o0[2]);
    },
    i(o0) {
      r0 || (b$2(i0, o0), r0 = !0);
    },
    o(o0) {
      C$2(i0, o0), r0 = !1;
    },
    d(o0) {
      o0 && M$2(n0), i0 && i0.d(o0);
    }
  };
}
function io$1(t0, e0, n0) {
  let { $$slots: r0 = {}, $$scope: i0 } = e0, { className: o0 } = e0, { href: s0 = void 0 } = e0, { as: a0 = "a" } = e0, { handleClick: c0 = void 0 } = e0, { handleKeyup: l0 = void 0 } = e0;
  return t0.$$set = (u0) => {
    "className" in u0 && n0(0, o0 = u0.className), "href" in u0 && n0(1, s0 = u0.href), "as" in u0 && n0(2, a0 = u0.as), "handleClick" in u0 && n0(3, c0 = u0.handleClick), "handleKeyup" in u0 && n0(4, l0 = u0.handleKeyup), "$$scope" in u0 && n0(5, i0 = u0.$$scope);
  }, [o0, s0, a0, c0, l0, i0, r0];
}
let Cr$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, io$1, no$1, U$1, {
      className: 0,
      href: 1,
      as: 2,
      handleClick: 3,
      handleKeyup: 4
    });
  }
};
function so$1(t0) {
  let e0;
  const n0 = (
    /*#slots*/
    t0[7].default
  ), r0 = we$1(
    n0,
    t0,
    /*$$scope*/
    t0[8],
    null
  );
  return {
    c() {
      r0 && r0.c();
    },
    m(i0, o0) {
      r0 && r0.m(i0, o0), e0 = !0;
    },
    p(i0, o0) {
      r0 && r0.p && (!e0 || o0 & /*$$scope*/
      256) && Ce$1(
        r0,
        n0,
        i0,
        /*$$scope*/
        i0[8],
        e0 ? be$1(
          n0,
          /*$$scope*/
          i0[8],
          o0,
          null
        ) : _e$1(
          /*$$scope*/
          i0[8]
        ),
        null
      );
    },
    i(i0) {
      e0 || (b$2(r0, i0), e0 = !0);
    },
    o(i0) {
      C$2(r0, i0), e0 = !1;
    },
    d(i0) {
      r0 && r0.d(i0);
    }
  };
}
function co$1(t0) {
  let e0, n0;
  return e0 = new Cr$1({
    props: {
      handleClick: (
        /*handleClick*/
        t0[3]
      ),
      handleKeyup: (
        /*handleKeyup*/
        t0[4]
      ),
      as: (
        /*as*/
        t0[2]
      ),
      href: (
        /*href*/
        t0[1]
      ),
      className: `
        ${/*className*/
      t0[0]} ${/*height*/
      t0[5]} px-4
        bg-button-secondary text-primary hover:bg-button-secondary-hover flex
        min-w-[140px] text-b3 rounded-3xl justify-center items-center
    `,
      $$slots: { default: [so$1] },
      $$scope: { ctx: t0 }
    }
  }), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    p(r0, [i0]) {
      const o0 = {};
      i0 & /*handleClick*/
      8 && (o0.handleClick = /*handleClick*/
      r0[3]), i0 & /*handleKeyup*/
      16 && (o0.handleKeyup = /*handleKeyup*/
      r0[4]), i0 & /*as*/
      4 && (o0.as = /*as*/
      r0[2]), i0 & /*href*/
      2 && (o0.href = /*href*/
      r0[1]), i0 & /*className*/
      1 && (o0.className = `
        ${/*className*/
      r0[0]} ${/*height*/
      r0[5]} px-4
        bg-button-secondary text-primary hover:bg-button-secondary-hover flex
        min-w-[140px] text-b3 rounded-3xl justify-center items-center
    `), i0 & /*$$scope*/
      256 && (o0.$$scope = { dirty: i0, ctx: r0 }), e0.$set(o0);
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function fo$1(t0, e0, n0) {
  let { $$slots: r0 = {}, $$scope: i0 } = e0, { className: o0 = "" } = e0, { href: s0 = void 0 } = e0, { as: a0 = "button" } = e0, { isLarge: c0 = !1 } = e0;
  const l0 = c0 ? "min-h-12" : "min-h-8";
  let { handleClick: u0 = (h0) => console.log("click", h0) } = e0, { handleKeyup: d0 = (h0) => console.log("keyup", h0) } = e0;
  return t0.$$set = (h0) => {
    "className" in h0 && n0(0, o0 = h0.className), "href" in h0 && n0(1, s0 = h0.href), "as" in h0 && n0(2, a0 = h0.as), "isLarge" in h0 && n0(6, c0 = h0.isLarge), "handleClick" in h0 && n0(3, u0 = h0.handleClick), "handleKeyup" in h0 && n0(4, d0 = h0.handleKeyup), "$$scope" in h0 && n0(8, i0 = h0.$$scope);
  }, [o0, s0, a0, u0, d0, l0, c0, r0, i0];
}
let _r$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, fo$1, co$1, U$1, {
      className: 0,
      href: 1,
      as: 2,
      isLarge: 6,
      handleClick: 3,
      handleKeyup: 4
    });
  }
};
function uo$1(t0) {
  let e0, n0;
  return {
    c() {
      e0 = c$2("svg"), n0 = c$2("path"), t$2(n0, "d", "M15.25 3.50011V6.50011C15.25 6.69902 15.171 6.88979 15.0303 7.03044C14.8897 7.17109 14.6989 7.25011 14.5 7.25011H11.5C11.3011 7.25011 11.1103 7.17109 10.9697 7.03044C10.829 6.88979 10.75 6.69902 10.75 6.50011C10.75 6.3012 10.829 6.11043 10.9697 5.96978C11.1103 5.82913 11.3011 5.75011 11.5 5.75011H12.5687L11.3812 4.66386C11.3731 4.65636 11.365 4.64886 11.3575 4.64074C10.8069 4.09046 10.1295 3.68394 9.38483 3.45695C8.64022 3.22996 7.85122 3.18945 7.08728 3.33899C6.32333 3.48853 5.60784 3.82353 5.00377 4.31452C4.39969 4.80552 3.92555 5.43745 3.62305 6.15472C3.32055 6.87199 3.19898 7.65261 3.26902 8.4279C3.33906 9.20319 3.59857 9.94938 4.02471 10.6008C4.45086 11.2523 5.03058 11.789 5.71287 12.1638C6.39516 12.5386 7.1591 12.7399 7.93748 12.7501H7.99998C9.21243 12.753 10.3795 12.2893 11.2594 11.4551C11.404 11.3184 11.597 11.2448 11.7959 11.2504C11.9948 11.2561 12.1833 11.3405 12.32 11.4851C12.4566 11.6297 12.5303 11.8227 12.5246 12.0216C12.519 12.2205 12.4346 12.4091 12.29 12.5457C11.1318 13.6435 9.59575 14.2537 7.99998 14.2501H7.91436C6.89126 14.2357 5.88735 13.9703 4.99078 13.4773C4.09421 12.9842 3.3324 12.2786 2.77224 11.4224C2.21208 10.5661 1.87071 9.58543 1.7781 8.56644C1.68548 7.54744 1.84447 6.52129 2.24108 5.57809C2.63769 4.63489 3.25981 3.80349 4.05281 3.15688C4.8458 2.51028 5.78541 2.06826 6.78915 1.86963C7.79288 1.671 8.83003 1.72184 9.80952 2.01768C10.789 2.31352 11.6809 2.84531 12.4069 3.56636L13.75 4.79511V3.50011C13.75 3.3012 13.829 3.11043 13.9697 2.96978C14.1103 2.82913 14.3011 2.75011 14.5 2.75011C14.6989 2.75011 14.8897 2.82913 15.0303 2.96978C15.171 3.11043 15.25 3.3012 15.25 3.50011Z"), t$2(n0, "fill", "currentColor"), t$2(e0, "xmlns", "http://www.w3.org/2000/svg"), t$2(e0, "width", "16"), t$2(e0, "height", "16"), t$2(e0, "viewBox", "0 0 16 16"), t$2(e0, "fill", "none");
    },
    m(r0, i0) {
      $$1(r0, e0, i0), i$4(e0, n0);
    },
    p: B$2,
    i: B$2,
    o: B$2,
    d(r0) {
      r0 && M$2(e0);
    }
  };
}
let po$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, null, uo$1, U$1, {});
  }
};
function ho$1(t0) {
  let e0, n0, r0, i0, o0;
  return n0 = new po$1({}), {
    c() {
      e0 = x$1("div"), A$2(n0.$$.fragment), r0 = X$2(" Retry connecting to "), i0 = X$2(
        /*walletName*/
        t0[0]
      ), t$2(e0, "class", "flex gap-2");
    },
    m(s0, a0) {
      $$1(s0, e0, a0), N$2(n0, e0, null), i$4(e0, r0), i$4(e0, i0), o0 = !0;
    },
    p(s0, a0) {
      (!o0 || a0 & /*walletName*/
      1) && ge$1(
        i0,
        /*walletName*/
        s0[0]
      );
    },
    i(s0) {
      o0 || (b$2(n0.$$.fragment, s0), o0 = !0);
    },
    o(s0) {
      C$2(n0.$$.fragment, s0), o0 = !1;
    },
    d(s0) {
      s0 && M$2(e0), Z$2(n0);
    }
  };
}
function er$1(t0) {
  let e0, n0;
  return e0 = new hr$1({
    props: { handleClick: (
      /*handleFallback*/
      t0[3]
    ) }
  }), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    p(r0, i0) {
      const o0 = {};
      i0 & /*handleFallback*/
      8 && (o0.handleClick = /*handleFallback*/
      r0[3]), e0.$set(o0);
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function go$1(t0) {
  let e0, n0, r0, i0, o0, s0, a0, c0, l0, u0;
  i0 = new br$1({}), c0 = new _r$1({
    props: {
      handleClick: (
        /*handleCallback*/
        t0[2]
      ),
      handleKeyup: (
        /*func*/
        t0[4]
      ),
      isLarge: !0,
      $$slots: { default: [ho$1] },
      $$scope: { ctx: t0 }
    }
  });
  let d0 = (
    /*showFallback*/
    t0[1] && er$1(t0)
  );
  return {
    c() {
      e0 = x$1("section"), n0 = x$1("div"), r0 = x$1("div"), A$2(i0.$$.fragment), o0 = K$3(), s0 = x$1("div"), s0.innerHTML = '<h3 class="text-primary text-h4 font-bold">Couldn&#39;t connect</h3> <p class="text-primary text-p3 font-[400]">Please try connecting again.</p>', a0 = K$3(), A$2(c0.$$.fragment), l0 = K$3(), d0 && d0.c(), t$2(r0, "class", "bg-button-secondary rounded-full p-5"), t$2(n0, "class", "flex flex-col h-full justify-center items-center gap-4 w-full flex-grow"), t$2(e0, "class", "flex flex-col justify-center items-center flex-grow");
    },
    m(h0, g0) {
      $$1(h0, e0, g0), i$4(e0, n0), i$4(n0, r0), N$2(i0, r0, null), i$4(n0, o0), i$4(n0, s0), i$4(n0, a0), N$2(c0, n0, null), i$4(e0, l0), d0 && d0.m(e0, null), u0 = !0;
    },
    p(h0, [g0]) {
      const w0 = {};
      g0 & /*handleCallback*/
      4 && (w0.handleClick = /*handleCallback*/
      h0[2]), g0 & /*handleCallback*/
      4 && (w0.handleKeyup = /*func*/
      h0[4]), g0 & /*$$scope, walletName*/
      33 && (w0.$$scope = { dirty: g0, ctx: h0 }), c0.$set(w0), /*showFallback*/
      h0[1] ? d0 ? (d0.p(h0, g0), g0 & /*showFallback*/
      2 && b$2(d0, 1)) : (d0 = er$1(h0), d0.c(), b$2(d0, 1), d0.m(e0, null)) : d0 && (ce$2(), C$2(d0, 1, 1, () => {
        d0 = null;
      }), fe$2());
    },
    i(h0) {
      u0 || (b$2(i0.$$.fragment, h0), b$2(c0.$$.fragment, h0), b$2(d0), u0 = !0);
    },
    o(h0) {
      C$2(i0.$$.fragment, h0), C$2(c0.$$.fragment, h0), C$2(d0), u0 = !1;
    },
    d(h0) {
      h0 && M$2(e0), Z$2(i0), Z$2(c0), d0 && d0.d();
    }
  };
}
function mo$1(t0, e0, n0) {
  let { walletName: r0 = "" } = e0, { showFallback: i0 = !1 } = e0, { handleCallback: o0 = async () => {
  } } = e0, { handleFallback: s0 = async () => {
  } } = e0;
  const a0 = (c0) => {
    c0.key === "Enter" && o0();
  };
  return t0.$$set = (c0) => {
    "walletName" in c0 && n0(0, r0 = c0.walletName), "showFallback" in c0 && n0(1, i0 = c0.showFallback), "handleCallback" in c0 && n0(2, o0 = c0.handleCallback), "handleFallback" in c0 && n0(3, s0 = c0.handleFallback);
  }, [r0, i0, o0, s0, a0];
}
let wo$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, mo$1, go$1, U$1, {
      walletName: 0,
      showFallback: 1,
      handleCallback: 2,
      handleFallback: 3
    });
  }
};
function bo$1(t0) {
  let e0, n0, r0;
  return {
    c() {
      e0 = c$2("svg"), n0 = c$2("path"), r0 = c$2("path"), t$2(n0, "d", "M28.7868 15.1583C29.5186 13.9874 29.1627 12.445 27.9918 11.7133C26.821 10.9815 25.2786 11.3374 24.5468 12.5083L17.656 23.5335L13.1668 20.1666C12.0622 19.3382 10.4952 19.562 9.66681 20.6666C8.83839 21.7712 9.06224 23.3382 10.1668 24.1666L16.8335 29.1666C17.3934 29.5865 18.1037 29.7525 18.7917 29.6242C19.4798 29.4959 20.0825 29.0851 20.4535 28.4916L28.7868 15.1583Z"), t$2(n0, "fill", "#02A17A"), t$2(r0, "fill-rule", "evenodd"), t$2(r0, "clip-rule", "evenodd"), t$2(r0, "d", "M40 20.5C40 31.5457 31.0457 40.5 20 40.5C8.9543 40.5 0 31.5457 0 20.5C0 9.4543 8.9543 0.5 20 0.5C31.0457 0.5 40 9.4543 40 20.5ZM36.6667 20.5C36.6667 29.7047 29.2047 37.1667 20 37.1667C10.7953 37.1667 3.33333 29.7047 3.33333 20.5C3.33333 11.2953 10.7953 3.83333 20 3.83333C29.2047 3.83333 36.6667 11.2953 36.6667 20.5Z"), t$2(r0, "fill", "#02A17A"), t$2(e0, "xmlns", "http://www.w3.org/2000/svg"), t$2(e0, "width", "40"), t$2(e0, "height", "41"), t$2(e0, "viewBox", "0 0 40 41"), t$2(e0, "fill", "none");
    },
    m(i0, o0) {
      $$1(i0, e0, o0), i$4(e0, n0), i$4(e0, r0);
    },
    p: B$2,
    i: B$2,
    o: B$2,
    d(i0) {
      i0 && M$2(e0);
    }
  };
}
let Co$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, null, bo$1, U$1, {});
  }
};
function _o$1(t0) {
  let e0, n0, r0, i0, o0, s0;
  return r0 = new Co$1({}), {
    c() {
      e0 = x$1("section"), n0 = x$1("div"), A$2(r0.$$.fragment), i0 = K$3(), o0 = x$1("h3"), o0.textContent = "Success!", t$2(n0, "class", "bg-button-secondary rounded-full p-5"), t$2(o0, "class", "text-primary text-h4 font-bold"), t$2(e0, "class", "flex flex-col justify-center items-center gap-4 flex-grow");
    },
    m(a0, c0) {
      $$1(a0, e0, c0), i$4(e0, n0), N$2(r0, n0, null), i$4(e0, i0), i$4(e0, o0), s0 = !0;
    },
    p: B$2,
    i(a0) {
      s0 || (b$2(r0.$$.fragment, a0), s0 = !0);
    },
    o(a0) {
      C$2(r0.$$.fragment, a0), s0 = !1;
    },
    d(a0) {
      a0 && M$2(e0), Z$2(r0);
    }
  };
}
let ko$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, null, _o$1, U$1, {});
  }
};
function vo$1(t0) {
  let e0, n0, r0, i0, o0, s0, a0, c0, l0, u0, d0, h0, g0, w0, y0, E0, b0, O0, S0, k0, D0, z0, G0, K0, U0, F0, H0, P0, I0, f0, m0, A0, x0;
  return {
    c() {
      e0 = c$2("svg"), n0 = c$2("path"), r0 = c$2("path"), i0 = c$2("path"), o0 = c$2("path"), s0 = c$2("path"), a0 = c$2("path"), c0 = c$2("defs"), l0 = c$2("linearGradient"), u0 = c$2("stop"), d0 = c$2("stop"), h0 = c$2("radialGradient"), g0 = c$2("stop"), w0 = c$2("stop"), y0 = c$2("stop"), E0 = c$2("linearGradient"), b0 = c$2("stop"), O0 = c$2("stop"), S0 = c$2("stop"), k0 = c$2("stop"), D0 = c$2("radialGradient"), z0 = c$2("stop"), G0 = c$2("stop"), K0 = c$2("stop"), U0 = c$2("radialGradient"), F0 = c$2("stop"), H0 = c$2("stop"), P0 = c$2("stop"), I0 = c$2("stop"), f0 = c$2("stop"), m0 = c$2("radialGradient"), A0 = c$2("stop"), x0 = c$2("stop"), t$2(n0, "d", "M18.9432 15.0009C18.6742 15.1415 18.3969 15.2653 18.1127 15.3717C17.208 15.7099 16.2497 15.8822 15.2839 15.8803C11.5552 15.8803 8.30719 13.3178 8.30719 10.0294C8.31196 9.58835 8.43446 9.15656 8.66205 8.77861C8.88963 8.40066 9.21405 8.09024 9.60182 7.87939C6.22931 8.0211 5.36255 11.5323 5.36255 13.5894C5.36255 19.4056 10.7278 19.9953 11.8838 19.9953C12.5071 19.9953 13.4471 19.8142 14.0113 19.6363L14.1145 19.6017C16.2856 18.8518 18.1364 17.3858 19.3624 15.4449C19.3999 15.3858 19.4167 15.3159 19.41 15.2462C19.4034 15.1765 19.3736 15.111 19.3256 15.0601C19.2775 15.0092 19.2138 14.9757 19.1445 14.965C19.0753 14.9543 19.0044 14.9669 18.9432 15.0009Z"), t$2(n0, "fill", "url(#paint0_linear_6297_45099)"), t$2(r0, "opacity", "0.35"), t$2(r0, "d", "M18.9432 15.0009C18.6742 15.1415 18.3969 15.2653 18.1127 15.3717C17.208 15.7099 16.2497 15.8822 15.2839 15.8803C11.5552 15.8803 8.30719 13.3178 8.30719 10.0294C8.31196 9.58835 8.43446 9.15656 8.66205 8.77861C8.88963 8.40066 9.21405 8.09024 9.60182 7.87939C6.22931 8.0211 5.36255 11.5323 5.36255 13.5894C5.36255 19.4056 10.7278 19.9953 11.8838 19.9953C12.5071 19.9953 13.4471 19.8142 14.0113 19.6363L14.1145 19.6017C16.2856 18.8518 18.1364 17.3858 19.3624 15.4449C19.3999 15.3858 19.4167 15.3159 19.41 15.2462C19.4034 15.1765 19.3736 15.111 19.3256 15.0601C19.2775 15.0092 19.2138 14.9757 19.1445 14.965C19.0753 14.9543 19.0044 14.9669 18.9432 15.0009Z"), t$2(r0, "fill", "url(#paint1_radial_6297_45099)"), t$2(i0, "d", "M9.06695 19.0054C8.36414 18.5696 7.75505 17.9985 7.27511 17.3254C6.7281 16.5766 6.35167 15.7174 6.17224 14.8078C5.99281 13.8983 6.01472 12.9606 6.23643 12.0605C6.45815 11.1603 6.8743 10.3195 7.45569 9.59705C8.03708 8.87459 8.76964 8.28797 9.60198 7.87832C9.84783 7.7626 10.2678 7.55319 10.8265 7.56342C11.2201 7.56628 11.6077 7.66017 11.9589 7.83773C12.3101 8.01529 12.6154 8.2717 12.8508 8.58685C13.169 9.01133 13.3444 9.5256 13.3519 10.0559C13.3519 10.0393 15.2793 3.78931 7.04818 3.78931C3.589 3.78931 0.74443 7.06902 0.74443 9.94645C0.730785 11.4686 1.05676 12.9746 1.69866 14.3551C2.7477 16.5914 4.5822 18.3649 6.85378 19.3388C9.12536 20.3128 11.6758 20.4194 14.0209 19.6384C13.1998 19.897 12.3323 19.9747 11.4783 19.8659C10.6243 19.7572 9.80398 19.4647 9.07405 19.0086L9.06695 19.0054Z"), t$2(i0, "fill", "url(#paint2_linear_6297_45099)"), t$2(o0, "opacity", "0.41"), t$2(o0, "d", "M9.06695 19.0054C8.36414 18.5696 7.75505 17.9985 7.27511 17.3254C6.7281 16.5766 6.35167 15.7174 6.17224 14.8078C5.99281 13.8983 6.01472 12.9606 6.23643 12.0605C6.45815 11.1603 6.8743 10.3195 7.45569 9.59705C8.03708 8.87459 8.76964 8.28797 9.60198 7.87832C9.84783 7.7626 10.2678 7.55319 10.8265 7.56342C11.2201 7.56628 11.6077 7.66017 11.9589 7.83773C12.3101 8.01529 12.6154 8.2717 12.8508 8.58685C13.169 9.01133 13.3444 9.5256 13.3519 10.0559C13.3519 10.0393 15.2793 3.78931 7.04818 3.78931C3.589 3.78931 0.74443 7.06902 0.74443 9.94645C0.730785 11.4686 1.05676 12.9746 1.69866 14.3551C2.7477 16.5914 4.5822 18.3649 6.85378 19.3388C9.12536 20.3128 11.6758 20.4194 14.0209 19.6384C13.1998 19.897 12.3323 19.9747 11.4783 19.8659C10.6243 19.7572 9.80398 19.4647 9.07405 19.0086L9.06695 19.0054Z"), t$2(o0, "fill", "url(#paint3_radial_6297_45099)"), t$2(s0, "d", "M12.7387 11.7191C12.6749 11.8018 12.4787 11.9159 12.4787 12.1647C12.4787 12.3702 12.6126 12.5678 12.8506 12.7339C13.9837 13.5211 16.1199 13.4172 16.1254 13.4172C16.965 13.4152 17.7887 13.1882 18.5106 12.7599C19.2388 12.335 19.8432 11.7273 20.2639 10.9971C20.6845 10.2668 20.9067 9.43939 20.9084 8.59685C20.9289 6.83261 20.278 5.6596 20.0148 5.14001C18.3451 1.87682 14.741 4.93329e-08 10.8216 4.93329e-08C8.17102 -0.000261808 5.62686 1.04193 3.7394 2.90118C1.85193 4.76042 0.772869 7.28727 0.735596 9.93519C0.773418 7.05855 3.63532 4.73535 7.03935 4.73535C7.31513 4.73535 8.88792 4.76212 10.3488 5.52812C11.6364 6.20359 12.3109 7.01919 12.7797 7.8277C13.2667 8.66771 13.3533 9.72893 13.3533 10.1517C13.3533 10.5744 13.1374 11.2011 12.7387 11.7191Z"), t$2(s0, "fill", "url(#paint4_radial_6297_45099)"), t$2(a0, "d", "M12.7387 11.7191C12.6749 11.8018 12.4787 11.9159 12.4787 12.1647C12.4787 12.3702 12.6126 12.5678 12.8506 12.7339C13.9837 13.5211 16.1199 13.4172 16.1254 13.4172C16.965 13.4152 17.7887 13.1882 18.5106 12.7599C19.2388 12.335 19.8432 11.7273 20.2639 10.9971C20.6845 10.2668 20.9067 9.43939 20.9084 8.59685C20.9289 6.83261 20.278 5.6596 20.0148 5.14001C18.3451 1.87682 14.741 4.93329e-08 10.8216 4.93329e-08C8.17102 -0.000261808 5.62686 1.04193 3.7394 2.90118C1.85193 4.76042 0.772869 7.28727 0.735596 9.93519C0.773418 7.05855 3.63532 4.73535 7.03935 4.73535C7.31513 4.73535 8.88792 4.76212 10.3488 5.52812C11.6364 6.20359 12.3109 7.01919 12.7797 7.8277C13.2667 8.66771 13.3533 9.72893 13.3533 10.1517C13.3533 10.5744 13.1374 11.2011 12.7387 11.7191Z"), t$2(a0, "fill", "url(#paint5_radial_6297_45099)"), t$2(u0, "stop-color", "#0C59A4"), t$2(d0, "offset", "1"), t$2(d0, "stop-color", "#114A8B"), t$2(l0, "id", "paint0_linear_6297_45099"), t$2(l0, "x1", "5.36255"), t$2(l0, "y1", "13.9389"), t$2(l0, "x2", "19.4152"), t$2(l0, "y2", "13.9389"), t$2(l0, "gradientUnits", "userSpaceOnUse"), t$2(g0, "offset", "0.72"), t$2(g0, "stop-opacity", "0"), t$2(w0, "offset", "0.95"), t$2(w0, "stop-opacity", "0.53"), t$2(y0, "offset", "1"), t$2(h0, "id", "paint1_radial_6297_45099"), t$2(h0, "cx", "0"), t$2(h0, "cy", "0"), t$2(h0, "r", "1"), t$2(h0, "gradientUnits", "userSpaceOnUse"), t$2(h0, "gradientTransform", "translate(13.124 14.0496) scale(7.51564 7.13342)"), t$2(b0, "stop-color", "#1B9DE2"), t$2(O0, "offset", "0.16"), t$2(O0, "stop-color", "#1595DF"), t$2(S0, "offset", "0.67"), t$2(S0, "stop-color", "#0680D7"), t$2(k0, "offset", "1"), t$2(k0, "stop-color", "#0078D4"), t$2(E0, "id", "paint2_linear_6297_45099"), t$2(E0, "x1", "12.7712"), t$2(E0, "y1", "7.84762"), t$2(E0, "x2", "4.00261"), t$2(E0, "y2", "17.4073"), t$2(E0, "gradientUnits", "userSpaceOnUse"), t$2(z0, "offset", "0.76"), t$2(z0, "stop-opacity", "0"), t$2(G0, "offset", "0.95"), t$2(G0, "stop-opacity", "0.5"), t$2(K0, "offset", "1"), t$2(D0, "id", "paint3_radial_6297_45099"), t$2(D0, "cx", "0"), t$2(D0, "cy", "0"), t$2(D0, "r", "1"), t$2(D0, "gradientUnits", "userSpaceOnUse"), t$2(D0, "gradientTransform", "translate(6.29839 15.6665) rotate(-81.3767) scale(11.2916 9.13031)"), t$2(F0, "stop-color", "#35C1F1"), t$2(H0, "offset", "0.11"), t$2(H0, "stop-color", "#34C1ED"), t$2(P0, "offset", "0.23"), t$2(P0, "stop-color", "#2FC2DF"), t$2(I0, "offset", "0.31"), t$2(I0, "stop-color", "#2BC3D2"), t$2(f0, "offset", "0.67"), t$2(f0, "stop-color", "#36C752"), t$2(U0, "id", "paint4_radial_6297_45099"), t$2(U0, "cx", "0"), t$2(U0, "cy", "0"), t$2(U0, "r", "1"), t$2(U0, "gradientUnits", "userSpaceOnUse"), t$2(U0, "gradientTransform", "translate(2.77348 3.72978) rotate(92.2927) scale(15.9492 33.9991)"), t$2(A0, "stop-color", "#66EB6E"), t$2(x0, "offset", "1"), t$2(x0, "stop-color", "#66EB6E"), t$2(x0, "stop-opacity", "0"), t$2(m0, "id", "paint5_radial_6297_45099"), t$2(m0, "cx", "0"), t$2(m0, "cy", "0"), t$2(m0, "r", "1"), t$2(m0, "gradientUnits", "userSpaceOnUse"), t$2(m0, "gradientTransform", "translate(19.6525 6.09385) rotate(73.7259) scale(7.66371 6.23687)"), t$2(e0, "xmlns", "http://www.w3.org/2000/svg"), t$2(
        e0,
        "width",
        /*size*/
        t0[0]
      ), t$2(
        e0,
        "height",
        /*size*/
        t0[0]
      ), t$2(e0, "viewBox", "0 0 21 21"), t$2(e0, "fill", "none");
    },
    m(_0, $0) {
      $$1(_0, e0, $0), i$4(e0, n0), i$4(e0, r0), i$4(e0, i0), i$4(e0, o0), i$4(e0, s0), i$4(e0, a0), i$4(e0, c0), i$4(c0, l0), i$4(l0, u0), i$4(l0, d0), i$4(c0, h0), i$4(h0, g0), i$4(h0, w0), i$4(h0, y0), i$4(c0, E0), i$4(E0, b0), i$4(E0, O0), i$4(E0, S0), i$4(E0, k0), i$4(c0, D0), i$4(D0, z0), i$4(D0, G0), i$4(D0, K0), i$4(c0, U0), i$4(U0, F0), i$4(U0, H0), i$4(U0, P0), i$4(U0, I0), i$4(U0, f0), i$4(c0, m0), i$4(m0, A0), i$4(m0, x0);
    },
    p(_0, [$0]) {
      $0 & /*size*/
      1 && t$2(
        e0,
        "width",
        /*size*/
        _0[0]
      ), $0 & /*size*/
      1 && t$2(
        e0,
        "height",
        /*size*/
        _0[0]
      );
    },
    i: B$2,
    o: B$2,
    d(_0) {
      _0 && M$2(e0);
    }
  };
}
function yo$1(t0, e0, n0) {
  let { size: r0 = "21" } = e0;
  return t0.$$set = (i0) => {
    "size" in i0 && n0(0, r0 = i0.size);
  }, [r0];
}
let xo$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, yo$1, vo$1, U$1, { size: 0 });
  }
};
function Fo$1(t0) {
  let e0, n0, r0, i0, o0, s0, a0, c0, l0, u0, d0, h0, g0, w0, y0, E0, b0, O0, S0, k0, D0, z0, G0, K0, U0, F0, H0, P0, I0, f0, m0, A0, x0, _0, $0, C0, M0, p0, v0, T0, L0, B0, W0, V0, Q0, X0, J0, yg, _g, wg, $g, Eg, bg, vg, Ag, Ig, Mg, Sg, Ng, Rg, kg, Dg, j0, N0, R0, Y0, Z0, q0, mg, Lg, Tg, Og, Pg, Cg, Ug, im, jg, Yg, om, Gg, Wg, sm, Bg, Vg, am, Qg, Zg, tm, Fg, Hg, rm, Kg;
  return {
    c() {
      e0 = c$2("svg"), n0 = c$2("path"), r0 = c$2("path"), i0 = c$2("path"), o0 = c$2("path"), s0 = c$2("path"), a0 = c$2("path"), c0 = c$2("path"), l0 = c$2("path"), u0 = c$2("path"), d0 = c$2("path"), h0 = c$2("path"), g0 = c$2("path"), w0 = c$2("defs"), y0 = c$2("linearGradient"), E0 = c$2("stop"), b0 = c$2("stop"), O0 = c$2("stop"), S0 = c$2("stop"), k0 = c$2("stop"), D0 = c$2("stop"), z0 = c$2("stop"), G0 = c$2("stop"), K0 = c$2("radialGradient"), U0 = c$2("stop"), F0 = c$2("stop"), H0 = c$2("stop"), P0 = c$2("stop"), I0 = c$2("stop"), f0 = c$2("stop"), m0 = c$2("stop"), A0 = c$2("stop"), x0 = c$2("stop"), _0 = c$2("radialGradient"), $0 = c$2("stop"), C0 = c$2("stop"), M0 = c$2("stop"), p0 = c$2("stop"), v0 = c$2("stop"), T0 = c$2("radialGradient"), L0 = c$2("stop"), B0 = c$2("stop"), W0 = c$2("stop"), V0 = c$2("stop"), Q0 = c$2("radialGradient"), X0 = c$2("stop"), J0 = c$2("stop"), yg = c$2("stop"), _g = c$2("stop"), wg = c$2("radialGradient"), $g = c$2("stop"), Eg = c$2("stop"), bg = c$2("stop"), vg = c$2("stop"), Ag = c$2("radialGradient"), Ig = c$2("stop"), Mg = c$2("stop"), Sg = c$2("stop"), Ng = c$2("stop"), Rg = c$2("stop"), kg = c$2("stop"), Dg = c$2("radialGradient"), j0 = c$2("stop"), N0 = c$2("stop"), R0 = c$2("stop"), Y0 = c$2("stop"), Z0 = c$2("stop"), q0 = c$2("radialGradient"), mg = c$2("stop"), Lg = c$2("stop"), Tg = c$2("stop"), Og = c$2("stop"), Pg = c$2("stop"), Cg = c$2("stop"), Ug = c$2("stop"), im = c$2("stop"), jg = c$2("radialGradient"), Yg = c$2("stop"), om = c$2("stop"), Gg = c$2("stop"), Wg = c$2("stop"), sm = c$2("stop"), Bg = c$2("radialGradient"), Vg = c$2("stop"), am = c$2("stop"), Qg = c$2("stop"), Zg = c$2("stop"), tm = c$2("linearGradient"), Fg = c$2("stop"), Hg = c$2("stop"), rm = c$2("stop"), Kg = c$2("stop"), t$2(n0, "d", "M19.0292 6.76185C18.6047 5.74052 17.7437 4.63778 17.0694 4.28919C17.5504 5.22056 17.8841 6.22082 18.0588 7.25436L18.0605 7.27075C16.956 4.51705 15.083 3.40675 13.5533 0.989041C13.4759 0.866794 13.3985 0.744296 13.3232 0.614992C13.2801 0.54114 13.2455 0.474597 13.2155 0.413348C13.1521 0.290485 13.1032 0.160639 13.0698 0.0264442C13.0699 0.0202518 13.0677 0.0142596 13.0636 0.0096107C13.0595 0.00496183 13.0538 0.00198167 13.0477 0.00123872C13.0416 -0.000412908 13.0353 -0.000412908 13.0293 0.00123872C13.028 0.00123872 13.026 0.00350722 13.0245 0.00401132C13.023 0.00451543 13.0197 0.00678392 13.0174 0.00779214L13.0212 0.00123872C10.5674 1.43795 9.73491 4.09763 9.65828 5.42798C8.67837 5.49533 7.7415 5.85643 6.96987 6.46417C6.88936 6.39598 6.80522 6.3322 6.71781 6.27311C6.49522 5.494 6.48573 4.66943 6.69034 3.8854C5.78923 4.32194 4.98854 4.94076 4.33892 5.70271H4.33439C3.94723 5.21196 3.97445 3.59377 3.99663 3.25577C3.8821 3.3018 3.77277 3.35984 3.67047 3.42893C3.3287 3.67286 3.00919 3.94657 2.71569 4.24685C2.38124 4.58594 2.07578 4.95245 1.8025 5.34253V5.34404V5.34228C1.17444 6.23267 0.728971 7.23866 0.491813 8.30216L0.478706 8.36668C0.460306 8.45263 0.394016 8.88314 0.382674 8.97665C0.382674 8.98396 0.381161 8.99077 0.380405 8.99808C0.294893 9.44254 0.241905 9.89264 0.221863 10.3448L0.221863 10.3952C0.224005 12.8412 1.14363 15.1974 2.799 16.9982C4.45436 18.799 6.72502 19.9132 9.16221 20.1208C11.5994 20.3284 14.0258 19.6141 15.9618 18.1193C17.8979 16.6244 19.2027 14.4576 19.6185 12.0472C19.6349 11.9212 19.6482 11.7964 19.6628 11.6691C19.864 10.0061 19.6462 8.31919 19.0292 6.76185ZM7.76989 14.4087C7.81551 14.4306 7.85836 14.4543 7.90524 14.4752L7.91205 14.4795C7.86466 14.4568 7.81728 14.4332 7.76989 14.4087ZM18.0613 7.27302V7.26369L18.063 7.27402L18.0613 7.27302Z"), t$2(n0, "fill", "url(#paint0_linear_6297_45086)"), t$2(r0, "d", "M19.029 6.76123C18.6045 5.7399 17.7435 4.63717 17.0693 4.28857C17.5502 5.21995 17.8839 6.2202 18.0586 7.25374V7.26307L18.0603 7.2734C18.8133 9.42808 18.7044 11.7904 17.7564 13.8667C16.6367 16.269 13.9266 18.7313 9.68457 18.6116C5.10095 18.4818 1.0643 15.0805 0.309647 10.6257C0.172277 9.92326 0.309647 9.5671 0.37871 8.9962C0.284499 9.43966 0.231927 9.89095 0.22168 10.3442L0.22168 10.3946C0.223821 12.8406 1.14345 15.1968 2.79882 16.9976C4.45418 18.7983 6.72484 19.9126 9.16203 20.1202C11.5992 20.3278 14.0256 19.6135 15.9616 18.1186C17.8977 16.6237 19.2025 14.457 19.6183 12.0466C19.6347 11.9205 19.648 11.7958 19.6627 11.6685C19.8639 10.0055 19.646 8.31857 19.029 6.76123Z"), t$2(r0, "fill", "url(#paint1_radial_6297_45086)"), t$2(i0, "d", "M19.029 6.76123C18.6045 5.7399 17.7435 4.63717 17.0693 4.28857C17.5502 5.21995 17.8839 6.2202 18.0586 7.25374V7.26307L18.0603 7.2734C18.8133 9.42808 18.7044 11.7904 17.7564 13.8667C16.6367 16.269 13.9266 18.7313 9.68457 18.6116C5.10095 18.4818 1.0643 15.0805 0.309647 10.6257C0.172277 9.92326 0.309647 9.5671 0.37871 8.9962C0.284499 9.43966 0.231927 9.89095 0.22168 10.3442L0.22168 10.3946C0.223821 12.8406 1.14345 15.1968 2.79882 16.9976C4.45418 18.7983 6.72484 19.9126 9.16203 20.1202C11.5992 20.3278 14.0256 19.6135 15.9616 18.1186C17.8977 16.6237 19.2025 14.457 19.6183 12.0466C19.6347 11.9205 19.648 11.7958 19.6627 11.6685C19.8639 10.0055 19.646 8.31857 19.029 6.76123Z"), t$2(i0, "fill", "url(#paint2_radial_6297_45086)"), t$2(o0, "d", "M14.2817 7.91068C14.3029 7.92555 14.3225 7.94042 14.3425 7.95529C14.0971 7.52017 13.7916 7.12179 13.4351 6.7719C10.3988 3.73514 12.6393 0.187473 13.0172 0.00725419L13.0209 0.00170898C10.5672 1.43842 9.73464 4.0981 9.65802 5.42844C9.77195 5.42063 9.88487 5.41105 10.0013 5.41105C10.872 5.41265 11.7267 5.64477 12.4785 6.08382C13.2303 6.52287 13.8525 7.15319 14.2817 7.91068Z"), t$2(o0, "fill", "url(#paint3_radial_6297_45086)"), t$2(s0, "d", "M10.0075 8.5172C9.9914 8.76018 9.1329 9.59826 8.8327 9.59826C6.05481 9.59826 5.60388 11.2787 5.60388 11.2787C5.72688 12.6937 6.71292 13.8592 7.90489 14.4758C7.95933 14.504 8.01453 14.5295 8.06973 14.5544C8.16535 14.5968 8.26096 14.6359 8.35657 14.6719C8.76565 14.8166 9.19411 14.8993 9.62768 14.9171C14.4966 15.1455 15.4398 9.09466 11.9262 7.33885C12.7551 7.23099 13.5945 7.43481 14.2816 7.91076C13.8524 7.15327 13.2302 6.52295 12.4784 6.0839C11.7266 5.64485 10.8719 5.41273 10.0012 5.41113C9.88528 5.41113 9.77186 5.42071 9.65793 5.42852C8.67802 5.49588 7.74115 5.85698 6.96951 6.46472C7.11848 6.59075 7.2866 6.75912 7.64074 7.10822C8.30364 7.76129 10.0037 8.4378 10.0075 8.5172Z"), t$2(s0, "fill", "url(#paint4_radial_6297_45086)"), t$2(a0, "d", "M10.0075 8.5172C9.9914 8.76018 9.1329 9.59826 8.8327 9.59826C6.05481 9.59826 5.60388 11.2787 5.60388 11.2787C5.72688 12.6937 6.71292 13.8592 7.90489 14.4758C7.95933 14.504 8.01453 14.5295 8.06973 14.5544C8.16535 14.5968 8.26096 14.6359 8.35657 14.6719C8.76565 14.8166 9.19411 14.8993 9.62768 14.9171C14.4966 15.1455 15.4398 9.09466 11.9262 7.33885C12.7551 7.23099 13.5945 7.43481 14.2816 7.91076C13.8524 7.15327 13.2302 6.52295 12.4784 6.0839C11.7266 5.64485 10.8719 5.41273 10.0012 5.41113C9.88528 5.41113 9.77186 5.42071 9.65793 5.42852C8.67802 5.49588 7.74115 5.85698 6.96951 6.46472C7.11848 6.59075 7.2866 6.75912 7.64074 7.10822C8.30364 7.76129 10.0037 8.4378 10.0075 8.5172Z"), t$2(a0, "fill", "url(#paint5_radial_6297_45086)"), t$2(c0, "d", "M6.51447 6.1401C6.59361 6.19051 6.65889 6.23437 6.71611 6.27394C6.49352 5.49483 6.48403 4.67026 6.68864 3.88623C5.78753 4.32277 4.98683 4.94159 4.33722 5.70354C4.38486 5.70228 5.80191 5.67683 6.51447 6.1401Z"), t$2(c0, "fill", "url(#paint6_radial_6297_45086)"), t$2(l0, "d", "M0.310452 10.6269C1.06435 15.0817 5.10176 18.4829 9.68537 18.6127C13.9275 18.7327 16.6375 16.2701 17.7572 13.8678C18.7052 11.7915 18.8141 9.4292 18.0611 7.27452V7.2652C18.0611 7.25789 18.0596 7.2536 18.0611 7.25587L18.0629 7.27225C18.4095 9.53495 17.2586 11.7271 15.4594 13.2094L15.4539 13.222C11.9483 16.077 8.59347 14.9445 7.91443 14.4823C7.86705 14.4596 7.81966 14.436 7.77228 14.4115C5.72837 13.4345 4.88398 11.5723 5.06496 9.97529C4.57978 9.98245 4.10294 9.84875 3.6922 9.59039C3.28147 9.33204 2.95448 8.96011 2.75084 8.51967C3.28737 8.19098 3.89913 8.00516 4.52783 7.97992C5.15653 7.95468 5.78122 8.09087 6.34237 8.3755C7.49926 8.90069 8.81572 8.95244 10.0103 8.51967C10.0065 8.44028 8.30638 7.76351 7.64348 7.11069C7.28934 6.76159 7.12122 6.59347 6.97226 6.46719C6.89175 6.399 6.80761 6.33522 6.7202 6.27614C6.66223 6.23656 6.59695 6.19371 6.51856 6.14229C5.806 5.67902 4.38895 5.70448 4.34207 5.70574H4.33753C3.95037 5.21499 3.97759 3.59679 3.99978 3.25879C3.88524 3.30482 3.77591 3.36286 3.67362 3.43195C3.33184 3.67588 3.01233 3.94959 2.71883 4.24987C2.38319 4.58801 2.07645 4.95367 1.80186 5.34303V5.34454V5.34278C1.1738 6.23317 0.728333 7.23916 0.491175 8.30265C0.486386 8.32257 0.139307 9.83994 0.310452 10.6269Z"), t$2(l0, "fill", "url(#paint7_radial_6297_45086)"), t$2(u0, "d", "M13.435 6.77143C13.7917 7.12171 14.0972 7.52052 14.3424 7.95608C14.3961 7.99666 14.4463 8.03699 14.4889 8.07606C16.7037 10.1177 15.5432 13.0037 15.4568 13.2092C17.2559 11.7268 18.4058 9.5347 18.0603 7.27201C16.9552 4.51705 15.0822 3.40675 13.5525 0.989041C13.4751 0.866794 13.3977 0.744296 13.3224 0.614992C13.2793 0.54114 13.2447 0.474597 13.2148 0.413348C13.1513 0.290485 13.1024 0.160639 13.0691 0.0264442C13.0691 0.0202518 13.0669 0.0142596 13.0628 0.0096107C13.0587 0.00496183 13.053 0.00198167 13.0469 0.00123872C13.0409 -0.000412908 13.0345 -0.000412908 13.0285 0.00123872C13.0272 0.00123872 13.0252 0.00350721 13.0237 0.00401132C13.0222 0.00451543 13.0189 0.00678392 13.0166 0.00779214C12.6388 0.187003 10.3983 3.73467 13.435 6.77143Z"), t$2(u0, "fill", "url(#paint8_radial_6297_45086)"), t$2(d0, "d", "M14.488 8.07354C14.4454 8.03447 14.3952 7.99414 14.3415 7.95356C14.3216 7.93869 14.302 7.92382 14.2808 7.90895C13.5936 7.433 12.7542 7.22919 11.9253 7.33704C15.439 9.09386 14.4963 15.1437 9.62685 14.9153C9.19327 14.8975 8.76481 14.8148 8.35573 14.6701C8.26012 14.6343 8.16451 14.5951 8.0689 14.5526C8.0137 14.5274 7.9585 14.5022 7.90405 14.474L7.91086 14.4782C8.58989 14.9418 11.9437 16.0743 15.4503 13.218L15.4559 13.2054C15.5433 13.0012 16.7038 10.1144 14.488 8.07354Z"), t$2(d0, "fill", "url(#paint9_radial_6297_45086)"), t$2(h0, "d", "M5.60413 11.2781C5.60413 11.2781 6.05506 9.59766 8.83295 9.59766C9.13315 9.59766 9.9924 8.75958 10.0078 8.51659C8.81323 8.94936 7.49677 8.89761 6.33988 8.37242C5.77873 8.08779 5.15404 7.9516 4.52534 7.97684C3.89664 8.00208 3.28488 8.1879 2.74835 8.51659C2.95199 8.95703 3.27898 9.32896 3.68971 9.58731C4.10044 9.84567 4.57729 9.97937 5.06247 9.97221C4.88149 11.5695 5.72587 13.4317 7.76978 14.4084C7.81541 14.4303 7.85825 14.454 7.90514 14.4749C6.71216 13.8586 5.72713 12.6931 5.60413 11.2781Z"), t$2(h0, "fill", "url(#paint10_radial_6297_45086)"), t$2(g0, "d", "M19.0292 6.76185C18.6047 5.74052 17.7437 4.63778 17.0694 4.28919C17.5504 5.22056 17.8841 6.22082 18.0588 7.25436L18.0605 7.27075C16.956 4.51705 15.083 3.40675 13.5533 0.989041C13.4759 0.866794 13.3985 0.744296 13.3232 0.614992C13.2801 0.54114 13.2455 0.474597 13.2155 0.413348C13.1521 0.290485 13.1032 0.160639 13.0698 0.0264442C13.0699 0.0202518 13.0677 0.0142596 13.0636 0.0096107C13.0595 0.00496183 13.0538 0.00198167 13.0477 0.00123872C13.0416 -0.000412908 13.0353 -0.000412908 13.0293 0.00123872C13.028 0.00123872 13.026 0.00350722 13.0245 0.00401132C13.023 0.00451543 13.0197 0.00678392 13.0174 0.00779214L13.0212 0.00123872C10.5674 1.43795 9.73491 4.09763 9.65828 5.42798C9.77221 5.42016 9.88513 5.41058 10.0016 5.41058C10.8722 5.41218 11.7269 5.6443 12.4788 6.08335C13.2306 6.5224 13.8527 7.15272 14.282 7.91021C13.5948 7.43426 12.7554 7.23044 11.9265 7.3383C15.4402 9.09512 14.4975 15.1449 9.62804 14.9166C9.19446 14.8988 8.766 14.8161 8.35693 14.6713C8.26131 14.6355 8.1657 14.5964 8.07009 14.5539C8.01489 14.5287 7.95969 14.5035 7.90524 14.4752L7.91205 14.4795C7.86466 14.4568 7.81728 14.4332 7.76989 14.4087C7.81551 14.4306 7.85836 14.4543 7.90524 14.4752C6.71227 13.8587 5.72724 12.6932 5.60424 11.2782C5.60424 11.2782 6.05516 9.59772 8.83306 9.59772C9.13325 9.59772 9.99251 8.75963 10.0079 8.51665C10.0041 8.43726 8.30399 7.76049 7.64109 7.10767C7.28695 6.75857 7.11883 6.59045 6.96987 6.46417C6.88936 6.39598 6.80522 6.3322 6.71781 6.27311C6.49522 5.494 6.48573 4.66943 6.69034 3.8854C5.78923 4.32194 4.98854 4.94076 4.33892 5.70271H4.33439C3.94723 5.21196 3.97445 3.59377 3.99663 3.25577C3.8821 3.3018 3.77277 3.35984 3.67047 3.42893C3.3287 3.67286 3.00919 3.94657 2.71569 4.24685C2.38124 4.58594 2.07578 4.95245 1.8025 5.34253V5.34404V5.34228C1.17444 6.23267 0.728971 7.23866 0.491813 8.30216L0.478706 8.36668C0.460306 8.45263 0.377885 8.88919 0.366038 8.98295C0.366038 8.97565 0.366038 8.99001 0.366038 8.98295C0.290651 9.43359 0.242505 9.88837 0.221863 10.3448L0.221863 10.3952C0.224005 12.8412 1.14363 15.1974 2.799 16.9982C4.45436 18.799 6.72502 19.9132 9.16221 20.1208C11.5994 20.3284 14.0258 19.6141 15.9618 18.1193C17.8979 16.6244 19.2027 14.4576 19.6185 12.0472C19.6349 11.9212 19.6482 11.7964 19.6628 11.6691C19.864 10.0061 19.6462 8.31919 19.0292 6.76185ZM18.06 7.26369L18.0618 7.27402L18.06 7.26369Z"), t$2(g0, "fill", "url(#paint11_linear_6297_45086)"), t$2(E0, "offset", "0.048"), t$2(E0, "stop-color", "#FFF44F"), t$2(b0, "offset", "0.111"), t$2(b0, "stop-color", "#FFE847"), t$2(O0, "offset", "0.225"), t$2(O0, "stop-color", "#FFC830"), t$2(S0, "offset", "0.368"), t$2(S0, "stop-color", "#FF980E"), t$2(k0, "offset", "0.401"), t$2(k0, "stop-color", "#FF8B16"), t$2(D0, "offset", "0.462"), t$2(D0, "stop-color", "#FF672A"), t$2(z0, "offset", "0.534"), t$2(z0, "stop-color", "#FF3647"), t$2(G0, "offset", "0.705"), t$2(G0, "stop-color", "#E31587"), t$2(y0, "id", "paint0_linear_6297_45086"), t$2(y0, "x1", "17.7361"), t$2(y0, "y1", "3.12268"), t$2(y0, "x2", "1.51918"), t$2(y0, "y2", "18.769"), t$2(y0, "gradientUnits", "userSpaceOnUse"), t$2(U0, "offset", "0.129"), t$2(U0, "stop-color", "#FFBD4F"), t$2(F0, "offset", "0.186"), t$2(F0, "stop-color", "#FFAC31"), t$2(H0, "offset", "0.247"), t$2(H0, "stop-color", "#FF9D17"), t$2(P0, "offset", "0.283"), t$2(P0, "stop-color", "#FF980E"), t$2(I0, "offset", "0.403"), t$2(I0, "stop-color", "#FF563B"), t$2(f0, "offset", "0.467"), t$2(f0, "stop-color", "#FF3750"), t$2(m0, "offset", "0.71"), t$2(m0, "stop-color", "#F5156C"), t$2(A0, "offset", "0.782"), t$2(A0, "stop-color", "#EB0878"), t$2(x0, "offset", "0.86"), t$2(x0, "stop-color", "#E50080"), t$2(K0, "id", "paint1_radial_6297_45086"), t$2(K0, "cx", "0"), t$2(K0, "cy", "0"), t$2(K0, "r", "1"), t$2(K0, "gradientUnits", "userSpaceOnUse"), t$2(K0, "gradientTransform", "translate(16.9866 2.23629) scale(20.3653 20.3653)"), t$2($0, "offset", "0.3"), t$2($0, "stop-color", "#960E18"), t$2(C0, "offset", "0.351"), t$2(C0, "stop-color", "#B11927"), t$2(C0, "stop-opacity", "0.74"), t$2(M0, "offset", "0.435"), t$2(M0, "stop-color", "#DB293D"), t$2(M0, "stop-opacity", "0.343"), t$2(p0, "offset", "0.497"), t$2(p0, "stop-color", "#F5334B"), t$2(p0, "stop-opacity", "0.094"), t$2(v0, "offset", "0.53"), t$2(v0, "stop-color", "#FF3750"), t$2(v0, "stop-opacity", "0"), t$2(_0, "id", "paint2_radial_6297_45086"), t$2(_0, "cx", "0"), t$2(_0, "cy", "0"), t$2(_0, "r", "1"), t$2(_0, "gradientUnits", "userSpaceOnUse"), t$2(_0, "gradientTransform", "translate(9.54495 10.5622) scale(20.3653 20.3653)"), t$2(L0, "offset", "0.132"), t$2(L0, "stop-color", "#FFF44F"), t$2(B0, "offset", "0.252"), t$2(B0, "stop-color", "#FFDC3E"), t$2(W0, "offset", "0.506"), t$2(W0, "stop-color", "#FF9D12"), t$2(V0, "offset", "0.526"), t$2(V0, "stop-color", "#FF980E"), t$2(T0, "id", "paint3_radial_6297_45086"), t$2(T0, "cx", "0"), t$2(T0, "cy", "0"), t$2(T0, "r", "1"), t$2(T0, "gradientUnits", "userSpaceOnUse"), t$2(T0, "gradientTransform", "translate(12.0001 -2.38427) scale(14.7538 14.7538)"), t$2(X0, "offset", "0.353"), t$2(X0, "stop-color", "#3A8EE6"), t$2(J0, "offset", "0.472"), t$2(J0, "stop-color", "#5C79F0"), t$2(yg, "offset", "0.669"), t$2(yg, "stop-color", "#9059FF"), t$2(_g, "offset", "1"), t$2(_g, "stop-color", "#C139E6"), t$2(Q0, "id", "paint4_radial_6297_45086"), t$2(Q0, "cx", "0"), t$2(Q0, "cy", "0"), t$2(Q0, "r", "1"), t$2(Q0, "gradientUnits", "userSpaceOnUse"), t$2(Q0, "gradientTransform", "translate(7.29217 15.8829) scale(9.6968 9.69679)"), t$2($g, "offset", "0.206"), t$2($g, "stop-color", "#9059FF"), t$2($g, "stop-opacity", "0"), t$2(Eg, "offset", "0.278"), t$2(Eg, "stop-color", "#8C4FF3"), t$2(Eg, "stop-opacity", "0.064"), t$2(bg, "offset", "0.747"), t$2(bg, "stop-color", "#7716A8"), t$2(bg, "stop-opacity", "0.45"), t$2(vg, "offset", "0.975"), t$2(vg, "stop-color", "#6E008B"), t$2(vg, "stop-opacity", "0.6"), t$2(wg, "id", "paint5_radial_6297_45086"), t$2(wg, "cx", "0"), t$2(wg, "cy", "0"), t$2(wg, "r", "1"), t$2(wg, "gradientUnits", "userSpaceOnUse"), t$2(wg, "gradientTransform", "translate(10.6576 8.89437) rotate(-13.5916) scale(5.14118 6.01904)"), t$2(Ig, "stop-color", "#FFE226"), t$2(Mg, "offset", "0.121"), t$2(Mg, "stop-color", "#FFDB27"), t$2(Sg, "offset", "0.295"), t$2(Sg, "stop-color", "#FFC82A"), t$2(Ng, "offset", "0.502"), t$2(Ng, "stop-color", "#FFA930"), t$2(Rg, "offset", "0.732"), t$2(Rg, "stop-color", "#FF7E37"), t$2(kg, "offset", "0.792"), t$2(kg, "stop-color", "#FF7139"), t$2(Ag, "id", "paint6_radial_6297_45086"), t$2(Ag, "cx", "0"), t$2(Ag, "cy", "0"), t$2(Ag, "r", "1"), t$2(Ag, "gradientUnits", "userSpaceOnUse"), t$2(Ag, "gradientTransform", "translate(9.28808 1.40453) scale(6.97586)"), t$2(j0, "offset", "0.113"), t$2(j0, "stop-color", "#FFF44F"), t$2(N0, "offset", "0.456"), t$2(N0, "stop-color", "#FF980E"), t$2(R0, "offset", "0.622"), t$2(R0, "stop-color", "#FF5634"), t$2(Y0, "offset", "0.716"), t$2(Y0, "stop-color", "#FF3647"), t$2(Z0, "offset", "0.904"), t$2(Z0, "stop-color", "#E31587"), t$2(Dg, "id", "paint7_radial_6297_45086"), t$2(Dg, "cx", "0"), t$2(Dg, "cy", "0"), t$2(Dg, "r", "1"), t$2(Dg, "gradientUnits", "userSpaceOnUse"), t$2(Dg, "gradientTransform", "translate(14.7705 -3.02052) scale(29.7629 29.7629)"), t$2(mg, "stop-color", "#FFF44F"), t$2(Lg, "offset", "0.06"), t$2(Lg, "stop-color", "#FFE847"), t$2(Tg, "offset", "0.168"), t$2(Tg, "stop-color", "#FFC830"), t$2(Og, "offset", "0.304"), t$2(Og, "stop-color", "#FF980E"), t$2(Pg, "offset", "0.356"), t$2(Pg, "stop-color", "#FF8B16"), t$2(Cg, "offset", "0.455"), t$2(Cg, "stop-color", "#FF672A"), t$2(Ug, "offset", "0.57"), t$2(Ug, "stop-color", "#FF3647"), t$2(im, "offset", "0.737"), t$2(im, "stop-color", "#E31587"), t$2(q0, "id", "paint8_radial_6297_45086"), t$2(q0, "cx", "0"), t$2(q0, "cy", "0"), t$2(q0, "r", "1"), t$2(q0, "gradientUnits", "userSpaceOnUse"), t$2(q0, "gradientTransform", "translate(12.262 -1.36605) rotate(83.976) scale(21.8139 14.3163)"), t$2(Yg, "offset", "0.137"), t$2(Yg, "stop-color", "#FFF44F"), t$2(om, "offset", "0.48"), t$2(om, "stop-color", "#FF980E"), t$2(Gg, "offset", "0.592"), t$2(Gg, "stop-color", "#FF5634"), t$2(Wg, "offset", "0.655"), t$2(Wg, "stop-color", "#FF3647"), t$2(sm, "offset", "0.904"), t$2(sm, "stop-color", "#E31587"), t$2(jg, "id", "paint9_radial_6297_45086"), t$2(jg, "cx", "0"), t$2(jg, "cy", "0"), t$2(jg, "r", "1"), t$2(jg, "gradientUnits", "userSpaceOnUse"), t$2(jg, "gradientTransform", "translate(9.12354 3.98625) scale(18.5815 18.5815)"), t$2(Vg, "offset", "0.094"), t$2(Vg, "stop-color", "#FFF44F"), t$2(am, "offset", "0.231"), t$2(am, "stop-color", "#FFE141"), t$2(Qg, "offset", "0.509"), t$2(Qg, "stop-color", "#FFAF1E"), t$2(Zg, "offset", "0.626"), t$2(Zg, "stop-color", "#FF980E"), t$2(Bg, "id", "paint10_radial_6297_45086"), t$2(Bg, "cx", "0"), t$2(Bg, "cy", "0"), t$2(Bg, "r", "1"), t$2(Bg, "gradientUnits", "userSpaceOnUse"), t$2(Bg, "gradientTransform", "translate(14.0286 5.07494) scale(20.3373 20.3373)"), t$2(Fg, "offset", "0.167"), t$2(Fg, "stop-color", "#FFF44F"), t$2(Fg, "stop-opacity", "0.8"), t$2(Hg, "offset", "0.266"), t$2(Hg, "stop-color", "#FFF44F"), t$2(Hg, "stop-opacity", "0.634"), t$2(rm, "offset", "0.489"), t$2(rm, "stop-color", "#FFF44F"), t$2(rm, "stop-opacity", "0.217"), t$2(Kg, "offset", "0.6"), t$2(Kg, "stop-color", "#FFF44F"), t$2(Kg, "stop-opacity", "0"), t$2(tm, "id", "paint11_linear_6297_45086"), t$2(tm, "x1", "17.5413"), t$2(tm, "y1", "3.039"), t$2(tm, "x2", "3.74231"), t$2(tm, "y2", "16.8377"), t$2(tm, "gradientUnits", "userSpaceOnUse"), t$2(e0, "xmlns", "http://www.w3.org/2000/svg"), t$2(
        e0,
        "width",
        /*size*/
        t0[0]
      ), t$2(
        e0,
        "height",
        /*size*/
        t0[0]
      ), t$2(e0, "viewBox", "0 0 20 21"), t$2(e0, "fill", "none");
    },
    m(zg, cm) {
      $$1(zg, e0, cm), i$4(e0, n0), i$4(e0, r0), i$4(e0, i0), i$4(e0, o0), i$4(e0, s0), i$4(e0, a0), i$4(e0, c0), i$4(e0, l0), i$4(e0, u0), i$4(e0, d0), i$4(e0, h0), i$4(e0, g0), i$4(e0, w0), i$4(w0, y0), i$4(y0, E0), i$4(y0, b0), i$4(y0, O0), i$4(y0, S0), i$4(y0, k0), i$4(y0, D0), i$4(y0, z0), i$4(y0, G0), i$4(w0, K0), i$4(K0, U0), i$4(K0, F0), i$4(K0, H0), i$4(K0, P0), i$4(K0, I0), i$4(K0, f0), i$4(K0, m0), i$4(K0, A0), i$4(K0, x0), i$4(w0, _0), i$4(_0, $0), i$4(_0, C0), i$4(_0, M0), i$4(_0, p0), i$4(_0, v0), i$4(w0, T0), i$4(T0, L0), i$4(T0, B0), i$4(T0, W0), i$4(T0, V0), i$4(w0, Q0), i$4(Q0, X0), i$4(Q0, J0), i$4(Q0, yg), i$4(Q0, _g), i$4(w0, wg), i$4(wg, $g), i$4(wg, Eg), i$4(wg, bg), i$4(wg, vg), i$4(w0, Ag), i$4(Ag, Ig), i$4(Ag, Mg), i$4(Ag, Sg), i$4(Ag, Ng), i$4(Ag, Rg), i$4(Ag, kg), i$4(w0, Dg), i$4(Dg, j0), i$4(Dg, N0), i$4(Dg, R0), i$4(Dg, Y0), i$4(Dg, Z0), i$4(w0, q0), i$4(q0, mg), i$4(q0, Lg), i$4(q0, Tg), i$4(q0, Og), i$4(q0, Pg), i$4(q0, Cg), i$4(q0, Ug), i$4(q0, im), i$4(w0, jg), i$4(jg, Yg), i$4(jg, om), i$4(jg, Gg), i$4(jg, Wg), i$4(jg, sm), i$4(w0, Bg), i$4(Bg, Vg), i$4(Bg, am), i$4(Bg, Qg), i$4(Bg, Zg), i$4(w0, tm), i$4(tm, Fg), i$4(tm, Hg), i$4(tm, rm), i$4(tm, Kg);
    },
    p(zg, [cm]) {
      cm & /*size*/
      1 && t$2(
        e0,
        "width",
        /*size*/
        zg[0]
      ), cm & /*size*/
      1 && t$2(
        e0,
        "height",
        /*size*/
        zg[0]
      );
    },
    i: B$2,
    o: B$2,
    d(zg) {
      zg && M$2(e0);
    }
  };
}
function Lo$1(t0, e0, n0) {
  let { size: r0 = "21" } = e0;
  return t0.$$set = (i0) => {
    "size" in i0 && n0(0, r0 = i0.size);
  }, [r0];
}
let Bo$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, Lo$1, Fo$1, U$1, { size: 0 });
  }
};
function Mo$1(t0) {
  let e0, n0, r0, i0, o0, s0, a0, c0, l0, u0, d0, h0, g0, w0, y0, E0, b0, O0, S0, k0, D0;
  return {
    c() {
      e0 = c$2("svg"), n0 = c$2("g"), r0 = c$2("mask"), i0 = c$2("circle"), o0 = c$2("g"), s0 = c$2("path"), a0 = c$2("path"), c0 = c$2("path"), l0 = c$2("path"), u0 = c$2("path"), d0 = c$2("path"), h0 = c$2("path"), g0 = c$2("path"), w0 = c$2("path"), y0 = c$2("path"), E0 = c$2("path"), b0 = c$2("path"), O0 = c$2("path"), S0 = c$2("defs"), k0 = c$2("clipPath"), D0 = c$2("rect"), t$2(i0, "cx", "59.2004"), t$2(i0, "cy", "53.9996"), t$2(i0, "r", "53.9"), t$2(i0, "fill", "#F2F2F2"), t$2(r0, "id", "mask0_6297_45055"), xe$1(r0, "mask-type", "alpha"), t$2(r0, "maskUnits", "userSpaceOnUse"), t$2(r0, "x", "5"), t$2(r0, "y", "0"), t$2(r0, "width", "109"), t$2(r0, "height", "108"), t$2(s0, "d", "M59.4166 107.844C89.1694 107.844 113.289 83.7244 113.289 53.9717C113.289 24.219 89.1694 0.0996094 59.4166 0.0996094C29.6639 0.0996094 5.54456 24.219 5.54456 53.9717C5.54456 83.7244 29.6639 107.844 59.4166 107.844Z"), t$2(s0, "fill", "#BFBFBF"), t$2(s0, "fill-opacity", "0.2"), t$2(o0, "mask", "url(#mask0_6297_45055)"), t$2(a0, "d", "M54.8457 95.6447L39.8764 33.1839C39.1425 30.1277 40.4294 26.9308 43.0935 25.2418L63.6825 12.1625C64.8688 11.4086 66.2964 11.4789 67.3721 12.1424C65.1503 9.74977 62.1946 9.70956 60.8978 10.745L39.3537 24.4275C36.2774 26.3778 34.7895 30.0674 35.634 33.6061L49.9397 93.3224C50.6636 96.3585 56.8463 99.3041 59.4501 97.5749V97.5548C57.6707 98.6305 55.3383 97.6754 54.8457 95.6246V95.6447Z"), t$2(a0, "fill", "#8C8C8C"), t$2(a0, "stroke", "#0F0F0F"), t$2(a0, "stroke-width", "0.502662"), t$2(a0, "stroke-miterlimit", "10"), t$2(c0, "d", "M58.4029 90.9901L60.7654 96.4993L59.4484 97.5851C56.8446 99.3142 50.6719 96.3686 49.938 93.3325L48.5406 87.5117L58.4029 90.9901Z"), t$2(c0, "fill", "#0F0F0F"), t$2(c0, "stroke", "#0F0F0F"), t$2(c0, "stroke-width", "0.603195"), t$2(c0, "stroke-miterlimit", "10"), t$2(l0, "d", "M83.7591 75.3371L68.9305 14.2838C68.3676 11.9715 65.6934 10.8958 63.6827 12.1625L43.0937 25.2418C40.4396 26.9307 39.1428 30.1176 39.8767 33.1839L54.8359 95.6447C55.3385 97.7357 57.7614 98.6908 59.5609 97.5045L80.532 83.5808C83.2363 81.7812 84.5231 78.4938 83.7591 75.3371Z"), t$2(l0, "fill", "#8C8C8C"), t$2(l0, "stroke", "#0F0F0F"), t$2(l0, "stroke-width", "0.502662"), t$2(l0, "stroke-miterlimit", "10"), t$2(u0, "d", "M82.3298 74.4824L68.5367 16.0429C68.014 13.8312 65.5509 12.7857 63.7112 14.0021L61.1476 15.6911L60.2127 19.0288C60.0418 19.642 59.6597 20.1648 59.1269 20.5166L50.6922 26.1666C49.9382 26.6692 48.9832 26.7597 48.1588 26.3978L46.1884 25.5533L44.8111 26.4682C42.3681 28.0767 41.1919 31.1228 41.8755 34.0584L55.7993 93.855C56.2718 95.8556 58.5036 96.7805 60.1523 95.6445L79.4043 82.3843C81.8875 80.6752 83.0637 77.5185 82.3499 74.5026L82.3298 74.4824Z"), t$2(u0, "fill", "#FF875B"), t$2(u0, "stroke", "#0F0F0F"), t$2(u0, "stroke-width", "0.603195"), t$2(u0, "stroke-miterlimit", "10"), t$2(d0, "d", "M51.5376 22.9399C51.5979 23.1208 51.809 23.161 52.0101 23.0203L58.1224 18.9085C58.3235 18.7778 58.4341 18.5164 58.3738 18.3355C58.3134 18.1545 58.1023 18.1143 57.9013 18.255L51.7889 22.3668C51.5878 22.4975 51.4772 22.7589 51.5376 22.9399Z"), t$2(d0, "fill", "#0F0F0F"), t$2(h0, "d", "M50.1602 24.5681C50.4718 24.548 50.703 24.2263 50.6729 23.8643C50.6427 23.4924 50.3713 23.2109 50.0697 23.231C49.758 23.2511 49.5268 23.5728 49.557 23.9347C49.5871 24.3067 49.8586 24.5882 50.1602 24.5681Z"), t$2(h0, "fill", "#0F0F0F"), t$2(g0, "d", "M50.9649 73.1354L54.2624 23.7739L50.6834 26.1666C50.0199 26.6089 49.1955 26.7296 48.4415 26.5084L46.2399 52.8982L50.9548 73.1454L50.9649 73.1354Z"), t$2(g0, "fill", "#FFCBB8"), t$2(w0, "d", "M44.7614 46.4642L45.2841 48.696L47.2847 26.0159L46.6413 25.7344L44.7614 46.4541V46.4642Z"), t$2(w0, "fill", "#FFCBB8"), t$2(y0, "d", "M82.3298 74.4824L68.5367 16.0429C68.014 13.8312 65.5509 12.7857 63.7112 14.0021L61.1476 15.6911L60.2127 19.0288C60.0418 19.642 59.6597 20.1648 59.1269 20.5166L50.6922 26.1666C49.9382 26.6692 48.9832 26.7597 48.1588 26.3978L46.1884 25.5533L44.8111 26.4682C42.3681 28.0767 41.1919 31.1228 41.8755 34.0584L55.7993 93.8551C56.2718 95.8556 58.5036 96.7805 60.1523 95.6445L79.4043 82.3843C81.8875 80.6752 83.0637 77.5185 82.3499 74.5026L82.3298 74.4824Z"), t$2(y0, "stroke", "#0F0F0F"), t$2(y0, "stroke-width", "0.502662"), t$2(y0, "stroke-miterlimit", "10"), t$2(E0, "d", "M47.7989 83.8722L52.4535 85.1389L41.4151 39.5675L36.861 38.7432L47.7989 83.8822V83.8722Z"), t$2(E0, "fill", "#0F0F0F"), t$2(E0, "stroke", "#0F0F0F"), t$2(E0, "stroke-width", "0.603195"), t$2(E0, "stroke-miterlimit", "10"), t$2(b0, "d", "M39.5939 33.3041C38.9806 30.7104 39.6341 27.9759 41.7654 25.8949L38.679 25.3018C36.3969 27.1918 35.4419 30.0268 35.7837 32.7713L39.5939 33.3041Z"), t$2(b0, "fill", "#F8F8F8"), t$2(O0, "d", "M62.0044 48.0829L59.8027 49.2792C59.7324 49.3194 59.6921 49.43 59.7223 49.5205C60.5366 52.2147 60.2451 55.3413 58.8678 58.1562C58.8276 58.2467 58.8477 58.3573 58.9181 58.4176L61.0694 60.0161C61.1398 60.0663 61.2404 60.0462 61.2906 59.9557C62.1451 58.2065 62.6679 56.3466 62.8489 54.4868C64.0653 55.6127 65.523 56.4472 67.1416 56.9297C67.222 56.9498 67.3025 56.8895 67.3226 56.789L67.775 53.783C67.785 53.6825 67.7347 53.582 67.6543 53.5619C65.1209 52.7777 63.1404 50.8374 62.2055 48.1834C62.1753 48.0929 62.0848 48.0426 62.0145 48.0829H62.0044Z"), t$2(O0, "fill", "white"), t$2(n0, "clip-path", "url(#clip0_6297_45055)"), t$2(D0, "width", "117.6"), t$2(D0, "height", "107.8"), t$2(D0, "fill", "white"), t$2(D0, "transform", "translate(0.400024 0.100098)"), t$2(k0, "id", "clip0_6297_45055"), t$2(e0, "xmlns", "http://www.w3.org/2000/svg"), t$2(e0, "width", "118"), t$2(e0, "height", "108"), t$2(e0, "viewBox", "0 0 118 108"), t$2(e0, "fill", "none");
    },
    m(z0, G0) {
      $$1(z0, e0, G0), i$4(e0, n0), i$4(n0, r0), i$4(r0, i0), i$4(n0, o0), i$4(o0, s0), i$4(n0, a0), i$4(n0, c0), i$4(n0, l0), i$4(n0, u0), i$4(n0, d0), i$4(n0, h0), i$4(n0, g0), i$4(n0, w0), i$4(n0, y0), i$4(n0, E0), i$4(n0, b0), i$4(n0, O0), i$4(e0, S0), i$4(S0, k0), i$4(k0, D0);
    },
    p: B$2,
    i: B$2,
    o: B$2,
    d(z0) {
      z0 && M$2(e0);
    }
  };
}
let So$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, null, Mo$1, U$1, {});
  }
};
function $o$1(t0) {
  let e0, n0, r0, i0, o0, s0, a0, c0, l0, u0, d0, h0, g0, w0, y0, E0, b0, O0, S0, k0, D0, z0, G0, K0, U0, F0, H0, P0, I0, f0, m0, A0, x0, _0, $0, C0, M0, p0, v0;
  return {
    c() {
      e0 = c$2("svg"), n0 = c$2("mask"), r0 = c$2("ellipse"), i0 = c$2("g"), o0 = c$2("path"), s0 = c$2("rect"), a0 = c$2("ellipse"), c0 = c$2("rect"), l0 = c$2("rect"), u0 = c$2("rect"), d0 = c$2("rect"), h0 = c$2("rect"), g0 = c$2("rect"), w0 = c$2("path"), y0 = c$2("g"), E0 = c$2("path"), b0 = c$2("path"), O0 = c$2("rect"), S0 = c$2("rect"), k0 = c$2("path"), D0 = c$2("rect"), z0 = c$2("rect"), G0 = c$2("rect"), K0 = c$2("path"), U0 = c$2("rect"), F0 = c$2("rect"), H0 = c$2("rect"), P0 = c$2("rect"), I0 = c$2("path"), f0 = c$2("path"), m0 = c$2("defs"), A0 = c$2("filter"), x0 = c$2("feFlood"), _0 = c$2("feColorMatrix"), $0 = c$2("feOffset"), C0 = c$2("feGaussianBlur"), M0 = c$2("feColorMatrix"), p0 = c$2("feBlend"), v0 = c$2("feBlend"), t$2(r0, "cx", "59.2004"), t$2(r0, "cy", "55.0779"), t$2(r0, "rx", "53.9"), t$2(r0, "ry", "54.2667"), t$2(r0, "fill", "#F2F2F2"), t$2(n0, "id", "mask0_6297_45112"), xe$1(n0, "mask-type", "alpha"), t$2(n0, "maskUnits", "userSpaceOnUse"), t$2(n0, "x", "5"), t$2(n0, "y", "0"), t$2(n0, "width", "109"), t$2(n0, "height", "110"), t$2(o0, "d", "M59.4166 109.288C89.1694 109.288 113.289 85.005 113.289 55.0498C113.289 25.0947 89.1694 0.811279 59.4166 0.811279C29.6639 0.811279 5.54456 25.0947 5.54456 55.0498C5.54456 85.005 29.6639 109.288 59.4166 109.288Z"), t$2(o0, "fill", "#BFBFBF"), t$2(o0, "fill-opacity", "0.2"), t$2(s0, "x", "21.4704"), t$2(s0, "y", "22.5181"), t$2(s0, "width", "75.46"), t$2(s0, "height", "105.573"), t$2(s0, "rx", "4.9"), t$2(s0, "fill", "black"), t$2(a0, "opacity", "0.4"), t$2(a0, "cx", "59.2004"), t$2(a0, "cy", "45.2112"), t$2(a0, "rx", "9.31"), t$2(a0, "ry", "9.37333"), t$2(a0, "fill", "#FF875B"), t$2(c0, "x", "54.7904"), t$2(c0, "y", "44.2246"), t$2(c0, "width", "5.39"), t$2(c0, "height", "1.97333"), t$2(c0, "rx", "0.986666"), t$2(c0, "fill", "#8C8C8C"), t$2(l0, "x", "61.65"), t$2(l0, "y", "44.2244"), t$2(l0, "width", "1.96"), t$2(l0, "height", "1.97333"), t$2(l0, "rx", "0.98"), t$2(l0, "fill", "#8C8C8C"), t$2(u0, "x", "54.3004"), t$2(u0, "y", "28.438"), t$2(u0, "width", "10.29"), t$2(u0, "height", "1.48"), t$2(u0, "rx", "0.74"), t$2(u0, "fill", "#595959"), t$2(d0, "x", "26.3708"), t$2(d0, "y", "70.3047"), t$2(d0, "width", "65.66"), t$2(d0, "height", "11.76"), t$2(d0, "rx", "1.96"), t$2(d0, "fill", "#595959"), t$2(h0, "x", "36.1716"), t$2(h0, "y", "74.2246"), t$2(h0, "width", "18.62"), t$2(h0, "height", "1.47"), t$2(h0, "rx", "0.735"), t$2(h0, "fill", "#F9F9F9"), t$2(g0, "x", "36.1716"), t$2(g0, "y", "76.6748"), t$2(g0, "width", "34.3"), t$2(g0, "height", "1.47"), t$2(g0, "rx", "0.735"), t$2(g0, "fill", "#8C8C8C"), t$2(w0, "fill-rule", "evenodd"), t$2(w0, "clip-rule", "evenodd"), t$2(w0, "d", "M88.5198 76.1844C88.5198 74.8313 87.4229 73.7344 86.0698 73.7344H83.2114C81.8583 73.7344 80.7614 74.8313 80.7614 76.1844C80.7614 77.5375 81.8583 78.6344 83.2114 78.6344H86.0698C87.4229 78.6344 88.5198 77.5375 88.5198 76.1844Z"), t$2(w0, "fill", "#FF875B"), t$2(E0, "fill-rule", "evenodd"), t$2(E0, "clip-rule", "evenodd"), t$2(E0, "d", "M86.0698 78.2262C84.9422 78.2262 84.0281 77.3121 84.0281 76.1845C84.0281 75.0569 84.9422 74.1428 86.0698 74.1428C87.1974 74.1428 88.1115 75.0569 88.1115 76.1845C88.1115 77.3121 87.1974 78.2262 86.0698 78.2262Z"), t$2(E0, "fill", "black"), t$2(y0, "filter", "url(#filter0_d_6297_45112)"), t$2(b0, "d", "M29.8866 74.895C29.9417 74.8416 30.0165 74.8115 30.0945 74.8115H32.4465C32.5244 74.8115 32.5992 74.8416 32.6544 74.895C32.7095 74.9485 32.7405 75.021 32.7405 75.0966V75.9334C32.7405 77.2483 31.5889 77.6834 31.365 77.7557C31.3038 77.7768 31.2371 77.7768 31.176 77.7557C30.952 77.6834 29.8005 77.2483 29.8005 75.9334V75.0966C29.8005 75.021 29.8315 74.9485 29.8866 74.895Z"), t$2(b0, "fill", "white"), t$2(O0, "x", "26.3708"), t$2(O0, "y", "87.9446"), t$2(O0, "width", "65.66"), t$2(O0, "height", "6.86"), t$2(O0, "rx", "1.96"), t$2(O0, "fill", "#262626"), t$2(S0, "x", "35.6814"), t$2(S0, "y", "90.8845"), t$2(S0, "width", "34.79"), t$2(S0, "height", "1.47"), t$2(S0, "rx", "0.735"), t$2(S0, "fill", "#595959"), t$2(k0, "d", "M86.1501 90.3948L87.1301 91.3748L86.1501 92.3548"), t$2(k0, "stroke", "#595959"), t$2(k0, "stroke-width", "0.98"), t$2(k0, "stroke-linecap", "round"), t$2(k0, "stroke-linejoin", "round"), t$2(D0, "x", "30.7809"), t$2(D0, "y", "90.3945"), t$2(D0, "width", "2.45"), t$2(D0, "height", "2.45"), t$2(D0, "rx", "0.49"), t$2(D0, "fill", "#595959"), t$2(z0, "x", "26.3708"), t$2(z0, "y", "97.7446"), t$2(z0, "width", "65.66"), t$2(z0, "height", "6.86"), t$2(z0, "rx", "1.96"), t$2(z0, "fill", "#262626"), t$2(G0, "x", "35.6814"), t$2(G0, "y", "100.685"), t$2(G0, "width", "34.79"), t$2(G0, "height", "1.47"), t$2(G0, "rx", "0.735"), t$2(G0, "fill", "#595959"), t$2(K0, "d", "M86.1501 100.195L87.1301 101.175L86.1501 102.155"), t$2(K0, "stroke", "#595959"), t$2(K0, "stroke-width", "0.98"), t$2(K0, "stroke-linecap", "round"), t$2(K0, "stroke-linejoin", "round"), t$2(U0, "x", "30.7809"), t$2(U0, "y", "100.195"), t$2(U0, "width", "2.45"), t$2(U0, "height", "2.45"), t$2(U0, "rx", "0.49"), t$2(U0, "fill", "#595959"), t$2(F0, "x", "26.3707"), t$2(F0, "y", "60.5046"), t$2(F0, "width", "65.66"), t$2(F0, "height", "6.86"), t$2(F0, "rx", "1.96"), t$2(F0, "fill", "#0F0F0F"), t$2(H0, "x", "44.0114"), t$2(H0, "y", "63.4446"), t$2(H0, "width", "30.87"), t$2(H0, "height", "1.47"), t$2(H0, "rx", "0.735"), t$2(H0, "fill", "#595959"), t$2(P0, "x", "85.1715"), t$2(P0, "y", "62.9548"), t$2(P0, "width", "2.45"), t$2(P0, "height", "2.45"), t$2(P0, "rx", "0.49"), t$2(P0, "fill", "#595959"), t$2(i0, "mask", "url(#mask0_6297_45112)"), t$2(I0, "d", "M27.8414 29.7214L26.8614 28.7414L27.8414 27.7614"), t$2(I0, "stroke", "#595959"), t$2(I0, "stroke-width", "0.98"), t$2(I0, "stroke-linecap", "round"), t$2(I0, "stroke-linejoin", "round"), t$2(f0, "d", "M27.3512 28.7415L29.5562 28.7415"), t$2(f0, "stroke", "#595959"), t$2(f0, "stroke-width", "0.98"), t$2(f0, "stroke-linecap", "round"), t$2(x0, "flood-opacity", "0"), t$2(x0, "result", "BackgroundImageFix"), t$2(_0, "in", "SourceAlpha"), t$2(_0, "type", "matrix"), t$2(_0, "values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"), t$2(_0, "result", "hardAlpha"), t$2($0, "dy", "0.326667"), t$2(C0, "stdDeviation", "0.163333"), t$2(M0, "type", "matrix"), t$2(M0, "values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.1 0"), t$2(p0, "mode", "normal"), t$2(p0, "in2", "BackgroundImageFix"), t$2(p0, "result", "effect1_dropShadow_6297_45112"), t$2(v0, "mode", "normal"), t$2(v0, "in", "SourceGraphic"), t$2(v0, "in2", "effect1_dropShadow_6297_45112"), t$2(v0, "result", "shape"), t$2(A0, "id", "filter0_d_6297_45112"), t$2(A0, "x", "83.7014"), t$2(A0, "y", "74.1428"), t$2(A0, "width", "4.73671"), t$2(A0, "height", "4.73659"), t$2(A0, "filterUnits", "userSpaceOnUse"), t$2(A0, "color-interpolation-filters", "sRGB"), t$2(e0, "width", "118"), t$2(e0, "height", "110"), t$2(e0, "viewBox", "0 0 118 110"), t$2(e0, "fill", "none"), t$2(e0, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(T0, L0) {
      $$1(T0, e0, L0), i$4(e0, n0), i$4(n0, r0), i$4(e0, i0), i$4(i0, o0), i$4(i0, s0), i$4(i0, a0), i$4(i0, c0), i$4(i0, l0), i$4(i0, u0), i$4(i0, d0), i$4(i0, h0), i$4(i0, g0), i$4(i0, w0), i$4(i0, y0), i$4(y0, E0), i$4(i0, b0), i$4(i0, O0), i$4(i0, S0), i$4(i0, k0), i$4(i0, D0), i$4(i0, z0), i$4(i0, G0), i$4(i0, K0), i$4(i0, U0), i$4(i0, F0), i$4(i0, H0), i$4(i0, P0), i$4(e0, I0), i$4(e0, f0), i$4(e0, m0), i$4(m0, A0), i$4(A0, x0), i$4(A0, _0), i$4(A0, $0), i$4(A0, C0), i$4(A0, M0), i$4(A0, p0), i$4(A0, v0);
    },
    p: B$2,
    i: B$2,
    o: B$2,
    d(T0) {
      T0 && M$2(e0);
    }
  };
}
let Eo$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, null, $o$1, U$1, {});
  }
};
function No$1(t0) {
  let e0, n0, r0, i0, o0, s0, a0, c0, l0, u0, d0, h0, g0, w0, y0, E0, b0, O0, S0, k0, D0, z0, G0, K0, U0, F0, H0, P0, I0, f0, m0, A0, x0, _0, $0, C0, M0;
  return {
    c() {
      e0 = c$2("svg"), n0 = c$2("mask"), r0 = c$2("ellipse"), i0 = c$2("g"), o0 = c$2("path"), s0 = c$2("rect"), a0 = c$2("ellipse"), c0 = c$2("rect"), l0 = c$2("rect"), u0 = c$2("rect"), d0 = c$2("rect"), h0 = c$2("rect"), g0 = c$2("rect"), w0 = c$2("path"), y0 = c$2("g"), E0 = c$2("path"), b0 = c$2("path"), O0 = c$2("rect"), S0 = c$2("rect"), k0 = c$2("path"), D0 = c$2("rect"), z0 = c$2("rect"), G0 = c$2("rect"), K0 = c$2("path"), U0 = c$2("rect"), F0 = c$2("rect"), H0 = c$2("rect"), P0 = c$2("rect"), I0 = c$2("defs"), f0 = c$2("filter"), m0 = c$2("feFlood"), A0 = c$2("feColorMatrix"), x0 = c$2("feOffset"), _0 = c$2("feGaussianBlur"), $0 = c$2("feColorMatrix"), C0 = c$2("feBlend"), M0 = c$2("feBlend"), t$2(r0, "cx", "54.201"), t$2(r0, "cy", "54.2667"), t$2(r0, "rx", "53.9"), t$2(r0, "ry", "54.2667"), t$2(r0, "fill", "#F2F2F2"), t$2(n0, "id", "mask0_697_1274"), xe$1(n0, "mask-type", "alpha"), t$2(n0, "maskUnits", "userSpaceOnUse"), t$2(n0, "x", "0"), t$2(n0, "y", "0"), t$2(n0, "width", "109"), t$2(n0, "height", "109"), t$2(o0, "d", "M54.4182 108.477C84.171 108.477 108.29 84.1937 108.29 54.2386C108.29 24.2834 84.171 0 54.4182 0C24.6655 0 0.546143 24.2834 0.546143 54.2386C0.546143 84.1937 24.6655 108.477 54.4182 108.477Z"), t$2(o0, "fill", "#BFBFBF"), t$2(o0, "fill-opacity", "0.2"), t$2(s0, "x", "16.4709"), t$2(s0, "y", "21.7067"), t$2(s0, "width", "75.46"), t$2(s0, "height", "105.573"), t$2(s0, "rx", "4.9"), t$2(s0, "fill", "black"), t$2(a0, "opacity", "0.4"), t$2(a0, "cx", "54.2011"), t$2(a0, "cy", "44.3999"), t$2(a0, "rx", "9.31"), t$2(a0, "ry", "9.37333"), t$2(a0, "fill", "#6D6D6D"), t$2(c0, "x", "49.791"), t$2(c0, "y", "43.4133"), t$2(c0, "width", "5.39"), t$2(c0, "height", "1.97333"), t$2(c0, "rx", "0.986666"), t$2(c0, "fill", "#8C8C8C"), t$2(l0, "x", "56.6511"), t$2(l0, "y", "43.4133"), t$2(l0, "width", "1.96"), t$2(l0, "height", "1.97333"), t$2(l0, "rx", "0.98"), t$2(l0, "fill", "#8C8C8C"), t$2(u0, "x", "49.301"), t$2(u0, "y", "27.6266"), t$2(u0, "width", "10.29"), t$2(u0, "height", "1.48"), t$2(u0, "rx", "0.74"), t$2(u0, "fill", "#595959"), t$2(d0, "x", "21.3711"), t$2(d0, "y", "69.4933"), t$2(d0, "width", "65.66"), t$2(d0, "height", "11.76"), t$2(d0, "rx", "1.96"), t$2(d0, "fill", "#3A3A3A"), t$2(h0, "x", "31.1711"), t$2(h0, "y", "73.4133"), t$2(h0, "width", "18.62"), t$2(h0, "height", "1.47"), t$2(h0, "rx", "0.735"), t$2(h0, "fill", "#CDCDCD"), t$2(g0, "x", "31.1711"), t$2(g0, "y", "75.8633"), t$2(g0, "width", "34.3"), t$2(g0, "height", "1.47"), t$2(g0, "rx", "0.735"), t$2(g0, "fill", "#8C8C8C"), t$2(w0, "fill-rule", "evenodd"), t$2(w0, "clip-rule", "evenodd"), t$2(w0, "d", "M83.52 75.373C83.52 74.0199 82.4231 72.923 81.07 72.923H78.2117C76.8586 72.923 75.7617 74.0199 75.7617 75.373C75.7617 76.7261 76.8586 77.823 78.2117 77.823H81.07C82.4231 77.823 83.52 76.7261 83.52 75.373Z"), t$2(w0, "fill", "#919191"), t$2(E0, "fill-rule", "evenodd"), t$2(E0, "clip-rule", "evenodd"), t$2(E0, "d", "M81.0701 77.4147C79.9426 77.4147 79.0285 76.5006 79.0285 75.373C79.0285 74.2454 79.9426 73.3314 81.0701 73.3314C82.1977 73.3314 83.1118 74.2454 83.1118 75.373C83.1118 76.5006 82.1977 77.4147 81.0701 77.4147Z"), t$2(E0, "fill", "#CDCDCD"), t$2(y0, "filter", "url(#filter0_d_697_1274)"), t$2(b0, "d", "M24.8874 74.0835C24.9425 74.03 25.0173 74 25.0953 74H27.4473C27.5252 74 27.6 74.03 27.6552 74.0835C27.7103 74.137 27.7413 74.2095 27.7413 74.2851V75.1219C27.7413 76.4368 26.5897 76.8719 26.3658 76.9442C26.3046 76.9653 26.2379 76.9653 26.1768 76.9442C25.9528 76.8719 24.8013 76.4368 24.8013 75.1219V74.2851C24.8013 74.2095 24.8322 74.137 24.8874 74.0835Z"), t$2(b0, "fill", "#CDCDCD"), t$2(O0, "x", "21.3711"), t$2(O0, "y", "87.1334"), t$2(O0, "width", "65.66"), t$2(O0, "height", "6.86"), t$2(O0, "rx", "1.96"), t$2(O0, "fill", "#262626"), t$2(S0, "x", "30.6812"), t$2(S0, "y", "90.0734"), t$2(S0, "width", "34.79"), t$2(S0, "height", "1.47"), t$2(S0, "rx", "0.735"), t$2(S0, "fill", "#595959"), t$2(k0, "d", "M81.1511 89.5834L82.1311 90.5634L81.1511 91.5434"), t$2(k0, "stroke", "#595959"), t$2(k0, "stroke-width", "0.98"), t$2(k0, "stroke-linecap", "round"), t$2(k0, "stroke-linejoin", "round"), t$2(D0, "x", "25.7812"), t$2(D0, "y", "89.5834"), t$2(D0, "width", "2.45"), t$2(D0, "height", "2.45"), t$2(D0, "rx", "0.49"), t$2(D0, "fill", "#595959"), t$2(z0, "x", "21.3711"), t$2(z0, "y", "96.9333"), t$2(z0, "width", "65.66"), t$2(z0, "height", "6.86"), t$2(z0, "rx", "1.96"), t$2(z0, "fill", "#262626"), t$2(G0, "x", "30.6812"), t$2(G0, "y", "99.8734"), t$2(G0, "width", "34.79"), t$2(G0, "height", "1.47"), t$2(G0, "rx", "0.735"), t$2(G0, "fill", "#595959"), t$2(K0, "d", "M81.1511 99.3834L82.1311 100.363L81.1511 101.343"), t$2(K0, "stroke", "#595959"), t$2(K0, "stroke-width", "0.98"), t$2(K0, "stroke-linecap", "round"), t$2(K0, "stroke-linejoin", "round"), t$2(U0, "x", "25.7812"), t$2(U0, "y", "99.3834"), t$2(U0, "width", "2.45"), t$2(U0, "height", "2.45"), t$2(U0, "rx", "0.49"), t$2(U0, "fill", "#595959"), t$2(F0, "x", "21.3711"), t$2(F0, "y", "59.6934"), t$2(F0, "width", "65.66"), t$2(F0, "height", "6.86"), t$2(F0, "rx", "1.96"), t$2(F0, "fill", "#0F0F0F"), t$2(H0, "x", "39.0112"), t$2(H0, "y", "62.6334"), t$2(H0, "width", "30.87"), t$2(H0, "height", "1.47"), t$2(H0, "rx", "0.735"), t$2(H0, "fill", "#595959"), t$2(P0, "x", "80.1711"), t$2(P0, "y", "62.1434"), t$2(P0, "width", "2.45"), t$2(P0, "height", "2.45"), t$2(P0, "rx", "0.49"), t$2(P0, "fill", "#595959"), t$2(i0, "mask", "url(#mask0_697_1274)"), t$2(m0, "flood-opacity", "0"), t$2(m0, "result", "BackgroundImageFix"), t$2(A0, "in", "SourceAlpha"), t$2(A0, "type", "matrix"), t$2(A0, "values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"), t$2(A0, "result", "hardAlpha"), t$2(x0, "dy", "0.326667"), t$2(_0, "stdDeviation", "0.163333"), t$2($0, "type", "matrix"), t$2($0, "values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.1 0"), t$2(C0, "mode", "normal"), t$2(C0, "in2", "BackgroundImageFix"), t$2(C0, "result", "effect1_dropShadow_697_1274"), t$2(M0, "mode", "normal"), t$2(M0, "in", "SourceGraphic"), t$2(M0, "in2", "effect1_dropShadow_697_1274"), t$2(M0, "result", "shape"), t$2(f0, "id", "filter0_d_697_1274"), t$2(f0, "x", "78.7019"), t$2(f0, "y", "73.3314"), t$2(f0, "width", "4.73659"), t$2(f0, "height", "4.73665"), t$2(f0, "filterUnits", "userSpaceOnUse"), t$2(f0, "color-interpolation-filters", "sRGB"), t$2(e0, "width", "109"), t$2(e0, "height", "109"), t$2(e0, "viewBox", "0 0 109 109"), t$2(e0, "fill", "none"), t$2(e0, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(p0, v0) {
      $$1(p0, e0, v0), i$4(e0, n0), i$4(n0, r0), i$4(e0, i0), i$4(i0, o0), i$4(i0, s0), i$4(i0, a0), i$4(i0, c0), i$4(i0, l0), i$4(i0, u0), i$4(i0, d0), i$4(i0, h0), i$4(i0, g0), i$4(i0, w0), i$4(i0, y0), i$4(y0, E0), i$4(i0, b0), i$4(i0, O0), i$4(i0, S0), i$4(i0, k0), i$4(i0, D0), i$4(i0, z0), i$4(i0, G0), i$4(i0, K0), i$4(i0, U0), i$4(i0, F0), i$4(i0, H0), i$4(i0, P0), i$4(e0, I0), i$4(I0, f0), i$4(f0, m0), i$4(f0, A0), i$4(f0, x0), i$4(f0, _0), i$4(f0, $0), i$4(f0, C0), i$4(f0, M0);
    },
    p: B$2,
    i: B$2,
    o: B$2,
    d(p0) {
      p0 && M$2(e0);
    }
  };
}
let Zo$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, null, No$1, U$1, {});
  }
};
const Ao$1 = (t0) => ({}), tr$1 = (t0) => ({}), zo$1 = (t0) => ({}), rr$1 = (t0) => ({}), Oo$1 = (t0) => ({}), or$1 = (t0) => ({});
function Uo$1(t0) {
  let e0;
  const n0 = (
    /*#slots*/
    t0[4].button
  ), r0 = we$1(
    n0,
    t0,
    /*$$scope*/
    t0[6],
    rr$1
  );
  return {
    c() {
      r0 && r0.c();
    },
    m(i0, o0) {
      r0 && r0.m(i0, o0), e0 = !0;
    },
    p(i0, o0) {
      r0 && r0.p && (!e0 || o0 & /*$$scope*/
      64) && Ce$1(
        r0,
        n0,
        i0,
        /*$$scope*/
        i0[6],
        e0 ? be$1(
          n0,
          /*$$scope*/
          i0[6],
          o0,
          zo$1
        ) : _e$1(
          /*$$scope*/
          i0[6]
        ),
        rr$1
      );
    },
    i(i0) {
      e0 || (b$2(r0, i0), e0 = !0);
    },
    o(i0) {
      C$2(r0, i0), e0 = !1;
    },
    d(i0) {
      r0 && r0.d(i0);
    }
  };
}
function Go$1(t0) {
  let e0, n0, r0, i0, o0, s0, a0, c0, l0, u0, d0, h0, g0, w0, y0;
  const E0 = (
    /*#slots*/
    t0[4].icons
  ), b0 = we$1(
    E0,
    t0,
    /*$$scope*/
    t0[6],
    or$1
  );
  h0 = new _r$1({
    props: {
      as: (
        /*handleClick*/
        t0[3] ? "button" : "a"
      ),
      href: (
        /*link*/
        t0[2]
      ),
      handleClick: (
        /*handleClick*/
        t0[3]
      ),
      handleKeyup: (
        /*func*/
        t0[5]
      ),
      className: "bg-button-secondary text-primary hover:bg-button-secondary-hover flex w-full h-[32px] text-b3 rounded-3xl justify-center items-center",
      $$slots: { default: [Uo$1] },
      $$scope: { ctx: t0 }
    }
  });
  const O0 = (
    /*#slots*/
    t0[4].graphic
  ), S0 = we$1(
    O0,
    t0,
    /*$$scope*/
    t0[6],
    tr$1
  );
  return {
    c() {
      e0 = x$1("div"), n0 = x$1("div"), r0 = x$1("div"), i0 = x$1("h4"), o0 = X$2(
        /*title*/
        t0[0]
      ), s0 = K$3(), a0 = x$1("p"), c0 = X$2(
        /*subtitle*/
        t0[1]
      ), l0 = K$3(), u0 = x$1("div"), b0 && b0.c(), d0 = K$3(), A$2(h0.$$.fragment), g0 = K$3(), w0 = x$1("div"), S0 && S0.c(), t$2(i0, "class", "text-heading5 text-primary capitalize"), t$2(a0, "class", "text-l1 text-secondary-web"), t$2(r0, "class", "flex flex-col gap-1 text-left"), t$2(u0, "class", "flex gap-3 text-primary"), t$2(n0, "class", "flex flex-col gap-3"), t$2(w0, "class", "flex items-center"), t$2(e0, "class", "flex flex-row gap-3 px-4 py-3 rounded-xl bg-surface-elevated");
    },
    m(k0, D0) {
      $$1(k0, e0, D0), i$4(e0, n0), i$4(n0, r0), i$4(r0, i0), i$4(i0, o0), i$4(r0, s0), i$4(r0, a0), i$4(a0, c0), i$4(n0, l0), i$4(n0, u0), b0 && b0.m(u0, null), i$4(n0, d0), N$2(h0, n0, null), i$4(e0, g0), i$4(e0, w0), S0 && S0.m(w0, null), y0 = !0;
    },
    p(k0, [D0]) {
      (!y0 || D0 & /*title*/
      1) && ge$1(
        o0,
        /*title*/
        k0[0]
      ), (!y0 || D0 & /*subtitle*/
      2) && ge$1(
        c0,
        /*subtitle*/
        k0[1]
      ), b0 && b0.p && (!y0 || D0 & /*$$scope*/
      64) && Ce$1(
        b0,
        E0,
        k0,
        /*$$scope*/
        k0[6],
        y0 ? be$1(
          E0,
          /*$$scope*/
          k0[6],
          D0,
          Oo$1
        ) : _e$1(
          /*$$scope*/
          k0[6]
        ),
        or$1
      );
      const z0 = {};
      D0 & /*handleClick*/
      8 && (z0.as = /*handleClick*/
      k0[3] ? "button" : "a"), D0 & /*link*/
      4 && (z0.href = /*link*/
      k0[2]), D0 & /*handleClick*/
      8 && (z0.handleClick = /*handleClick*/
      k0[3]), D0 & /*handleClick*/
      8 && (z0.handleKeyup = /*func*/
      k0[5]), D0 & /*$$scope*/
      64 && (z0.$$scope = { dirty: D0, ctx: k0 }), h0.$set(z0), S0 && S0.p && (!y0 || D0 & /*$$scope*/
      64) && Ce$1(
        S0,
        O0,
        k0,
        /*$$scope*/
        k0[6],
        y0 ? be$1(
          O0,
          /*$$scope*/
          k0[6],
          D0,
          Ao$1
        ) : _e$1(
          /*$$scope*/
          k0[6]
        ),
        tr$1
      );
    },
    i(k0) {
      y0 || (b$2(b0, k0), b$2(h0.$$.fragment, k0), b$2(S0, k0), y0 = !0);
    },
    o(k0) {
      C$2(b0, k0), C$2(h0.$$.fragment, k0), C$2(S0, k0), y0 = !1;
    },
    d(k0) {
      k0 && M$2(e0), b0 && b0.d(k0), Z$2(h0), S0 && S0.d(k0);
    }
  };
}
function Io$1(t0, e0, n0) {
  let { $$slots: r0 = {}, $$scope: i0 } = e0, { title: o0 } = e0, { subtitle: s0 } = e0, { link: a0 = void 0 } = e0, { handleClick: c0 = void 0 } = e0;
  const l0 = (u0) => {
    c0 && u0.key === "Enter" && c0();
  };
  return t0.$$set = (u0) => {
    "title" in u0 && n0(0, o0 = u0.title), "subtitle" in u0 && n0(1, s0 = u0.subtitle), "link" in u0 && n0(2, a0 = u0.link), "handleClick" in u0 && n0(3, c0 = u0.handleClick), "$$scope" in u0 && n0(6, i0 = u0.$$scope);
  }, [o0, s0, a0, c0, r0, l0, i0];
}
let kr$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, Io$1, Go$1, U$1, {
      title: 0,
      subtitle: 1,
      link: 2,
      handleClick: 3
    });
  }
};
function lr$1(t0) {
  let e0, n0;
  return e0 = new kr$1({
    props: {
      title: "Ready mobile",
      subtitle: "Download Ready wallet on your mobile.",
      link: "https://www.argent.xyz/app",
      $$slots: {
        graphic: [Do$1],
        button: [jo$1],
        icons: [Wo$1]
      },
      $$scope: { ctx: t0 }
    }
  }), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function Wo$1(t0) {
  let e0, n0, r0, i0;
  return e0 = new wr$1({}), r0 = new gr$1({}), {
    c() {
      A$2(e0.$$.fragment), n0 = K$3(), A$2(r0.$$.fragment);
    },
    m(o0, s0) {
      N$2(e0, o0, s0), $$1(o0, n0, s0), N$2(r0, o0, s0), i0 = !0;
    },
    i(o0) {
      i0 || (b$2(e0.$$.fragment, o0), b$2(r0.$$.fragment, o0), i0 = !0);
    },
    o(o0) {
      C$2(e0.$$.fragment, o0), C$2(r0.$$.fragment, o0), i0 = !1;
    },
    d(o0) {
      o0 && M$2(n0), Z$2(e0, o0), Z$2(r0, o0);
    }
  };
}
function jo$1(t0) {
  let e0;
  return {
    c() {
      e0 = X$2("Download");
    },
    m(n0, r0) {
      $$1(n0, e0, r0);
    },
    d(n0) {
      n0 && M$2(e0);
    }
  };
}
function Do$1(t0) {
  let e0, n0;
  return e0 = new So$1({}), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function ar$1(t0) {
  let e0, n0;
  return e0 = new kr$1({
    props: {
      title: (
        /*extensionName*/
        t0[1]
      ),
      subtitle: `Install ${/*extensionName*/
      t0[1]} extension.`,
      link: (
        /*storeLink*/
        t0[3]
      ),
      $$slots: {
        graphic: [Ho$1],
        button: [Vo$1]
      },
      $$scope: { ctx: t0 }
    }
  }), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    p(r0, i0) {
      const o0 = {};
      i0 & /*extensionName*/
      2 && (o0.title = /*extensionName*/
      r0[1]), i0 & /*extensionName*/
      2 && (o0.subtitle = `Install ${/*extensionName*/
      r0[1]} extension.`), i0 & /*storeLink*/
      8 && (o0.link = /*storeLink*/
      r0[3]), i0 & /*$$scope, isArgent, store*/
      37 && (o0.$$scope = { dirty: i0, ctx: r0 }), e0.$set(o0);
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function Vo$1(t0) {
  let e0, n0, r0, i0 = (
    /*storeData*/
    t0[4][
      /*store*/
      t0[2]
    ].name + ""
  ), o0, s0;
  var a0 = (
    /*storeData*/
    t0[4][
      /*store*/
      t0[2]
    ].icon
  );
  function c0(l0, u0) {
    return {};
  }
  return a0 && (n0 = Wt$1(a0, c0())), {
    c() {
      e0 = x$1("div"), n0 && A$2(n0.$$.fragment), r0 = X$2(" Install for "), o0 = X$2(i0), t$2(e0, "class", "flex gap-1 items-center whitespace-nowrap");
    },
    m(l0, u0) {
      $$1(l0, e0, u0), n0 && N$2(n0, e0, null), i$4(e0, r0), i$4(e0, o0), s0 = !0;
    },
    p(l0, u0) {
      if (u0 & /*store*/
      4 && a0 !== (a0 = /*storeData*/
      l0[4][
        /*store*/
        l0[2]
      ].icon)) {
        if (n0) {
          ce$2();
          const d0 = n0;
          C$2(d0.$$.fragment, 1, 0, () => {
            Z$2(d0, 1);
          }), fe$2();
        }
        a0 ? (n0 = Wt$1(a0, c0()), A$2(n0.$$.fragment), b$2(n0.$$.fragment, 1), N$2(n0, e0, r0)) : n0 = null;
      }
      (!s0 || u0 & /*store*/
      4) && i0 !== (i0 = /*storeData*/
      l0[4][
        /*store*/
        l0[2]
      ].name + "") && ge$1(o0, i0);
    },
    i(l0) {
      s0 || (n0 && b$2(n0.$$.fragment, l0), s0 = !0);
    },
    o(l0) {
      n0 && C$2(n0.$$.fragment, l0), s0 = !1;
    },
    d(l0) {
      l0 && M$2(e0), n0 && Z$2(n0);
    }
  };
}
function Ro$1(t0) {
  let e0, n0;
  return e0 = new Zo$1({}), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function To$1(t0) {
  let e0, n0;
  return e0 = new Eo$1({}), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function Ho$1(t0) {
  let e0, n0, r0, i0;
  const o0 = [To$1, Ro$1], s0 = [];
  function a0(c0, l0) {
    return (
      /*isArgent*/
      c0[0] ? 0 : 1
    );
  }
  return e0 = a0(t0), n0 = s0[e0] = o0[e0](t0), {
    c() {
      n0.c(), r0 = ye$1();
    },
    m(c0, l0) {
      s0[e0].m(c0, l0), $$1(c0, r0, l0), i0 = !0;
    },
    p(c0, l0) {
      let u0 = e0;
      e0 = a0(c0), e0 !== u0 && (ce$2(), C$2(s0[u0], 1, 1, () => {
        s0[u0] = null;
      }), fe$2(), n0 = s0[e0], n0 || (n0 = s0[e0] = o0[e0](c0), n0.c()), b$2(n0, 1), n0.m(r0.parentNode, r0));
    },
    i(c0) {
      i0 || (b$2(n0), i0 = !0);
    },
    o(c0) {
      C$2(n0), i0 = !1;
    },
    d(c0) {
      c0 && M$2(r0), s0[e0].d(c0);
    }
  };
}
function nr$1(t0) {
  let e0, n0, r0, i0, o0, s0;
  return e0 = new Ut$2({}), o0 = new Cr$1({
    props: {
      as: "a",
      className: "text-brand",
      href: "https://www.ready.co/",
      $$slots: { default: [Ko$1] },
      $$scope: { ctx: t0 }
    }
  }), {
    c() {
      A$2(e0.$$.fragment), n0 = K$3(), r0 = x$1("p"), i0 = X$2(`If you want to learn more about Ready visit our site:
        `), A$2(o0.$$.fragment), t$2(r0, "class", "text-[13px] text-secondary");
    },
    m(a0, c0) {
      N$2(e0, a0, c0), $$1(a0, n0, c0), $$1(a0, r0, c0), i$4(r0, i0), N$2(o0, r0, null), s0 = !0;
    },
    i(a0) {
      s0 || (b$2(e0.$$.fragment, a0), b$2(o0.$$.fragment, a0), s0 = !0);
    },
    o(a0) {
      C$2(e0.$$.fragment, a0), C$2(o0.$$.fragment, a0), s0 = !1;
    },
    d(a0) {
      a0 && (M$2(n0), M$2(r0)), Z$2(e0, a0), Z$2(o0);
    }
  };
}
function Ko$1(t0) {
  let e0;
  return {
    c() {
      e0 = X$2("www.ready.co");
    },
    m(n0, r0) {
      $$1(n0, e0, r0);
    },
    d(n0) {
      n0 && M$2(e0);
    }
  };
}
function Po$1(t0) {
  let e0, n0, r0, i0, o0, s0, a0 = (
    /*isArgent*/
    t0[0] && lr$1(t0)
  ), c0 = (
    /*store*/
    t0[2] && /*storeLink*/
    t0[3] && ar$1(t0)
  ), l0 = (
    /*isArgent*/
    t0[0] && nr$1(t0)
  );
  return {
    c() {
      e0 = x$1("section"), n0 = x$1("div"), a0 && a0.c(), r0 = K$3(), c0 && c0.c(), i0 = K$3(), o0 = x$1("footer"), l0 && l0.c(), t$2(n0, "class", "flex flex-col gap-2"), t$2(o0, "class", "flex flex-col gap-4"), t$2(e0, "class", "flex flex-col flex-grow justify-between");
    },
    m(u0, d0) {
      $$1(u0, e0, d0), i$4(e0, n0), a0 && a0.m(n0, null), i$4(n0, r0), c0 && c0.m(n0, null), i$4(e0, i0), i$4(e0, o0), l0 && l0.m(o0, null), s0 = !0;
    },
    p(u0, [d0]) {
      u0[0] ? a0 ? d0 & /*isArgent*/
      1 && b$2(a0, 1) : (a0 = lr$1(u0), a0.c(), b$2(a0, 1), a0.m(n0, r0)) : a0 && (ce$2(), C$2(a0, 1, 1, () => {
        a0 = null;
      }), fe$2()), /*store*/
      u0[2] && /*storeLink*/
      u0[3] ? c0 ? (c0.p(u0, d0), d0 & /*store, storeLink*/
      12 && b$2(c0, 1)) : (c0 = ar$1(u0), c0.c(), b$2(c0, 1), c0.m(n0, null)) : c0 && (ce$2(), C$2(c0, 1, 1, () => {
        c0 = null;
      }), fe$2()), /*isArgent*/
      u0[0] ? l0 ? d0 & /*isArgent*/
      1 && b$2(l0, 1) : (l0 = nr$1(u0), l0.c(), b$2(l0, 1), l0.m(o0, null)) : l0 && (ce$2(), C$2(l0, 1, 1, () => {
        l0 = null;
      }), fe$2());
    },
    i(u0) {
      s0 || (b$2(a0), b$2(c0), b$2(l0), s0 = !0);
    },
    o(u0) {
      C$2(a0), C$2(c0), C$2(l0), s0 = !1;
    },
    d(u0) {
      u0 && M$2(e0), a0 && a0.d(), c0 && c0.d(), l0 && l0.d();
    }
  };
}
function qo$1(t0, e0, n0) {
  let { isArgent: r0 = !1 } = e0, { extensionName: i0 = "" } = e0, { store: o0 } = e0, { storeLink: s0 } = e0;
  const a0 = {
    // @dev - Be mindful of name property length, it might break the UI
    chrome: { name: "Chrome", icon: mr$1 },
    edge: { name: "Edge", icon: xo$1 },
    firefox: { name: "Firefox", icon: Bo$1 }
  };
  return t0.$$set = (c0) => {
    "isArgent" in c0 && n0(0, r0 = c0.isArgent), "extensionName" in c0 && n0(1, i0 = c0.extensionName), "store" in c0 && n0(2, o0 = c0.store), "storeLink" in c0 && n0(3, s0 = c0.storeLink);
  }, [r0, i0, o0, s0, a0];
}
let Xo$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, qo$1, Po$1, U$1, {
      isArgent: 0,
      extensionName: 1,
      store: 2,
      storeLink: 3
    });
  }
};
function Qo$1(t0) {
  let e0, n0, r0, i0, o0, s0, a0;
  return i0 = new br$1({}), {
    c() {
      e0 = x$1("section"), n0 = x$1("div"), r0 = x$1("div"), A$2(i0.$$.fragment), o0 = K$3(), s0 = x$1("div"), s0.innerHTML = '<h3 class="text-primary text-h4 font-bold">Couldn&#39;t perform the action</h3> <p class="text-primary text-p3 font-[400]">Please try again.</p>', t$2(r0, "class", "bg-button-secondary rounded-full p-5"), t$2(n0, "class", "flex flex-col h-full justify-center items-center gap-4 w-full flex-grow"), t$2(e0, "class", "flex flex-col justify-center items-center flex-grow");
    },
    m(c0, l0) {
      $$1(c0, e0, l0), i$4(e0, n0), i$4(n0, r0), N$2(i0, r0, null), i$4(n0, o0), i$4(n0, s0), a0 = !0;
    },
    p: B$2,
    i(c0) {
      a0 || (b$2(i0.$$.fragment, c0), a0 = !0);
    },
    o(c0) {
      C$2(i0.$$.fragment, c0), a0 = !1;
    },
    d(c0) {
      c0 && M$2(e0), Z$2(i0);
    }
  };
}
let Yo$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, null, Qo$1, U$1, {});
  }
};
function ir$1(t0) {
  let e0, n0, r0, i0, o0, s0, a0, c0, l0;
  r0 = new n1({
    props: {
      handleBack: (
        /*func*/
        t0[14]
      ),
      handleClose: (
        /*func_1*/
        t0[15]
      ),
      title: (
        /*dappName*/
        t0[2]
      ),
      showBackButton: (
        /*showBackButton*/
        t0[5] && ![Q$2.walletList, Q$2.success].includes(
          /*layout*/
          t0[0]
        )
      )
    }
  });
  const u0 = [
    nl$1,
    al$1,
    ll$1,
    ol$1,
    rl$1,
    tl$1,
    el$1,
    Jo$1
  ], d0 = [];
  function h0(g0, w0) {
    return (
      /*layout*/
      g0[0] === Q$2.walletList ? 0 : (
        /*layout*/
        g0[0] === Q$2.connecting ? 1 : (
          /*layout*/
          g0[0] === Q$2.success ? 2 : (
            /*layout*/
            g0[0] === Q$2.loginFailure ? 3 : (
              /*layout*/
              g0[0] === Q$2.requestFailure ? 4 : (
                /*layout*/
                g0[0] === Q$2.qrCode ? 5 : (
                  /*layout*/
                  g0[0] === Q$2.approval ? 6 : (
                    /*layout*/
                    g0[0] === Q$2.download ? 7 : -1
                  )
                )
              )
            )
          )
        )
      )
    );
  }
  return ~(o0 = h0(t0)) && (s0 = d0[o0] = u0[o0](t0)), {
    c() {
      e0 = x$1("div"), n0 = x$1("main"), A$2(r0.$$.fragment), i0 = K$3(), s0 && s0.c(), t$2(n0, "role", "dialog"), t$2(n0, "class", a0 = `
        rounded-3xl bg-surface-default shadow-modal dark:shadow-none flex flex-col
        z-[9999] w-full max-w-[380px] mx-6 p-6 text-center gap-8
        ${/*layout*/
      t0[0] !== Q$2.walletList ? "min-h-[570px]" : ""}
      `), t$2(e0, "part", "starknetkit-modal"), t$2(e0, "class", c0 = `${/*darkModeControlClass*/
      t0[1]} modal-font fixed inset-0 z-[9998] flex items-center justify-center backdrop-blur-sm bg-black/25`);
    },
    m(g0, w0) {
      $$1(g0, e0, w0), i$4(e0, n0), N$2(r0, n0, null), i$4(n0, i0), ~o0 && d0[o0].m(n0, null), t0[20](e0), l0 = !0;
    },
    p(g0, w0) {
      const y0 = {};
      w0 & /*nodeRef*/
      128 && (y0.handleClose = /*func_1*/
      g0[15]), w0 & /*dappName*/
      4 && (y0.title = /*dappName*/
      g0[2]), w0 & /*showBackButton, layout*/
      33 && (y0.showBackButton = /*showBackButton*/
      g0[5] && ![Q$2.walletList, Q$2.success].includes(
        /*layout*/
        g0[0]
      )), r0.$set(y0);
      let E0 = o0;
      o0 = h0(g0), o0 === E0 ? ~o0 && d0[o0].p(g0, w0) : (s0 && (ce$2(), C$2(d0[E0], 1, 1, () => {
        d0[E0] = null;
      }), fe$2()), ~o0 ? (s0 = d0[o0], s0 ? s0.p(g0, w0) : (s0 = d0[o0] = u0[o0](g0), s0.c()), b$2(s0, 1), s0.m(n0, null)) : s0 = null), (!l0 || w0 & /*layout*/
      1 && a0 !== (a0 = `
        rounded-3xl bg-surface-default shadow-modal dark:shadow-none flex flex-col
        z-[9999] w-full max-w-[380px] mx-6 p-6 text-center gap-8
        ${/*layout*/
      g0[0] !== Q$2.walletList ? "min-h-[570px]" : ""}
      `)) && t$2(n0, "class", a0), (!l0 || w0 & /*darkModeControlClass*/
      2 && c0 !== (c0 = `${/*darkModeControlClass*/
      g0[1]} modal-font fixed inset-0 z-[9998] flex items-center justify-center backdrop-blur-sm bg-black/25`)) && t$2(e0, "class", c0);
    },
    i(g0) {
      l0 || (b$2(r0.$$.fragment, g0), b$2(s0), l0 = !0);
    },
    o(g0) {
      C$2(r0.$$.fragment, g0), C$2(s0), l0 = !1;
    },
    d(g0) {
      g0 && M$2(e0), Z$2(r0), ~o0 && d0[o0].d(), t0[20](null);
    }
  };
}
function Jo$1(t0) {
  let e0, n0;
  return e0 = new Xo$1({
    props: {
      store: Pe$2(),
      isArgent: !!/*selectedConnector*/
      (t0[9] && /*selectedConnector*/
      (t0[9]?.id === "argentMobile" || /*selectedConnector*/
      t0[9]?.id === "argentX")),
      storeLink: (
        /*selectedWallet*/
        t0[4]?.download
      ),
      extensionName: (
        /*selectedWallet*/
        t0[4]?.name.includes("Ready") ? "Ready Wallet (formerly Argent)" : (
          /*selectedConnector*/
          t0[9]?.name
        )
      )
    }
  }), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    p(r0, i0) {
      const o0 = {};
      i0 & /*selectedConnector*/
      512 && (o0.isArgent = !!/*selectedConnector*/
      (r0[9] && /*selectedConnector*/
      (r0[9]?.id === "argentMobile" || /*selectedConnector*/
      r0[9]?.id === "argentX"))), i0 & /*selectedWallet*/
      16 && (o0.storeLink = /*selectedWallet*/
      r0[4]?.download), i0 & /*selectedWallet, selectedConnector*/
      528 && (o0.extensionName = /*selectedWallet*/
      r0[4]?.name.includes("Ready") ? "Ready Wallet (formerly Argent)" : (
        /*selectedConnector*/
        r0[9]?.name
      )), e0.$set(o0);
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function el$1(t0) {
  let e0, n0;
  return e0 = new $1({}), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    p: B$2,
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function tl$1(t0) {
  let e0, n0;
  return e0 = new lo$1({
    props: { handleInstallClick: (
      /*func_5*/
      t0[19]
    ) }
  }), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    p: B$2,
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function rl$1(t0) {
  let e0, n0;
  return e0 = new Yo$1({}), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    p: B$2,
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function ol$1(t0) {
  let e0, n0;
  return e0 = new wo$1({
    props: {
      walletName: (
        /*selectedConnector*/
        t0[9]?.name
      ),
      handleCallback: (
        /*func_3*/
        t0[17]
      ),
      showFallback: (
        /*showFallback*/
        t0[8]
      ),
      handleFallback: (
        /*func_4*/
        t0[18]
      )
    }
  }), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    p(r0, i0) {
      const o0 = {};
      i0 & /*selectedConnector*/
      512 && (o0.walletName = /*selectedConnector*/
      r0[9]?.name), i0 & /*callback, selectedWallet*/
      80 && (o0.handleCallback = /*func_3*/
      r0[17]), i0 & /*showFallback*/
      256 && (o0.showFallback = /*showFallback*/
      r0[8]), i0 & /*callback, selectedWallet*/
      80 && (o0.handleFallback = /*func_4*/
      r0[18]), e0.$set(o0);
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function ll$1(t0) {
  let e0, n0;
  return e0 = new ko$1({}), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    p: B$2,
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function al$1(t0) {
  let e0, n0;
  return e0 = new B1({
    props: {
      walletName: (
        /*selectedConnector*/
        t0[9]?.name
      ),
      showFallback: (
        /*showFallback*/
        t0[8]
      ),
      handleFallback: (
        /*func_2*/
        t0[16]
      ),
      $$slots: { default: [il$1] },
      $$scope: { ctx: t0 }
    }
  }), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    p(r0, i0) {
      const o0 = {};
      i0 & /*selectedConnector*/
      512 && (o0.walletName = /*selectedConnector*/
      r0[9]?.name), i0 & /*showFallback*/
      256 && (o0.showFallback = /*showFallback*/
      r0[8]), i0 & /*callback, selectedWallet*/
      80 && (o0.handleFallback = /*func_2*/
      r0[16]), i0 & /*$$scope, selectedConnector, darkModeControlClass*/
      2097666 && (o0.$$scope = { dirty: i0, ctx: r0 }), e0.$set(o0);
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function nl$1(t0) {
  let e0, n0;
  return e0 = new C1({
    props: {
      walletList: (
        /*modalWallets*/
        t0[3]
      ),
      theme: (
        /*darkModeControlClass*/
        t0[1]
      ),
      callback: (
        /*callback*/
        t0[6]
      )
    }
  }), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    p(r0, i0) {
      const o0 = {};
      i0 & /*modalWallets*/
      8 && (o0.walletList = /*modalWallets*/
      r0[3]), i0 & /*darkModeControlClass*/
      2 && (o0.theme = /*darkModeControlClass*/
      r0[1]), i0 & /*callback*/
      64 && (o0.callback = /*callback*/
      r0[6]), e0.$set(o0);
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function sr$1(t0) {
  let e0, n0;
  return e0 = new pr$1({
    props: {
      icon: (
        /*selectedConnector*/
        t0[9].icon
      ),
      theme: (
        /*darkModeControlClass*/
        t0[1]
      )
    }
  }), {
    c() {
      A$2(e0.$$.fragment);
    },
    m(r0, i0) {
      N$2(e0, r0, i0), n0 = !0;
    },
    p(r0, i0) {
      const o0 = {};
      i0 & /*selectedConnector*/
      512 && (o0.icon = /*selectedConnector*/
      r0[9].icon), i0 & /*darkModeControlClass*/
      2 && (o0.theme = /*darkModeControlClass*/
      r0[1]), e0.$set(o0);
    },
    i(r0) {
      n0 || (b$2(e0.$$.fragment, r0), n0 = !0);
    },
    o(r0) {
      C$2(e0.$$.fragment, r0), n0 = !1;
    },
    d(r0) {
      Z$2(e0, r0);
    }
  };
}
function il$1(t0) {
  let e0, n0, r0 = (
    /*selectedConnector*/
    t0[9]?.icon && sr$1(t0)
  );
  return {
    c() {
      r0 && r0.c(), e0 = ye$1();
    },
    m(i0, o0) {
      r0 && r0.m(i0, o0), $$1(i0, e0, o0), n0 = !0;
    },
    p(i0, o0) {
      i0[9]?.icon ? r0 ? (r0.p(i0, o0), o0 & /*selectedConnector*/
      512 && b$2(r0, 1)) : (r0 = sr$1(i0), r0.c(), b$2(r0, 1), r0.m(e0.parentNode, e0)) : r0 && (ce$2(), C$2(r0, 1, 1, () => {
        r0 = null;
      }), fe$2());
    },
    i(i0) {
      n0 || (b$2(r0), n0 = !0);
    },
    o(i0) {
      C$2(r0), n0 = !1;
    },
    d(i0) {
      i0 && M$2(e0), r0 && r0.d(i0);
    }
  };
}
function sl$1(t0) {
  let e0, n0, r0 = !/*isInAppBrowser*/
  t0[11] && /*layout*/
  (t0[0] === Q$2.walletList ? (
    /*modalWallets*/
    t0[3].length > 1
  ) : !0) && ir$1(t0);
  return {
    c() {
      r0 && r0.c(), e0 = ye$1();
    },
    m(i0, o0) {
      r0 && r0.m(i0, o0), $$1(i0, e0, o0), n0 = !0;
    },
    p(i0, [o0]) {
      !/*isInAppBrowser*/
      i0[11] && /*layout*/
      (i0[0] !== Q$2.walletList || /*modalWallets*/
      i0[3].length > 1) ? r0 ? (r0.p(i0, o0), o0 & /*layout, modalWallets*/
      9 && b$2(r0, 1)) : (r0 = ir$1(i0), r0.c(), b$2(r0, 1), r0.m(e0.parentNode, e0)) : r0 && (ce$2(), C$2(r0, 1, 1, () => {
        r0 = null;
      }), fe$2());
    },
    i(i0) {
      n0 || (b$2(r0), n0 = !0);
    },
    o(i0) {
      C$2(r0), n0 = !1;
    },
    d(i0) {
      i0 && M$2(e0), r0 && r0.d(i0);
    }
  };
}
function cl$1(t0, e0, n0) {
  let r0, i0, o0, { dappName: s0 = window?.document.title ?? "" } = e0, { layout: a0 = Q$2.walletList } = e0;
  function c0(K0) {
    n0(0, a0 = K0);
  }
  function l0() {
    return a0;
  }
  let { modalWallets: u0 = [] } = e0, { selectedWallet: d0 = null } = e0, { showBackButton: h0 = !0 } = e0, { callback: g0 = async () => {
  } } = e0, w0 = q$3(), { theme: y0 = "dark" } = e0, { darkModeControlClass: E0 = y0 === "dark" ? "dark" : "" } = e0;
  Vr$1(async () => {
    if (y0 === "dark" || y0 == null && window.matchMedia("(prefers-color-scheme: dark)").matches ? n0(1, E0 = "dark") : n0(1, E0 = "light"), w0) {
      try {
        setTimeout(() => {
          g0(G$2(new p$1()));
        });
      } catch (K0) {
        console.error(K0);
      }
      return;
    }
    if (navigator?.userAgent?.toLowerCase()?.includes("braavos") && window?.starknet_braavos) {
      try {
        setTimeout(() => {
          g0(G$2(new n$3()));
        });
      } catch (K0) {
        console.error(K0);
      }
      return;
    }
    if (u0.length === 1)
      try {
        await g0(u0[0]);
      } catch (K0) {
        console.error(K0);
      }
  });
  const b0 = () => c0(Q$2.walletList), O0 = () => o0?.parentNode?.removeChild(o0), S0 = () => g0(d0, !0), k0 = () => g0(d0), D0 = () => g0(d0, !0), z0 = () => c0(Q$2.download);
  function G0(K0) {
    Nt$2[K0 ? "unshift" : "push"](() => {
      o0 = K0, n0(7, o0);
    });
  }
  return t0.$$set = (K0) => {
    "dappName" in K0 && n0(2, s0 = K0.dappName), "layout" in K0 && n0(0, a0 = K0.layout), "modalWallets" in K0 && n0(3, u0 = K0.modalWallets), "selectedWallet" in K0 && n0(4, d0 = K0.selectedWallet), "showBackButton" in K0 && n0(5, h0 = K0.showBackButton), "callback" in K0 && n0(6, g0 = K0.callback), "theme" in K0 && n0(13, y0 = K0.theme), "darkModeControlClass" in K0 && n0(1, E0 = K0.darkModeControlClass);
  }, t0.$$.update = () => {
    t0.$$.dirty & /*selectedWallet*/
    16 && n0(9, r0 = d0?.connector && S$1(d0.connector)), t0.$$.dirty & /*selectedWallet*/
    16 && n0(8, i0 = !!(d0 && C$3(d0?.connector) && d0?.connector?.fallbackConnector));
  }, [
    a0,
    E0,
    s0,
    u0,
    d0,
    h0,
    g0,
    o0,
    i0,
    r0,
    c0,
    w0,
    l0,
    y0,
    b0,
    O0,
    S0,
    k0,
    D0,
    z0,
    G0
  ];
}
let bl$1 = class extends j$2 {
  constructor(e0) {
    super(), W$1(this, e0, cl$1, sl$1, U$1, {
      dappName: 2,
      layout: 0,
      getLayout: 12,
      modalWallets: 3,
      selectedWallet: 4,
      showBackButton: 5,
      callback: 6,
      theme: 13,
      darkModeControlClass: 1
    });
  }
  get getLayout() {
    return this.$$.ctx[12];
  }
};
var o$1 = Object.defineProperty, l$2 = (t0, e0, n0) => e0 in t0 ? o$1(t0, e0, { enumerable: !0, configurable: !0, writable: !0, value: n0 }) : t0[e0] = n0, n$2 = (t0, e0, n0) => (l$2(t0, typeof e0 != "symbol" ? e0 + "" : e0, n0), n0);
const i$3 = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32px" height="32px" viewBox="0 0 32 32" version="1.1">
    <defs>
    <clipPath id="clip1">
      <path d="M 5.332031 0 L 26.667969 0 C 29.613281 0 32 2.386719 32 5.332031 L 32 26.667969 C 32 29.613281 29.613281 32 26.667969 32 L 5.332031 32 C 2.386719 32 0 29.613281 0 26.667969 L 0 5.332031 C 0 2.386719 2.386719 0 5.332031 0 Z M 5.332031 0 "/>
    </clipPath>
    <linearGradient id="linear0" gradientUnits="userSpaceOnUse" x1="-9.552" y1="-6.444" x2="50.240002" y2="41.303001" gradientTransform="matrix(0.666667,0,0,0.666667,0,0)">
      <stop offset="0" style="stop-color:rgb(3.529412%,45.09804%,75.294119%);stop-opacity:1;"/>
      <stop offset="1" style="stop-color:rgb(10.980392%,28.627452%,87.058824%);stop-opacity:1;"/>
    </linearGradient>
    <clipPath id="clip2">
      <path d="M 7 4 L 25 4 L 25 15 L 7 15 Z M 7 4 "/>
    </clipPath>
    <clipPath id="clip3">
      <path d="M 5.332031 0 L 26.667969 0 C 29.613281 0 32 2.386719 32 5.332031 L 32 26.667969 C 32 29.613281 29.613281 32 26.667969 32 L 5.332031 32 C 2.386719 32 0 29.613281 0 26.667969 L 0 5.332031 C 0 2.386719 2.386719 0 5.332031 0 Z M 5.332031 0 "/>
    </clipPath>
    <clipPath id="clip4">
    	<path d="M 6 13 L 26 13 L 26 28 L 6 28 Z M 6 13 "/>
    </clipPath>
    <clipPath id="clip5">
      <path d="M 5.332031 0 L 26.667969 0 C 29.613281 0 32 2.386719 32 5.332031 L 32 26.667969 C 32 29.613281 29.613281 32 26.667969 32 L 5.332031 32 C 2.386719 32 0 29.613281 0 26.667969 L 0 5.332031 C 0 2.386719 2.386719 0 5.332031 0 Z M 5.332031 0 "/>
    </clipPath>
    </defs>
    <g id="surface1">
      <g clip-path="url(#clip1)" clip-rule="nonzero">
        <rect x="0" y="0" width="32" height="32" style="fill:url(#linear0);stroke:none;"/>
      </g>
    	<g clip-path="url(#clip2)" clip-rule="nonzero">
        <g clip-path="url(#clip3)" clip-rule="nonzero">
	        <path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" d="M 19.507812 6.320312 C 19.542969 6.378906 19.496094 6.453125 19.425781 6.453125 C 18.027344 6.453125 16.886719 7.5625 16.859375 8.941406 C 16.375 8.851562 15.878906 8.847656 15.390625 8.929688 C 15.359375 7.554688 14.222656 6.453125 12.824219 6.453125 C 12.757812 6.453125 12.710938 6.378906 12.746094 6.320312 C 13.453125 5.128906 14.738281 4.398438 16.125 4.398438 C 17.515625 4.394531 18.800781 5.125 19.507812 6.320312 M 23.65625 14.847656 C 24.132812 14.992188 24.585938 14.574219 24.402344 14.109375 C 23.066406 10.65625 19.109375 9.242188 16.105469 9.242188 C 13.097656 9.242188 9.054688 10.703125 7.804688 14.128906 C 7.632812 14.589844 8.082031 14.996094 8.550781 14.851562 L 15.75 12.648438 C 15.957031 12.582031 16.179688 12.582031 16.386719 12.644531 Z M 23.65625 14.847656 "/>
        </g>
    	</g>
    	<g clip-path="url(#clip4)" clip-rule="nonzero">
        <g clip-path="url(#clip5)" clip-rule="nonzero">
          <path style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" d="M 7.734375 15.511719 L 15.757812 13.078125 C 15.964844 13.015625 16.183594 13.015625 16.390625 13.078125 L 24.464844 15.511719 C 25.136719 15.714844 25.597656 16.335938 25.597656 17.042969 L 25.597656 24.378906 C 25.566406 26.167969 23.960938 27.605469 22.167969 27.605469 L 19.195312 27.605469 C 19.054688 27.605469 18.917969 27.550781 18.820312 27.449219 C 18.71875 27.347656 18.664062 27.214844 18.664062 27.074219 L 18.664062 24.5 C 18.664062 23.488281 19.261719 22.570312 20.191406 22.164062 C 21.433594 21.621094 22.90625 20.886719 23.183594 19.410156 C 23.269531 18.933594 22.960938 18.472656 22.484375 18.378906 C 21.285156 18.140625 19.953125 18.230469 18.824219 18.734375 C 17.546875 19.308594 17.210938 20.257812 17.085938 21.539062 L 16.9375 22.914062 C 16.890625 23.335938 16.496094 23.65625 16.074219 23.65625 C 15.636719 23.65625 15.308594 23.324219 15.261719 22.886719 L 15.113281 21.539062 C 15.007812 20.441406 14.8125 19.378906 13.683594 18.875 C 12.390625 18.296875 11.09375 18.105469 9.714844 18.378906 C 9.238281 18.472656 8.929688 18.933594 9.015625 19.410156 C 9.296875 20.898438 10.757812 21.617188 12.007812 22.164062 C 12.9375 22.570312 13.535156 23.488281 13.535156 24.5 L 13.535156 27.074219 C 13.535156 27.367188 13.296875 27.605469 13.003906 27.605469 L 10.03125 27.605469 C 8.238281 27.605469 6.628906 26.167969 6.597656 24.378906 L 6.597656 17.039062 C 6.597656 16.335938 7.058594 15.714844 7.734375 15.511719 "/>
        </g>
    	</g>
    </g>
</svg>
`;
let c$1 = class extends M$5 {
  constructor() {
    super(), n$2(this, "_wallet", null);
  }
  available() {
    return !0;
  }
  async ready() {
    return !0;
  }
  get id() {
    return "braavosMobile";
  }
  get name() {
    return "Braavos (mobile)";
  }
  get icon() {
    return {
      dark: i$3,
      light: i$3
    };
  }
  get wallet() {
    throw new Error("not implemented");
  }
  async connect(e0 = {}) {
    return await this.ensureWallet(), {
      account: "",
      chainId: BigInt(0)
    };
  }
  async disconnect() {
    throw new Error("not implemented");
  }
  async account(e0) {
    throw new Error("not implemented");
  }
  async chainId() {
    throw new Error("not implemented");
  }
  async request(e0) {
    throw new Error("not implemented");
  }
  // needed, methods required by starknet-react. Otherwise an exception is throwd
  async initEventListener(e0) {
    throw new Error("not implemented");
  }
  // needed, methods required by starknet-react. Otherwise an exception is throwd
  async removeEventListener(e0) {
    throw new Error("not implemented");
  }
  async ensureWallet() {
    window.open(`https://link.braavos.app/dapp/${window.origin}`, "_blank");
  }
};
const e$2 = "fordefi";
let i$2 = class extends L$3 {
  constructor(e0) {
    super({ options: { id: e$2, ...e0 } });
  }
  static getInjectedWallet() {
    return super.getInjectedWallet(e$2);
  }
  static isWalletInjected() {
    return super.isWalletInjected(e$2);
  }
};
const e$1 = "keplr";
let l$1 = class extends L$3 {
  constructor(e0) {
    super({ options: { id: e$1, ...e0 } });
  }
  static getInjectedWallet() {
    return super.getInjectedWallet(e$1);
  }
  static isWalletInjected() {
    return super.isWalletInjected(e$1);
  }
};
const t$1 = "metamask";
class o extends L$3 {
  constructor(e0) {
    super({ options: { id: t$1, ...e0 } });
  }
  static getInjectedWallet() {
    return super.getInjectedWallet(t$1);
  }
  static isWalletInjected() {
    return super.isWalletInjected(t$1);
  }
}
const Q$1 = () => {
  const t0 = navigator.userAgent.toLowerCase(), e0 = /android|webos|iphone|ipad|ipod|blackberry|windows phone/.test(t0), n0 = "ontouchstart" in window || navigator.maxTouchPoints > 0, r0 = window.innerWidth <= 768;
  return e0 && (n0 || r0);
}, q$2 = () => typeof window < "u" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1, P$2 = ({
  argentMobileOptions: t0,
  webWalletUrl: e0
}) => {
  const n0 = (
    // | StarknetkitCompoundConnector
    []
  );
  return n0.push(new p$1()), q$2() || (n0.push(new n$3()), o.isWalletInjected() && n0.push(new o()), i$2.isWalletInjected() && n0.push(new i$2()), l$1.isWalletInjected() && n0.push(new l$1())), Q$1() && n0.push(new c$1()), n0;
};
let n$1 = null;
const K$2 = async ({
  modalMode: t0 = "canAsk",
  storeVersion: e0 = Pe$2(),
  modalTheme: n0,
  dappName: r0,
  resultType: i0 = "wallet",
  skipEmit: o0 = !1,
  ...s0
}) => {
  const { webWalletUrl: a0 = fn$1, argentMobileOptions: c0 } = s0, { connectors: l0 } = s0;
  n$1 = null;
  const u0 = !l0 || l0.length === 0 ? P$2({
    argentMobileOptions: c0,
    webWalletUrl: a0
  }) : l0;
  o0 && u0?.map((y0) => {
    C$3(y0) && "connector" in y0 && "_options" in y0.connector && (y0.connector._options.shouldEmit = !1);
  });
  const d0 = localStorage.getItem("starknetLastConnectedWallet");
  if (t0 === "neverAsk")
    try {
      const y0 = Fe$2(u0, d0);
      let E0 = null;
      return y0 && i0 === "wallet" && (E0 = await y0.connect({
        onlyQRCode: !0
      })), {
        connector: y0,
        wallet: y0?.wallet ?? null,
        connectorData: E0
      };
    } catch (y0) {
      throw W$4(), new Error(y0);
    }
  const h0 = await main.getAvailableWallets(s0);
  if (t0 === "canAsk" && d0 && (((await main.getAuthorizedWallets(s0)).find((y0) => y0.id === d0) ?? h0.length === 1) && h0[0])) {
    const y0 = Fe$2(u0, d0);
    let E0 = null;
    return i0 === "wallet" && (E0 = await y0?.connect({
      onlyQRCode: !0
    }) ?? null), y0 && (n$1 = y0), {
      connector: n$1,
      connectorData: E0,
      wallet: y0?.wallet ?? null
    };
  }
  const g0 = (await main.getDiscoveryWallets(s0)).map(
    (y0) => y0.id.toLowerCase() === "argentx" ? {
      ...y0,
      name: "Ready Wallet (formerly Argent)"
    } : y0
  ), w0 = Ve$2({
    availableConnectors: u0,
    installedWallets: h0,
    discoveryWallets: g0,
    storeVersion: e0,
    customOrder: l0 ? l0?.length > 0 : !1
  });
  return new Promise((y0, E0) => {
    const b0 = new bl$1({
      target: wl$1(),
      props: {
        dappName: r0,
        callback: async (O0, S0 = !1) => {
          try {
            if (!O0)
              throw new Error("Connector error");
            if (b0.$set({ selectedWallet: O0 }), !O0.installed) {
              b0.$set({ layout: Q$2.download });
              return;
            }
            if (n$1 = S$1(
              O0.connector,
              S0
            ), i0 === "wallet") {
              n$1 instanceof Re$2 ? b0.$set({ layout: Q$2.qrCode }) : b0.$set({ layout: Q$2.connecting });
              const k0 = await n$1?.connect({
                onlyQRCode: !0
              }) ?? null;
              n$1 !== null && U$3(n$1.id), y0({
                connector: n$1,
                connectorData: k0,
                wallet: n$1?.wallet ?? null
              }), b0.$set({ layout: Q$2.success }), setTimeout(() => b0.$destroy(), 500);
            } else
              y0({
                connector: n$1,
                wallet: null,
                connectorData: null
              }), b0.$destroy();
          } catch (k0) {
            [Q$2.connecting, Q$2.qrCode].includes(b0.getLayout()) ? b0.$set({ layout: Q$2.loginFailure }) : E0(k0);
          }
        },
        theme: n0 === "system" ? null : n0 ?? null,
        modalWallets: w0
      }
    });
  });
};
var browserPonyfill = { exports: {} };
(function(t0, e0) {
  var n0 = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof commonjsGlobal < "u" && commonjsGlobal, r0 = function() {
    function o0() {
      this.fetch = !1, this.DOMException = n0.DOMException;
    }
    return o0.prototype = n0, new o0();
  }();
  (function(o0) {
    (function(s0) {
      var a0 = typeof o0 < "u" && o0 || typeof self < "u" && self || // eslint-disable-next-line no-undef
      typeof commonjsGlobal < "u" && commonjsGlobal || {}, c0 = {
        searchParams: "URLSearchParams" in a0,
        iterable: "Symbol" in a0 && "iterator" in Symbol,
        blob: "FileReader" in a0 && "Blob" in a0 && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in a0,
        arrayBuffer: "ArrayBuffer" in a0
      };
      function l0(m0) {
        return m0 && DataView.prototype.isPrototypeOf(m0);
      }
      if (c0.arrayBuffer)
        var u0 = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], d0 = ArrayBuffer.isView || function(m0) {
          return m0 && u0.indexOf(Object.prototype.toString.call(m0)) > -1;
        };
      function h0(m0) {
        if (typeof m0 != "string" && (m0 = String(m0)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(m0) || m0 === "")
          throw new TypeError('Invalid character in header field name: "' + m0 + '"');
        return m0.toLowerCase();
      }
      function g0(m0) {
        return typeof m0 != "string" && (m0 = String(m0)), m0;
      }
      function w0(m0) {
        var A0 = {
          next: function() {
            var x0 = m0.shift();
            return { done: x0 === void 0, value: x0 };
          }
        };
        return c0.iterable && (A0[Symbol.iterator] = function() {
          return A0;
        }), A0;
      }
      function y0(m0) {
        this.map = {}, m0 instanceof y0 ? m0.forEach(function(A0, x0) {
          this.append(x0, A0);
        }, this) : Array.isArray(m0) ? m0.forEach(function(A0) {
          if (A0.length != 2)
            throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + A0.length);
          this.append(A0[0], A0[1]);
        }, this) : m0 && Object.getOwnPropertyNames(m0).forEach(function(A0) {
          this.append(A0, m0[A0]);
        }, this);
      }
      y0.prototype.append = function(m0, A0) {
        m0 = h0(m0), A0 = g0(A0);
        var x0 = this.map[m0];
        this.map[m0] = x0 ? x0 + ", " + A0 : A0;
      }, y0.prototype.delete = function(m0) {
        delete this.map[h0(m0)];
      }, y0.prototype.get = function(m0) {
        return m0 = h0(m0), this.has(m0) ? this.map[m0] : null;
      }, y0.prototype.has = function(m0) {
        return this.map.hasOwnProperty(h0(m0));
      }, y0.prototype.set = function(m0, A0) {
        this.map[h0(m0)] = g0(A0);
      }, y0.prototype.forEach = function(m0, A0) {
        for (var x0 in this.map)
          this.map.hasOwnProperty(x0) && m0.call(A0, this.map[x0], x0, this);
      }, y0.prototype.keys = function() {
        var m0 = [];
        return this.forEach(function(A0, x0) {
          m0.push(x0);
        }), w0(m0);
      }, y0.prototype.values = function() {
        var m0 = [];
        return this.forEach(function(A0) {
          m0.push(A0);
        }), w0(m0);
      }, y0.prototype.entries = function() {
        var m0 = [];
        return this.forEach(function(A0, x0) {
          m0.push([x0, A0]);
        }), w0(m0);
      }, c0.iterable && (y0.prototype[Symbol.iterator] = y0.prototype.entries);
      function E0(m0) {
        if (!m0._noBody) {
          if (m0.bodyUsed)
            return Promise.reject(new TypeError("Already read"));
          m0.bodyUsed = !0;
        }
      }
      function b0(m0) {
        return new Promise(function(A0, x0) {
          m0.onload = function() {
            A0(m0.result);
          }, m0.onerror = function() {
            x0(m0.error);
          };
        });
      }
      function O0(m0) {
        var A0 = new FileReader(), x0 = b0(A0);
        return A0.readAsArrayBuffer(m0), x0;
      }
      function S0(m0) {
        var A0 = new FileReader(), x0 = b0(A0), _0 = /charset=([A-Za-z0-9_-]+)/.exec(m0.type), $0 = _0 ? _0[1] : "utf-8";
        return A0.readAsText(m0, $0), x0;
      }
      function k0(m0) {
        for (var A0 = new Uint8Array(m0), x0 = new Array(A0.length), _0 = 0; _0 < A0.length; _0++)
          x0[_0] = String.fromCharCode(A0[_0]);
        return x0.join("");
      }
      function D0(m0) {
        if (m0.slice)
          return m0.slice(0);
        var A0 = new Uint8Array(m0.byteLength);
        return A0.set(new Uint8Array(m0)), A0.buffer;
      }
      function z0() {
        return this.bodyUsed = !1, this._initBody = function(m0) {
          this.bodyUsed = this.bodyUsed, this._bodyInit = m0, m0 ? typeof m0 == "string" ? this._bodyText = m0 : c0.blob && Blob.prototype.isPrototypeOf(m0) ? this._bodyBlob = m0 : c0.formData && FormData.prototype.isPrototypeOf(m0) ? this._bodyFormData = m0 : c0.searchParams && URLSearchParams.prototype.isPrototypeOf(m0) ? this._bodyText = m0.toString() : c0.arrayBuffer && c0.blob && l0(m0) ? (this._bodyArrayBuffer = D0(m0.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : c0.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(m0) || d0(m0)) ? this._bodyArrayBuffer = D0(m0) : this._bodyText = m0 = Object.prototype.toString.call(m0) : (this._noBody = !0, this._bodyText = ""), this.headers.get("content-type") || (typeof m0 == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : c0.searchParams && URLSearchParams.prototype.isPrototypeOf(m0) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, c0.blob && (this.blob = function() {
          var m0 = E0(this);
          if (m0)
            return m0;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }), this.arrayBuffer = function() {
          if (this._bodyArrayBuffer) {
            var m0 = E0(this);
            return m0 || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(
              this._bodyArrayBuffer.buffer.slice(
                this._bodyArrayBuffer.byteOffset,
                this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
              )
            ) : Promise.resolve(this._bodyArrayBuffer));
          } else {
            if (c0.blob)
              return this.blob().then(O0);
            throw new Error("could not read as ArrayBuffer");
          }
        }, this.text = function() {
          var m0 = E0(this);
          if (m0)
            return m0;
          if (this._bodyBlob)
            return S0(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(k0(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, c0.formData && (this.formData = function() {
          return this.text().then(F0);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var G0 = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
      function K0(m0) {
        var A0 = m0.toUpperCase();
        return G0.indexOf(A0) > -1 ? A0 : m0;
      }
      function U0(m0, A0) {
        if (!(this instanceof U0))
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        A0 = A0 || {};
        var x0 = A0.body;
        if (m0 instanceof U0) {
          if (m0.bodyUsed)
            throw new TypeError("Already read");
          this.url = m0.url, this.credentials = m0.credentials, A0.headers || (this.headers = new y0(m0.headers)), this.method = m0.method, this.mode = m0.mode, this.signal = m0.signal, !x0 && m0._bodyInit != null && (x0 = m0._bodyInit, m0.bodyUsed = !0);
        } else
          this.url = String(m0);
        if (this.credentials = A0.credentials || this.credentials || "same-origin", (A0.headers || !this.headers) && (this.headers = new y0(A0.headers)), this.method = K0(A0.method || this.method || "GET"), this.mode = A0.mode || this.mode || null, this.signal = A0.signal || this.signal || function() {
          if ("AbortController" in a0) {
            var C0 = new AbortController();
            return C0.signal;
          }
        }(), this.referrer = null, (this.method === "GET" || this.method === "HEAD") && x0)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        if (this._initBody(x0), (this.method === "GET" || this.method === "HEAD") && (A0.cache === "no-store" || A0.cache === "no-cache")) {
          var _0 = /([?&])_=[^&]*/;
          if (_0.test(this.url))
            this.url = this.url.replace(_0, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
          else {
            var $0 = /\?/;
            this.url += ($0.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
          }
        }
      }
      U0.prototype.clone = function() {
        return new U0(this, { body: this._bodyInit });
      };
      function F0(m0) {
        var A0 = new FormData();
        return m0.trim().split("&").forEach(function(x0) {
          if (x0) {
            var _0 = x0.split("="), $0 = _0.shift().replace(/\+/g, " "), C0 = _0.join("=").replace(/\+/g, " ");
            A0.append(decodeURIComponent($0), decodeURIComponent(C0));
          }
        }), A0;
      }
      function H0(m0) {
        var A0 = new y0(), x0 = m0.replace(/\r?\n[\t ]+/g, " ");
        return x0.split("\r").map(function(_0) {
          return _0.indexOf(`
`) === 0 ? _0.substr(1, _0.length) : _0;
        }).forEach(function(_0) {
          var $0 = _0.split(":"), C0 = $0.shift().trim();
          if (C0) {
            var M0 = $0.join(":").trim();
            try {
              A0.append(C0, M0);
            } catch (p0) {
              console.warn("Response " + p0.message);
            }
          }
        }), A0;
      }
      z0.call(U0.prototype);
      function P0(m0, A0) {
        if (!(this instanceof P0))
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        if (A0 || (A0 = {}), this.type = "default", this.status = A0.status === void 0 ? 200 : A0.status, this.status < 200 || this.status > 599)
          throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
        this.ok = this.status >= 200 && this.status < 300, this.statusText = A0.statusText === void 0 ? "" : "" + A0.statusText, this.headers = new y0(A0.headers), this.url = A0.url || "", this._initBody(m0);
      }
      z0.call(P0.prototype), P0.prototype.clone = function() {
        return new P0(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new y0(this.headers),
          url: this.url
        });
      }, P0.error = function() {
        var m0 = new P0(null, { status: 200, statusText: "" });
        return m0.ok = !1, m0.status = 0, m0.type = "error", m0;
      };
      var I0 = [301, 302, 303, 307, 308];
      P0.redirect = function(m0, A0) {
        if (I0.indexOf(A0) === -1)
          throw new RangeError("Invalid status code");
        return new P0(null, { status: A0, headers: { location: m0 } });
      }, s0.DOMException = a0.DOMException;
      try {
        new s0.DOMException();
      } catch {
        s0.DOMException = function(A0, x0) {
          this.message = A0, this.name = x0;
          var _0 = Error(A0);
          this.stack = _0.stack;
        }, s0.DOMException.prototype = Object.create(Error.prototype), s0.DOMException.prototype.constructor = s0.DOMException;
      }
      function f0(m0, A0) {
        return new Promise(function(x0, _0) {
          var $0 = new U0(m0, A0);
          if ($0.signal && $0.signal.aborted)
            return _0(new s0.DOMException("Aborted", "AbortError"));
          var C0 = new XMLHttpRequest();
          function M0() {
            C0.abort();
          }
          C0.onload = function() {
            var T0 = {
              statusText: C0.statusText,
              headers: H0(C0.getAllResponseHeaders() || "")
            };
            $0.url.indexOf("file://") === 0 && (C0.status < 200 || C0.status > 599) ? T0.status = 200 : T0.status = C0.status, T0.url = "responseURL" in C0 ? C0.responseURL : T0.headers.get("X-Request-URL");
            var L0 = "response" in C0 ? C0.response : C0.responseText;
            setTimeout(function() {
              x0(new P0(L0, T0));
            }, 0);
          }, C0.onerror = function() {
            setTimeout(function() {
              _0(new TypeError("Network request failed"));
            }, 0);
          }, C0.ontimeout = function() {
            setTimeout(function() {
              _0(new TypeError("Network request timed out"));
            }, 0);
          }, C0.onabort = function() {
            setTimeout(function() {
              _0(new s0.DOMException("Aborted", "AbortError"));
            }, 0);
          };
          function p0(T0) {
            try {
              return T0 === "" && a0.location.href ? a0.location.href : T0;
            } catch {
              return T0;
            }
          }
          if (C0.open($0.method, p0($0.url), !0), $0.credentials === "include" ? C0.withCredentials = !0 : $0.credentials === "omit" && (C0.withCredentials = !1), "responseType" in C0 && (c0.blob ? C0.responseType = "blob" : c0.arrayBuffer && (C0.responseType = "arraybuffer")), A0 && typeof A0.headers == "object" && !(A0.headers instanceof y0 || a0.Headers && A0.headers instanceof a0.Headers)) {
            var v0 = [];
            Object.getOwnPropertyNames(A0.headers).forEach(function(T0) {
              v0.push(h0(T0)), C0.setRequestHeader(T0, g0(A0.headers[T0]));
            }), $0.headers.forEach(function(T0, L0) {
              v0.indexOf(L0) === -1 && C0.setRequestHeader(L0, T0);
            });
          } else
            $0.headers.forEach(function(T0, L0) {
              C0.setRequestHeader(L0, T0);
            });
          $0.signal && ($0.signal.addEventListener("abort", M0), C0.onreadystatechange = function() {
            C0.readyState === 4 && $0.signal.removeEventListener("abort", M0);
          }), C0.send(typeof $0._bodyInit > "u" ? null : $0._bodyInit);
        });
      }
      return f0.polyfill = !0, a0.fetch || (a0.fetch = f0, a0.Headers = y0, a0.Request = U0, a0.Response = P0), s0.Headers = y0, s0.Request = U0, s0.Response = P0, s0.fetch = f0, s0;
    })({});
  })(r0), r0.fetch.ponyfill = !0, delete r0.fetch.polyfill;
  var i0 = n0.fetch ? n0 : r0;
  e0 = i0.fetch, e0.default = i0.fetch, e0.fetch = i0.fetch, e0.Headers = i0.Headers, e0.Request = i0.Request, e0.Response = i0.Response, t0.exports = e0;
})(browserPonyfill, browserPonyfill.exports);
var browserPonyfillExports = browserPonyfill.exports;
const e = /* @__PURE__ */ getDefaultExportFromCjs(browserPonyfillExports);
var browser = { exports: {} }, ms$1, hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms$1;
  hasRequiredMs = 1;
  var t0 = 1e3, e0 = t0 * 60, n0 = e0 * 60, r0 = n0 * 24, i0 = r0 * 7, o0 = r0 * 365.25;
  ms$1 = function(u0, d0) {
    d0 = d0 || {};
    var h0 = typeof u0;
    if (h0 === "string" && u0.length > 0)
      return s0(u0);
    if (h0 === "number" && isFinite(u0))
      return d0.long ? c0(u0) : a0(u0);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u0)
    );
  };
  function s0(u0) {
    if (u0 = String(u0), !(u0.length > 100)) {
      var d0 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u0
      );
      if (d0) {
        var h0 = parseFloat(d0[1]), g0 = (d0[2] || "ms").toLowerCase();
        switch (g0) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return h0 * o0;
          case "weeks":
          case "week":
          case "w":
            return h0 * i0;
          case "days":
          case "day":
          case "d":
            return h0 * r0;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return h0 * n0;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return h0 * e0;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return h0 * t0;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return h0;
          default:
            return;
        }
      }
    }
  }
  function a0(u0) {
    var d0 = Math.abs(u0);
    return d0 >= r0 ? Math.round(u0 / r0) + "d" : d0 >= n0 ? Math.round(u0 / n0) + "h" : d0 >= e0 ? Math.round(u0 / e0) + "m" : d0 >= t0 ? Math.round(u0 / t0) + "s" : u0 + "ms";
  }
  function c0(u0) {
    var d0 = Math.abs(u0);
    return d0 >= r0 ? l0(u0, d0, r0, "day") : d0 >= n0 ? l0(u0, d0, n0, "hour") : d0 >= e0 ? l0(u0, d0, e0, "minute") : d0 >= t0 ? l0(u0, d0, t0, "second") : u0 + " ms";
  }
  function l0(u0, d0, h0, g0) {
    var w0 = d0 >= h0 * 1.5;
    return Math.round(u0 / h0) + " " + g0 + (w0 ? "s" : "");
  }
  return ms$1;
}
function setup(t0) {
  n0.debug = n0, n0.default = n0, n0.coerce = c0, n0.disable = s0, n0.enable = i0, n0.enabled = a0, n0.humanize = requireMs(), n0.destroy = l0, Object.keys(t0).forEach((u0) => {
    n0[u0] = t0[u0];
  }), n0.names = [], n0.skips = [], n0.formatters = {};
  function e0(u0) {
    let d0 = 0;
    for (let h0 = 0; h0 < u0.length; h0++)
      d0 = (d0 << 5) - d0 + u0.charCodeAt(h0), d0 |= 0;
    return n0.colors[Math.abs(d0) % n0.colors.length];
  }
  n0.selectColor = e0;
  function n0(u0) {
    let d0, h0 = null, g0, w0;
    function y0(...E0) {
      if (!y0.enabled)
        return;
      const b0 = y0, O0 = Number(/* @__PURE__ */ new Date()), S0 = O0 - (d0 || O0);
      b0.diff = S0, b0.prev = d0, b0.curr = O0, d0 = O0, E0[0] = n0.coerce(E0[0]), typeof E0[0] != "string" && E0.unshift("%O");
      let k0 = 0;
      E0[0] = E0[0].replace(/%([a-zA-Z%])/g, (z0, G0) => {
        if (z0 === "%%")
          return "%";
        k0++;
        const K0 = n0.formatters[G0];
        if (typeof K0 == "function") {
          const U0 = E0[k0];
          z0 = K0.call(b0, U0), E0.splice(k0, 1), k0--;
        }
        return z0;
      }), n0.formatArgs.call(b0, E0), (b0.log || n0.log).apply(b0, E0);
    }
    return y0.namespace = u0, y0.useColors = n0.useColors(), y0.color = n0.selectColor(u0), y0.extend = r0, y0.destroy = n0.destroy, Object.defineProperty(y0, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => h0 !== null ? h0 : (g0 !== n0.namespaces && (g0 = n0.namespaces, w0 = n0.enabled(u0)), w0),
      set: (E0) => {
        h0 = E0;
      }
    }), typeof n0.init == "function" && n0.init(y0), y0;
  }
  function r0(u0, d0) {
    const h0 = n0(this.namespace + (typeof d0 > "u" ? ":" : d0) + u0);
    return h0.log = this.log, h0;
  }
  function i0(u0) {
    n0.save(u0), n0.namespaces = u0, n0.names = [], n0.skips = [];
    const d0 = (typeof u0 == "string" ? u0 : "").trim().replace(" ", ",").split(",").filter(Boolean);
    for (const h0 of d0)
      h0[0] === "-" ? n0.skips.push(h0.slice(1)) : n0.names.push(h0);
  }
  function o0(u0, d0) {
    let h0 = 0, g0 = 0, w0 = -1, y0 = 0;
    for (; h0 < u0.length; )
      if (g0 < d0.length && (d0[g0] === u0[h0] || d0[g0] === "*"))
        d0[g0] === "*" ? (w0 = g0, y0 = h0, g0++) : (h0++, g0++);
      else if (w0 !== -1)
        g0 = w0 + 1, y0++, h0 = y0;
      else
        return !1;
    for (; g0 < d0.length && d0[g0] === "*"; )
      g0++;
    return g0 === d0.length;
  }
  function s0() {
    const u0 = [
      ...n0.names,
      ...n0.skips.map((d0) => "-" + d0)
    ].join(",");
    return n0.enable(""), u0;
  }
  function a0(u0) {
    for (const d0 of n0.skips)
      if (o0(u0, d0))
        return !1;
    for (const d0 of n0.names)
      if (o0(u0, d0))
        return !0;
    return !1;
  }
  function c0(u0) {
    return u0 instanceof Error ? u0.stack || u0.message : u0;
  }
  function l0() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return n0.enable(n0.load()), n0;
}
var common = setup;
(function(t0, e0) {
  e0.formatArgs = r0, e0.save = i0, e0.load = o0, e0.useColors = n0, e0.storage = s0(), e0.destroy = (() => {
    let c0 = !1;
    return () => {
      c0 || (c0 = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), e0.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function n0() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let c0;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (c0 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(c0[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function r0(c0) {
    if (c0[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c0[0] + (this.useColors ? "%c " : " ") + "+" + t0.exports.humanize(this.diff), !this.useColors)
      return;
    const l0 = "color: " + this.color;
    c0.splice(1, 0, l0, "color: inherit");
    let u0 = 0, d0 = 0;
    c0[0].replace(/%[a-zA-Z%]/g, (h0) => {
      h0 !== "%%" && (u0++, h0 === "%c" && (d0 = u0));
    }), c0.splice(d0, 0, l0);
  }
  e0.log = console.debug || console.log || (() => {
  });
  function i0(c0) {
    try {
      c0 ? e0.storage.setItem("debug", c0) : e0.storage.removeItem("debug");
    } catch {
    }
  }
  function o0() {
    let c0;
    try {
      c0 = e0.storage.getItem("debug");
    } catch {
    }
    return !c0 && typeof process < "u" && "env" in process && (c0 = process.env.DEBUG), c0;
  }
  function s0() {
    try {
      return localStorage;
    } catch {
    }
  }
  t0.exports = common(e0);
  const { formatters: a0 } = t0.exports;
  a0.j = function(c0) {
    try {
      return JSON.stringify(c0);
    } catch (l0) {
      return "[UnexpectedJSONParseError]: " + l0.message;
    }
  };
})(browser, browser.exports);
var browserExports = browser.exports;
const t = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var eventemitter2 = { exports: {} };
/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
(function(t0, e0) {
  (function(n0) {
    var r0 = Object.hasOwnProperty, i0 = Array.isArray ? Array.isArray : function($0) {
      return Object.prototype.toString.call($0) === "[object Array]";
    }, o0 = 10, s0 = typeof process == "object" && typeof process.nextTick == "function", a0 = typeof Symbol == "function", c0 = typeof Reflect == "object", l0 = typeof setImmediate == "function", u0 = l0 ? setImmediate : setTimeout, d0 = a0 ? c0 && typeof Reflect.ownKeys == "function" ? Reflect.ownKeys : function(_0) {
      var $0 = Object.getOwnPropertyNames(_0);
      return $0.push.apply($0, Object.getOwnPropertySymbols(_0)), $0;
    } : Object.keys;
    function h0() {
      this._events = {}, this._conf && g0.call(this, this._conf);
    }
    function g0(_0) {
      _0 && (this._conf = _0, _0.delimiter && (this.delimiter = _0.delimiter), _0.maxListeners !== n0 && (this._maxListeners = _0.maxListeners), _0.wildcard && (this.wildcard = _0.wildcard), _0.newListener && (this._newListener = _0.newListener), _0.removeListener && (this._removeListener = _0.removeListener), _0.verboseMemoryLeak && (this.verboseMemoryLeak = _0.verboseMemoryLeak), _0.ignoreErrors && (this.ignoreErrors = _0.ignoreErrors), this.wildcard && (this.listenerTree = {}));
    }
    function w0(_0, $0) {
      var C0 = "(node) warning: possible EventEmitter memory leak detected. " + _0 + " listeners added. Use emitter.setMaxListeners() to increase limit.";
      if (this.verboseMemoryLeak && (C0 += " Event name: " + $0 + "."), typeof process < "u" && process.emitWarning) {
        var M0 = new Error(C0);
        M0.name = "MaxListenersExceededWarning", M0.emitter = this, M0.count = _0, process.emitWarning(M0);
      } else
        console.error(C0), console.trace && console.trace();
    }
    var y0 = function(_0, $0, C0) {
      var M0 = arguments.length;
      switch (M0) {
        case 0:
          return [];
        case 1:
          return [_0];
        case 2:
          return [_0, $0];
        case 3:
          return [_0, $0, C0];
        default:
          for (var p0 = new Array(M0); M0--; )
            p0[M0] = arguments[M0];
          return p0;
      }
    };
    function E0(_0, $0) {
      for (var C0 = {}, M0, p0 = _0.length, v0 = $0 ? $0.length : 0, T0 = 0; T0 < p0; T0++)
        M0 = _0[T0], C0[M0] = T0 < v0 ? $0[T0] : n0;
      return C0;
    }
    function b0(_0, $0, C0) {
      this._emitter = _0, this._target = $0, this._listeners = {}, this._listenersCount = 0;
      var M0, p0;
      if ((C0.on || C0.off) && (M0 = C0.on, p0 = C0.off), $0.addEventListener ? (M0 = $0.addEventListener, p0 = $0.removeEventListener) : $0.addListener ? (M0 = $0.addListener, p0 = $0.removeListener) : $0.on && (M0 = $0.on, p0 = $0.off), !M0 && !p0)
        throw Error("target does not implement any known event API");
      if (typeof M0 != "function")
        throw TypeError("on method must be a function");
      if (typeof p0 != "function")
        throw TypeError("off method must be a function");
      this._on = M0, this._off = p0;
      var v0 = _0._observers;
      v0 ? v0.push(this) : _0._observers = [this];
    }
    Object.assign(b0.prototype, {
      subscribe: function(_0, $0, C0) {
        var M0 = this, p0 = this._target, v0 = this._emitter, T0 = this._listeners, L0 = function() {
          var B0 = y0.apply(null, arguments), W0 = {
            data: B0,
            name: $0,
            original: _0
          };
          if (C0) {
            var V0 = C0.call(p0, W0);
            V0 !== !1 && v0.emit.apply(v0, [W0.name].concat(B0));
            return;
          }
          v0.emit.apply(v0, [$0].concat(B0));
        };
        if (T0[_0])
          throw Error("Event '" + _0 + "' is already listening");
        this._listenersCount++, v0._newListener && v0._removeListener && !M0._onNewListener ? (this._onNewListener = function(B0) {
          B0 === $0 && T0[_0] === null && (T0[_0] = L0, M0._on.call(p0, _0, L0));
        }, v0.on("newListener", this._onNewListener), this._onRemoveListener = function(B0) {
          B0 === $0 && !v0.hasListeners(B0) && T0[_0] && (T0[_0] = null, M0._off.call(p0, _0, L0));
        }, T0[_0] = null, v0.on("removeListener", this._onRemoveListener)) : (T0[_0] = L0, M0._on.call(p0, _0, L0));
      },
      unsubscribe: function(_0) {
        var $0 = this, C0 = this._listeners, M0 = this._emitter, p0, v0, T0 = this._off, L0 = this._target, B0;
        if (_0 && typeof _0 != "string")
          throw TypeError("event must be a string");
        function W0() {
          $0._onNewListener && (M0.off("newListener", $0._onNewListener), M0.off("removeListener", $0._onRemoveListener), $0._onNewListener = null, $0._onRemoveListener = null);
          var V0 = K0.call(M0, $0);
          M0._observers.splice(V0, 1);
        }
        if (_0) {
          if (p0 = C0[_0], !p0)
            return;
          T0.call(L0, _0, p0), delete C0[_0], --this._listenersCount || W0();
        } else {
          for (v0 = d0(C0), B0 = v0.length; B0-- > 0; )
            _0 = v0[B0], T0.call(L0, _0, C0[_0]);
          this._listeners = {}, this._listenersCount = 0, W0();
        }
      }
    });
    function O0(_0, $0, C0, M0) {
      var p0 = Object.assign({}, $0);
      if (!_0)
        return p0;
      if (typeof _0 != "object")
        throw TypeError("options must be an object");
      var v0 = Object.keys(_0), T0 = v0.length, L0, B0, W0;
      function V0(X0) {
        throw Error('Invalid "' + L0 + '" option value' + (X0 ? ". Reason: " + X0 : ""));
      }
      for (var Q0 = 0; Q0 < T0; Q0++) {
        if (L0 = v0[Q0], !M0 && !r0.call($0, L0))
          throw Error('Unknown "' + L0 + '" option');
        B0 = _0[L0], B0 !== n0 && (W0 = C0[L0], p0[L0] = W0 ? W0(B0, V0) : B0);
      }
      return p0;
    }
    function S0(_0, $0) {
      return (typeof _0 != "function" || !_0.hasOwnProperty("prototype")) && $0("value must be a constructor"), _0;
    }
    function k0(_0) {
      var $0 = "value must be type of " + _0.join("|"), C0 = _0.length, M0 = _0[0], p0 = _0[1];
      return C0 === 1 ? function(v0, T0) {
        if (typeof v0 === M0)
          return v0;
        T0($0);
      } : C0 === 2 ? function(v0, T0) {
        var L0 = typeof v0;
        if (L0 === M0 || L0 === p0)
          return v0;
        T0($0);
      } : function(v0, T0) {
        for (var L0 = typeof v0, B0 = C0; B0-- > 0; )
          if (L0 === _0[B0])
            return v0;
        T0($0);
      };
    }
    var D0 = k0(["function"]), z0 = k0(["object", "function"]);
    function G0(_0, $0, C0) {
      var M0, p0, v0 = 0, T0, L0 = new _0(function(B0, W0, V0) {
        C0 = O0(C0, {
          timeout: 0,
          overload: !1
        }, {
          timeout: function(yg, _g) {
            return yg *= 1, (typeof yg != "number" || yg < 0 || !Number.isFinite(yg)) && _g("timeout must be a positive number"), yg;
          }
        }), M0 = !C0.overload && typeof _0.prototype.cancel == "function" && typeof V0 == "function";
        function Q0() {
          p0 && (p0 = null), v0 && (clearTimeout(v0), v0 = 0);
        }
        var X0 = function(yg) {
          Q0(), B0(yg);
        }, J0 = function(yg) {
          Q0(), W0(yg);
        };
        M0 ? $0(X0, J0, V0) : (p0 = [function(yg) {
          J0(yg || Error("canceled"));
        }], $0(X0, J0, function(yg) {
          if (T0)
            throw Error("Unable to subscribe on cancel event asynchronously");
          if (typeof yg != "function")
            throw TypeError("onCancel callback must be a function");
          p0.push(yg);
        }), T0 = !0), C0.timeout > 0 && (v0 = setTimeout(function() {
          var yg = Error("timeout");
          yg.code = "ETIMEDOUT", v0 = 0, L0.cancel(yg), W0(yg);
        }, C0.timeout));
      });
      return M0 || (L0.cancel = function(B0) {
        if (p0) {
          for (var W0 = p0.length, V0 = 1; V0 < W0; V0++)
            p0[V0](B0);
          p0[0](B0), p0 = null;
        }
      }), L0;
    }
    function K0(_0) {
      var $0 = this._observers;
      if (!$0)
        return -1;
      for (var C0 = $0.length, M0 = 0; M0 < C0; M0++)
        if ($0[M0]._target === _0)
          return M0;
      return -1;
    }
    function U0(_0, $0, C0, M0, p0) {
      if (!C0)
        return null;
      if (M0 === 0) {
        var v0 = typeof $0;
        if (v0 === "string") {
          var T0, L0, B0 = 0, W0 = 0, V0 = this.delimiter, Q0 = V0.length;
          if ((L0 = $0.indexOf(V0)) !== -1) {
            T0 = new Array(5);
            do
              T0[B0++] = $0.slice(W0, L0), W0 = L0 + Q0;
            while ((L0 = $0.indexOf(V0, W0)) !== -1);
            T0[B0++] = $0.slice(W0), $0 = T0, p0 = B0;
          } else
            $0 = [$0], p0 = 1;
        } else
          v0 === "object" ? p0 = $0.length : ($0 = [$0], p0 = 1);
      }
      var X0 = null, J0, yg, _g, wg, $g, Eg = $0[M0], bg = $0[M0 + 1], vg, Ag;
      if (M0 === p0)
        C0._listeners && (typeof C0._listeners == "function" ? (_0 && _0.push(C0._listeners), X0 = [C0]) : (_0 && _0.push.apply(_0, C0._listeners), X0 = [C0]));
      else if (Eg === "*") {
        for (vg = d0(C0), L0 = vg.length; L0-- > 0; )
          J0 = vg[L0], J0 !== "_listeners" && (Ag = U0(_0, $0, C0[J0], M0 + 1, p0), Ag && (X0 ? X0.push.apply(X0, Ag) : X0 = Ag));
        return X0;
      } else if (Eg === "**") {
        for ($g = M0 + 1 === p0 || M0 + 2 === p0 && bg === "*", $g && C0._listeners && (X0 = U0(_0, $0, C0, p0, p0)), vg = d0(C0), L0 = vg.length; L0-- > 0; )
          J0 = vg[L0], J0 !== "_listeners" && (J0 === "*" || J0 === "**" ? (C0[J0]._listeners && !$g && (Ag = U0(_0, $0, C0[J0], p0, p0), Ag && (X0 ? X0.push.apply(X0, Ag) : X0 = Ag)), Ag = U0(_0, $0, C0[J0], M0, p0)) : J0 === bg ? Ag = U0(_0, $0, C0[J0], M0 + 2, p0) : Ag = U0(_0, $0, C0[J0], M0, p0), Ag && (X0 ? X0.push.apply(X0, Ag) : X0 = Ag));
        return X0;
      } else
        C0[Eg] && (X0 = U0(_0, $0, C0[Eg], M0 + 1, p0));
      if (yg = C0["*"], yg && U0(_0, $0, yg, M0 + 1, p0), _g = C0["**"], _g)
        if (M0 < p0)
          for (_g._listeners && U0(_0, $0, _g, p0, p0), vg = d0(_g), L0 = vg.length; L0-- > 0; )
            J0 = vg[L0], J0 !== "_listeners" && (J0 === bg ? U0(_0, $0, _g[J0], M0 + 2, p0) : J0 === Eg ? U0(_0, $0, _g[J0], M0 + 1, p0) : (wg = {}, wg[J0] = _g[J0], U0(_0, $0, { "**": wg }, M0 + 1, p0)));
        else
          _g._listeners ? U0(_0, $0, _g, p0, p0) : _g["*"] && _g["*"]._listeners && U0(_0, $0, _g["*"], p0, p0);
      return X0;
    }
    function F0(_0, $0, C0) {
      var M0 = 0, p0 = 0, v0, T0 = this.delimiter, L0 = T0.length, B0;
      if (typeof _0 == "string")
        if ((v0 = _0.indexOf(T0)) !== -1) {
          B0 = new Array(5);
          do
            B0[M0++] = _0.slice(p0, v0), p0 = v0 + L0;
          while ((v0 = _0.indexOf(T0, p0)) !== -1);
          B0[M0++] = _0.slice(p0);
        } else
          B0 = [_0], M0 = 1;
      else
        B0 = _0, M0 = _0.length;
      if (M0 > 1) {
        for (v0 = 0; v0 + 1 < M0; v0++)
          if (B0[v0] === "**" && B0[v0 + 1] === "**")
            return;
      }
      var W0 = this.listenerTree, V0;
      for (v0 = 0; v0 < M0; v0++)
        if (V0 = B0[v0], W0 = W0[V0] || (W0[V0] = {}), v0 === M0 - 1)
          return W0._listeners ? (typeof W0._listeners == "function" && (W0._listeners = [W0._listeners]), C0 ? W0._listeners.unshift($0) : W0._listeners.push($0), !W0._listeners.warned && this._maxListeners > 0 && W0._listeners.length > this._maxListeners && (W0._listeners.warned = !0, w0.call(this, W0._listeners.length, V0))) : W0._listeners = $0, !0;
      return !0;
    }
    function H0(_0, $0, C0, M0) {
      for (var p0 = d0(_0), v0 = p0.length, T0, L0, B0, W0 = _0._listeners, V0; v0-- > 0; )
        L0 = p0[v0], T0 = _0[L0], L0 === "_listeners" ? B0 = C0 : B0 = C0 ? C0.concat(L0) : [L0], V0 = M0 || typeof L0 == "symbol", W0 && $0.push(V0 ? B0 : B0.join(this.delimiter)), typeof T0 == "object" && H0.call(this, T0, $0, B0, V0);
      return $0;
    }
    function P0(_0) {
      for (var $0 = d0(_0), C0 = $0.length, M0, p0, v0; C0-- > 0; )
        p0 = $0[C0], M0 = _0[p0], M0 && (v0 = !0, p0 !== "_listeners" && !P0(M0) && delete _0[p0]);
      return v0;
    }
    function I0(_0, $0, C0) {
      this.emitter = _0, this.event = $0, this.listener = C0;
    }
    I0.prototype.off = function() {
      return this.emitter.off(this.event, this.listener), this;
    };
    function f0(_0, $0, C0) {
      if (C0 === !0)
        p0 = !0;
      else if (C0 === !1)
        M0 = !0;
      else {
        if (!C0 || typeof C0 != "object")
          throw TypeError("options should be an object or true");
        var M0 = C0.async, p0 = C0.promisify, v0 = C0.nextTick, T0 = C0.objectify;
      }
      if (M0 || v0 || p0) {
        var L0 = $0, B0 = $0._origin || $0;
        if (v0 && !s0)
          throw Error("process.nextTick is not supported");
        p0 === n0 && (p0 = $0.constructor.name === "AsyncFunction"), $0 = function() {
          var W0 = arguments, V0 = this, Q0 = this.event;
          return p0 ? v0 ? Promise.resolve() : new Promise(function(X0) {
            u0(X0);
          }).then(function() {
            return V0.event = Q0, L0.apply(V0, W0);
          }) : (v0 ? process.nextTick : u0)(function() {
            V0.event = Q0, L0.apply(V0, W0);
          });
        }, $0._async = !0, $0._origin = B0;
      }
      return [$0, T0 ? new I0(this, _0, $0) : this];
    }
    function m0(_0) {
      this._events = {}, this._newListener = !1, this._removeListener = !1, this.verboseMemoryLeak = !1, g0.call(this, _0);
    }
    m0.EventEmitter2 = m0, m0.prototype.listenTo = function(_0, $0, C0) {
      if (typeof _0 != "object")
        throw TypeError("target musts be an object");
      var M0 = this;
      C0 = O0(C0, {
        on: n0,
        off: n0,
        reducers: n0
      }, {
        on: D0,
        off: D0,
        reducers: z0
      });
      function p0(v0) {
        if (typeof v0 != "object")
          throw TypeError("events must be an object");
        var T0 = C0.reducers, L0 = K0.call(M0, _0), B0;
        L0 === -1 ? B0 = new b0(M0, _0, C0) : B0 = M0._observers[L0];
        for (var W0 = d0(v0), V0 = W0.length, Q0, X0 = typeof T0 == "function", J0 = 0; J0 < V0; J0++)
          Q0 = W0[J0], B0.subscribe(
            Q0,
            v0[Q0] || Q0,
            X0 ? T0 : T0 && T0[Q0]
          );
      }
      return i0($0) ? p0(E0($0)) : p0(typeof $0 == "string" ? E0($0.split(/\s+/)) : $0), this;
    }, m0.prototype.stopListeningTo = function(_0, $0) {
      var C0 = this._observers;
      if (!C0)
        return !1;
      var M0 = C0.length, p0, v0 = !1;
      if (_0 && typeof _0 != "object")
        throw TypeError("target should be an object");
      for (; M0-- > 0; )
        p0 = C0[M0], (!_0 || p0._target === _0) && (p0.unsubscribe($0), v0 = !0);
      return v0;
    }, m0.prototype.delimiter = ".", m0.prototype.setMaxListeners = function(_0) {
      _0 !== n0 && (this._maxListeners = _0, this._conf || (this._conf = {}), this._conf.maxListeners = _0);
    }, m0.prototype.getMaxListeners = function() {
      return this._maxListeners;
    }, m0.prototype.event = "", m0.prototype.once = function(_0, $0, C0) {
      return this._once(_0, $0, !1, C0);
    }, m0.prototype.prependOnceListener = function(_0, $0, C0) {
      return this._once(_0, $0, !0, C0);
    }, m0.prototype._once = function(_0, $0, C0, M0) {
      return this._many(_0, 1, $0, C0, M0);
    }, m0.prototype.many = function(_0, $0, C0, M0) {
      return this._many(_0, $0, C0, !1, M0);
    }, m0.prototype.prependMany = function(_0, $0, C0, M0) {
      return this._many(_0, $0, C0, !0, M0);
    }, m0.prototype._many = function(_0, $0, C0, M0, p0) {
      var v0 = this;
      if (typeof C0 != "function")
        throw new Error("many only accepts instances of Function");
      function T0() {
        return --$0 === 0 && v0.off(_0, T0), C0.apply(this, arguments);
      }
      return T0._origin = C0, this._on(_0, T0, M0, p0);
    }, m0.prototype.emit = function() {
      if (!this._events && !this._all)
        return !1;
      this._events || h0.call(this);
      var _0 = arguments[0], $0, C0 = this.wildcard, M0, p0, v0, T0, L0;
      if (_0 === "newListener" && !this._newListener && !this._events.newListener)
        return !1;
      if (C0 && ($0 = _0, _0 !== "newListener" && _0 !== "removeListener" && typeof _0 == "object")) {
        if (p0 = _0.length, a0) {
          for (v0 = 0; v0 < p0; v0++)
            if (typeof _0[v0] == "symbol") {
              L0 = !0;
              break;
            }
        }
        L0 || (_0 = _0.join(this.delimiter));
      }
      var B0 = arguments.length, W0;
      if (this._all && this._all.length)
        for (W0 = this._all.slice(), v0 = 0, p0 = W0.length; v0 < p0; v0++)
          switch (this.event = _0, B0) {
            case 1:
              W0[v0].call(this, _0);
              break;
            case 2:
              W0[v0].call(this, _0, arguments[1]);
              break;
            case 3:
              W0[v0].call(this, _0, arguments[1], arguments[2]);
              break;
            default:
              W0[v0].apply(this, arguments);
          }
      if (C0)
        W0 = [], U0.call(this, W0, $0, this.listenerTree, 0, p0);
      else if (W0 = this._events[_0], typeof W0 == "function") {
        switch (this.event = _0, B0) {
          case 1:
            W0.call(this);
            break;
          case 2:
            W0.call(this, arguments[1]);
            break;
          case 3:
            W0.call(this, arguments[1], arguments[2]);
            break;
          default:
            for (M0 = new Array(B0 - 1), T0 = 1; T0 < B0; T0++)
              M0[T0 - 1] = arguments[T0];
            W0.apply(this, M0);
        }
        return !0;
      } else
        W0 && (W0 = W0.slice());
      if (W0 && W0.length) {
        if (B0 > 3)
          for (M0 = new Array(B0 - 1), T0 = 1; T0 < B0; T0++)
            M0[T0 - 1] = arguments[T0];
        for (v0 = 0, p0 = W0.length; v0 < p0; v0++)
          switch (this.event = _0, B0) {
            case 1:
              W0[v0].call(this);
              break;
            case 2:
              W0[v0].call(this, arguments[1]);
              break;
            case 3:
              W0[v0].call(this, arguments[1], arguments[2]);
              break;
            default:
              W0[v0].apply(this, M0);
          }
        return !0;
      } else if (!this.ignoreErrors && !this._all && _0 === "error")
        throw arguments[1] instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
      return !!this._all;
    }, m0.prototype.emitAsync = function() {
      if (!this._events && !this._all)
        return !1;
      this._events || h0.call(this);
      var _0 = arguments[0], $0 = this.wildcard, C0, M0, p0, v0, T0, L0;
      if (_0 === "newListener" && !this._newListener && !this._events.newListener)
        return Promise.resolve([!1]);
      if ($0 && (C0 = _0, _0 !== "newListener" && _0 !== "removeListener" && typeof _0 == "object")) {
        if (v0 = _0.length, a0) {
          for (T0 = 0; T0 < v0; T0++)
            if (typeof _0[T0] == "symbol") {
              M0 = !0;
              break;
            }
        }
        M0 || (_0 = _0.join(this.delimiter));
      }
      var B0 = [], W0 = arguments.length, V0;
      if (this._all)
        for (T0 = 0, v0 = this._all.length; T0 < v0; T0++)
          switch (this.event = _0, W0) {
            case 1:
              B0.push(this._all[T0].call(this, _0));
              break;
            case 2:
              B0.push(this._all[T0].call(this, _0, arguments[1]));
              break;
            case 3:
              B0.push(this._all[T0].call(this, _0, arguments[1], arguments[2]));
              break;
            default:
              B0.push(this._all[T0].apply(this, arguments));
          }
      if ($0 ? (V0 = [], U0.call(this, V0, C0, this.listenerTree, 0)) : V0 = this._events[_0], typeof V0 == "function")
        switch (this.event = _0, W0) {
          case 1:
            B0.push(V0.call(this));
            break;
          case 2:
            B0.push(V0.call(this, arguments[1]));
            break;
          case 3:
            B0.push(V0.call(this, arguments[1], arguments[2]));
            break;
          default:
            for (p0 = new Array(W0 - 1), L0 = 1; L0 < W0; L0++)
              p0[L0 - 1] = arguments[L0];
            B0.push(V0.apply(this, p0));
        }
      else if (V0 && V0.length) {
        if (V0 = V0.slice(), W0 > 3)
          for (p0 = new Array(W0 - 1), L0 = 1; L0 < W0; L0++)
            p0[L0 - 1] = arguments[L0];
        for (T0 = 0, v0 = V0.length; T0 < v0; T0++)
          switch (this.event = _0, W0) {
            case 1:
              B0.push(V0[T0].call(this));
              break;
            case 2:
              B0.push(V0[T0].call(this, arguments[1]));
              break;
            case 3:
              B0.push(V0[T0].call(this, arguments[1], arguments[2]));
              break;
            default:
              B0.push(V0[T0].apply(this, p0));
          }
      } else if (!this.ignoreErrors && !this._all && _0 === "error")
        return arguments[1] instanceof Error ? Promise.reject(arguments[1]) : Promise.reject("Uncaught, unspecified 'error' event.");
      return Promise.all(B0);
    }, m0.prototype.on = function(_0, $0, C0) {
      return this._on(_0, $0, !1, C0);
    }, m0.prototype.prependListener = function(_0, $0, C0) {
      return this._on(_0, $0, !0, C0);
    }, m0.prototype.onAny = function(_0) {
      return this._onAny(_0, !1);
    }, m0.prototype.prependAny = function(_0) {
      return this._onAny(_0, !0);
    }, m0.prototype.addListener = m0.prototype.on, m0.prototype._onAny = function(_0, $0) {
      if (typeof _0 != "function")
        throw new Error("onAny only accepts instances of Function");
      return this._all || (this._all = []), $0 ? this._all.unshift(_0) : this._all.push(_0), this;
    }, m0.prototype._on = function(_0, $0, C0, M0) {
      if (typeof _0 == "function")
        return this._onAny(_0, $0), this;
      if (typeof $0 != "function")
        throw new Error("on only accepts instances of Function");
      this._events || h0.call(this);
      var p0 = this, v0;
      return M0 !== n0 && (v0 = f0.call(this, _0, $0, M0), $0 = v0[0], p0 = v0[1]), this._newListener && this.emit("newListener", _0, $0), this.wildcard ? (F0.call(this, _0, $0, C0), p0) : (this._events[_0] ? (typeof this._events[_0] == "function" && (this._events[_0] = [this._events[_0]]), C0 ? this._events[_0].unshift($0) : this._events[_0].push($0), !this._events[_0].warned && this._maxListeners > 0 && this._events[_0].length > this._maxListeners && (this._events[_0].warned = !0, w0.call(this, this._events[_0].length, _0))) : this._events[_0] = $0, p0);
    }, m0.prototype.off = function(_0, $0) {
      if (typeof $0 != "function")
        throw new Error("removeListener only takes instances of Function");
      var C0, M0 = [];
      if (this.wildcard) {
        var p0 = typeof _0 == "string" ? _0.split(this.delimiter) : _0.slice();
        if (M0 = U0.call(this, null, p0, this.listenerTree, 0), !M0)
          return this;
      } else {
        if (!this._events[_0])
          return this;
        C0 = this._events[_0], M0.push({ _listeners: C0 });
      }
      for (var v0 = 0; v0 < M0.length; v0++) {
        var T0 = M0[v0];
        if (C0 = T0._listeners, i0(C0)) {
          for (var L0 = -1, B0 = 0, W0 = C0.length; B0 < W0; B0++)
            if (C0[B0] === $0 || C0[B0].listener && C0[B0].listener === $0 || C0[B0]._origin && C0[B0]._origin === $0) {
              L0 = B0;
              break;
            }
          if (L0 < 0)
            continue;
          return this.wildcard ? T0._listeners.splice(L0, 1) : this._events[_0].splice(L0, 1), C0.length === 0 && (this.wildcard ? delete T0._listeners : delete this._events[_0]), this._removeListener && this.emit("removeListener", _0, $0), this;
        } else
          (C0 === $0 || C0.listener && C0.listener === $0 || C0._origin && C0._origin === $0) && (this.wildcard ? delete T0._listeners : delete this._events[_0], this._removeListener && this.emit("removeListener", _0, $0));
      }
      return this.listenerTree && P0(this.listenerTree), this;
    }, m0.prototype.offAny = function(_0) {
      var $0 = 0, C0 = 0, M0;
      if (_0 && this._all && this._all.length > 0) {
        for (M0 = this._all, $0 = 0, C0 = M0.length; $0 < C0; $0++)
          if (_0 === M0[$0])
            return M0.splice($0, 1), this._removeListener && this.emit("removeListenerAny", _0), this;
      } else {
        if (M0 = this._all, this._removeListener)
          for ($0 = 0, C0 = M0.length; $0 < C0; $0++)
            this.emit("removeListenerAny", M0[$0]);
        this._all = [];
      }
      return this;
    }, m0.prototype.removeListener = m0.prototype.off, m0.prototype.removeAllListeners = function(_0) {
      if (_0 === n0)
        return !this._events || h0.call(this), this;
      if (this.wildcard) {
        var $0 = U0.call(this, null, _0, this.listenerTree, 0), C0, M0;
        if (!$0)
          return this;
        for (M0 = 0; M0 < $0.length; M0++)
          C0 = $0[M0], C0._listeners = null;
        this.listenerTree && P0(this.listenerTree);
      } else
        this._events && (this._events[_0] = null);
      return this;
    }, m0.prototype.listeners = function(_0) {
      var $0 = this._events, C0, M0, p0, v0, T0;
      if (_0 === n0) {
        if (this.wildcard)
          throw Error("event name required for wildcard emitter");
        if (!$0)
          return [];
        for (C0 = d0($0), v0 = C0.length, p0 = []; v0-- > 0; )
          M0 = $0[C0[v0]], typeof M0 == "function" ? p0.push(M0) : p0.push.apply(p0, M0);
        return p0;
      } else {
        if (this.wildcard) {
          if (T0 = this.listenerTree, !T0)
            return [];
          var L0 = [], B0 = typeof _0 == "string" ? _0.split(this.delimiter) : _0.slice();
          return U0.call(this, L0, B0, T0, 0), L0;
        }
        return $0 ? (M0 = $0[_0], M0 ? typeof M0 == "function" ? [M0] : M0 : []) : [];
      }
    }, m0.prototype.eventNames = function(_0) {
      var $0 = this._events;
      return this.wildcard ? H0.call(this, this.listenerTree, [], null, _0) : $0 ? d0($0) : [];
    }, m0.prototype.listenerCount = function(_0) {
      return this.listeners(_0).length;
    }, m0.prototype.hasListeners = function(_0) {
      if (this.wildcard) {
        var $0 = [], C0 = typeof _0 == "string" ? _0.split(this.delimiter) : _0.slice();
        return U0.call(this, $0, C0, this.listenerTree, 0), $0.length > 0;
      }
      var M0 = this._events, p0 = this._all;
      return !!(p0 && p0.length || M0 && (_0 === n0 ? d0(M0).length : M0[_0]));
    }, m0.prototype.listenersAny = function() {
      return this._all ? this._all : [];
    }, m0.prototype.waitFor = function(_0, $0) {
      var C0 = this, M0 = typeof $0;
      return M0 === "number" ? $0 = { timeout: $0 } : M0 === "function" && ($0 = { filter: $0 }), $0 = O0($0, {
        timeout: 0,
        filter: n0,
        handleError: !1,
        Promise,
        overload: !1
      }, {
        filter: D0,
        Promise: S0
      }), G0($0.Promise, function(p0, v0, T0) {
        function L0() {
          var B0 = $0.filter;
          if (!(B0 && !B0.apply(C0, arguments)))
            if (C0.off(_0, L0), $0.handleError) {
              var W0 = arguments[0];
              W0 ? v0(W0) : p0(y0.apply(null, arguments).slice(1));
            } else
              p0(y0.apply(null, arguments));
        }
        T0(function() {
          C0.off(_0, L0);
        }), C0._on(_0, L0, !1);
      }, {
        timeout: $0.timeout,
        overload: $0.overload
      });
    };
    function A0(_0, $0, C0) {
      C0 = O0(C0, {
        Promise,
        timeout: 0,
        overload: !1
      }, {
        Promise: S0
      });
      var M0 = C0.Promise;
      return G0(M0, function(p0, v0, T0) {
        var L0;
        if (typeof _0.addEventListener == "function") {
          L0 = function() {
            p0(y0.apply(null, arguments));
          }, T0(function() {
            _0.removeEventListener($0, L0);
          }), _0.addEventListener(
            $0,
            L0,
            { once: !0 }
          );
          return;
        }
        var B0 = function() {
          W0 && _0.removeListener("error", W0), p0(y0.apply(null, arguments));
        }, W0;
        $0 !== "error" && (W0 = function(V0) {
          _0.removeListener($0, B0), v0(V0);
        }, _0.once("error", W0)), T0(function() {
          W0 && _0.removeListener("error", W0), _0.removeListener($0, B0);
        }), _0.once($0, B0);
      }, {
        timeout: C0.timeout,
        overload: C0.overload
      });
    }
    var x0 = m0.prototype;
    Object.defineProperties(m0, {
      defaultMaxListeners: {
        get: function() {
          return x0._maxListeners;
        },
        set: function(_0) {
          if (typeof _0 != "number" || _0 < 0 || Number.isNaN(_0))
            throw TypeError("n must be a non-negative number");
          x0._maxListeners = _0;
        },
        enumerable: !0
      },
      once: {
        value: A0,
        writable: !0,
        configurable: !0
      }
    }), Object.defineProperties(x0, {
      _maxListeners: {
        value: o0,
        writable: !0,
        configurable: !0
      },
      _observers: { value: null, writable: !0, configurable: !0 }
    }), typeof n0 == "function" && n0.amd ? n0(function() {
      return m0;
    }) : t0.exports = m0;
  })();
})(eventemitter2);
var eventemitter2Exports = eventemitter2.exports;
const n = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter2Exports);
var getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate$1(t0) {
  return typeof t0 == "string" && REGEX.test(t0);
}
var byteToHex = [];
for (var i$1 = 0; i$1 < 256; ++i$1)
  byteToHex.push((i$1 + 256).toString(16).substr(1));
function stringify(t0) {
  var e0 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n0 = (byteToHex[t0[e0 + 0]] + byteToHex[t0[e0 + 1]] + byteToHex[t0[e0 + 2]] + byteToHex[t0[e0 + 3]] + "-" + byteToHex[t0[e0 + 4]] + byteToHex[t0[e0 + 5]] + "-" + byteToHex[t0[e0 + 6]] + byteToHex[t0[e0 + 7]] + "-" + byteToHex[t0[e0 + 8]] + byteToHex[t0[e0 + 9]] + "-" + byteToHex[t0[e0 + 10]] + byteToHex[t0[e0 + 11]] + byteToHex[t0[e0 + 12]] + byteToHex[t0[e0 + 13]] + byteToHex[t0[e0 + 14]] + byteToHex[t0[e0 + 15]]).toLowerCase();
  if (!validate$1(n0))
    throw TypeError("Stringified UUID is invalid");
  return n0;
}
var _nodeId, _clockseq, _lastMSecs = 0, _lastNSecs = 0;
function v1(t0, e0, n0) {
  var r0 = e0 && n0 || 0, i0 = e0 || new Array(16);
  t0 = t0 || {};
  var o0 = t0.node || _nodeId, s0 = t0.clockseq !== void 0 ? t0.clockseq : _clockseq;
  if (o0 == null || s0 == null) {
    var a0 = t0.random || (t0.rng || rng)();
    o0 == null && (o0 = _nodeId = [a0[0] | 1, a0[1], a0[2], a0[3], a0[4], a0[5]]), s0 == null && (s0 = _clockseq = (a0[6] << 8 | a0[7]) & 16383);
  }
  var c0 = t0.msecs !== void 0 ? t0.msecs : Date.now(), l0 = t0.nsecs !== void 0 ? t0.nsecs : _lastNSecs + 1, u0 = c0 - _lastMSecs + (l0 - _lastNSecs) / 1e4;
  if (u0 < 0 && t0.clockseq === void 0 && (s0 = s0 + 1 & 16383), (u0 < 0 || c0 > _lastMSecs) && t0.nsecs === void 0 && (l0 = 0), l0 >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  _lastMSecs = c0, _lastNSecs = l0, _clockseq = s0, c0 += 122192928e5;
  var d0 = ((c0 & 268435455) * 1e4 + l0) % 4294967296;
  i0[r0++] = d0 >>> 24 & 255, i0[r0++] = d0 >>> 16 & 255, i0[r0++] = d0 >>> 8 & 255, i0[r0++] = d0 & 255;
  var h0 = c0 / 4294967296 * 1e4 & 268435455;
  i0[r0++] = h0 >>> 8 & 255, i0[r0++] = h0 & 255, i0[r0++] = h0 >>> 24 & 15 | 16, i0[r0++] = h0 >>> 16 & 255, i0[r0++] = s0 >>> 8 | 128, i0[r0++] = s0 & 255;
  for (var g0 = 0; g0 < 6; ++g0)
    i0[r0 + g0] = o0[g0];
  return e0 || stringify(i0);
}
function parse$1(t0) {
  if (!validate$1(t0))
    throw TypeError("Invalid UUID");
  var e0, n0 = new Uint8Array(16);
  return n0[0] = (e0 = parseInt(t0.slice(0, 8), 16)) >>> 24, n0[1] = e0 >>> 16 & 255, n0[2] = e0 >>> 8 & 255, n0[3] = e0 & 255, n0[4] = (e0 = parseInt(t0.slice(9, 13), 16)) >>> 8, n0[5] = e0 & 255, n0[6] = (e0 = parseInt(t0.slice(14, 18), 16)) >>> 8, n0[7] = e0 & 255, n0[8] = (e0 = parseInt(t0.slice(19, 23), 16)) >>> 8, n0[9] = e0 & 255, n0[10] = (e0 = parseInt(t0.slice(24, 36), 16)) / 1099511627776 & 255, n0[11] = e0 / 4294967296 & 255, n0[12] = e0 >>> 24 & 255, n0[13] = e0 >>> 16 & 255, n0[14] = e0 >>> 8 & 255, n0[15] = e0 & 255, n0;
}
function stringToBytes(t0) {
  t0 = unescape(encodeURIComponent(t0));
  for (var e0 = [], n0 = 0; n0 < t0.length; ++n0)
    e0.push(t0.charCodeAt(n0));
  return e0;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(t0, e0, n0) {
  function r0(i0, o0, s0, a0) {
    if (typeof i0 == "string" && (i0 = stringToBytes(i0)), typeof o0 == "string" && (o0 = parse$1(o0)), o0.length !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var c0 = new Uint8Array(16 + i0.length);
    if (c0.set(o0), c0.set(i0, o0.length), c0 = n0(c0), c0[6] = c0[6] & 15 | e0, c0[8] = c0[8] & 63 | 128, s0) {
      a0 = a0 || 0;
      for (var l0 = 0; l0 < 16; ++l0)
        s0[a0 + l0] = c0[l0];
      return s0;
    }
    return stringify(c0);
  }
  try {
    r0.name = t0;
  } catch {
  }
  return r0.DNS = DNS, r0.URL = URL$1, r0;
}
function md5(t0) {
  if (typeof t0 == "string") {
    var e0 = unescape(encodeURIComponent(t0));
    t0 = new Uint8Array(e0.length);
    for (var n0 = 0; n0 < e0.length; ++n0)
      t0[n0] = e0.charCodeAt(n0);
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(t0), t0.length * 8));
}
function md5ToHexEncodedArray(t0) {
  for (var e0 = [], n0 = t0.length * 32, r0 = "0123456789abcdef", i0 = 0; i0 < n0; i0 += 8) {
    var o0 = t0[i0 >> 5] >>> i0 % 32 & 255, s0 = parseInt(r0.charAt(o0 >>> 4 & 15) + r0.charAt(o0 & 15), 16);
    e0.push(s0);
  }
  return e0;
}
function getOutputLength(t0) {
  return (t0 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(t0, e0) {
  t0[e0 >> 5] |= 128 << e0 % 32, t0[getOutputLength(e0) - 1] = e0;
  for (var n0 = 1732584193, r0 = -271733879, i0 = -1732584194, o0 = 271733878, s0 = 0; s0 < t0.length; s0 += 16) {
    var a0 = n0, c0 = r0, l0 = i0, u0 = o0;
    n0 = md5ff(n0, r0, i0, o0, t0[s0], 7, -680876936), o0 = md5ff(o0, n0, r0, i0, t0[s0 + 1], 12, -389564586), i0 = md5ff(i0, o0, n0, r0, t0[s0 + 2], 17, 606105819), r0 = md5ff(r0, i0, o0, n0, t0[s0 + 3], 22, -1044525330), n0 = md5ff(n0, r0, i0, o0, t0[s0 + 4], 7, -176418897), o0 = md5ff(o0, n0, r0, i0, t0[s0 + 5], 12, 1200080426), i0 = md5ff(i0, o0, n0, r0, t0[s0 + 6], 17, -1473231341), r0 = md5ff(r0, i0, o0, n0, t0[s0 + 7], 22, -45705983), n0 = md5ff(n0, r0, i0, o0, t0[s0 + 8], 7, 1770035416), o0 = md5ff(o0, n0, r0, i0, t0[s0 + 9], 12, -1958414417), i0 = md5ff(i0, o0, n0, r0, t0[s0 + 10], 17, -42063), r0 = md5ff(r0, i0, o0, n0, t0[s0 + 11], 22, -1990404162), n0 = md5ff(n0, r0, i0, o0, t0[s0 + 12], 7, 1804603682), o0 = md5ff(o0, n0, r0, i0, t0[s0 + 13], 12, -40341101), i0 = md5ff(i0, o0, n0, r0, t0[s0 + 14], 17, -1502002290), r0 = md5ff(r0, i0, o0, n0, t0[s0 + 15], 22, 1236535329), n0 = md5gg(n0, r0, i0, o0, t0[s0 + 1], 5, -165796510), o0 = md5gg(o0, n0, r0, i0, t0[s0 + 6], 9, -1069501632), i0 = md5gg(i0, o0, n0, r0, t0[s0 + 11], 14, 643717713), r0 = md5gg(r0, i0, o0, n0, t0[s0], 20, -373897302), n0 = md5gg(n0, r0, i0, o0, t0[s0 + 5], 5, -701558691), o0 = md5gg(o0, n0, r0, i0, t0[s0 + 10], 9, 38016083), i0 = md5gg(i0, o0, n0, r0, t0[s0 + 15], 14, -660478335), r0 = md5gg(r0, i0, o0, n0, t0[s0 + 4], 20, -405537848), n0 = md5gg(n0, r0, i0, o0, t0[s0 + 9], 5, 568446438), o0 = md5gg(o0, n0, r0, i0, t0[s0 + 14], 9, -1019803690), i0 = md5gg(i0, o0, n0, r0, t0[s0 + 3], 14, -187363961), r0 = md5gg(r0, i0, o0, n0, t0[s0 + 8], 20, 1163531501), n0 = md5gg(n0, r0, i0, o0, t0[s0 + 13], 5, -1444681467), o0 = md5gg(o0, n0, r0, i0, t0[s0 + 2], 9, -51403784), i0 = md5gg(i0, o0, n0, r0, t0[s0 + 7], 14, 1735328473), r0 = md5gg(r0, i0, o0, n0, t0[s0 + 12], 20, -1926607734), n0 = md5hh(n0, r0, i0, o0, t0[s0 + 5], 4, -378558), o0 = md5hh(o0, n0, r0, i0, t0[s0 + 8], 11, -2022574463), i0 = md5hh(i0, o0, n0, r0, t0[s0 + 11], 16, 1839030562), r0 = md5hh(r0, i0, o0, n0, t0[s0 + 14], 23, -35309556), n0 = md5hh(n0, r0, i0, o0, t0[s0 + 1], 4, -1530992060), o0 = md5hh(o0, n0, r0, i0, t0[s0 + 4], 11, 1272893353), i0 = md5hh(i0, o0, n0, r0, t0[s0 + 7], 16, -155497632), r0 = md5hh(r0, i0, o0, n0, t0[s0 + 10], 23, -1094730640), n0 = md5hh(n0, r0, i0, o0, t0[s0 + 13], 4, 681279174), o0 = md5hh(o0, n0, r0, i0, t0[s0], 11, -358537222), i0 = md5hh(i0, o0, n0, r0, t0[s0 + 3], 16, -722521979), r0 = md5hh(r0, i0, o0, n0, t0[s0 + 6], 23, 76029189), n0 = md5hh(n0, r0, i0, o0, t0[s0 + 9], 4, -640364487), o0 = md5hh(o0, n0, r0, i0, t0[s0 + 12], 11, -421815835), i0 = md5hh(i0, o0, n0, r0, t0[s0 + 15], 16, 530742520), r0 = md5hh(r0, i0, o0, n0, t0[s0 + 2], 23, -995338651), n0 = md5ii(n0, r0, i0, o0, t0[s0], 6, -198630844), o0 = md5ii(o0, n0, r0, i0, t0[s0 + 7], 10, 1126891415), i0 = md5ii(i0, o0, n0, r0, t0[s0 + 14], 15, -1416354905), r0 = md5ii(r0, i0, o0, n0, t0[s0 + 5], 21, -57434055), n0 = md5ii(n0, r0, i0, o0, t0[s0 + 12], 6, 1700485571), o0 = md5ii(o0, n0, r0, i0, t0[s0 + 3], 10, -1894986606), i0 = md5ii(i0, o0, n0, r0, t0[s0 + 10], 15, -1051523), r0 = md5ii(r0, i0, o0, n0, t0[s0 + 1], 21, -2054922799), n0 = md5ii(n0, r0, i0, o0, t0[s0 + 8], 6, 1873313359), o0 = md5ii(o0, n0, r0, i0, t0[s0 + 15], 10, -30611744), i0 = md5ii(i0, o0, n0, r0, t0[s0 + 6], 15, -1560198380), r0 = md5ii(r0, i0, o0, n0, t0[s0 + 13], 21, 1309151649), n0 = md5ii(n0, r0, i0, o0, t0[s0 + 4], 6, -145523070), o0 = md5ii(o0, n0, r0, i0, t0[s0 + 11], 10, -1120210379), i0 = md5ii(i0, o0, n0, r0, t0[s0 + 2], 15, 718787259), r0 = md5ii(r0, i0, o0, n0, t0[s0 + 9], 21, -343485551), n0 = safeAdd(n0, a0), r0 = safeAdd(r0, c0), i0 = safeAdd(i0, l0), o0 = safeAdd(o0, u0);
  }
  return [n0, r0, i0, o0];
}
function bytesToWords(t0) {
  if (t0.length === 0)
    return [];
  for (var e0 = t0.length * 8, n0 = new Uint32Array(getOutputLength(e0)), r0 = 0; r0 < e0; r0 += 8)
    n0[r0 >> 5] |= (t0[r0 / 8] & 255) << r0 % 32;
  return n0;
}
function safeAdd(t0, e0) {
  var n0 = (t0 & 65535) + (e0 & 65535), r0 = (t0 >> 16) + (e0 >> 16) + (n0 >> 16);
  return r0 << 16 | n0 & 65535;
}
function bitRotateLeft(t0, e0) {
  return t0 << e0 | t0 >>> 32 - e0;
}
function md5cmn(t0, e0, n0, r0, i0, o0) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(e0, t0), safeAdd(r0, o0)), i0), n0);
}
function md5ff(t0, e0, n0, r0, i0, o0, s0) {
  return md5cmn(e0 & n0 | ~e0 & r0, t0, e0, i0, o0, s0);
}
function md5gg(t0, e0, n0, r0, i0, o0, s0) {
  return md5cmn(e0 & r0 | n0 & ~r0, t0, e0, i0, o0, s0);
}
function md5hh(t0, e0, n0, r0, i0, o0, s0) {
  return md5cmn(e0 ^ n0 ^ r0, t0, e0, i0, o0, s0);
}
function md5ii(t0, e0, n0, r0, i0, o0, s0) {
  return md5cmn(n0 ^ (e0 | ~r0), t0, e0, i0, o0, s0);
}
var v3 = v35("v3", 48, md5);
const v3$1 = v3;
function v4(t0, e0, n0) {
  t0 = t0 || {};
  var r0 = t0.random || (t0.rng || rng)();
  if (r0[6] = r0[6] & 15 | 64, r0[8] = r0[8] & 63 | 128, e0) {
    n0 = n0 || 0;
    for (var i0 = 0; i0 < 16; ++i0)
      e0[n0 + i0] = r0[i0];
    return e0;
  }
  return stringify(r0);
}
function f$1(t0, e0, n0, r0) {
  switch (t0) {
    case 0:
      return e0 & n0 ^ ~e0 & r0;
    case 1:
      return e0 ^ n0 ^ r0;
    case 2:
      return e0 & n0 ^ e0 & r0 ^ n0 & r0;
    case 3:
      return e0 ^ n0 ^ r0;
  }
}
function ROTL(t0, e0) {
  return t0 << e0 | t0 >>> 32 - e0;
}
function sha1(t0) {
  var e0 = [1518500249, 1859775393, 2400959708, 3395469782], n0 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof t0 == "string") {
    var r0 = unescape(encodeURIComponent(t0));
    t0 = [];
    for (var i0 = 0; i0 < r0.length; ++i0)
      t0.push(r0.charCodeAt(i0));
  } else
    Array.isArray(t0) || (t0 = Array.prototype.slice.call(t0));
  t0.push(128);
  for (var o0 = t0.length / 4 + 2, s0 = Math.ceil(o0 / 16), a0 = new Array(s0), c0 = 0; c0 < s0; ++c0) {
    for (var l0 = new Uint32Array(16), u0 = 0; u0 < 16; ++u0)
      l0[u0] = t0[c0 * 64 + u0 * 4] << 24 | t0[c0 * 64 + u0 * 4 + 1] << 16 | t0[c0 * 64 + u0 * 4 + 2] << 8 | t0[c0 * 64 + u0 * 4 + 3];
    a0[c0] = l0;
  }
  a0[s0 - 1][14] = (t0.length - 1) * 8 / Math.pow(2, 32), a0[s0 - 1][14] = Math.floor(a0[s0 - 1][14]), a0[s0 - 1][15] = (t0.length - 1) * 8 & 4294967295;
  for (var d0 = 0; d0 < s0; ++d0) {
    for (var h0 = new Uint32Array(80), g0 = 0; g0 < 16; ++g0)
      h0[g0] = a0[d0][g0];
    for (var w0 = 16; w0 < 80; ++w0)
      h0[w0] = ROTL(h0[w0 - 3] ^ h0[w0 - 8] ^ h0[w0 - 14] ^ h0[w0 - 16], 1);
    for (var y0 = n0[0], E0 = n0[1], b0 = n0[2], O0 = n0[3], S0 = n0[4], k0 = 0; k0 < 80; ++k0) {
      var D0 = Math.floor(k0 / 20), z0 = ROTL(y0, 5) + f$1(D0, E0, b0, O0) + S0 + e0[D0] + h0[k0] >>> 0;
      S0 = O0, O0 = b0, b0 = ROTL(E0, 30) >>> 0, E0 = y0, y0 = z0;
    }
    n0[0] = n0[0] + y0 >>> 0, n0[1] = n0[1] + E0 >>> 0, n0[2] = n0[2] + b0 >>> 0, n0[3] = n0[3] + O0 >>> 0, n0[4] = n0[4] + S0 >>> 0;
  }
  return [n0[0] >> 24 & 255, n0[0] >> 16 & 255, n0[0] >> 8 & 255, n0[0] & 255, n0[1] >> 24 & 255, n0[1] >> 16 & 255, n0[1] >> 8 & 255, n0[1] & 255, n0[2] >> 24 & 255, n0[2] >> 16 & 255, n0[2] >> 8 & 255, n0[2] & 255, n0[3] >> 24 & 255, n0[3] >> 16 & 255, n0[3] >> 8 & 255, n0[3] & 255, n0[4] >> 24 & 255, n0[4] >> 16 & 255, n0[4] >> 8 & 255, n0[4] & 255];
}
var v5 = v35("v5", 80, sha1);
const v5$1 = v5, nil = "00000000-0000-0000-0000-000000000000";
function version(t0) {
  if (!validate$1(t0))
    throw TypeError("Invalid UUID");
  return parseInt(t0.substr(14, 1), 16);
}
const esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NIL: nil,
  parse: parse$1,
  stringify,
  v1,
  v3: v3$1,
  v4,
  v5: v5$1,
  validate: validate$1,
  version
}, Symbol.toStringTag, { value: "Module" })), PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES.open = "0";
PACKET_TYPES.close = "1";
PACKET_TYPES.ping = "2";
PACKET_TYPES.pong = "3";
PACKET_TYPES.message = "4";
PACKET_TYPES.upgrade = "5";
PACKET_TYPES.noop = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((t0) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[t0]] = t0;
});
const ERROR_PACKET = { type: "error", data: "parser error" }, withNativeBlob$1 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", withNativeArrayBuffer$2 = typeof ArrayBuffer == "function", isView$1 = (t0) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(t0) : t0 && t0.buffer instanceof ArrayBuffer, encodePacket = ({ type: t0, data: e0 }, n0, r0) => withNativeBlob$1 && e0 instanceof Blob ? n0 ? r0(e0) : encodeBlobAsBase64(e0, r0) : withNativeArrayBuffer$2 && (e0 instanceof ArrayBuffer || isView$1(e0)) ? n0 ? r0(e0) : encodeBlobAsBase64(new Blob([e0]), r0) : r0(PACKET_TYPES[t0] + (e0 || "")), encodeBlobAsBase64 = (t0, e0) => {
  const n0 = new FileReader();
  return n0.onload = function() {
    const r0 = n0.result.split(",")[1];
    e0("b" + (r0 || ""));
  }, n0.readAsDataURL(t0);
};
function toArray(t0) {
  return t0 instanceof Uint8Array ? t0 : t0 instanceof ArrayBuffer ? new Uint8Array(t0) : new Uint8Array(t0.buffer, t0.byteOffset, t0.byteLength);
}
let TEXT_ENCODER;
function encodePacketToBinary(t0, e0) {
  if (withNativeBlob$1 && t0.data instanceof Blob)
    return t0.data.arrayBuffer().then(toArray).then(e0);
  if (withNativeArrayBuffer$2 && (t0.data instanceof ArrayBuffer || isView$1(t0.data)))
    return e0(toArray(t0.data));
  encodePacket(t0, !1, (n0) => {
    TEXT_ENCODER || (TEXT_ENCODER = new TextEncoder()), e0(TEXT_ENCODER.encode(n0));
  });
}
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup$2 = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let t0 = 0; t0 < chars.length; t0++)
  lookup$2[chars.charCodeAt(t0)] = t0;
const decode$1 = (t0) => {
  let e0 = t0.length * 0.75, n0 = t0.length, r0, i0 = 0, o0, s0, a0, c0;
  t0[t0.length - 1] === "=" && (e0--, t0[t0.length - 2] === "=" && e0--);
  const l0 = new ArrayBuffer(e0), u0 = new Uint8Array(l0);
  for (r0 = 0; r0 < n0; r0 += 4)
    o0 = lookup$2[t0.charCodeAt(r0)], s0 = lookup$2[t0.charCodeAt(r0 + 1)], a0 = lookup$2[t0.charCodeAt(r0 + 2)], c0 = lookup$2[t0.charCodeAt(r0 + 3)], u0[i0++] = o0 << 2 | s0 >> 4, u0[i0++] = (s0 & 15) << 4 | a0 >> 2, u0[i0++] = (a0 & 3) << 6 | c0 & 63;
  return l0;
}, withNativeArrayBuffer$1 = typeof ArrayBuffer == "function", decodePacket = (t0, e0) => {
  if (typeof t0 != "string")
    return {
      type: "message",
      data: mapBinary(t0, e0)
    };
  const n0 = t0.charAt(0);
  return n0 === "b" ? {
    type: "message",
    data: decodeBase64Packet(t0.substring(1), e0)
  } : PACKET_TYPES_REVERSE[n0] ? t0.length > 1 ? {
    type: PACKET_TYPES_REVERSE[n0],
    data: t0.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[n0]
  } : ERROR_PACKET;
}, decodeBase64Packet = (t0, e0) => {
  if (withNativeArrayBuffer$1) {
    const n0 = decode$1(t0);
    return mapBinary(n0, e0);
  } else
    return { base64: !0, data: t0 };
}, mapBinary = (t0, e0) => {
  switch (e0) {
    case "blob":
      return t0 instanceof Blob ? t0 : new Blob([t0]);
    case "arraybuffer":
    default:
      return t0 instanceof ArrayBuffer ? t0 : t0.buffer;
  }
}, SEPARATOR = String.fromCharCode(30), encodePayload = (t0, e0) => {
  const n0 = t0.length, r0 = new Array(n0);
  let i0 = 0;
  t0.forEach((o0, s0) => {
    encodePacket(o0, !1, (a0) => {
      r0[s0] = a0, ++i0 === n0 && e0(r0.join(SEPARATOR));
    });
  });
}, decodePayload = (t0, e0) => {
  const n0 = t0.split(SEPARATOR), r0 = [];
  for (let i0 = 0; i0 < n0.length; i0++) {
    const o0 = decodePacket(n0[i0], e0);
    if (r0.push(o0), o0.type === "error")
      break;
  }
  return r0;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(t0, e0) {
      encodePacketToBinary(t0, (n0) => {
        const r0 = n0.length;
        let i0;
        if (r0 < 126)
          i0 = new Uint8Array(1), new DataView(i0.buffer).setUint8(0, r0);
        else if (r0 < 65536) {
          i0 = new Uint8Array(3);
          const o0 = new DataView(i0.buffer);
          o0.setUint8(0, 126), o0.setUint16(1, r0);
        } else {
          i0 = new Uint8Array(9);
          const o0 = new DataView(i0.buffer);
          o0.setUint8(0, 127), o0.setBigUint64(1, BigInt(r0));
        }
        t0.data && typeof t0.data != "string" && (i0[0] |= 128), e0.enqueue(i0), e0.enqueue(n0);
      });
    }
  });
}
let TEXT_DECODER;
function totalLength(t0) {
  return t0.reduce((e0, n0) => e0 + n0.length, 0);
}
function concatChunks(t0, e0) {
  if (t0[0].length === e0)
    return t0.shift();
  const n0 = new Uint8Array(e0);
  let r0 = 0;
  for (let i0 = 0; i0 < e0; i0++)
    n0[i0] = t0[0][r0++], r0 === t0[0].length && (t0.shift(), r0 = 0);
  return t0.length && r0 < t0[0].length && (t0[0] = t0[0].slice(r0)), n0;
}
function createPacketDecoderStream(t0, e0) {
  TEXT_DECODER || (TEXT_DECODER = new TextDecoder());
  const n0 = [];
  let r0 = 0, i0 = -1, o0 = !1;
  return new TransformStream({
    transform(s0, a0) {
      for (n0.push(s0); ; ) {
        if (r0 === 0) {
          if (totalLength(n0) < 1)
            break;
          const c0 = concatChunks(n0, 1);
          o0 = (c0[0] & 128) === 128, i0 = c0[0] & 127, i0 < 126 ? r0 = 3 : i0 === 126 ? r0 = 1 : r0 = 2;
        } else if (r0 === 1) {
          if (totalLength(n0) < 2)
            break;
          const c0 = concatChunks(n0, 2);
          i0 = new DataView(c0.buffer, c0.byteOffset, c0.length).getUint16(0), r0 = 3;
        } else if (r0 === 2) {
          if (totalLength(n0) < 8)
            break;
          const c0 = concatChunks(n0, 8), l0 = new DataView(c0.buffer, c0.byteOffset, c0.length), u0 = l0.getUint32(0);
          if (u0 > Math.pow(2, 53 - 32) - 1) {
            a0.enqueue(ERROR_PACKET);
            break;
          }
          i0 = u0 * Math.pow(2, 32) + l0.getUint32(4), r0 = 3;
        } else {
          if (totalLength(n0) < i0)
            break;
          const c0 = concatChunks(n0, i0);
          a0.enqueue(decodePacket(o0 ? c0 : TEXT_DECODER.decode(c0), e0)), r0 = 0;
        }
        if (i0 === 0 || i0 > t0) {
          a0.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
const protocol$1 = 4;
function Emitter(t0) {
  if (t0)
    return mixin(t0);
}
function mixin(t0) {
  for (var e0 in Emitter.prototype)
    t0[e0] = Emitter.prototype[e0];
  return t0;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(t0, e0) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + t0] = this._callbacks["$" + t0] || []).push(e0), this;
};
Emitter.prototype.once = function(t0, e0) {
  function n0() {
    this.off(t0, n0), e0.apply(this, arguments);
  }
  return n0.fn = e0, this.on(t0, n0), this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(t0, e0) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var n0 = this._callbacks["$" + t0];
  if (!n0)
    return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + t0], this;
  for (var r0, i0 = 0; i0 < n0.length; i0++)
    if (r0 = n0[i0], r0 === e0 || r0.fn === e0) {
      n0.splice(i0, 1);
      break;
    }
  return n0.length === 0 && delete this._callbacks["$" + t0], this;
};
Emitter.prototype.emit = function(t0) {
  this._callbacks = this._callbacks || {};
  for (var e0 = new Array(arguments.length - 1), n0 = this._callbacks["$" + t0], r0 = 1; r0 < arguments.length; r0++)
    e0[r0 - 1] = arguments[r0];
  if (n0) {
    n0 = n0.slice(0);
    for (var r0 = 0, i0 = n0.length; r0 < i0; ++r0)
      n0[r0].apply(this, e0);
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(t0) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + t0] || [];
};
Emitter.prototype.hasListeners = function(t0) {
  return !!this.listeners(t0).length;
};
const nextTick = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? (e0) => Promise.resolve().then(e0) : (e0, n0) => n0(e0, 0))(), globalThisShim = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())(), defaultBinaryType = "arraybuffer";
function createCookieJar() {
}
function pick(t0, ...e0) {
  return e0.reduce((n0, r0) => (t0.hasOwnProperty(r0) && (n0[r0] = t0[r0]), n0), {});
}
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout, NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(t0, e0) {
  e0.useNativeTimers ? (t0.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim), t0.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim)) : (t0.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim), t0.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim));
}
const BASE64_OVERHEAD = 1.33;
function byteLength$1(t0) {
  return typeof t0 == "string" ? utf8Length(t0) : Math.ceil((t0.byteLength || t0.size) * BASE64_OVERHEAD);
}
function utf8Length(t0) {
  let e0 = 0, n0 = 0;
  for (let r0 = 0, i0 = t0.length; r0 < i0; r0++)
    e0 = t0.charCodeAt(r0), e0 < 128 ? n0 += 1 : e0 < 2048 ? n0 += 2 : e0 < 55296 || e0 >= 57344 ? n0 += 3 : (r0++, n0 += 4);
  return n0;
}
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function encode(t0) {
  let e0 = "";
  for (let n0 in t0)
    t0.hasOwnProperty(n0) && (e0.length && (e0 += "&"), e0 += encodeURIComponent(n0) + "=" + encodeURIComponent(t0[n0]));
  return e0;
}
function decode(t0) {
  let e0 = {}, n0 = t0.split("&");
  for (let r0 = 0, i0 = n0.length; r0 < i0; r0++) {
    let o0 = n0[r0].split("=");
    e0[decodeURIComponent(o0[0])] = decodeURIComponent(o0[1]);
  }
  return e0;
}
class TransportError extends Error {
  constructor(e0, n0, r0) {
    super(e0), this.description = n0, this.context = r0, this.type = "TransportError";
  }
}
class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(e0) {
    super(), this.writable = !1, installTimerFunctions(this, e0), this.opts = e0, this.query = e0.query, this.socket = e0.socket, this.supportsBinary = !e0.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(e0, n0, r0) {
    return super.emitReserved("error", new TransportError(e0, n0, r0)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(e0) {
    this.readyState === "open" && this.write(e0);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(e0) {
    const n0 = decodePacket(e0, this.socket.binaryType);
    this.onPacket(n0);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(e0) {
    super.emitReserved("packet", e0);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(e0) {
    this.readyState = "closed", super.emitReserved("close", e0);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(e0) {
  }
  createUri(e0, n0 = {}) {
    return e0 + "://" + this._hostname() + this._port() + this.opts.path + this._query(n0);
  }
  _hostname() {
    const e0 = this.opts.hostname;
    return e0.indexOf(":") === -1 ? e0 : "[" + e0 + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(e0) {
    const n0 = encode(e0);
    return n0.length ? "?" + n0 : "";
  }
}
class Polling extends Transport {
  constructor() {
    super(...arguments), this._polling = !1;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(e0) {
    this.readyState = "pausing";
    const n0 = () => {
      this.readyState = "paused", e0();
    };
    if (this._polling || !this.writable) {
      let r0 = 0;
      this._polling && (r0++, this.once("pollComplete", function() {
        --r0 || n0();
      })), this.writable || (r0++, this.once("drain", function() {
        --r0 || n0();
      }));
    } else
      n0();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(e0) {
    const n0 = (r0) => {
      if (this.readyState === "opening" && r0.type === "open" && this.onOpen(), r0.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(r0);
    };
    decodePayload(e0, this.socket.binaryType).forEach(n0), this.readyState !== "closed" && (this._polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this._poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const e0 = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? e0() : this.once("open", e0);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(e0) {
    this.writable = !1, encodePayload(e0, (n0) => {
      this.doWrite(n0, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const e0 = this.opts.secure ? "https" : "http", n0 = this.query || {};
    return this.opts.timestampRequests !== !1 && (n0[this.opts.timestampParam] = randomString()), !this.supportsBinary && !n0.sid && (n0.b64 = 1), this.createUri(e0, n0);
  }
}
let value = !1;
try {
  value = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch (t0) {
}
const hasCORS = value;
function empty() {
}
class BaseXHR extends Polling {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(e0) {
    if (super(e0), typeof location < "u") {
      const n0 = location.protocol === "https:";
      let r0 = location.port;
      r0 || (r0 = n0 ? "443" : "80"), this.xd = typeof location < "u" && e0.hostname !== location.hostname || r0 !== e0.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(e0, n0) {
    const r0 = this.request({
      method: "POST",
      data: e0
    });
    r0.on("success", n0), r0.on("error", (i0, o0) => {
      this.onError("xhr post error", i0, o0);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const e0 = this.request();
    e0.on("data", this.onData.bind(this)), e0.on("error", (n0, r0) => {
      this.onError("xhr poll error", n0, r0);
    }), this.pollXhr = e0;
  }
}
class Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(e0, n0, r0) {
    super(), this.createRequest = e0, installTimerFunctions(this, r0), this._opts = r0, this._method = r0.method || "GET", this._uri = n0, this._data = r0.data !== void 0 ? r0.data : null, this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var e0;
    const n0 = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    n0.xdomain = !!this._opts.xd;
    const r0 = this._xhr = this.createRequest(n0);
    try {
      r0.open(this._method, this._uri, !0);
      try {
        if (this._opts.extraHeaders) {
          r0.setDisableHeaderCheck && r0.setDisableHeaderCheck(!0);
          for (let i0 in this._opts.extraHeaders)
            this._opts.extraHeaders.hasOwnProperty(i0) && r0.setRequestHeader(i0, this._opts.extraHeaders[i0]);
        }
      } catch {
      }
      if (this._method === "POST")
        try {
          r0.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        r0.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (e0 = this._opts.cookieJar) === null || e0 === void 0 || e0.addCookies(r0), "withCredentials" in r0 && (r0.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (r0.timeout = this._opts.requestTimeout), r0.onreadystatechange = () => {
        var i0;
        r0.readyState === 3 && ((i0 = this._opts.cookieJar) === null || i0 === void 0 || i0.parseCookies(
          // @ts-ignore
          r0.getResponseHeader("set-cookie")
        )), r0.readyState === 4 && (r0.status === 200 || r0.status === 1223 ? this._onLoad() : this.setTimeoutFn(() => {
          this._onError(typeof r0.status == "number" ? r0.status : 0);
        }, 0));
      }, r0.send(this._data);
    } catch (i0) {
      this.setTimeoutFn(() => {
        this._onError(i0);
      }, 0);
      return;
    }
    typeof document < "u" && (this._index = Request.requestsCount++, Request.requests[this._index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(e0) {
    this.emitReserved("error", e0, this._xhr), this._cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(e0) {
    if (!(typeof this._xhr > "u" || this._xhr === null)) {
      if (this._xhr.onreadystatechange = empty, e0)
        try {
          this._xhr.abort();
        } catch {
        }
      typeof document < "u" && delete Request.requests[this._index], this._xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const e0 = this._xhr.responseText;
    e0 !== null && (this.emitReserved("data", e0), this.emitReserved("success"), this._cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", unloadHandler);
  else if (typeof addEventListener == "function") {
    const t0 = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(t0, unloadHandler, !1);
  }
}
function unloadHandler() {
  for (let t0 in Request.requests)
    Request.requests.hasOwnProperty(t0) && Request.requests[t0].abort();
}
const hasXHR2 = function() {
  const t0 = newRequest({
    xdomain: !1
  });
  return t0 && t0.responseType !== null;
}();
class XHR extends BaseXHR {
  constructor(e0) {
    super(e0);
    const n0 = e0 && e0.forceBase64;
    this.supportsBinary = hasXHR2 && !n0;
  }
  request(e0 = {}) {
    return Object.assign(e0, { xd: this.xd }, this.opts), new Request(newRequest, this.uri(), e0);
  }
}
function newRequest(t0) {
  const e0 = t0.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!e0 || hasCORS))
      return new XMLHttpRequest();
  } catch {
  }
  if (!e0)
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
const isReactNative = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class BaseWS extends Transport {
  get name() {
    return "websocket";
  }
  doOpen() {
    const e0 = this.uri(), n0 = this.opts.protocols, r0 = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (r0.headers = this.opts.extraHeaders);
    try {
      this.ws = this.createSocket(e0, n0, r0);
    } catch (i0) {
      return this.emitReserved("error", i0);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (e0) => this.onClose({
      description: "websocket connection closed",
      context: e0
    }), this.ws.onmessage = (e0) => this.onData(e0.data), this.ws.onerror = (e0) => this.onError("websocket error", e0);
  }
  write(e0) {
    this.writable = !1;
    for (let n0 = 0; n0 < e0.length; n0++) {
      const r0 = e0[n0], i0 = n0 === e0.length - 1;
      encodePacket(r0, this.supportsBinary, (o0) => {
        try {
          this.doWrite(r0, o0);
        } catch {
        }
        i0 && nextTick(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.onerror = () => {
    }, this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const e0 = this.opts.secure ? "wss" : "ws", n0 = this.query || {};
    return this.opts.timestampRequests && (n0[this.opts.timestampParam] = randomString()), this.supportsBinary || (n0.b64 = 1), this.createUri(e0, n0);
  }
}
const WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
class WS extends BaseWS {
  createSocket(e0, n0, r0) {
    return isReactNative ? new WebSocketCtor(e0, n0, r0) : n0 ? new WebSocketCtor(e0, n0) : new WebSocketCtor(e0);
  }
  doWrite(e0, n0) {
    this.ws.send(n0);
  }
}
class WT extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (e0) {
      return this.emitReserved("error", e0);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((e0) => {
      this.onError("webtransport error", e0);
    }), this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((e0) => {
        const n0 = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType), r0 = e0.readable.pipeThrough(n0).getReader(), i0 = createPacketEncoderStream();
        i0.readable.pipeTo(e0.writable), this._writer = i0.writable.getWriter();
        const o0 = () => {
          r0.read().then(({ done: a0, value: c0 }) => {
            a0 || (this.onPacket(c0), o0());
          }).catch((a0) => {
          });
        };
        o0();
        const s0 = { type: "open" };
        this.query.sid && (s0.data = `{"sid":"${this.query.sid}"}`), this._writer.write(s0).then(() => this.onOpen());
      });
    });
  }
  write(e0) {
    this.writable = !1;
    for (let n0 = 0; n0 < e0.length; n0++) {
      const r0 = e0[n0], i0 = n0 === e0.length - 1;
      this._writer.write(r0).then(() => {
        i0 && nextTick(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var e0;
    (e0 = this._transport) === null || e0 === void 0 || e0.close();
  }
}
const transports = {
  websocket: WS,
  webtransport: WT,
  polling: XHR
}, re$2 = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse(t0) {
  if (t0.length > 8e3)
    throw "URI too long";
  const e0 = t0, n0 = t0.indexOf("["), r0 = t0.indexOf("]");
  n0 != -1 && r0 != -1 && (t0 = t0.substring(0, n0) + t0.substring(n0, r0).replace(/:/g, ";") + t0.substring(r0, t0.length));
  let i0 = re$2.exec(t0 || ""), o0 = {}, s0 = 14;
  for (; s0--; )
    o0[parts[s0]] = i0[s0] || "";
  return n0 != -1 && r0 != -1 && (o0.source = e0, o0.host = o0.host.substring(1, o0.host.length - 1).replace(/;/g, ":"), o0.authority = o0.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), o0.ipv6uri = !0), o0.pathNames = pathNames(o0, o0.path), o0.queryKey = queryKey(o0, o0.query), o0;
}
function pathNames(t0, e0) {
  const n0 = /\/{2,9}/g, r0 = e0.replace(n0, "/").split("/");
  return (e0.slice(0, 1) == "/" || e0.length === 0) && r0.splice(0, 1), e0.slice(-1) == "/" && r0.splice(r0.length - 1, 1), r0;
}
function queryKey(t0, e0) {
  const n0 = {};
  return e0.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r0, i0, o0) {
    i0 && (n0[i0] = o0);
  }), n0;
}
const withEventListeners = typeof addEventListener == "function" && typeof removeEventListener == "function", OFFLINE_EVENT_LISTENERS = [];
withEventListeners && addEventListener("offline", () => {
  OFFLINE_EVENT_LISTENERS.forEach((t0) => t0());
}, !1);
class SocketWithoutUpgrade extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(e0, n0) {
    if (super(), this.binaryType = defaultBinaryType, this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, e0 && typeof e0 == "object" && (n0 = e0, e0 = null), e0) {
      const r0 = parse(e0);
      n0.hostname = r0.host, n0.secure = r0.protocol === "https" || r0.protocol === "wss", n0.port = r0.port, r0.query && (n0.query = r0.query);
    } else
      n0.host && (n0.hostname = parse(n0.host).host);
    installTimerFunctions(this, n0), this.secure = n0.secure != null ? n0.secure : typeof location < "u" && location.protocol === "https:", n0.hostname && !n0.port && (n0.port = this.secure ? "443" : "80"), this.hostname = n0.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = n0.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, n0.transports.forEach((r0) => {
      const i0 = r0.prototype.name;
      this.transports.push(i0), this._transportsByName[i0] = r0;
    }), this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, n0), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = decode(this.opts.query)), withEventListeners && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this._beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this._offlineEventListener = () => {
      this._onClose("transport close", {
        description: "network connection lost"
      });
    }, OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(e0) {
    const n0 = Object.assign({}, this.opts.query);
    n0.EIO = protocol$1, n0.transport = e0, this.id && (n0.sid = this.id);
    const r0 = Object.assign({}, this.opts, {
      query: n0,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[e0]);
    return new this._transportsByName[e0](r0);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const e0 = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const n0 = this.createTransport(e0);
    n0.open(), this.setTransport(n0);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(e0) {
    this.transport && this.transport.removeAllListeners(), this.transport = e0, e0.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (n0) => this._onClose("transport close", n0));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open", SocketWithoutUpgrade.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(e0) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", e0), this.emitReserved("heartbeat"), e0.type) {
        case "open":
          this.onHandshake(JSON.parse(e0.data));
          break;
        case "ping":
          this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout();
          break;
        case "error":
          const n0 = new Error("server error");
          n0.code = e0.data, this._onError(n0);
          break;
        case "message":
          this.emitReserved("data", e0.data), this.emitReserved("message", e0.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(e0) {
    this.emitReserved("handshake", e0), this.id = e0.sid, this.transport.query.sid = e0.sid, this._pingInterval = e0.pingInterval, this._pingTimeout = e0.pingTimeout, this._maxPayload = e0.maxPayload, this.onOpen(), this.readyState !== "closed" && this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const e0 = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + e0, this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, e0), this.opts.autoUnref && this._pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const e0 = this._getWritablePackets();
      this.transport.send(e0), this._prevBufferLen = e0.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let n0 = 1;
    for (let r0 = 0; r0 < this.writeBuffer.length; r0++) {
      const i0 = this.writeBuffer[r0].data;
      if (i0 && (n0 += byteLength$1(i0)), r0 > 0 && n0 > this._maxPayload)
        return this.writeBuffer.slice(0, r0);
      n0 += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return !0;
    const e0 = Date.now() > this._pingTimeoutTime;
    return e0 && (this._pingTimeoutTime = 0, nextTick(() => {
      this._onClose("ping timeout");
    }, this.setTimeoutFn)), e0;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(e0, n0, r0) {
    return this._sendPacket("message", e0, n0, r0), this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(e0, n0, r0) {
    return this._sendPacket("message", e0, n0, r0), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(e0, n0, r0, i0) {
    if (typeof n0 == "function" && (i0 = n0, n0 = void 0), typeof r0 == "function" && (i0 = r0, r0 = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    r0 = r0 || {}, r0.compress = r0.compress !== !1;
    const o0 = {
      type: e0,
      data: n0,
      options: r0
    };
    this.emitReserved("packetCreate", o0), this.writeBuffer.push(o0), i0 && this.once("flush", i0), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const e0 = () => {
      this._onClose("forced close"), this.transport.close();
    }, n0 = () => {
      this.off("upgrade", n0), this.off("upgradeError", n0), e0();
    }, r0 = () => {
      this.once("upgrade", n0), this.once("upgradeError", n0);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? r0() : e0();
    }) : this.upgrading ? r0() : e0()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(e0) {
    if (SocketWithoutUpgrade.priorWebsocketSuccess = !1, this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening")
      return this.transports.shift(), this._open();
    this.emitReserved("error", e0), this._onClose("transport error", e0);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(e0, n0) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), withEventListeners && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1), this._offlineEventListener)) {
        const r0 = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
        r0 !== -1 && OFFLINE_EVENT_LISTENERS.splice(r0, 1);
      }
      this.readyState = "closed", this.id = null, this.emitReserved("close", e0, n0), this.writeBuffer = [], this._prevBufferLen = 0;
    }
  }
}
SocketWithoutUpgrade.protocol = protocol$1;
class SocketWithUpgrade extends SocketWithoutUpgrade {
  constructor() {
    super(...arguments), this._upgrades = [];
  }
  onOpen() {
    if (super.onOpen(), this.readyState === "open" && this.opts.upgrade)
      for (let e0 = 0; e0 < this._upgrades.length; e0++)
        this._probe(this._upgrades[e0]);
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(e0) {
    let n0 = this.createTransport(e0), r0 = !1;
    SocketWithoutUpgrade.priorWebsocketSuccess = !1;
    const i0 = () => {
      r0 || (n0.send([{ type: "ping", data: "probe" }]), n0.once("packet", (d0) => {
        if (!r0)
          if (d0.type === "pong" && d0.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", n0), !n0)
              return;
            SocketWithoutUpgrade.priorWebsocketSuccess = n0.name === "websocket", this.transport.pause(() => {
              r0 || this.readyState !== "closed" && (u0(), this.setTransport(n0), n0.send([{ type: "upgrade" }]), this.emitReserved("upgrade", n0), n0 = null, this.upgrading = !1, this.flush());
            });
          } else {
            const h0 = new Error("probe error");
            h0.transport = n0.name, this.emitReserved("upgradeError", h0);
          }
      }));
    };
    function o0() {
      r0 || (r0 = !0, u0(), n0.close(), n0 = null);
    }
    const s0 = (d0) => {
      const h0 = new Error("probe error: " + d0);
      h0.transport = n0.name, o0(), this.emitReserved("upgradeError", h0);
    };
    function a0() {
      s0("transport closed");
    }
    function c0() {
      s0("socket closed");
    }
    function l0(d0) {
      n0 && d0.name !== n0.name && o0();
    }
    const u0 = () => {
      n0.removeListener("open", i0), n0.removeListener("error", s0), n0.removeListener("close", a0), this.off("close", c0), this.off("upgrading", l0);
    };
    n0.once("open", i0), n0.once("error", s0), n0.once("close", a0), this.once("close", c0), this.once("upgrading", l0), this._upgrades.indexOf("webtransport") !== -1 && e0 !== "webtransport" ? this.setTimeoutFn(() => {
      r0 || n0.open();
    }, 200) : n0.open();
  }
  onHandshake(e0) {
    this._upgrades = this._filterUpgrades(e0.upgrades), super.onHandshake(e0);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(e0) {
    const n0 = [];
    for (let r0 = 0; r0 < e0.length; r0++)
      ~this.transports.indexOf(e0[r0]) && n0.push(e0[r0]);
    return n0;
  }
}
let Socket$1 = class extends SocketWithUpgrade {
  constructor(e0, n0 = {}) {
    const r0 = typeof e0 == "object" ? e0 : n0;
    (!r0.transports || r0.transports && typeof r0.transports[0] == "string") && (r0.transports = (r0.transports || ["polling", "websocket", "webtransport"]).map((i0) => transports[i0]).filter((i0) => !!i0)), super(e0, r0);
  }
};
function url(t0, e0 = "", n0) {
  let r0 = t0;
  n0 = n0 || typeof location < "u" && location, t0 == null && (t0 = n0.protocol + "//" + n0.host), typeof t0 == "string" && (t0.charAt(0) === "/" && (t0.charAt(1) === "/" ? t0 = n0.protocol + t0 : t0 = n0.host + t0), /^(https?|wss?):\/\//.test(t0) || (typeof n0 < "u" ? t0 = n0.protocol + "//" + t0 : t0 = "https://" + t0), r0 = parse(t0)), r0.port || (/^(http|ws)$/.test(r0.protocol) ? r0.port = "80" : /^(http|ws)s$/.test(r0.protocol) && (r0.port = "443")), r0.path = r0.path || "/";
  const o0 = r0.host.indexOf(":") !== -1 ? "[" + r0.host + "]" : r0.host;
  return r0.id = r0.protocol + "://" + o0 + ":" + r0.port + e0, r0.href = r0.protocol + "://" + o0 + (n0 && n0.port === r0.port ? "" : ":" + r0.port), r0;
}
const withNativeArrayBuffer = typeof ArrayBuffer == "function", isView = (t0) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(t0) : t0.buffer instanceof ArrayBuffer, toString = Object.prototype.toString, withNativeBlob = typeof Blob == "function" || typeof Blob < "u" && toString.call(Blob) === "[object BlobConstructor]", withNativeFile = typeof File == "function" || typeof File < "u" && toString.call(File) === "[object FileConstructor]";
function isBinary(t0) {
  return withNativeArrayBuffer && (t0 instanceof ArrayBuffer || isView(t0)) || withNativeBlob && t0 instanceof Blob || withNativeFile && t0 instanceof File;
}
function hasBinary(t0, e0) {
  if (!t0 || typeof t0 != "object")
    return !1;
  if (Array.isArray(t0)) {
    for (let n0 = 0, r0 = t0.length; n0 < r0; n0++)
      if (hasBinary(t0[n0]))
        return !0;
    return !1;
  }
  if (isBinary(t0))
    return !0;
  if (t0.toJSON && typeof t0.toJSON == "function" && arguments.length === 1)
    return hasBinary(t0.toJSON(), !0);
  for (const n0 in t0)
    if (Object.prototype.hasOwnProperty.call(t0, n0) && hasBinary(t0[n0]))
      return !0;
  return !1;
}
function deconstructPacket(t0) {
  const e0 = [], n0 = t0.data, r0 = t0;
  return r0.data = _deconstructPacket(n0, e0), r0.attachments = e0.length, { packet: r0, buffers: e0 };
}
function _deconstructPacket(t0, e0) {
  if (!t0)
    return t0;
  if (isBinary(t0)) {
    const n0 = { _placeholder: !0, num: e0.length };
    return e0.push(t0), n0;
  } else if (Array.isArray(t0)) {
    const n0 = new Array(t0.length);
    for (let r0 = 0; r0 < t0.length; r0++)
      n0[r0] = _deconstructPacket(t0[r0], e0);
    return n0;
  } else if (typeof t0 == "object" && !(t0 instanceof Date)) {
    const n0 = {};
    for (const r0 in t0)
      Object.prototype.hasOwnProperty.call(t0, r0) && (n0[r0] = _deconstructPacket(t0[r0], e0));
    return n0;
  }
  return t0;
}
function reconstructPacket(t0, e0) {
  return t0.data = _reconstructPacket(t0.data, e0), delete t0.attachments, t0;
}
function _reconstructPacket(t0, e0) {
  if (!t0)
    return t0;
  if (t0 && t0._placeholder === !0) {
    if (typeof t0.num == "number" && t0.num >= 0 && t0.num < e0.length)
      return e0[t0.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(t0))
    for (let n0 = 0; n0 < t0.length; n0++)
      t0[n0] = _reconstructPacket(t0[n0], e0);
  else if (typeof t0 == "object")
    for (const n0 in t0)
      Object.prototype.hasOwnProperty.call(t0, n0) && (t0[n0] = _reconstructPacket(t0[n0], e0));
  return t0;
}
const RESERVED_EVENTS$1 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
], protocol = 5;
var PacketType;
(function(t0) {
  t0[t0.CONNECT = 0] = "CONNECT", t0[t0.DISCONNECT = 1] = "DISCONNECT", t0[t0.EVENT = 2] = "EVENT", t0[t0.ACK = 3] = "ACK", t0[t0.CONNECT_ERROR = 4] = "CONNECT_ERROR", t0[t0.BINARY_EVENT = 5] = "BINARY_EVENT", t0[t0.BINARY_ACK = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(e0) {
    this.replacer = e0;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(e0) {
    return (e0.type === PacketType.EVENT || e0.type === PacketType.ACK) && hasBinary(e0) ? this.encodeAsBinary({
      type: e0.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
      nsp: e0.nsp,
      data: e0.data,
      id: e0.id
    }) : [this.encodeAsString(e0)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(e0) {
    let n0 = "" + e0.type;
    return (e0.type === PacketType.BINARY_EVENT || e0.type === PacketType.BINARY_ACK) && (n0 += e0.attachments + "-"), e0.nsp && e0.nsp !== "/" && (n0 += e0.nsp + ","), e0.id != null && (n0 += e0.id), e0.data != null && (n0 += JSON.stringify(e0.data, this.replacer)), n0;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(e0) {
    const n0 = deconstructPacket(e0), r0 = this.encodeAsString(n0.packet), i0 = n0.buffers;
    return i0.unshift(r0), i0;
  }
}
function isObject$1(t0) {
  return Object.prototype.toString.call(t0) === "[object Object]";
}
class Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(e0) {
    super(), this.reviver = e0;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(e0) {
    let n0;
    if (typeof e0 == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      n0 = this.decodeString(e0);
      const r0 = n0.type === PacketType.BINARY_EVENT;
      r0 || n0.type === PacketType.BINARY_ACK ? (n0.type = r0 ? PacketType.EVENT : PacketType.ACK, this.reconstructor = new BinaryReconstructor(n0), n0.attachments === 0 && super.emitReserved("decoded", n0)) : super.emitReserved("decoded", n0);
    } else if (isBinary(e0) || e0.base64)
      if (this.reconstructor)
        n0 = this.reconstructor.takeBinaryData(e0), n0 && (this.reconstructor = null, super.emitReserved("decoded", n0));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + e0);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(e0) {
    let n0 = 0;
    const r0 = {
      type: Number(e0.charAt(0))
    };
    if (PacketType[r0.type] === void 0)
      throw new Error("unknown packet type " + r0.type);
    if (r0.type === PacketType.BINARY_EVENT || r0.type === PacketType.BINARY_ACK) {
      const o0 = n0 + 1;
      for (; e0.charAt(++n0) !== "-" && n0 != e0.length; )
        ;
      const s0 = e0.substring(o0, n0);
      if (s0 != Number(s0) || e0.charAt(n0) !== "-")
        throw new Error("Illegal attachments");
      r0.attachments = Number(s0);
    }
    if (e0.charAt(n0 + 1) === "/") {
      const o0 = n0 + 1;
      for (; ++n0 && !(e0.charAt(n0) === "," || n0 === e0.length); )
        ;
      r0.nsp = e0.substring(o0, n0);
    } else
      r0.nsp = "/";
    const i0 = e0.charAt(n0 + 1);
    if (i0 !== "" && Number(i0) == i0) {
      const o0 = n0 + 1;
      for (; ++n0; ) {
        const s0 = e0.charAt(n0);
        if (s0 == null || Number(s0) != s0) {
          --n0;
          break;
        }
        if (n0 === e0.length)
          break;
      }
      r0.id = Number(e0.substring(o0, n0 + 1));
    }
    if (e0.charAt(++n0)) {
      const o0 = this.tryParse(e0.substr(n0));
      if (Decoder.isPayloadValid(r0.type, o0))
        r0.data = o0;
      else
        throw new Error("invalid payload");
    }
    return r0;
  }
  tryParse(e0) {
    try {
      return JSON.parse(e0, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(e0, n0) {
    switch (e0) {
      case PacketType.CONNECT:
        return isObject$1(n0);
      case PacketType.DISCONNECT:
        return n0 === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof n0 == "string" || isObject$1(n0);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(n0) && (typeof n0[0] == "number" || typeof n0[0] == "string" && RESERVED_EVENTS$1.indexOf(n0[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(n0);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class BinaryReconstructor {
  constructor(e0) {
    this.packet = e0, this.buffers = [], this.reconPack = e0;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(e0) {
    if (this.buffers.push(e0), this.buffers.length === this.reconPack.attachments) {
      const n0 = reconstructPacket(this.reconPack, this.buffers);
      return this.finishedReconstruction(), n0;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder,
  Encoder,
  get PacketType() {
    return PacketType;
  },
  protocol
}, Symbol.toStringTag, { value: "Module" }));
function on$1(t0, e0, n0) {
  return t0.on(e0, n0), function() {
    t0.off(e0, n0);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(e0, n0, r0) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = e0, this.nsp = n0, r0 && r0.auth && (this.auth = r0.auth), this._opts = Object.assign({}, r0), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const e0 = this.io;
    this.subs = [
      on$1(e0, "open", this.onopen.bind(this)),
      on$1(e0, "packet", this.onpacket.bind(this)),
      on$1(e0, "error", this.onerror.bind(this)),
      on$1(e0, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...e0) {
    return e0.unshift("message"), this.emit.apply(this, e0), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(e0, ...n0) {
    var r0, i0, o0;
    if (RESERVED_EVENTS.hasOwnProperty(e0))
      throw new Error('"' + e0.toString() + '" is a reserved event name');
    if (n0.unshift(e0), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(n0), this;
    const s0 = {
      type: PacketType.EVENT,
      data: n0
    };
    if (s0.options = {}, s0.options.compress = this.flags.compress !== !1, typeof n0[n0.length - 1] == "function") {
      const u0 = this.ids++, d0 = n0.pop();
      this._registerAckCallback(u0, d0), s0.id = u0;
    }
    const a0 = (i0 = (r0 = this.io.engine) === null || r0 === void 0 ? void 0 : r0.transport) === null || i0 === void 0 ? void 0 : i0.writable, c0 = this.connected && !(!((o0 = this.io.engine) === null || o0 === void 0) && o0._hasPingExpired());
    return this.flags.volatile && !a0 || (c0 ? (this.notifyOutgoingListeners(s0), this.packet(s0)) : this.sendBuffer.push(s0)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(e0, n0) {
    var r0;
    const i0 = (r0 = this.flags.timeout) !== null && r0 !== void 0 ? r0 : this._opts.ackTimeout;
    if (i0 === void 0) {
      this.acks[e0] = n0;
      return;
    }
    const o0 = this.io.setTimeoutFn(() => {
      delete this.acks[e0];
      for (let a0 = 0; a0 < this.sendBuffer.length; a0++)
        this.sendBuffer[a0].id === e0 && this.sendBuffer.splice(a0, 1);
      n0.call(this, new Error("operation has timed out"));
    }, i0), s0 = (...a0) => {
      this.io.clearTimeoutFn(o0), n0.apply(this, a0);
    };
    s0.withError = !0, this.acks[e0] = s0;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(e0, ...n0) {
    return new Promise((r0, i0) => {
      const o0 = (s0, a0) => s0 ? i0(s0) : r0(a0);
      o0.withError = !0, n0.push(o0), this.emit(e0, ...n0);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(e0) {
    let n0;
    typeof e0[e0.length - 1] == "function" && (n0 = e0.pop());
    const r0 = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: e0,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    e0.push((i0, ...o0) => r0 !== this._queue[0] ? void 0 : (i0 !== null ? r0.tryCount > this._opts.retries && (this._queue.shift(), n0 && n0(i0)) : (this._queue.shift(), n0 && n0(null, ...o0)), r0.pending = !1, this._drainQueue())), this._queue.push(r0), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(e0 = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const n0 = this._queue[0];
    n0.pending && !e0 || (n0.pending = !0, n0.tryCount++, this.flags = n0.flags, this.emit.apply(this, n0.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(e0) {
    e0.nsp = this.nsp, this.io._packet(e0);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((e0) => {
      this._sendConnectPacket(e0);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(e0) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e0) : e0
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(e0) {
    this.connected || this.emitReserved("connect_error", e0);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(e0, n0) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", e0, n0), this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((e0) => {
      if (!this.sendBuffer.some((r0) => String(r0.id) === e0)) {
        const r0 = this.acks[e0];
        delete this.acks[e0], r0.withError && r0.call(this, new Error("socket has been disconnected"));
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(e0) {
    if (e0.nsp === this.nsp)
      switch (e0.type) {
        case PacketType.CONNECT:
          e0.data && e0.data.sid ? this.onconnect(e0.data.sid, e0.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          this.onevent(e0);
          break;
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          this.onack(e0);
          break;
        case PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case PacketType.CONNECT_ERROR:
          this.destroy();
          const r0 = new Error(e0.data.message);
          r0.data = e0.data.data, this.emitReserved("connect_error", r0);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(e0) {
    const n0 = e0.data || [];
    e0.id != null && n0.push(this.ack(e0.id)), this.connected ? this.emitEvent(n0) : this.receiveBuffer.push(Object.freeze(n0));
  }
  emitEvent(e0) {
    if (this._anyListeners && this._anyListeners.length) {
      const n0 = this._anyListeners.slice();
      for (const r0 of n0)
        r0.apply(this, e0);
    }
    super.emit.apply(this, e0), this._pid && e0.length && typeof e0[e0.length - 1] == "string" && (this._lastOffset = e0[e0.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(e0) {
    const n0 = this;
    let r0 = !1;
    return function(...i0) {
      r0 || (r0 = !0, n0.packet({
        type: PacketType.ACK,
        id: e0,
        data: i0
      }));
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(e0) {
    const n0 = this.acks[e0.id];
    typeof n0 == "function" && (delete this.acks[e0.id], n0.withError && e0.data.unshift(null), n0.apply(this, e0.data));
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(e0, n0) {
    this.id = e0, this.recovered = n0 && this._pid === n0, this._pid = n0, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((e0) => this.emitEvent(e0)), this.receiveBuffer = [], this.sendBuffer.forEach((e0) => {
      this.notifyOutgoingListeners(e0), this.packet(e0);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((e0) => e0()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: PacketType.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(e0) {
    return this.flags.compress = e0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(e0) {
    return this.flags.timeout = e0, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(e0) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e0), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(e0) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e0), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(e0) {
    if (!this._anyListeners)
      return this;
    if (e0) {
      const n0 = this._anyListeners;
      for (let r0 = 0; r0 < n0.length; r0++)
        if (e0 === n0[r0])
          return n0.splice(r0, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(e0) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e0), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(e0) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e0), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(e0) {
    if (!this._anyOutgoingListeners)
      return this;
    if (e0) {
      const n0 = this._anyOutgoingListeners;
      for (let r0 = 0; r0 < n0.length; r0++)
        if (e0 === n0[r0])
          return n0.splice(r0, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(e0) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const n0 = this._anyOutgoingListeners.slice();
      for (const r0 of n0)
        r0.apply(this, e0.data);
    }
  }
}
function Backoff(t0) {
  t0 = t0 || {}, this.ms = t0.min || 100, this.max = t0.max || 1e4, this.factor = t0.factor || 2, this.jitter = t0.jitter > 0 && t0.jitter <= 1 ? t0.jitter : 0, this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var t0 = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var e0 = Math.random(), n0 = Math.floor(e0 * this.jitter * t0);
    t0 = Math.floor(e0 * 10) & 1 ? t0 + n0 : t0 - n0;
  }
  return Math.min(t0, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(t0) {
  this.ms = t0;
};
Backoff.prototype.setMax = function(t0) {
  this.max = t0;
};
Backoff.prototype.setJitter = function(t0) {
  this.jitter = t0;
};
class Manager extends Emitter {
  constructor(e0, n0) {
    var r0;
    super(), this.nsps = {}, this.subs = [], e0 && typeof e0 == "object" && (n0 = e0, e0 = void 0), n0 = n0 || {}, n0.path = n0.path || "/socket.io", this.opts = n0, installTimerFunctions(this, n0), this.reconnection(n0.reconnection !== !1), this.reconnectionAttempts(n0.reconnectionAttempts || 1 / 0), this.reconnectionDelay(n0.reconnectionDelay || 1e3), this.reconnectionDelayMax(n0.reconnectionDelayMax || 5e3), this.randomizationFactor((r0 = n0.randomizationFactor) !== null && r0 !== void 0 ? r0 : 0.5), this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(n0.timeout == null ? 2e4 : n0.timeout), this._readyState = "closed", this.uri = e0;
    const i0 = n0.parser || parser;
    this.encoder = new i0.Encoder(), this.decoder = new i0.Decoder(), this._autoConnect = n0.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(e0) {
    return arguments.length ? (this._reconnection = !!e0, e0 || (this.skipReconnect = !0), this) : this._reconnection;
  }
  reconnectionAttempts(e0) {
    return e0 === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e0, this);
  }
  reconnectionDelay(e0) {
    var n0;
    return e0 === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e0, (n0 = this.backoff) === null || n0 === void 0 || n0.setMin(e0), this);
  }
  randomizationFactor(e0) {
    var n0;
    return e0 === void 0 ? this._randomizationFactor : (this._randomizationFactor = e0, (n0 = this.backoff) === null || n0 === void 0 || n0.setJitter(e0), this);
  }
  reconnectionDelayMax(e0) {
    var n0;
    return e0 === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e0, (n0 = this.backoff) === null || n0 === void 0 || n0.setMax(e0), this);
  }
  timeout(e0) {
    return arguments.length ? (this._timeout = e0, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(e0) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const n0 = this.engine, r0 = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const i0 = on$1(n0, "open", function() {
      r0.onopen(), e0 && e0();
    }), o0 = (a0) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", a0), e0 ? e0(a0) : this.maybeReconnectOnOpen();
    }, s0 = on$1(n0, "error", o0);
    if (this._timeout !== !1) {
      const a0 = this._timeout, c0 = this.setTimeoutFn(() => {
        i0(), o0(new Error("timeout")), n0.close();
      }, a0);
      this.opts.autoUnref && c0.unref(), this.subs.push(() => {
        this.clearTimeoutFn(c0);
      });
    }
    return this.subs.push(i0), this.subs.push(s0), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(e0) {
    return this.open(e0);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const e0 = this.engine;
    this.subs.push(
      on$1(e0, "ping", this.onping.bind(this)),
      on$1(e0, "data", this.ondata.bind(this)),
      on$1(e0, "error", this.onerror.bind(this)),
      on$1(e0, "close", this.onclose.bind(this)),
      // @ts-ignore
      on$1(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(e0) {
    try {
      this.decoder.add(e0);
    } catch (n0) {
      this.onclose("parse error", n0);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(e0) {
    nextTick(() => {
      this.emitReserved("packet", e0);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(e0) {
    this.emitReserved("error", e0);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(e0, n0) {
    let r0 = this.nsps[e0];
    return r0 ? this._autoConnect && !r0.active && r0.connect() : (r0 = new Socket(this, e0, n0), this.nsps[e0] = r0), r0;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(e0) {
    const n0 = Object.keys(this.nsps);
    for (const r0 of n0)
      if (this.nsps[r0].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(e0) {
    const n0 = this.encoder.encode(e0);
    for (let r0 = 0; r0 < n0.length; r0++)
      this.engine.write(n0[r0], e0.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((e0) => e0()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(e0, n0) {
    var r0;
    this.cleanup(), (r0 = this.engine) === null || r0 === void 0 || r0.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e0, n0), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const e0 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const n0 = this.backoff.duration();
      this._reconnecting = !0;
      const r0 = this.setTimeoutFn(() => {
        e0.skipReconnect || (this.emitReserved("reconnect_attempt", e0.backoff.attempts), !e0.skipReconnect && e0.open((i0) => {
          i0 ? (e0._reconnecting = !1, e0.reconnect(), this.emitReserved("reconnect_error", i0)) : e0.onreconnect();
        }));
      }, n0);
      this.opts.autoUnref && r0.unref(), this.subs.push(() => {
        this.clearTimeoutFn(r0);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const e0 = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", e0);
  }
}
const cache = {};
function lookup$1(t0, e0) {
  typeof t0 == "object" && (e0 = t0, t0 = void 0), e0 = e0 || {};
  const n0 = url(t0, e0.path || "/socket.io"), r0 = n0.source, i0 = n0.id, o0 = n0.path, s0 = cache[i0] && o0 in cache[i0].nsps, a0 = e0.forceNew || e0["force new connection"] || e0.multiplex === !1 || s0;
  let c0;
  return a0 ? c0 = new Manager(r0, e0) : (cache[i0] || (cache[i0] = new Manager(r0, e0)), c0 = cache[i0]), n0.query && !e0.query && (e0.query = n0.queryKey), c0.socket(n0.path, e0);
}
Object.assign(lookup$1, {
  Manager,
  Socket,
  io: lookup$1,
  connect: lookup$1
});
function a(t0, e0, n0, r0) {
  return new (n0 || (n0 = Promise))(function(i0, o0) {
    function s0(l0) {
      try {
        c0(r0.next(l0));
      } catch (u0) {
        o0(u0);
      }
    }
    function a0(l0) {
      try {
        c0(r0.throw(l0));
      } catch (u0) {
        o0(u0);
      }
    }
    function c0(l0) {
      var u0;
      l0.done ? i0(l0.value) : (u0 = l0.value, u0 instanceof n0 ? u0 : new n0(function(d0) {
        d0(u0);
      })).then(s0, a0);
    }
    c0((r0 = r0.apply(t0, e0 || [])).next());
  });
}
var c = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {}, l = [], d = [], u = typeof Uint8Array < "u" ? Uint8Array : Array, h = !1;
function f() {
  h = !0;
  for (var t0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e0 = 0; e0 < 64; ++e0)
    l[e0] = t0[e0], d[t0.charCodeAt(e0)] = e0;
  d["-".charCodeAt(0)] = 62, d["_".charCodeAt(0)] = 63;
}
function p(t0, e0, n0) {
  for (var r0, i0, o0 = [], s0 = e0; s0 < n0; s0 += 3)
    r0 = (t0[s0] << 16) + (t0[s0 + 1] << 8) + t0[s0 + 2], o0.push(l[(i0 = r0) >> 18 & 63] + l[i0 >> 12 & 63] + l[i0 >> 6 & 63] + l[63 & i0]);
  return o0.join("");
}
function g(t0) {
  var e0;
  h || f();
  for (var n0 = t0.length, r0 = n0 % 3, i0 = "", o0 = [], s0 = 16383, a0 = 0, c0 = n0 - r0; a0 < c0; a0 += s0)
    o0.push(p(t0, a0, a0 + s0 > c0 ? c0 : a0 + s0));
  return r0 === 1 ? (e0 = t0[n0 - 1], i0 += l[e0 >> 2], i0 += l[e0 << 4 & 63], i0 += "==") : r0 === 2 && (e0 = (t0[n0 - 2] << 8) + t0[n0 - 1], i0 += l[e0 >> 10], i0 += l[e0 >> 4 & 63], i0 += l[e0 << 2 & 63], i0 += "="), o0.push(i0), o0.join("");
}
function m$1(t0, e0, n0, r0, i0) {
  var o0, s0, a0 = 8 * i0 - r0 - 1, c0 = (1 << a0) - 1, l0 = c0 >> 1, u0 = -7, d0 = n0 ? i0 - 1 : 0, h0 = n0 ? -1 : 1, g0 = t0[e0 + d0];
  for (d0 += h0, o0 = g0 & (1 << -u0) - 1, g0 >>= -u0, u0 += a0; u0 > 0; o0 = 256 * o0 + t0[e0 + d0], d0 += h0, u0 -= 8)
    ;
  for (s0 = o0 & (1 << -u0) - 1, o0 >>= -u0, u0 += r0; u0 > 0; s0 = 256 * s0 + t0[e0 + d0], d0 += h0, u0 -= 8)
    ;
  if (o0 === 0)
    o0 = 1 - l0;
  else {
    if (o0 === c0)
      return s0 ? NaN : 1 / 0 * (g0 ? -1 : 1);
    s0 += Math.pow(2, r0), o0 -= l0;
  }
  return (g0 ? -1 : 1) * s0 * Math.pow(2, o0 - r0);
}
function y(t0, e0, n0, r0, i0, o0) {
  var s0, a0, c0, l0 = 8 * o0 - i0 - 1, u0 = (1 << l0) - 1, d0 = u0 >> 1, h0 = i0 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, g0 = r0 ? 0 : o0 - 1, w0 = r0 ? 1 : -1, y0 = e0 < 0 || e0 === 0 && 1 / e0 < 0 ? 1 : 0;
  for (e0 = Math.abs(e0), isNaN(e0) || e0 === 1 / 0 ? (a0 = isNaN(e0) ? 1 : 0, s0 = u0) : (s0 = Math.floor(Math.log(e0) / Math.LN2), e0 * (c0 = Math.pow(2, -s0)) < 1 && (s0--, c0 *= 2), (e0 += s0 + d0 >= 1 ? h0 / c0 : h0 * Math.pow(2, 1 - d0)) * c0 >= 2 && (s0++, c0 /= 2), s0 + d0 >= u0 ? (a0 = 0, s0 = u0) : s0 + d0 >= 1 ? (a0 = (e0 * c0 - 1) * Math.pow(2, i0), s0 += d0) : (a0 = e0 * Math.pow(2, d0 - 1) * Math.pow(2, i0), s0 = 0)); i0 >= 8; t0[n0 + g0] = 255 & a0, g0 += w0, a0 /= 256, i0 -= 8)
    ;
  for (s0 = s0 << i0 | a0, l0 += i0; l0 > 0; t0[n0 + g0] = 255 & s0, g0 += w0, s0 /= 256, l0 -= 8)
    ;
  t0[n0 + g0 - w0] |= 128 * y0;
}
var v$1 = {}.toString, b$1 = Array.isArray || function(t0) {
  return v$1.call(t0) == "[object Array]";
};
_.TYPED_ARRAY_SUPPORT = c.TYPED_ARRAY_SUPPORT === void 0 || c.TYPED_ARRAY_SUPPORT;
var w = E();
function E() {
  return _.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function S(t0, e0) {
  if (E() < e0)
    throw new RangeError("Invalid typed array length");
  return _.TYPED_ARRAY_SUPPORT ? (t0 = new Uint8Array(e0)).__proto__ = _.prototype : (t0 === null && (t0 = new _(e0)), t0.length = e0), t0;
}
function _(t0, e0, n0) {
  if (!(_.TYPED_ARRAY_SUPPORT || this instanceof _))
    return new _(t0, e0, n0);
  if (typeof t0 == "number") {
    if (typeof e0 == "string")
      throw new Error("If encoding is specified then the first argument must be a string");
    return x(this, t0);
  }
  return C$1(this, t0, e0, n0);
}
function C$1(t0, e0, n0, r0) {
  if (typeof e0 == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && e0 instanceof ArrayBuffer ? function(i0, o0, s0, a0) {
    if (o0.byteLength, s0 < 0 || o0.byteLength < s0)
      throw new RangeError("'offset' is out of bounds");
    if (o0.byteLength < s0 + (a0 || 0))
      throw new RangeError("'length' is out of bounds");
    return o0 = s0 === void 0 && a0 === void 0 ? new Uint8Array(o0) : a0 === void 0 ? new Uint8Array(o0, s0) : new Uint8Array(o0, s0, a0), _.TYPED_ARRAY_SUPPORT ? (i0 = o0).__proto__ = _.prototype : i0 = M$1(i0, o0), i0;
  }(t0, e0, n0, r0) : typeof e0 == "string" ? function(i0, o0, s0) {
    if (typeof s0 == "string" && s0 !== "" || (s0 = "utf8"), !_.isEncoding(s0))
      throw new TypeError('"encoding" must be a valid string encoding');
    var a0 = 0 | R(o0, s0);
    i0 = S(i0, a0);
    var c0 = i0.write(o0, s0);
    return c0 !== a0 && (i0 = i0.slice(0, c0)), i0;
  }(t0, e0, n0) : function(i0, o0) {
    if (I(o0)) {
      var s0 = 0 | A$1(o0.length);
      return (i0 = S(i0, s0)).length === 0 || o0.copy(i0, 0, 0, s0), i0;
    }
    if (o0) {
      if (typeof ArrayBuffer < "u" && o0.buffer instanceof ArrayBuffer || "length" in o0)
        return typeof o0.length != "number" || (a0 = o0.length) != a0 ? S(i0, 0) : M$1(i0, o0);
      if (o0.type === "Buffer" && b$1(o0.data))
        return M$1(i0, o0.data);
    }
    var a0;
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }(t0, e0);
}
function k(t0) {
  if (typeof t0 != "number")
    throw new TypeError('"size" argument must be a number');
  if (t0 < 0)
    throw new RangeError('"size" argument must not be negative');
}
function x(t0, e0) {
  if (k(e0), t0 = S(t0, e0 < 0 ? 0 : 0 | A$1(e0)), !_.TYPED_ARRAY_SUPPORT)
    for (var n0 = 0; n0 < e0; ++n0)
      t0[n0] = 0;
  return t0;
}
function M$1(t0, e0) {
  var n0 = e0.length < 0 ? 0 : 0 | A$1(e0.length);
  t0 = S(t0, n0);
  for (var r0 = 0; r0 < n0; r0 += 1)
    t0[r0] = 255 & e0[r0];
  return t0;
}
function A$1(t0) {
  if (t0 >= E())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + E().toString(16) + " bytes");
  return 0 | t0;
}
function I(t0) {
  return !(t0 == null || !t0._isBuffer);
}
function R(t0, e0) {
  if (I(t0))
    return t0.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(t0) || t0 instanceof ArrayBuffer))
    return t0.byteLength;
  typeof t0 != "string" && (t0 = "" + t0);
  var n0 = t0.length;
  if (n0 === 0)
    return 0;
  for (var r0 = !1; ; )
    switch (e0) {
      case "ascii":
      case "latin1":
      case "binary":
        return n0;
      case "utf8":
      case "utf-8":
      case void 0:
        return re$1(t0).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * n0;
      case "hex":
        return n0 >>> 1;
      case "base64":
        return ie$1(t0).length;
      default:
        if (r0)
          return re$1(t0).length;
        e0 = ("" + e0).toLowerCase(), r0 = !0;
    }
}
function P$1(t0, e0, n0) {
  var r0 = !1;
  if ((e0 === void 0 || e0 < 0) && (e0 = 0), e0 > this.length || ((n0 === void 0 || n0 > this.length) && (n0 = this.length), n0 <= 0) || (n0 >>>= 0) <= (e0 >>>= 0))
    return "";
  for (t0 || (t0 = "utf8"); ; )
    switch (t0) {
      case "hex":
        return W(this, e0, n0);
      case "utf8":
      case "utf-8":
        return H$1(this, e0, n0);
      case "ascii":
        return z$1(this, e0, n0);
      case "latin1":
      case "binary":
        return q$1(this, e0, n0);
      case "base64":
        return U(this, e0, n0);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return V$1(this, e0, n0);
      default:
        if (r0)
          throw new TypeError("Unknown encoding: " + t0);
        t0 = (t0 + "").toLowerCase(), r0 = !0;
    }
}
function T(t0, e0, n0) {
  var r0 = t0[e0];
  t0[e0] = t0[n0], t0[n0] = r0;
}
function O$1(t0, e0, n0, r0, i0) {
  if (t0.length === 0)
    return -1;
  if (typeof n0 == "string" ? (r0 = n0, n0 = 0) : n0 > 2147483647 ? n0 = 2147483647 : n0 < -2147483648 && (n0 = -2147483648), n0 = +n0, isNaN(n0) && (n0 = i0 ? 0 : t0.length - 1), n0 < 0 && (n0 = t0.length + n0), n0 >= t0.length) {
    if (i0)
      return -1;
    n0 = t0.length - 1;
  } else if (n0 < 0) {
    if (!i0)
      return -1;
    n0 = 0;
  }
  if (typeof e0 == "string" && (e0 = _.from(e0, r0)), I(e0))
    return e0.length === 0 ? -1 : L$1(t0, e0, n0, r0, i0);
  if (typeof e0 == "number")
    return e0 &= 255, _.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? i0 ? Uint8Array.prototype.indexOf.call(t0, e0, n0) : Uint8Array.prototype.lastIndexOf.call(t0, e0, n0) : L$1(t0, [e0], n0, r0, i0);
  throw new TypeError("val must be string, number or Buffer");
}
function L$1(t0, e0, n0, r0, i0) {
  var o0, s0 = 1, a0 = t0.length, c0 = e0.length;
  if (r0 !== void 0 && ((r0 = String(r0).toLowerCase()) === "ucs2" || r0 === "ucs-2" || r0 === "utf16le" || r0 === "utf-16le")) {
    if (t0.length < 2 || e0.length < 2)
      return -1;
    s0 = 2, a0 /= 2, c0 /= 2, n0 /= 2;
  }
  function l0(g0, w0) {
    return s0 === 1 ? g0[w0] : g0.readUInt16BE(w0 * s0);
  }
  if (i0) {
    var u0 = -1;
    for (o0 = n0; o0 < a0; o0++)
      if (l0(t0, o0) === l0(e0, u0 === -1 ? 0 : o0 - u0)) {
        if (u0 === -1 && (u0 = o0), o0 - u0 + 1 === c0)
          return u0 * s0;
      } else
        u0 !== -1 && (o0 -= o0 - u0), u0 = -1;
  } else
    for (n0 + c0 > a0 && (n0 = a0 - c0), o0 = n0; o0 >= 0; o0--) {
      for (var d0 = !0, h0 = 0; h0 < c0; h0++)
        if (l0(t0, o0 + h0) !== l0(e0, h0)) {
          d0 = !1;
          break;
        }
      if (d0)
        return o0;
    }
  return -1;
}
function N$1(t0, e0, n0, r0) {
  n0 = Number(n0) || 0;
  var i0 = t0.length - n0;
  r0 ? (r0 = Number(r0)) > i0 && (r0 = i0) : r0 = i0;
  var o0 = e0.length;
  if (o0 % 2 != 0)
    throw new TypeError("Invalid hex string");
  r0 > o0 / 2 && (r0 = o0 / 2);
  for (var s0 = 0; s0 < r0; ++s0) {
    var a0 = parseInt(e0.substr(2 * s0, 2), 16);
    if (isNaN(a0))
      return s0;
    t0[n0 + s0] = a0;
  }
  return s0;
}
function $(t0, e0, n0, r0) {
  return oe$1(re$1(e0, t0.length - n0), t0, n0, r0);
}
function D$1(t0, e0, n0, r0) {
  return oe$1(function(i0) {
    for (var o0 = [], s0 = 0; s0 < i0.length; ++s0)
      o0.push(255 & i0.charCodeAt(s0));
    return o0;
  }(e0), t0, n0, r0);
}
function B$1(t0, e0, n0, r0) {
  return D$1(t0, e0, n0, r0);
}
function K$1(t0, e0, n0, r0) {
  return oe$1(ie$1(e0), t0, n0, r0);
}
function j$1(t0, e0, n0, r0) {
  return oe$1(function(i0, o0) {
    for (var s0, a0, c0, l0 = [], u0 = 0; u0 < i0.length && !((o0 -= 2) < 0); ++u0)
      a0 = (s0 = i0.charCodeAt(u0)) >> 8, c0 = s0 % 256, l0.push(c0), l0.push(a0);
    return l0;
  }(e0, t0.length - n0), t0, n0, r0);
}
function U(t0, e0, n0) {
  return e0 === 0 && n0 === t0.length ? g(t0) : g(t0.slice(e0, n0));
}
function H$1(t0, e0, n0) {
  n0 = Math.min(t0.length, n0);
  for (var r0 = [], i0 = e0; i0 < n0; ) {
    var o0, s0, a0, c0, l0 = t0[i0], u0 = null, d0 = l0 > 239 ? 4 : l0 > 223 ? 3 : l0 > 191 ? 2 : 1;
    if (i0 + d0 <= n0)
      switch (d0) {
        case 1:
          l0 < 128 && (u0 = l0);
          break;
        case 2:
          (192 & (o0 = t0[i0 + 1])) == 128 && (c0 = (31 & l0) << 6 | 63 & o0) > 127 && (u0 = c0);
          break;
        case 3:
          o0 = t0[i0 + 1], s0 = t0[i0 + 2], (192 & o0) == 128 && (192 & s0) == 128 && (c0 = (15 & l0) << 12 | (63 & o0) << 6 | 63 & s0) > 2047 && (c0 < 55296 || c0 > 57343) && (u0 = c0);
          break;
        case 4:
          o0 = t0[i0 + 1], s0 = t0[i0 + 2], a0 = t0[i0 + 3], (192 & o0) == 128 && (192 & s0) == 128 && (192 & a0) == 128 && (c0 = (15 & l0) << 18 | (63 & o0) << 12 | (63 & s0) << 6 | 63 & a0) > 65535 && c0 < 1114112 && (u0 = c0);
      }
    u0 === null ? (u0 = 65533, d0 = 1) : u0 > 65535 && (u0 -= 65536, r0.push(u0 >>> 10 & 1023 | 55296), u0 = 56320 | 1023 & u0), r0.push(u0), i0 += d0;
  }
  return function(h0) {
    var g0 = h0.length;
    if (g0 <= F)
      return String.fromCharCode.apply(String, h0);
    for (var w0 = "", y0 = 0; y0 < g0; )
      w0 += String.fromCharCode.apply(String, h0.slice(y0, y0 += F));
    return w0;
  }(r0);
}
_.poolSize = 8192, _._augment = function(t0) {
  return t0.__proto__ = _.prototype, t0;
}, _.from = function(t0, e0, n0) {
  return C$1(null, t0, e0, n0);
}, _.TYPED_ARRAY_SUPPORT && (_.prototype.__proto__ = Uint8Array.prototype, _.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && _[Symbol.species]), _.alloc = function(t0, e0, n0) {
  return function(r0, i0, o0, s0) {
    return k(i0), i0 <= 0 ? S(r0, i0) : o0 !== void 0 ? typeof s0 == "string" ? S(r0, i0).fill(o0, s0) : S(r0, i0).fill(o0) : S(r0, i0);
  }(null, t0, e0, n0);
}, _.allocUnsafe = function(t0) {
  return x(null, t0);
}, _.allocUnsafeSlow = function(t0) {
  return x(null, t0);
}, _.isBuffer = se$1, _.compare = function(t0, e0) {
  if (!I(t0) || !I(e0))
    throw new TypeError("Arguments must be Buffers");
  if (t0 === e0)
    return 0;
  for (var n0 = t0.length, r0 = e0.length, i0 = 0, o0 = Math.min(n0, r0); i0 < o0; ++i0)
    if (t0[i0] !== e0[i0]) {
      n0 = t0[i0], r0 = e0[i0];
      break;
    }
  return n0 < r0 ? -1 : r0 < n0 ? 1 : 0;
}, _.isEncoding = function(t0) {
  switch (String(t0).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
}, _.concat = function(t0, e0) {
  if (!b$1(t0))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (t0.length === 0)
    return _.alloc(0);
  var n0;
  if (e0 === void 0)
    for (e0 = 0, n0 = 0; n0 < t0.length; ++n0)
      e0 += t0[n0].length;
  var r0 = _.allocUnsafe(e0), i0 = 0;
  for (n0 = 0; n0 < t0.length; ++n0) {
    var o0 = t0[n0];
    if (!I(o0))
      throw new TypeError('"list" argument must be an Array of Buffers');
    o0.copy(r0, i0), i0 += o0.length;
  }
  return r0;
}, _.byteLength = R, _.prototype._isBuffer = !0, _.prototype.swap16 = function() {
  var t0 = this.length;
  if (t0 % 2 != 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var e0 = 0; e0 < t0; e0 += 2)
    T(this, e0, e0 + 1);
  return this;
}, _.prototype.swap32 = function() {
  var t0 = this.length;
  if (t0 % 4 != 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var e0 = 0; e0 < t0; e0 += 4)
    T(this, e0, e0 + 3), T(this, e0 + 1, e0 + 2);
  return this;
}, _.prototype.swap64 = function() {
  var t0 = this.length;
  if (t0 % 8 != 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var e0 = 0; e0 < t0; e0 += 8)
    T(this, e0, e0 + 7), T(this, e0 + 1, e0 + 6), T(this, e0 + 2, e0 + 5), T(this, e0 + 3, e0 + 4);
  return this;
}, _.prototype.toString = function() {
  var t0 = 0 | this.length;
  return t0 === 0 ? "" : arguments.length === 0 ? H$1(this, 0, t0) : P$1.apply(this, arguments);
}, _.prototype.equals = function(t0) {
  if (!I(t0))
    throw new TypeError("Argument must be a Buffer");
  return this === t0 || _.compare(this, t0) === 0;
}, _.prototype.inspect = function() {
  var t0 = "";
  return this.length > 0 && (t0 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (t0 += " ... ")), "<Buffer " + t0 + ">";
}, _.prototype.compare = function(t0, e0, n0, r0, i0) {
  if (!I(t0))
    throw new TypeError("Argument must be a Buffer");
  if (e0 === void 0 && (e0 = 0), n0 === void 0 && (n0 = t0 ? t0.length : 0), r0 === void 0 && (r0 = 0), i0 === void 0 && (i0 = this.length), e0 < 0 || n0 > t0.length || r0 < 0 || i0 > this.length)
    throw new RangeError("out of range index");
  if (r0 >= i0 && e0 >= n0)
    return 0;
  if (r0 >= i0)
    return -1;
  if (e0 >= n0)
    return 1;
  if (this === t0)
    return 0;
  for (var o0 = (i0 >>>= 0) - (r0 >>>= 0), s0 = (n0 >>>= 0) - (e0 >>>= 0), a0 = Math.min(o0, s0), c0 = this.slice(r0, i0), l0 = t0.slice(e0, n0), u0 = 0; u0 < a0; ++u0)
    if (c0[u0] !== l0[u0]) {
      o0 = c0[u0], s0 = l0[u0];
      break;
    }
  return o0 < s0 ? -1 : s0 < o0 ? 1 : 0;
}, _.prototype.includes = function(t0, e0, n0) {
  return this.indexOf(t0, e0, n0) !== -1;
}, _.prototype.indexOf = function(t0, e0, n0) {
  return O$1(this, t0, e0, n0, !0);
}, _.prototype.lastIndexOf = function(t0, e0, n0) {
  return O$1(this, t0, e0, n0, !1);
}, _.prototype.write = function(t0, e0, n0, r0) {
  if (e0 === void 0)
    r0 = "utf8", n0 = this.length, e0 = 0;
  else if (n0 === void 0 && typeof e0 == "string")
    r0 = e0, n0 = this.length, e0 = 0;
  else {
    if (!isFinite(e0))
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    e0 |= 0, isFinite(n0) ? (n0 |= 0, r0 === void 0 && (r0 = "utf8")) : (r0 = n0, n0 = void 0);
  }
  var i0 = this.length - e0;
  if ((n0 === void 0 || n0 > i0) && (n0 = i0), t0.length > 0 && (n0 < 0 || e0 < 0) || e0 > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  r0 || (r0 = "utf8");
  for (var o0 = !1; ; )
    switch (r0) {
      case "hex":
        return N$1(this, t0, e0, n0);
      case "utf8":
      case "utf-8":
        return $(this, t0, e0, n0);
      case "ascii":
        return D$1(this, t0, e0, n0);
      case "latin1":
      case "binary":
        return B$1(this, t0, e0, n0);
      case "base64":
        return K$1(this, t0, e0, n0);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return j$1(this, t0, e0, n0);
      default:
        if (o0)
          throw new TypeError("Unknown encoding: " + r0);
        r0 = ("" + r0).toLowerCase(), o0 = !0;
    }
}, _.prototype.toJSON = function() {
  return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
};
var F = 4096;
function z$1(t0, e0, n0) {
  var r0 = "";
  n0 = Math.min(t0.length, n0);
  for (var i0 = e0; i0 < n0; ++i0)
    r0 += String.fromCharCode(127 & t0[i0]);
  return r0;
}
function q$1(t0, e0, n0) {
  var r0 = "";
  n0 = Math.min(t0.length, n0);
  for (var i0 = e0; i0 < n0; ++i0)
    r0 += String.fromCharCode(t0[i0]);
  return r0;
}
function W(t0, e0, n0) {
  var r0 = t0.length;
  (!e0 || e0 < 0) && (e0 = 0), (!n0 || n0 < 0 || n0 > r0) && (n0 = r0);
  for (var i0 = "", o0 = e0; o0 < n0; ++o0)
    i0 += ne$1(t0[o0]);
  return i0;
}
function V$1(t0, e0, n0) {
  for (var r0 = t0.slice(e0, n0), i0 = "", o0 = 0; o0 < r0.length; o0 += 2)
    i0 += String.fromCharCode(r0[o0] + 256 * r0[o0 + 1]);
  return i0;
}
function G$1(t0, e0, n0) {
  if (t0 % 1 != 0 || t0 < 0)
    throw new RangeError("offset is not uint");
  if (t0 + e0 > n0)
    throw new RangeError("Trying to access beyond buffer length");
}
function Y$1(t0, e0, n0, r0, i0, o0) {
  if (!I(t0))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (e0 > i0 || e0 < o0)
    throw new RangeError('"value" argument is out of bounds');
  if (n0 + r0 > t0.length)
    throw new RangeError("Index out of range");
}
function Z$1(t0, e0, n0, r0) {
  e0 < 0 && (e0 = 65535 + e0 + 1);
  for (var i0 = 0, o0 = Math.min(t0.length - n0, 2); i0 < o0; ++i0)
    t0[n0 + i0] = (e0 & 255 << 8 * (r0 ? i0 : 1 - i0)) >>> 8 * (r0 ? i0 : 1 - i0);
}
function J$1(t0, e0, n0, r0) {
  e0 < 0 && (e0 = 4294967295 + e0 + 1);
  for (var i0 = 0, o0 = Math.min(t0.length - n0, 4); i0 < o0; ++i0)
    t0[n0 + i0] = e0 >>> 8 * (r0 ? i0 : 3 - i0) & 255;
}
function X$1(t0, e0, n0, r0, i0, o0) {
  if (n0 + r0 > t0.length)
    throw new RangeError("Index out of range");
  if (n0 < 0)
    throw new RangeError("Index out of range");
}
function Q(t0, e0, n0, r0, i0) {
  return i0 || X$1(t0, 0, n0, 4), y(t0, e0, n0, r0, 23, 4), n0 + 4;
}
function ee$1(t0, e0, n0, r0, i0) {
  return i0 || X$1(t0, 0, n0, 8), y(t0, e0, n0, r0, 52, 8), n0 + 8;
}
_.prototype.slice = function(t0, e0) {
  var n0, r0 = this.length;
  if ((t0 = ~~t0) < 0 ? (t0 += r0) < 0 && (t0 = 0) : t0 > r0 && (t0 = r0), (e0 = e0 === void 0 ? r0 : ~~e0) < 0 ? (e0 += r0) < 0 && (e0 = 0) : e0 > r0 && (e0 = r0), e0 < t0 && (e0 = t0), _.TYPED_ARRAY_SUPPORT)
    (n0 = this.subarray(t0, e0)).__proto__ = _.prototype;
  else {
    var i0 = e0 - t0;
    n0 = new _(i0, void 0);
    for (var o0 = 0; o0 < i0; ++o0)
      n0[o0] = this[o0 + t0];
  }
  return n0;
}, _.prototype.readUIntLE = function(t0, e0, n0) {
  t0 |= 0, e0 |= 0, n0 || G$1(t0, e0, this.length);
  for (var r0 = this[t0], i0 = 1, o0 = 0; ++o0 < e0 && (i0 *= 256); )
    r0 += this[t0 + o0] * i0;
  return r0;
}, _.prototype.readUIntBE = function(t0, e0, n0) {
  t0 |= 0, e0 |= 0, n0 || G$1(t0, e0, this.length);
  for (var r0 = this[t0 + --e0], i0 = 1; e0 > 0 && (i0 *= 256); )
    r0 += this[t0 + --e0] * i0;
  return r0;
}, _.prototype.readUInt8 = function(t0, e0) {
  return e0 || G$1(t0, 1, this.length), this[t0];
}, _.prototype.readUInt16LE = function(t0, e0) {
  return e0 || G$1(t0, 2, this.length), this[t0] | this[t0 + 1] << 8;
}, _.prototype.readUInt16BE = function(t0, e0) {
  return e0 || G$1(t0, 2, this.length), this[t0] << 8 | this[t0 + 1];
}, _.prototype.readUInt32LE = function(t0, e0) {
  return e0 || G$1(t0, 4, this.length), (this[t0] | this[t0 + 1] << 8 | this[t0 + 2] << 16) + 16777216 * this[t0 + 3];
}, _.prototype.readUInt32BE = function(t0, e0) {
  return e0 || G$1(t0, 4, this.length), 16777216 * this[t0] + (this[t0 + 1] << 16 | this[t0 + 2] << 8 | this[t0 + 3]);
}, _.prototype.readIntLE = function(t0, e0, n0) {
  t0 |= 0, e0 |= 0, n0 || G$1(t0, e0, this.length);
  for (var r0 = this[t0], i0 = 1, o0 = 0; ++o0 < e0 && (i0 *= 256); )
    r0 += this[t0 + o0] * i0;
  return r0 >= (i0 *= 128) && (r0 -= Math.pow(2, 8 * e0)), r0;
}, _.prototype.readIntBE = function(t0, e0, n0) {
  t0 |= 0, e0 |= 0, n0 || G$1(t0, e0, this.length);
  for (var r0 = e0, i0 = 1, o0 = this[t0 + --r0]; r0 > 0 && (i0 *= 256); )
    o0 += this[t0 + --r0] * i0;
  return o0 >= (i0 *= 128) && (o0 -= Math.pow(2, 8 * e0)), o0;
}, _.prototype.readInt8 = function(t0, e0) {
  return e0 || G$1(t0, 1, this.length), 128 & this[t0] ? -1 * (255 - this[t0] + 1) : this[t0];
}, _.prototype.readInt16LE = function(t0, e0) {
  e0 || G$1(t0, 2, this.length);
  var n0 = this[t0] | this[t0 + 1] << 8;
  return 32768 & n0 ? 4294901760 | n0 : n0;
}, _.prototype.readInt16BE = function(t0, e0) {
  e0 || G$1(t0, 2, this.length);
  var n0 = this[t0 + 1] | this[t0] << 8;
  return 32768 & n0 ? 4294901760 | n0 : n0;
}, _.prototype.readInt32LE = function(t0, e0) {
  return e0 || G$1(t0, 4, this.length), this[t0] | this[t0 + 1] << 8 | this[t0 + 2] << 16 | this[t0 + 3] << 24;
}, _.prototype.readInt32BE = function(t0, e0) {
  return e0 || G$1(t0, 4, this.length), this[t0] << 24 | this[t0 + 1] << 16 | this[t0 + 2] << 8 | this[t0 + 3];
}, _.prototype.readFloatLE = function(t0, e0) {
  return e0 || G$1(t0, 4, this.length), m$1(this, t0, !0, 23, 4);
}, _.prototype.readFloatBE = function(t0, e0) {
  return e0 || G$1(t0, 4, this.length), m$1(this, t0, !1, 23, 4);
}, _.prototype.readDoubleLE = function(t0, e0) {
  return e0 || G$1(t0, 8, this.length), m$1(this, t0, !0, 52, 8);
}, _.prototype.readDoubleBE = function(t0, e0) {
  return e0 || G$1(t0, 8, this.length), m$1(this, t0, !1, 52, 8);
}, _.prototype.writeUIntLE = function(t0, e0, n0, r0) {
  t0 = +t0, e0 |= 0, n0 |= 0, r0 || Y$1(this, t0, e0, n0, Math.pow(2, 8 * n0) - 1, 0);
  var i0 = 1, o0 = 0;
  for (this[e0] = 255 & t0; ++o0 < n0 && (i0 *= 256); )
    this[e0 + o0] = t0 / i0 & 255;
  return e0 + n0;
}, _.prototype.writeUIntBE = function(t0, e0, n0, r0) {
  t0 = +t0, e0 |= 0, n0 |= 0, r0 || Y$1(this, t0, e0, n0, Math.pow(2, 8 * n0) - 1, 0);
  var i0 = n0 - 1, o0 = 1;
  for (this[e0 + i0] = 255 & t0; --i0 >= 0 && (o0 *= 256); )
    this[e0 + i0] = t0 / o0 & 255;
  return e0 + n0;
}, _.prototype.writeUInt8 = function(t0, e0, n0) {
  return t0 = +t0, e0 |= 0, n0 || Y$1(this, t0, e0, 1, 255, 0), _.TYPED_ARRAY_SUPPORT || (t0 = Math.floor(t0)), this[e0] = 255 & t0, e0 + 1;
}, _.prototype.writeUInt16LE = function(t0, e0, n0) {
  return t0 = +t0, e0 |= 0, n0 || Y$1(this, t0, e0, 2, 65535, 0), _.TYPED_ARRAY_SUPPORT ? (this[e0] = 255 & t0, this[e0 + 1] = t0 >>> 8) : Z$1(this, t0, e0, !0), e0 + 2;
}, _.prototype.writeUInt16BE = function(t0, e0, n0) {
  return t0 = +t0, e0 |= 0, n0 || Y$1(this, t0, e0, 2, 65535, 0), _.TYPED_ARRAY_SUPPORT ? (this[e0] = t0 >>> 8, this[e0 + 1] = 255 & t0) : Z$1(this, t0, e0, !1), e0 + 2;
}, _.prototype.writeUInt32LE = function(t0, e0, n0) {
  return t0 = +t0, e0 |= 0, n0 || Y$1(this, t0, e0, 4, 4294967295, 0), _.TYPED_ARRAY_SUPPORT ? (this[e0 + 3] = t0 >>> 24, this[e0 + 2] = t0 >>> 16, this[e0 + 1] = t0 >>> 8, this[e0] = 255 & t0) : J$1(this, t0, e0, !0), e0 + 4;
}, _.prototype.writeUInt32BE = function(t0, e0, n0) {
  return t0 = +t0, e0 |= 0, n0 || Y$1(this, t0, e0, 4, 4294967295, 0), _.TYPED_ARRAY_SUPPORT ? (this[e0] = t0 >>> 24, this[e0 + 1] = t0 >>> 16, this[e0 + 2] = t0 >>> 8, this[e0 + 3] = 255 & t0) : J$1(this, t0, e0, !1), e0 + 4;
}, _.prototype.writeIntLE = function(t0, e0, n0, r0) {
  if (t0 = +t0, e0 |= 0, !r0) {
    var i0 = Math.pow(2, 8 * n0 - 1);
    Y$1(this, t0, e0, n0, i0 - 1, -i0);
  }
  var o0 = 0, s0 = 1, a0 = 0;
  for (this[e0] = 255 & t0; ++o0 < n0 && (s0 *= 256); )
    t0 < 0 && a0 === 0 && this[e0 + o0 - 1] !== 0 && (a0 = 1), this[e0 + o0] = (t0 / s0 >> 0) - a0 & 255;
  return e0 + n0;
}, _.prototype.writeIntBE = function(t0, e0, n0, r0) {
  if (t0 = +t0, e0 |= 0, !r0) {
    var i0 = Math.pow(2, 8 * n0 - 1);
    Y$1(this, t0, e0, n0, i0 - 1, -i0);
  }
  var o0 = n0 - 1, s0 = 1, a0 = 0;
  for (this[e0 + o0] = 255 & t0; --o0 >= 0 && (s0 *= 256); )
    t0 < 0 && a0 === 0 && this[e0 + o0 + 1] !== 0 && (a0 = 1), this[e0 + o0] = (t0 / s0 >> 0) - a0 & 255;
  return e0 + n0;
}, _.prototype.writeInt8 = function(t0, e0, n0) {
  return t0 = +t0, e0 |= 0, n0 || Y$1(this, t0, e0, 1, 127, -128), _.TYPED_ARRAY_SUPPORT || (t0 = Math.floor(t0)), t0 < 0 && (t0 = 255 + t0 + 1), this[e0] = 255 & t0, e0 + 1;
}, _.prototype.writeInt16LE = function(t0, e0, n0) {
  return t0 = +t0, e0 |= 0, n0 || Y$1(this, t0, e0, 2, 32767, -32768), _.TYPED_ARRAY_SUPPORT ? (this[e0] = 255 & t0, this[e0 + 1] = t0 >>> 8) : Z$1(this, t0, e0, !0), e0 + 2;
}, _.prototype.writeInt16BE = function(t0, e0, n0) {
  return t0 = +t0, e0 |= 0, n0 || Y$1(this, t0, e0, 2, 32767, -32768), _.TYPED_ARRAY_SUPPORT ? (this[e0] = t0 >>> 8, this[e0 + 1] = 255 & t0) : Z$1(this, t0, e0, !1), e0 + 2;
}, _.prototype.writeInt32LE = function(t0, e0, n0) {
  return t0 = +t0, e0 |= 0, n0 || Y$1(this, t0, e0, 4, 2147483647, -2147483648), _.TYPED_ARRAY_SUPPORT ? (this[e0] = 255 & t0, this[e0 + 1] = t0 >>> 8, this[e0 + 2] = t0 >>> 16, this[e0 + 3] = t0 >>> 24) : J$1(this, t0, e0, !0), e0 + 4;
}, _.prototype.writeInt32BE = function(t0, e0, n0) {
  return t0 = +t0, e0 |= 0, n0 || Y$1(this, t0, e0, 4, 2147483647, -2147483648), t0 < 0 && (t0 = 4294967295 + t0 + 1), _.TYPED_ARRAY_SUPPORT ? (this[e0] = t0 >>> 24, this[e0 + 1] = t0 >>> 16, this[e0 + 2] = t0 >>> 8, this[e0 + 3] = 255 & t0) : J$1(this, t0, e0, !1), e0 + 4;
}, _.prototype.writeFloatLE = function(t0, e0, n0) {
  return Q(this, t0, e0, !0, n0);
}, _.prototype.writeFloatBE = function(t0, e0, n0) {
  return Q(this, t0, e0, !1, n0);
}, _.prototype.writeDoubleLE = function(t0, e0, n0) {
  return ee$1(this, t0, e0, !0, n0);
}, _.prototype.writeDoubleBE = function(t0, e0, n0) {
  return ee$1(this, t0, e0, !1, n0);
}, _.prototype.copy = function(t0, e0, n0, r0) {
  if (n0 || (n0 = 0), r0 || r0 === 0 || (r0 = this.length), e0 >= t0.length && (e0 = t0.length), e0 || (e0 = 0), r0 > 0 && r0 < n0 && (r0 = n0), r0 === n0 || t0.length === 0 || this.length === 0)
    return 0;
  if (e0 < 0)
    throw new RangeError("targetStart out of bounds");
  if (n0 < 0 || n0 >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (r0 < 0)
    throw new RangeError("sourceEnd out of bounds");
  r0 > this.length && (r0 = this.length), t0.length - e0 < r0 - n0 && (r0 = t0.length - e0 + n0);
  var i0, o0 = r0 - n0;
  if (this === t0 && n0 < e0 && e0 < r0)
    for (i0 = o0 - 1; i0 >= 0; --i0)
      t0[i0 + e0] = this[i0 + n0];
  else if (o0 < 1e3 || !_.TYPED_ARRAY_SUPPORT)
    for (i0 = 0; i0 < o0; ++i0)
      t0[i0 + e0] = this[i0 + n0];
  else
    Uint8Array.prototype.set.call(t0, this.subarray(n0, n0 + o0), e0);
  return o0;
}, _.prototype.fill = function(t0, e0, n0, r0) {
  if (typeof t0 == "string") {
    if (typeof e0 == "string" ? (r0 = e0, e0 = 0, n0 = this.length) : typeof n0 == "string" && (r0 = n0, n0 = this.length), t0.length === 1) {
      var i0 = t0.charCodeAt(0);
      i0 < 256 && (t0 = i0);
    }
    if (r0 !== void 0 && typeof r0 != "string")
      throw new TypeError("encoding must be a string");
    if (typeof r0 == "string" && !_.isEncoding(r0))
      throw new TypeError("Unknown encoding: " + r0);
  } else
    typeof t0 == "number" && (t0 &= 255);
  if (e0 < 0 || this.length < e0 || this.length < n0)
    throw new RangeError("Out of range index");
  if (n0 <= e0)
    return this;
  var o0;
  if (e0 >>>= 0, n0 = n0 === void 0 ? this.length : n0 >>> 0, t0 || (t0 = 0), typeof t0 == "number")
    for (o0 = e0; o0 < n0; ++o0)
      this[o0] = t0;
  else {
    var s0 = I(t0) ? t0 : re$1(new _(t0, r0).toString()), a0 = s0.length;
    for (o0 = 0; o0 < n0 - e0; ++o0)
      this[o0 + e0] = s0[o0 % a0];
  }
  return this;
};
var te$1 = /[^+\/0-9A-Za-z-_]/g;
function ne$1(t0) {
  return t0 < 16 ? "0" + t0.toString(16) : t0.toString(16);
}
function re$1(t0, e0) {
  var n0;
  e0 = e0 || 1 / 0;
  for (var r0 = t0.length, i0 = null, o0 = [], s0 = 0; s0 < r0; ++s0) {
    if ((n0 = t0.charCodeAt(s0)) > 55295 && n0 < 57344) {
      if (!i0) {
        if (n0 > 56319) {
          (e0 -= 3) > -1 && o0.push(239, 191, 189);
          continue;
        }
        if (s0 + 1 === r0) {
          (e0 -= 3) > -1 && o0.push(239, 191, 189);
          continue;
        }
        i0 = n0;
        continue;
      }
      if (n0 < 56320) {
        (e0 -= 3) > -1 && o0.push(239, 191, 189), i0 = n0;
        continue;
      }
      n0 = 65536 + (i0 - 55296 << 10 | n0 - 56320);
    } else
      i0 && (e0 -= 3) > -1 && o0.push(239, 191, 189);
    if (i0 = null, n0 < 128) {
      if ((e0 -= 1) < 0)
        break;
      o0.push(n0);
    } else if (n0 < 2048) {
      if ((e0 -= 2) < 0)
        break;
      o0.push(n0 >> 6 | 192, 63 & n0 | 128);
    } else if (n0 < 65536) {
      if ((e0 -= 3) < 0)
        break;
      o0.push(n0 >> 12 | 224, n0 >> 6 & 63 | 128, 63 & n0 | 128);
    } else {
      if (!(n0 < 1114112))
        throw new Error("Invalid code point");
      if ((e0 -= 4) < 0)
        break;
      o0.push(n0 >> 18 | 240, n0 >> 12 & 63 | 128, n0 >> 6 & 63 | 128, 63 & n0 | 128);
    }
  }
  return o0;
}
function ie$1(t0) {
  return function(e0) {
    var n0, r0, i0, o0, s0, a0;
    h || f();
    var c0 = e0.length;
    if (c0 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    s0 = e0[c0 - 2] === "=" ? 2 : e0[c0 - 1] === "=" ? 1 : 0, a0 = new u(3 * c0 / 4 - s0), i0 = s0 > 0 ? c0 - 4 : c0;
    var l0 = 0;
    for (n0 = 0, r0 = 0; n0 < i0; n0 += 4, r0 += 3)
      o0 = d[e0.charCodeAt(n0)] << 18 | d[e0.charCodeAt(n0 + 1)] << 12 | d[e0.charCodeAt(n0 + 2)] << 6 | d[e0.charCodeAt(n0 + 3)], a0[l0++] = o0 >> 16 & 255, a0[l0++] = o0 >> 8 & 255, a0[l0++] = 255 & o0;
    return s0 === 2 ? (o0 = d[e0.charCodeAt(n0)] << 2 | d[e0.charCodeAt(n0 + 1)] >> 4, a0[l0++] = 255 & o0) : s0 === 1 && (o0 = d[e0.charCodeAt(n0)] << 10 | d[e0.charCodeAt(n0 + 1)] << 4 | d[e0.charCodeAt(n0 + 2)] >> 2, a0[l0++] = o0 >> 8 & 255, a0[l0++] = 255 & o0), a0;
  }(function(e0) {
    if ((e0 = function(n0) {
      return n0.trim ? n0.trim() : n0.replace(/^\s+|\s+$/g, "");
    }(e0).replace(te$1, "")).length < 2)
      return "";
    for (; e0.length % 4 != 0; )
      e0 += "=";
    return e0;
  }(t0));
}
function oe$1(t0, e0, n0, r0) {
  for (var i0 = 0; i0 < r0 && !(i0 + n0 >= e0.length || i0 >= t0.length); ++i0)
    e0[i0 + n0] = t0[i0];
  return i0;
}
function se$1(t0) {
  return t0 != null && (!!t0._isBuffer || ae$1(t0) || function(e0) {
    return typeof e0.readFloatLE == "function" && typeof e0.slice == "function" && ae$1(e0.slice(0, 0));
  }(t0));
}
function ae$1(t0) {
  return !!t0.constructor && typeof t0.constructor.isBuffer == "function" && t0.constructor.isBuffer(t0);
}
var ce$1 = Object.freeze({ __proto__: null, Buffer: _, INSPECT_MAX_BYTES: 50, SlowBuffer: function(t0) {
  return +t0 != t0 && (t0 = 0), _.alloc(+t0);
}, isBuffer: se$1, kMaxLength: w }), le$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function de$1(t0) {
  return t0 && t0.__esModule && Object.prototype.hasOwnProperty.call(t0, "default") ? t0.default : t0;
}
function ue$1(t0) {
  if (t0.__esModule)
    return t0;
  var e0 = t0.default;
  if (typeof e0 == "function") {
    var n0 = function r0() {
      return this instanceof r0 ? Reflect.construct(e0, arguments, this.constructor) : e0.apply(this, arguments);
    };
    n0.prototype = e0.prototype;
  } else
    n0 = {};
  return Object.defineProperty(n0, "__esModule", { value: !0 }), Object.keys(t0).forEach(function(r0) {
    var i0 = Object.getOwnPropertyDescriptor(t0, r0);
    Object.defineProperty(n0, r0, i0.get ? i0 : { enumerable: !0, get: function() {
      return t0[r0];
    } });
  }), n0;
}
var he$1 = {}, fe$1 = {}, pe = {};
function ge(t0) {
  if (!Number.isSafeInteger(t0) || t0 < 0)
    throw new Error(`positive integer expected, not ${t0}`);
}
function me(t0) {
  if (typeof t0 != "boolean")
    throw new Error(`boolean expected, not ${t0}`);
}
function ye(t0) {
  return t0 instanceof Uint8Array || t0 != null && typeof t0 == "object" && t0.constructor.name === "Uint8Array";
}
function ve(t0, ...e0) {
  if (!ye(t0))
    throw new Error("Uint8Array expected");
  if (e0.length > 0 && !e0.includes(t0.length))
    throw new Error(`Uint8Array expected of length ${e0}, not of length=${t0.length}`);
}
function be(t0) {
  if (typeof t0 != "function" || typeof t0.create != "function")
    throw new Error("hash must be wrapped by utils.wrapConstructor");
  ge(t0.outputLen), ge(t0.blockLen);
}
function we(t0, e0 = !0) {
  if (t0.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e0 && t0.finished)
    throw new Error("Hash#digest() has already been called");
}
function Ee(t0, e0) {
  ve(t0);
  const n0 = e0.outputLen;
  if (t0.length < n0)
    throw new Error(`digestInto() expects output buffer of length at least ${n0}`);
}
Object.defineProperty(pe, "__esModule", { value: !0 }), pe.isBytes = ye, pe.number = ge, pe.bool = me, pe.bytes = ve, pe.hash = be, pe.exists = we, pe.output = Ee;
const Se$1 = { number: ge, bool: me, bytes: ve, hash: be, exists: we, output: Ee };
pe.default = Se$1, function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.wrapCipher = t0.Hash = t0.nextTick = t0.isLE = t0.createView = t0.u32 = t0.u16 = t0.u8 = void 0, t0.bytesToHex = r0, t0.hexToBytes = s0, t0.hexToNumber = a0, t0.bytesToNumberBE = function(d0) {
    return a0(r0(d0));
  }, t0.numberToBytesBE = function(d0, h0) {
    return s0(d0.toString(16).padStart(2 * h0, "0"));
  }, t0.asyncLoop = async function(d0, h0, g0) {
    let w0 = Date.now();
    for (let y0 = 0; y0 < d0; y0++) {
      g0(y0);
      const E0 = Date.now() - w0;
      E0 >= 0 && E0 < h0 || (await (0, t0.nextTick)(), w0 += E0);
    }
  }, t0.utf8ToBytes = c0, t0.bytesToUtf8 = function(d0) {
    return new TextDecoder().decode(d0);
  }, t0.toBytes = function(d0) {
    if (typeof d0 == "string")
      d0 = c0(d0);
    else {
      if (!(0, e0.isBytes)(d0))
        throw new Error("Uint8Array expected, got " + typeof d0);
      d0 = u0(d0);
    }
    return d0;
  }, t0.concatBytes = function(...d0) {
    let h0 = 0;
    for (let w0 = 0; w0 < d0.length; w0++) {
      const y0 = d0[w0];
      (0, e0.bytes)(y0), h0 += y0.length;
    }
    const g0 = new Uint8Array(h0);
    for (let w0 = 0, y0 = 0; w0 < d0.length; w0++) {
      const E0 = d0[w0];
      g0.set(E0, y0), y0 += E0.length;
    }
    return g0;
  }, t0.checkOpts = function(d0, h0) {
    if (h0 == null || typeof h0 != "object")
      throw new Error("options must be defined");
    return Object.assign(d0, h0);
  }, t0.equalBytes = function(d0, h0) {
    if (d0.length !== h0.length)
      return !1;
    let g0 = 0;
    for (let w0 = 0; w0 < d0.length; w0++)
      g0 |= d0[w0] ^ h0[w0];
    return g0 === 0;
  }, t0.setBigUint64 = l0, t0.u64Lengths = function(d0, h0) {
    const g0 = new Uint8Array(16), w0 = (0, t0.createView)(g0);
    return l0(w0, 0, BigInt(h0 ? h0.length : 0), !0), l0(w0, 8, BigInt(d0.length), !0), g0;
  }, t0.isAligned32 = function(d0) {
    return d0.byteOffset % 4 == 0;
  }, t0.copyBytes = u0, t0.clean = function(...d0) {
    for (let h0 = 0; h0 < d0.length; h0++)
      d0[h0].fill(0);
  };
  const e0 = pe;
  if (t0.u8 = (d0) => new Uint8Array(d0.buffer, d0.byteOffset, d0.byteLength), t0.u16 = (d0) => new Uint16Array(d0.buffer, d0.byteOffset, Math.floor(d0.byteLength / 2)), t0.u32 = (d0) => new Uint32Array(d0.buffer, d0.byteOffset, Math.floor(d0.byteLength / 4)), t0.createView = (d0) => new DataView(d0.buffer, d0.byteOffset, d0.byteLength), t0.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !t0.isLE)
    throw new Error("Non little-endian hardware is not supported");
  const n0 = Array.from({ length: 256 }, (d0, h0) => h0.toString(16).padStart(2, "0"));
  function r0(d0) {
    (0, e0.bytes)(d0);
    let h0 = "";
    for (let g0 = 0; g0 < d0.length; g0++)
      h0 += n0[d0[g0]];
    return h0;
  }
  const i0 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function o0(d0) {
    return d0 >= i0._0 && d0 <= i0._9 ? d0 - i0._0 : d0 >= i0._A && d0 <= i0._F ? d0 - (i0._A - 10) : d0 >= i0._a && d0 <= i0._f ? d0 - (i0._a - 10) : void 0;
  }
  function s0(d0) {
    if (typeof d0 != "string")
      throw new Error("hex string expected, got " + typeof d0);
    const h0 = d0.length, g0 = h0 / 2;
    if (h0 % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + h0);
    const w0 = new Uint8Array(g0);
    for (let y0 = 0, E0 = 0; y0 < g0; y0++, E0 += 2) {
      const b0 = o0(d0.charCodeAt(E0)), O0 = o0(d0.charCodeAt(E0 + 1));
      if (b0 === void 0 || O0 === void 0) {
        const S0 = d0[E0] + d0[E0 + 1];
        throw new Error('hex string expected, got non-hex character "' + S0 + '" at index ' + E0);
      }
      w0[y0] = 16 * b0 + O0;
    }
    return w0;
  }
  function a0(d0) {
    if (typeof d0 != "string")
      throw new Error("hex string expected, got " + typeof d0);
    return BigInt(d0 === "" ? "0" : `0x${d0}`);
  }
  function c0(d0) {
    if (typeof d0 != "string")
      throw new Error("string expected, got " + typeof d0);
    return new Uint8Array(new TextEncoder().encode(d0));
  }
  t0.nextTick = async () => {
  }, t0.Hash = class {
  };
  function l0(d0, h0, g0, w0) {
    if (typeof d0.setBigUint64 == "function")
      return d0.setBigUint64(h0, g0, w0);
    const y0 = BigInt(32), E0 = BigInt(4294967295), b0 = Number(g0 >> y0 & E0), O0 = Number(g0 & E0), S0 = w0 ? 4 : 0, k0 = w0 ? 0 : 4;
    d0.setUint32(h0 + S0, b0, w0), d0.setUint32(h0 + k0, O0, w0);
  }
  function u0(d0) {
    return Uint8Array.from(d0);
  }
  t0.wrapCipher = (d0, h0) => (Object.assign(h0, d0), h0);
}(fe$1);
var _e = {}, Ce = {};
Object.defineProperty(Ce, "__esModule", { value: !0 }), Ce.AEAD_TAG_LENGTH = Ce.XCHACHA20_NONCE_LENGTH = Ce.CURVE25519_PUBLIC_KEY_SIZE = Ce.ETH_PUBLIC_KEY_SIZE = Ce.UNCOMPRESSED_PUBLIC_KEY_SIZE = Ce.COMPRESSED_PUBLIC_KEY_SIZE = Ce.SECRET_KEY_LENGTH = void 0, Ce.SECRET_KEY_LENGTH = 32, Ce.COMPRESSED_PUBLIC_KEY_SIZE = 33, Ce.UNCOMPRESSED_PUBLIC_KEY_SIZE = 65, Ce.ETH_PUBLIC_KEY_SIZE = 64, Ce.CURVE25519_PUBLIC_KEY_SIZE = 32, Ce.XCHACHA20_NONCE_LENGTH = 24, Ce.AEAD_TAG_LENGTH = 16, function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.ephemeralKeySize = t0.symmetricNonceLength = t0.symmetricAlgorithm = t0.isHkdfKeyCompressed = t0.isEphemeralKeyCompressed = t0.ellipticCurve = t0.ECIES_CONFIG = void 0;
  var e0 = Ce, n0 = function() {
    this.ellipticCurve = "secp256k1", this.isEphemeralKeyCompressed = !1, this.isHkdfKeyCompressed = !1, this.symmetricAlgorithm = "aes-256-gcm", this.symmetricNonceLength = 16;
  };
  t0.ECIES_CONFIG = new n0(), t0.ellipticCurve = function() {
    return t0.ECIES_CONFIG.ellipticCurve;
  }, t0.isEphemeralKeyCompressed = function() {
    return t0.ECIES_CONFIG.isEphemeralKeyCompressed;
  }, t0.isHkdfKeyCompressed = function() {
    return t0.ECIES_CONFIG.isHkdfKeyCompressed;
  }, t0.symmetricAlgorithm = function() {
    return t0.ECIES_CONFIG.symmetricAlgorithm;
  }, t0.symmetricNonceLength = function() {
    return t0.ECIES_CONFIG.symmetricNonceLength;
  }, t0.ephemeralKeySize = function() {
    var r0 = { secp256k1: t0.ECIES_CONFIG.isEphemeralKeyCompressed ? e0.COMPRESSED_PUBLIC_KEY_SIZE : e0.UNCOMPRESSED_PUBLIC_KEY_SIZE, x25519: e0.CURVE25519_PUBLIC_KEY_SIZE, ed25519: e0.CURVE25519_PUBLIC_KEY_SIZE };
    if (t0.ECIES_CONFIG.ellipticCurve in r0)
      return r0[t0.ECIES_CONFIG.ellipticCurve];
    throw new Error("Not implemented");
  };
}(_e);
var ke = {}, xe = {}, Me$1 = {}, Ae = {}, Ie = {}, Re$1 = {};
Object.defineProperty(Re$1, "__esModule", { value: !0 }), Re$1.crypto = void 0, Re$1.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0, function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.gcm = t0.ctr = t0.cbc = t0.utils = void 0, t0.randomBytes = i0, t0.getWebcryptoSubtle = o0, t0.managedNonce = function(c0) {
    return (0, n0.number)(c0.nonceLength), (l0, ...u0) => ({ encrypt(d0, ...h0) {
      const { nonceLength: g0 } = c0, w0 = i0(g0), y0 = c0(l0, w0, ...u0).encrypt(d0, ...h0), E0 = (0, r0.concatBytes)(w0, y0);
      return y0.fill(0), E0;
    }, decrypt(d0, ...h0) {
      const { nonceLength: g0 } = c0, w0 = d0.subarray(0, g0), y0 = d0.subarray(g0);
      return c0(l0, w0, ...u0).decrypt(y0, ...h0);
    } });
  };
  const e0 = Re$1, n0 = pe, r0 = fe$1;
  function i0(c0 = 32) {
    if (e0.crypto && typeof e0.crypto.getRandomValues == "function")
      return e0.crypto.getRandomValues(new Uint8Array(c0));
    if (e0.crypto && typeof e0.crypto.randomBytes == "function")
      return e0.crypto.randomBytes(c0);
    throw new Error("crypto.getRandomValues must be defined");
  }
  function o0() {
    if (e0.crypto && typeof e0.crypto.subtle == "object" && e0.crypto.subtle != null)
      return e0.crypto.subtle;
    throw new Error("crypto.subtle must be defined");
  }
  t0.utils = { async encrypt(c0, l0, u0, d0) {
    const h0 = o0(), g0 = await h0.importKey("raw", c0, l0, !0, ["encrypt"]), w0 = await h0.encrypt(u0, g0, d0);
    return new Uint8Array(w0);
  }, async decrypt(c0, l0, u0, d0) {
    const h0 = o0(), g0 = await h0.importKey("raw", c0, l0, !0, ["decrypt"]), w0 = await h0.decrypt(u0, g0, d0);
    return new Uint8Array(w0);
  } };
  const s0 = { CBC: "AES-CBC", CTR: "AES-CTR", GCM: "AES-GCM" };
  function a0(c0) {
    return (l0, u0, d0) => {
      (0, n0.bytes)(l0), (0, n0.bytes)(u0);
      const h0 = { name: c0, length: 8 * l0.length }, g0 = function(w0, y0, E0) {
        if (w0 === s0.CBC)
          return { name: s0.CBC, iv: y0 };
        if (w0 === s0.CTR)
          return { name: s0.CTR, counter: y0, length: 64 };
        if (w0 === s0.GCM)
          return E0 ? { name: s0.GCM, iv: y0, additionalData: E0 } : { name: s0.GCM, iv: y0 };
        throw new Error("unknown aes block mode");
      }(c0, u0, d0);
      return { encrypt: (w0) => ((0, n0.bytes)(w0), t0.utils.encrypt(l0, h0, g0, w0)), decrypt: (w0) => ((0, n0.bytes)(w0), t0.utils.decrypt(l0, h0, g0, w0)) };
    };
  }
  t0.cbc = a0(s0.CBC), t0.ctr = a0(s0.CTR), t0.gcm = a0(s0.GCM);
}(Ie);
var Pe$1 = {}, Te$1 = {}, Oe$1 = {}, Le$1 = {};
function Ne$1(t0) {
  if (!Number.isSafeInteger(t0) || t0 < 0)
    throw new Error(`positive integer expected, not ${t0}`);
}
function $e$1(t0) {
  if (typeof t0 != "boolean")
    throw new Error(`boolean expected, not ${t0}`);
}
function De$1(t0) {
  return t0 instanceof Uint8Array || t0 != null && typeof t0 == "object" && t0.constructor.name === "Uint8Array";
}
function Be$1(t0, ...e0) {
  if (!De$1(t0))
    throw new Error("Uint8Array expected");
  if (e0.length > 0 && !e0.includes(t0.length))
    throw new Error(`Uint8Array expected of length ${e0}, not of length=${t0.length}`);
}
function Ke$1(t0) {
  if (typeof t0 != "function" || typeof t0.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Ne$1(t0.outputLen), Ne$1(t0.blockLen);
}
function je$1(t0, e0 = !0) {
  if (t0.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e0 && t0.finished)
    throw new Error("Hash#digest() has already been called");
}
function Ue$1(t0, e0) {
  Be$1(t0);
  const n0 = e0.outputLen;
  if (t0.length < n0)
    throw new Error(`digestInto() expects output buffer of length at least ${n0}`);
}
Object.defineProperty(Le$1, "__esModule", { value: !0 }), Le$1.isBytes = De$1, Le$1.number = Ne$1, Le$1.bool = $e$1, Le$1.bytes = Be$1, Le$1.hash = Ke$1, Le$1.exists = je$1, Le$1.output = Ue$1;
const He$1 = { number: Ne$1, bool: $e$1, bytes: Be$1, hash: Ke$1, exists: je$1, output: Ue$1 };
Le$1.default = He$1;
var Fe$1 = {}, ze$1 = {};
Object.defineProperty(ze$1, "__esModule", { value: !0 }), ze$1.crypto = void 0, ze$1.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0, function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.Hash = t0.nextTick = t0.byteSwapIfBE = t0.byteSwap = t0.isLE = t0.rotl = t0.rotr = t0.createView = t0.u32 = t0.u8 = void 0, t0.isBytes = function(l0) {
    return l0 instanceof Uint8Array || l0 != null && typeof l0 == "object" && l0.constructor.name === "Uint8Array";
  }, t0.byteSwap32 = function(l0) {
    for (let u0 = 0; u0 < l0.length; u0++)
      l0[u0] = (0, t0.byteSwap)(l0[u0]);
  }, t0.bytesToHex = function(l0) {
    (0, n0.bytes)(l0);
    let u0 = "";
    for (let d0 = 0; d0 < l0.length; d0++)
      u0 += r0[l0[d0]];
    return u0;
  }, t0.hexToBytes = function(l0) {
    if (typeof l0 != "string")
      throw new Error("hex string expected, got " + typeof l0);
    const u0 = l0.length, d0 = u0 / 2;
    if (u0 % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + u0);
    const h0 = new Uint8Array(d0);
    for (let g0 = 0, w0 = 0; g0 < d0; g0++, w0 += 2) {
      const y0 = o0(l0.charCodeAt(w0)), E0 = o0(l0.charCodeAt(w0 + 1));
      if (y0 === void 0 || E0 === void 0) {
        const b0 = l0[w0] + l0[w0 + 1];
        throw new Error('hex string expected, got non-hex character "' + b0 + '" at index ' + w0);
      }
      h0[g0] = 16 * y0 + E0;
    }
    return h0;
  }, t0.asyncLoop = async function(l0, u0, d0) {
    let h0 = Date.now();
    for (let g0 = 0; g0 < l0; g0++) {
      d0(g0);
      const w0 = Date.now() - h0;
      w0 >= 0 && w0 < u0 || (await (0, t0.nextTick)(), h0 += w0);
    }
  }, t0.utf8ToBytes = s0, t0.toBytes = a0, t0.concatBytes = function(...l0) {
    let u0 = 0;
    for (let h0 = 0; h0 < l0.length; h0++) {
      const g0 = l0[h0];
      (0, n0.bytes)(g0), u0 += g0.length;
    }
    const d0 = new Uint8Array(u0);
    for (let h0 = 0, g0 = 0; h0 < l0.length; h0++) {
      const w0 = l0[h0];
      d0.set(w0, g0), g0 += w0.length;
    }
    return d0;
  }, t0.checkOpts = function(l0, u0) {
    if (u0 !== void 0 && c0.call(u0) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(l0, u0);
  }, t0.wrapConstructor = function(l0) {
    const u0 = (h0) => l0().update(a0(h0)).digest(), d0 = l0();
    return u0.outputLen = d0.outputLen, u0.blockLen = d0.blockLen, u0.create = () => l0(), u0;
  }, t0.wrapConstructorWithOpts = function(l0) {
    const u0 = (h0, g0) => l0(g0).update(a0(h0)).digest(), d0 = l0({});
    return u0.outputLen = d0.outputLen, u0.blockLen = d0.blockLen, u0.create = (h0) => l0(h0), u0;
  }, t0.wrapXOFConstructorWithOpts = function(l0) {
    const u0 = (h0, g0) => l0(g0).update(a0(h0)).digest(), d0 = l0({});
    return u0.outputLen = d0.outputLen, u0.blockLen = d0.blockLen, u0.create = (h0) => l0(h0), u0;
  }, t0.randomBytes = function(l0 = 32) {
    if (e0.crypto && typeof e0.crypto.getRandomValues == "function")
      return e0.crypto.getRandomValues(new Uint8Array(l0));
    if (e0.crypto && typeof e0.crypto.randomBytes == "function")
      return e0.crypto.randomBytes(l0);
    throw new Error("crypto.getRandomValues must be defined");
  };
  const e0 = ze$1, n0 = Le$1;
  t0.u8 = (l0) => new Uint8Array(l0.buffer, l0.byteOffset, l0.byteLength), t0.u32 = (l0) => new Uint32Array(l0.buffer, l0.byteOffset, Math.floor(l0.byteLength / 4)), t0.createView = (l0) => new DataView(l0.buffer, l0.byteOffset, l0.byteLength), t0.rotr = (l0, u0) => l0 << 32 - u0 | l0 >>> u0, t0.rotl = (l0, u0) => l0 << u0 | l0 >>> 32 - u0 >>> 0, t0.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, t0.byteSwap = (l0) => l0 << 24 & 4278190080 | l0 << 8 & 16711680 | l0 >>> 8 & 65280 | l0 >>> 24 & 255, t0.byteSwapIfBE = t0.isLE ? (l0) => l0 : (l0) => (0, t0.byteSwap)(l0);
  const r0 = Array.from({ length: 256 }, (l0, u0) => u0.toString(16).padStart(2, "0")), i0 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function o0(l0) {
    return l0 >= i0._0 && l0 <= i0._9 ? l0 - i0._0 : l0 >= i0._A && l0 <= i0._F ? l0 - (i0._A - 10) : l0 >= i0._a && l0 <= i0._f ? l0 - (i0._a - 10) : void 0;
  }
  function s0(l0) {
    if (typeof l0 != "string")
      throw new Error("utf8ToBytes expected string, got " + typeof l0);
    return new Uint8Array(new TextEncoder().encode(l0));
  }
  function a0(l0) {
    return typeof l0 == "string" && (l0 = s0(l0)), (0, n0.bytes)(l0), l0;
  }
  t0.nextTick = async () => {
  }, t0.Hash = class {
    clone() {
      return this._cloneInto();
    }
  };
  const c0 = {}.toString;
}(Fe$1), Object.defineProperty(Oe$1, "__esModule", { value: !0 }), Oe$1.HashMD = Oe$1.Maj = Oe$1.Chi = void 0;
const qe$1 = Le$1, We$1 = Fe$1;
Oe$1.Chi = (t0, e0, n0) => t0 & e0 ^ ~t0 & n0;
Oe$1.Maj = (t0, e0, n0) => t0 & e0 ^ t0 & n0 ^ e0 & n0;
Oe$1.HashMD = class extends We$1.Hash {
  constructor(t0, e0, n0, r0) {
    super(), this.blockLen = t0, this.outputLen = e0, this.padOffset = n0, this.isLE = r0, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t0), this.view = (0, We$1.createView)(this.buffer);
  }
  update(t0) {
    (0, qe$1.exists)(this);
    const { view: e0, buffer: n0, blockLen: r0 } = this, i0 = (t0 = (0, We$1.toBytes)(t0)).length;
    for (let o0 = 0; o0 < i0; ) {
      const s0 = Math.min(r0 - this.pos, i0 - o0);
      if (s0 !== r0)
        n0.set(t0.subarray(o0, o0 + s0), this.pos), this.pos += s0, o0 += s0, this.pos === r0 && (this.process(e0, 0), this.pos = 0);
      else {
        const a0 = (0, We$1.createView)(t0);
        for (; r0 <= i0 - o0; o0 += r0)
          this.process(a0, o0);
      }
    }
    return this.length += t0.length, this.roundClean(), this;
  }
  digestInto(t0) {
    (0, qe$1.exists)(this), (0, qe$1.output)(t0, this), this.finished = !0;
    const { buffer: e0, view: n0, blockLen: r0, isLE: i0 } = this;
    let { pos: o0 } = this;
    e0[o0++] = 128, this.buffer.subarray(o0).fill(0), this.padOffset > r0 - o0 && (this.process(n0, 0), o0 = 0);
    for (let u0 = o0; u0 < r0; u0++)
      e0[u0] = 0;
    (function(u0, d0, h0, g0) {
      if (typeof u0.setBigUint64 == "function")
        return u0.setBigUint64(d0, h0, g0);
      const w0 = BigInt(32), y0 = BigInt(4294967295), E0 = Number(h0 >> w0 & y0), b0 = Number(h0 & y0), O0 = g0 ? 4 : 0, S0 = g0 ? 0 : 4;
      u0.setUint32(d0 + O0, E0, g0), u0.setUint32(d0 + S0, b0, g0);
    })(n0, r0 - 8, BigInt(8 * this.length), i0), this.process(n0, 0);
    const s0 = (0, We$1.createView)(t0), a0 = this.outputLen;
    if (a0 % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c0 = a0 / 4, l0 = this.get();
    if (c0 > l0.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let u0 = 0; u0 < c0; u0++)
      s0.setUint32(4 * u0, l0[u0], i0);
  }
  digest() {
    const { buffer: t0, outputLen: e0 } = this;
    this.digestInto(t0);
    const n0 = t0.slice(0, e0);
    return this.destroy(), n0;
  }
  _cloneInto(t0) {
    t0 || (t0 = new this.constructor()), t0.set(...this.get());
    const { blockLen: e0, buffer: n0, length: r0, finished: i0, destroyed: o0, pos: s0 } = this;
    return t0.length = r0, t0.pos = s0, t0.finished = i0, t0.destroyed = o0, r0 % e0 && t0.buffer.set(n0), t0;
  }
};
var Ve$1 = {};
Object.defineProperty(Ve$1, "__esModule", { value: !0 }), Ve$1.add5L = Ve$1.add5H = Ve$1.add4H = Ve$1.add4L = Ve$1.add3H = Ve$1.add3L = Ve$1.rotlBL = Ve$1.rotlBH = Ve$1.rotlSL = Ve$1.rotlSH = Ve$1.rotr32L = Ve$1.rotr32H = Ve$1.rotrBL = Ve$1.rotrBH = Ve$1.rotrSL = Ve$1.rotrSH = Ve$1.shrSL = Ve$1.shrSH = Ve$1.toBig = void 0, Ve$1.fromBig = Ze$1, Ve$1.split = Je$1, Ve$1.add = ut$1;
const Ge$1 = BigInt(2 ** 32 - 1), Ye$1 = BigInt(32);
function Ze$1(t0, e0 = !1) {
  return e0 ? { h: Number(t0 & Ge$1), l: Number(t0 >> Ye$1 & Ge$1) } : { h: 0 | Number(t0 >> Ye$1 & Ge$1), l: 0 | Number(t0 & Ge$1) };
}
function Je$1(t0, e0 = !1) {
  let n0 = new Uint32Array(t0.length), r0 = new Uint32Array(t0.length);
  for (let i0 = 0; i0 < t0.length; i0++) {
    const { h: o0, l: s0 } = Ze$1(t0[i0], e0);
    [n0[i0], r0[i0]] = [o0, s0];
  }
  return [n0, r0];
}
const Xe$1 = (t0, e0) => BigInt(t0 >>> 0) << Ye$1 | BigInt(e0 >>> 0);
Ve$1.toBig = Xe$1;
const Qe$1 = (t0, e0, n0) => t0 >>> n0;
Ve$1.shrSH = Qe$1;
const et$1 = (t0, e0, n0) => t0 << 32 - n0 | e0 >>> n0;
Ve$1.shrSL = et$1;
const tt$1 = (t0, e0, n0) => t0 >>> n0 | e0 << 32 - n0;
Ve$1.rotrSH = tt$1;
const nt$1 = (t0, e0, n0) => t0 << 32 - n0 | e0 >>> n0;
Ve$1.rotrSL = nt$1;
const rt$1 = (t0, e0, n0) => t0 << 64 - n0 | e0 >>> n0 - 32;
Ve$1.rotrBH = rt$1;
const it$1 = (t0, e0, n0) => t0 >>> n0 - 32 | e0 << 64 - n0;
Ve$1.rotrBL = it$1;
const ot$1 = (t0, e0) => e0;
Ve$1.rotr32H = ot$1;
const st$1 = (t0, e0) => t0;
Ve$1.rotr32L = st$1;
const at$1 = (t0, e0, n0) => t0 << n0 | e0 >>> 32 - n0;
Ve$1.rotlSH = at$1;
const ct$1 = (t0, e0, n0) => e0 << n0 | t0 >>> 32 - n0;
Ve$1.rotlSL = ct$1;
const lt$1 = (t0, e0, n0) => e0 << n0 - 32 | t0 >>> 64 - n0;
Ve$1.rotlBH = lt$1;
const dt$1 = (t0, e0, n0) => t0 << n0 - 32 | e0 >>> 64 - n0;
function ut$1(t0, e0, n0, r0) {
  const i0 = (e0 >>> 0) + (r0 >>> 0);
  return { h: t0 + n0 + (i0 / 2 ** 32 | 0) | 0, l: 0 | i0 };
}
Ve$1.rotlBL = dt$1;
const ht$1 = (t0, e0, n0) => (t0 >>> 0) + (e0 >>> 0) + (n0 >>> 0);
Ve$1.add3L = ht$1;
const ft$1 = (t0, e0, n0, r0) => e0 + n0 + r0 + (t0 / 2 ** 32 | 0) | 0;
Ve$1.add3H = ft$1;
const pt$1 = (t0, e0, n0, r0) => (t0 >>> 0) + (e0 >>> 0) + (n0 >>> 0) + (r0 >>> 0);
Ve$1.add4L = pt$1;
const gt$1 = (t0, e0, n0, r0, i0) => e0 + n0 + r0 + i0 + (t0 / 2 ** 32 | 0) | 0;
Ve$1.add4H = gt$1;
const mt$1 = (t0, e0, n0, r0, i0) => (t0 >>> 0) + (e0 >>> 0) + (n0 >>> 0) + (r0 >>> 0) + (i0 >>> 0);
Ve$1.add5L = mt$1;
const yt$1 = (t0, e0, n0, r0, i0, o0) => e0 + n0 + r0 + i0 + o0 + (t0 / 2 ** 32 | 0) | 0;
Ve$1.add5H = yt$1;
const vt$1 = { fromBig: Ze$1, split: Je$1, toBig: Xe$1, shrSH: Qe$1, shrSL: et$1, rotrSH: tt$1, rotrSL: nt$1, rotrBH: rt$1, rotrBL: it$1, rotr32H: ot$1, rotr32L: st$1, rotlSH: at$1, rotlSL: ct$1, rotlBH: lt$1, rotlBL: dt$1, add: ut$1, add3L: ht$1, add3H: ft$1, add4L: pt$1, add4H: gt$1, add5H: yt$1, add5L: mt$1 };
Ve$1.default = vt$1, Object.defineProperty(Te$1, "__esModule", { value: !0 }), Te$1.sha384 = Te$1.sha512_256 = Te$1.sha512_224 = Te$1.sha512 = Te$1.SHA384 = Te$1.SHA512_256 = Te$1.SHA512_224 = Te$1.SHA512 = void 0;
const bt$1 = Oe$1, wt$1 = Ve$1, Et$1 = Fe$1, [St$1, _t$1] = (() => wt$1.default.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t0) => BigInt(t0))))(), Ct$1 = new Uint32Array(80), kt$1 = new Uint32Array(80);
let xt$1 = class extends bt$1.HashMD {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: e0, Al: n0, Bh: r0, Bl: i0, Ch: o0, Cl: s0, Dh: a0, Dl: c0, Eh: l0, El: u0, Fh: d0, Fl: h0, Gh: g0, Gl: w0, Hh: y0, Hl: E0 } = this;
    return [e0, n0, r0, i0, o0, s0, a0, c0, l0, u0, d0, h0, g0, w0, y0, E0];
  }
  set(e0, n0, r0, i0, o0, s0, a0, c0, l0, u0, d0, h0, g0, w0, y0, E0) {
    this.Ah = 0 | e0, this.Al = 0 | n0, this.Bh = 0 | r0, this.Bl = 0 | i0, this.Ch = 0 | o0, this.Cl = 0 | s0, this.Dh = 0 | a0, this.Dl = 0 | c0, this.Eh = 0 | l0, this.El = 0 | u0, this.Fh = 0 | d0, this.Fl = 0 | h0, this.Gh = 0 | g0, this.Gl = 0 | w0, this.Hh = 0 | y0, this.Hl = 0 | E0;
  }
  process(e0, n0) {
    for (let S0 = 0; S0 < 16; S0++, n0 += 4)
      Ct$1[S0] = e0.getUint32(n0), kt$1[S0] = e0.getUint32(n0 += 4);
    for (let S0 = 16; S0 < 80; S0++) {
      const k0 = 0 | Ct$1[S0 - 15], D0 = 0 | kt$1[S0 - 15], z0 = wt$1.default.rotrSH(k0, D0, 1) ^ wt$1.default.rotrSH(k0, D0, 8) ^ wt$1.default.shrSH(k0, D0, 7), G0 = wt$1.default.rotrSL(k0, D0, 1) ^ wt$1.default.rotrSL(k0, D0, 8) ^ wt$1.default.shrSL(k0, D0, 7), K0 = 0 | Ct$1[S0 - 2], U0 = 0 | kt$1[S0 - 2], F0 = wt$1.default.rotrSH(K0, U0, 19) ^ wt$1.default.rotrBH(K0, U0, 61) ^ wt$1.default.shrSH(K0, U0, 6), H0 = wt$1.default.rotrSL(K0, U0, 19) ^ wt$1.default.rotrBL(K0, U0, 61) ^ wt$1.default.shrSL(K0, U0, 6), P0 = wt$1.default.add4L(G0, H0, kt$1[S0 - 7], kt$1[S0 - 16]), I0 = wt$1.default.add4H(P0, z0, F0, Ct$1[S0 - 7], Ct$1[S0 - 16]);
      Ct$1[S0] = 0 | I0, kt$1[S0] = 0 | P0;
    }
    let { Ah: r0, Al: i0, Bh: o0, Bl: s0, Ch: a0, Cl: c0, Dh: l0, Dl: u0, Eh: d0, El: h0, Fh: g0, Fl: w0, Gh: y0, Gl: E0, Hh: b0, Hl: O0 } = this;
    for (let S0 = 0; S0 < 80; S0++) {
      const k0 = wt$1.default.rotrSH(d0, h0, 14) ^ wt$1.default.rotrSH(d0, h0, 18) ^ wt$1.default.rotrBH(d0, h0, 41), D0 = wt$1.default.rotrSL(d0, h0, 14) ^ wt$1.default.rotrSL(d0, h0, 18) ^ wt$1.default.rotrBL(d0, h0, 41), z0 = d0 & g0 ^ ~d0 & y0, G0 = h0 & w0 ^ ~h0 & E0, K0 = wt$1.default.add5L(O0, D0, G0, _t$1[S0], kt$1[S0]), U0 = wt$1.default.add5H(K0, b0, k0, z0, St$1[S0], Ct$1[S0]), F0 = 0 | K0, H0 = wt$1.default.rotrSH(r0, i0, 28) ^ wt$1.default.rotrBH(r0, i0, 34) ^ wt$1.default.rotrBH(r0, i0, 39), P0 = wt$1.default.rotrSL(r0, i0, 28) ^ wt$1.default.rotrBL(r0, i0, 34) ^ wt$1.default.rotrBL(r0, i0, 39), I0 = r0 & o0 ^ r0 & a0 ^ o0 & a0, f0 = i0 & s0 ^ i0 & c0 ^ s0 & c0;
      b0 = 0 | y0, O0 = 0 | E0, y0 = 0 | g0, E0 = 0 | w0, g0 = 0 | d0, w0 = 0 | h0, { h: d0, l: h0 } = wt$1.default.add(0 | l0, 0 | u0, 0 | U0, 0 | F0), l0 = 0 | a0, u0 = 0 | c0, a0 = 0 | o0, c0 = 0 | s0, o0 = 0 | r0, s0 = 0 | i0;
      const m0 = wt$1.default.add3L(F0, P0, f0);
      r0 = wt$1.default.add3H(m0, U0, H0, I0), i0 = 0 | m0;
    }
    ({ h: r0, l: i0 } = wt$1.default.add(0 | this.Ah, 0 | this.Al, 0 | r0, 0 | i0)), { h: o0, l: s0 } = wt$1.default.add(0 | this.Bh, 0 | this.Bl, 0 | o0, 0 | s0), { h: a0, l: c0 } = wt$1.default.add(0 | this.Ch, 0 | this.Cl, 0 | a0, 0 | c0), { h: l0, l: u0 } = wt$1.default.add(0 | this.Dh, 0 | this.Dl, 0 | l0, 0 | u0), { h: d0, l: h0 } = wt$1.default.add(0 | this.Eh, 0 | this.El, 0 | d0, 0 | h0), { h: g0, l: w0 } = wt$1.default.add(0 | this.Fh, 0 | this.Fl, 0 | g0, 0 | w0), { h: y0, l: E0 } = wt$1.default.add(0 | this.Gh, 0 | this.Gl, 0 | y0, 0 | E0), { h: b0, l: O0 } = wt$1.default.add(0 | this.Hh, 0 | this.Hl, 0 | b0, 0 | O0), this.set(r0, i0, o0, s0, a0, c0, l0, u0, d0, h0, g0, w0, y0, E0, b0, O0);
  }
  roundClean() {
    Ct$1.fill(0), kt$1.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
Te$1.SHA512 = xt$1;
let Mt$1 = class extends xt$1 {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
};
Te$1.SHA512_224 = Mt$1;
let At$1 = class extends xt$1 {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
};
Te$1.SHA512_256 = At$1;
let It$1 = class extends xt$1 {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
};
Te$1.SHA384 = It$1, Te$1.sha512 = (0, Et$1.wrapConstructor)(() => new xt$1()), Te$1.sha512_224 = (0, Et$1.wrapConstructor)(() => new Mt$1()), Te$1.sha512_256 = (0, Et$1.wrapConstructor)(() => new At$1()), Te$1.sha384 = (0, Et$1.wrapConstructor)(() => new It$1());
var Rt$1 = {}, Pt$1 = {}, Tt$1 = {}, Ot = {};
Object.defineProperty(Ot, "__esModule", { value: !0 }), Ot.notImplemented = Ot.bitMask = void 0, Ot.isBytes = Dt$1, Ot.abytes = Bt$1, Ot.abool = function(t0, e0) {
  if (typeof e0 != "boolean")
    throw new Error(`${t0} must be valid boolean, got "${e0}".`);
}, Ot.bytesToHex = jt, Ot.numberToHexUnpadded = Ut$1, Ot.hexToNumber = Ht$1, Ot.hexToBytes = qt, Ot.bytesToNumberBE = function(t0) {
  return Ht$1(jt(t0));
}, Ot.bytesToNumberLE = function(t0) {
  return Bt$1(t0), Ht$1(jt(Uint8Array.from(t0).reverse()));
}, Ot.numberToBytesBE = Wt, Ot.numberToBytesLE = function(t0, e0) {
  return Wt(t0, e0).reverse();
}, Ot.numberToVarBytesBE = function(t0) {
  return qt(Ut$1(t0));
}, Ot.ensureBytes = function(t0, e0, n0) {
  let r0;
  if (typeof e0 == "string")
    try {
      r0 = qt(e0);
    } catch (o0) {
      throw new Error(`${t0} must be valid hex string, got "${e0}". Cause: ${o0}`);
    }
  else {
    if (!Dt$1(e0))
      throw new Error(`${t0} must be hex string or Uint8Array`);
    r0 = Uint8Array.from(e0);
  }
  const i0 = r0.length;
  if (typeof n0 == "number" && i0 !== n0)
    throw new Error(`${t0} expected ${n0} bytes, got ${i0}`);
  return r0;
}, Ot.concatBytes = Vt, Ot.equalBytes = function(t0, e0) {
  if (t0.length !== e0.length)
    return !1;
  let n0 = 0;
  for (let r0 = 0; r0 < t0.length; r0++)
    n0 |= t0[r0] ^ e0[r0];
  return n0 === 0;
}, Ot.utf8ToBytes = function(t0) {
  if (typeof t0 != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof t0);
  return new Uint8Array(new TextEncoder().encode(t0));
}, Ot.inRange = Yt, Ot.aInRange = function(t0, e0, n0, r0) {
  if (!Yt(e0, n0, r0))
    throw new Error(`expected valid ${t0}: ${n0} <= n < ${r0}, got ${typeof e0} ${e0}`);
}, Ot.bitLen = function(t0) {
  let e0;
  for (e0 = 0; t0 > Lt; t0 >>= Nt$1, e0 += 1)
    ;
  return e0;
}, Ot.bitGet = function(t0, e0) {
  return t0 >> BigInt(e0) & Nt$1;
}, Ot.bitSet = function(t0, e0, n0) {
  return t0 | (n0 ? Nt$1 : Lt) << BigInt(e0);
}, Ot.createHmacDrbg = function(t0, e0, n0) {
  if (typeof t0 != "number" || t0 < 2)
    throw new Error("hashLen must be a number");
  if (typeof e0 != "number" || e0 < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n0 != "function")
    throw new Error("hmacFn must be a function");
  let r0 = Zt(t0), i0 = Zt(t0), o0 = 0;
  const s0 = () => {
    r0.fill(1), i0.fill(0), o0 = 0;
  }, a0 = (...u0) => n0(i0, r0, ...u0), c0 = (u0 = Zt()) => {
    i0 = a0(Jt([0]), u0), r0 = a0(), u0.length !== 0 && (i0 = a0(Jt([1]), u0), r0 = a0());
  }, l0 = () => {
    if (o0++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let u0 = 0;
    const d0 = [];
    for (; u0 < e0; ) {
      r0 = a0();
      const h0 = r0.slice();
      d0.push(h0), u0 += r0.length;
    }
    return Vt(...d0);
  };
  return (u0, d0) => {
    let h0;
    for (s0(), c0(u0); !(h0 = d0(l0())); )
      c0();
    return s0(), h0;
  };
}, Ot.validateObject = function(t0, e0, n0 = {}) {
  const r0 = (i0, o0, s0) => {
    const a0 = Xt[o0];
    if (typeof a0 != "function")
      throw new Error(`Invalid validator "${o0}", expected function`);
    const c0 = t0[i0];
    if (!(s0 && c0 === void 0 || a0(c0, t0)))
      throw new Error(`Invalid param ${String(i0)}=${c0} (${typeof c0}), expected ${o0}`);
  };
  for (const [i0, o0] of Object.entries(e0))
    r0(i0, o0, !1);
  for (const [i0, o0] of Object.entries(n0))
    r0(i0, o0, !0);
  return t0;
}, Ot.memoized = function(t0) {
  const e0 = /* @__PURE__ */ new WeakMap();
  return (n0, ...r0) => {
    const i0 = e0.get(n0);
    if (i0 !== void 0)
      return i0;
    const o0 = t0(n0, ...r0);
    return e0.set(n0, o0), o0;
  };
};
const Lt = BigInt(0), Nt$1 = BigInt(1), $t = BigInt(2);
function Dt$1(t0) {
  return t0 instanceof Uint8Array || t0 != null && typeof t0 == "object" && t0.constructor.name === "Uint8Array";
}
function Bt$1(t0) {
  if (!Dt$1(t0))
    throw new Error("Uint8Array expected");
}
const Kt = Array.from({ length: 256 }, (t0, e0) => e0.toString(16).padStart(2, "0"));
function jt(t0) {
  Bt$1(t0);
  let e0 = "";
  for (let n0 = 0; n0 < t0.length; n0++)
    e0 += Kt[t0[n0]];
  return e0;
}
function Ut$1(t0) {
  const e0 = t0.toString(16);
  return 1 & e0.length ? `0${e0}` : e0;
}
function Ht$1(t0) {
  if (typeof t0 != "string")
    throw new Error("hex string expected, got " + typeof t0);
  return BigInt(t0 === "" ? "0" : `0x${t0}`);
}
const Ft = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function zt(t0) {
  return t0 >= Ft._0 && t0 <= Ft._9 ? t0 - Ft._0 : t0 >= Ft._A && t0 <= Ft._F ? t0 - (Ft._A - 10) : t0 >= Ft._a && t0 <= Ft._f ? t0 - (Ft._a - 10) : void 0;
}
function qt(t0) {
  if (typeof t0 != "string")
    throw new Error("hex string expected, got " + typeof t0);
  const e0 = t0.length, n0 = e0 / 2;
  if (e0 % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + e0);
  const r0 = new Uint8Array(n0);
  for (let i0 = 0, o0 = 0; i0 < n0; i0++, o0 += 2) {
    const s0 = zt(t0.charCodeAt(o0)), a0 = zt(t0.charCodeAt(o0 + 1));
    if (s0 === void 0 || a0 === void 0) {
      const c0 = t0[o0] + t0[o0 + 1];
      throw new Error('hex string expected, got non-hex character "' + c0 + '" at index ' + o0);
    }
    r0[i0] = 16 * s0 + a0;
  }
  return r0;
}
function Wt(t0, e0) {
  return qt(t0.toString(16).padStart(2 * e0, "0"));
}
function Vt(...t0) {
  let e0 = 0;
  for (let r0 = 0; r0 < t0.length; r0++) {
    const i0 = t0[r0];
    Bt$1(i0), e0 += i0.length;
  }
  const n0 = new Uint8Array(e0);
  for (let r0 = 0, i0 = 0; r0 < t0.length; r0++) {
    const o0 = t0[r0];
    n0.set(o0, i0), i0 += o0.length;
  }
  return n0;
}
const Gt = (t0) => typeof t0 == "bigint" && Lt <= t0;
function Yt(t0, e0, n0) {
  return Gt(t0) && Gt(e0) && Gt(n0) && e0 <= t0 && t0 < n0;
}
Ot.bitMask = (t0) => ($t << BigInt(t0 - 1)) - Nt$1;
const Zt = (t0) => new Uint8Array(t0), Jt = (t0) => Uint8Array.from(t0), Xt = { bigint: (t0) => typeof t0 == "bigint", function: (t0) => typeof t0 == "function", boolean: (t0) => typeof t0 == "boolean", string: (t0) => typeof t0 == "string", stringOrUint8Array: (t0) => typeof t0 == "string" || Dt$1(t0), isSafeInteger: (t0) => Number.isSafeInteger(t0), array: (t0) => Array.isArray(t0), field: (t0, e0) => e0.Fp.isValid(t0), hash: (t0) => typeof t0 == "function" && Number.isSafeInteger(t0.outputLen) };
Ot.notImplemented = () => {
  throw new Error("not implemented");
}, Object.defineProperty(Tt$1, "__esModule", { value: !0 }), Tt$1.isNegativeLE = void 0, Tt$1.mod = cn, Tt$1.pow = ln, Tt$1.pow2 = function(t0, e0, n0) {
  let r0 = t0;
  for (; e0-- > en; )
    r0 *= r0, r0 %= n0;
  return r0;
}, Tt$1.invert = dn, Tt$1.tonelliShanks = un, Tt$1.FpSqrt = hn, Tt$1.validateField = function(t0) {
  const e0 = fn.reduce((n0, r0) => (n0[r0] = "function", n0), { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" });
  return (0, Qt$1.validateObject)(t0, e0);
}, Tt$1.FpPow = pn, Tt$1.FpInvertBatch = gn, Tt$1.FpDiv = function(t0, e0, n0) {
  return t0.mul(e0, typeof n0 == "bigint" ? dn(n0, t0.ORDER) : t0.inv(n0));
}, Tt$1.FpLegendre = mn, Tt$1.FpIsSquare = function(t0) {
  const e0 = mn(t0.ORDER);
  return (n0) => {
    const r0 = e0(t0, n0);
    return t0.eql(r0, t0.ZERO) || t0.eql(r0, t0.ONE);
  };
}, Tt$1.nLength = yn, Tt$1.Field = function(t0, e0, n0 = !1, r0 = {}) {
  if (t0 <= en)
    throw new Error(`Expected Field ORDER > 0, got ${t0}`);
  const { nBitLength: i0, nByteLength: o0 } = yn(t0, e0);
  if (o0 > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const s0 = hn(t0), a0 = Object.freeze({ ORDER: t0, BITS: i0, BYTES: o0, MASK: (0, Qt$1.bitMask)(i0), ZERO: en, ONE: tn, create: (c0) => cn(c0, t0), isValid: (c0) => {
    if (typeof c0 != "bigint")
      throw new Error("Invalid field element: expected bigint, got " + typeof c0);
    return en <= c0 && c0 < t0;
  }, is0: (c0) => c0 === en, isOdd: (c0) => (c0 & tn) === tn, neg: (c0) => cn(-c0, t0), eql: (c0, l0) => c0 === l0, sqr: (c0) => cn(c0 * c0, t0), add: (c0, l0) => cn(c0 + l0, t0), sub: (c0, l0) => cn(c0 - l0, t0), mul: (c0, l0) => cn(c0 * l0, t0), pow: (c0, l0) => pn(a0, c0, l0), div: (c0, l0) => cn(c0 * dn(l0, t0), t0), sqrN: (c0) => c0 * c0, addN: (c0, l0) => c0 + l0, subN: (c0, l0) => c0 - l0, mulN: (c0, l0) => c0 * l0, inv: (c0) => dn(c0, t0), sqrt: r0.sqrt || ((c0) => s0(a0, c0)), invertBatch: (c0) => gn(a0, c0), cmov: (c0, l0, u0) => u0 ? l0 : c0, toBytes: (c0) => n0 ? (0, Qt$1.numberToBytesLE)(c0, o0) : (0, Qt$1.numberToBytesBE)(c0, o0), fromBytes: (c0) => {
    if (c0.length !== o0)
      throw new Error(`Fp.fromBytes: expected ${o0}, got ${c0.length}`);
    return n0 ? (0, Qt$1.bytesToNumberLE)(c0) : (0, Qt$1.bytesToNumberBE)(c0);
  } });
  return Object.freeze(a0);
}, Tt$1.FpSqrtOdd = function(t0, e0) {
  if (!t0.isOdd)
    throw new Error("Field doesn't have isOdd");
  const n0 = t0.sqrt(e0);
  return t0.isOdd(n0) ? n0 : t0.neg(n0);
}, Tt$1.FpSqrtEven = function(t0, e0) {
  if (!t0.isOdd)
    throw new Error("Field doesn't have isOdd");
  const n0 = t0.sqrt(e0);
  return t0.isOdd(n0) ? t0.neg(n0) : n0;
}, Tt$1.hashToPrivateScalar = function(t0, e0, n0 = !1) {
  t0 = (0, Qt$1.ensureBytes)("privateHash", t0);
  const r0 = t0.length, i0 = yn(e0).nByteLength + 8;
  if (i0 < 24 || r0 < i0 || r0 > 1024)
    throw new Error(`hashToPrivateScalar: expected ${i0}-1024 bytes of input, got ${r0}`);
  const o0 = n0 ? (0, Qt$1.bytesToNumberLE)(t0) : (0, Qt$1.bytesToNumberBE)(t0);
  return cn(o0, e0 - tn) + tn;
}, Tt$1.getFieldBytesLength = vn, Tt$1.getMinHashLength = bn$1, Tt$1.mapHashToField = function(t0, e0, n0 = !1) {
  const r0 = t0.length, i0 = vn(e0), o0 = bn$1(e0);
  if (r0 < 16 || r0 < o0 || r0 > 1024)
    throw new Error(`expected ${o0}-1024 bytes of input, got ${r0}`);
  const s0 = cn(n0 ? (0, Qt$1.bytesToNumberBE)(t0) : (0, Qt$1.bytesToNumberLE)(t0), e0 - tn) + tn;
  return n0 ? (0, Qt$1.numberToBytesLE)(s0, i0) : (0, Qt$1.numberToBytesBE)(s0, i0);
};
const Qt$1 = Ot, en = BigInt(0), tn = BigInt(1), nn = BigInt(2), rn = BigInt(3), on = BigInt(4), sn = BigInt(5), an = BigInt(8);
function cn(t0, e0) {
  const n0 = t0 % e0;
  return n0 >= en ? n0 : e0 + n0;
}
function ln(t0, e0, n0) {
  if (n0 <= en || e0 < en)
    throw new Error("Expected power/modulo > 0");
  if (n0 === tn)
    return en;
  let r0 = tn;
  for (; e0 > en; )
    e0 & tn && (r0 = r0 * t0 % n0), t0 = t0 * t0 % n0, e0 >>= tn;
  return r0;
}
function dn(t0, e0) {
  if (t0 === en || e0 <= en)
    throw new Error(`invert: expected positive integers, got n=${t0} mod=${e0}`);
  let n0 = cn(t0, e0), r0 = e0, i0 = en, o0 = tn;
  for (; n0 !== en; ) {
    const s0 = r0 % n0, a0 = i0 - o0 * (r0 / n0);
    r0 = n0, n0 = s0, i0 = o0, o0 = a0;
  }
  if (r0 !== tn)
    throw new Error("invert: does not exist");
  return cn(i0, e0);
}
function un(t0) {
  const e0 = (t0 - tn) / nn;
  let n0, r0, i0;
  for (n0 = t0 - tn, r0 = 0; n0 % nn === en; n0 /= nn, r0++)
    ;
  for (i0 = nn; i0 < t0 && ln(i0, e0, t0) !== t0 - tn; i0++)
    ;
  if (r0 === 1) {
    const s0 = (t0 + tn) / on;
    return function(a0, c0) {
      const l0 = a0.pow(c0, s0);
      if (!a0.eql(a0.sqr(l0), c0))
        throw new Error("Cannot find square root");
      return l0;
    };
  }
  const o0 = (n0 + tn) / nn;
  return function(s0, a0) {
    if (s0.pow(a0, e0) === s0.neg(s0.ONE))
      throw new Error("Cannot find square root");
    let c0 = r0, l0 = s0.pow(s0.mul(s0.ONE, i0), n0), u0 = s0.pow(a0, o0), d0 = s0.pow(a0, n0);
    for (; !s0.eql(d0, s0.ONE); ) {
      if (s0.eql(d0, s0.ZERO))
        return s0.ZERO;
      let h0 = 1;
      for (let w0 = s0.sqr(d0); h0 < c0 && !s0.eql(w0, s0.ONE); h0++)
        w0 = s0.sqr(w0);
      const g0 = s0.pow(l0, tn << BigInt(c0 - h0 - 1));
      l0 = s0.sqr(g0), u0 = s0.mul(u0, g0), d0 = s0.mul(d0, l0), c0 = h0;
    }
    return u0;
  };
}
function hn(t0) {
  if (t0 % on === rn) {
    const e0 = (t0 + tn) / on;
    return function(n0, r0) {
      const i0 = n0.pow(r0, e0);
      if (!n0.eql(n0.sqr(i0), r0))
        throw new Error("Cannot find square root");
      return i0;
    };
  }
  if (t0 % an === sn) {
    const e0 = (t0 - sn) / an;
    return function(n0, r0) {
      const i0 = n0.mul(r0, nn), o0 = n0.pow(i0, e0), s0 = n0.mul(r0, o0), a0 = n0.mul(n0.mul(s0, nn), o0), c0 = n0.mul(s0, n0.sub(a0, n0.ONE));
      if (!n0.eql(n0.sqr(c0), r0))
        throw new Error("Cannot find square root");
      return c0;
    };
  }
  return un(t0);
}
BigInt(9), BigInt(16);
Tt$1.isNegativeLE = (t0, e0) => (cn(t0, e0) & tn) === tn;
const fn = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function pn(t0, e0, n0) {
  if (n0 < en)
    throw new Error("Expected power > 0");
  if (n0 === en)
    return t0.ONE;
  if (n0 === tn)
    return e0;
  let r0 = t0.ONE, i0 = e0;
  for (; n0 > en; )
    n0 & tn && (r0 = t0.mul(r0, i0)), i0 = t0.sqr(i0), n0 >>= tn;
  return r0;
}
function gn(t0, e0) {
  const n0 = new Array(e0.length), r0 = e0.reduce((o0, s0, a0) => t0.is0(s0) ? o0 : (n0[a0] = o0, t0.mul(o0, s0)), t0.ONE), i0 = t0.inv(r0);
  return e0.reduceRight((o0, s0, a0) => t0.is0(s0) ? o0 : (n0[a0] = t0.mul(o0, n0[a0]), t0.mul(o0, s0)), i0), n0;
}
function mn(t0) {
  const e0 = (t0 - tn) / nn;
  return (n0, r0) => n0.pow(r0, e0);
}
function yn(t0, e0) {
  const n0 = e0 !== void 0 ? e0 : t0.toString(2).length;
  return { nBitLength: n0, nByteLength: Math.ceil(n0 / 8) };
}
function vn(t0) {
  if (typeof t0 != "bigint")
    throw new Error("field order must be bigint");
  const e0 = t0.toString(2).length;
  return Math.ceil(e0 / 8);
}
function bn$1(t0) {
  const e0 = vn(t0);
  return e0 + Math.ceil(e0 / 2);
}
Object.defineProperty(Pt$1, "__esModule", { value: !0 }), Pt$1.wNAF = function(t0, e0) {
  const n0 = (o0, s0) => {
    const a0 = s0.negate();
    return o0 ? a0 : s0;
  }, r0 = (o0) => {
    if (!Number.isSafeInteger(o0) || o0 <= 0 || o0 > e0)
      throw new Error(`Wrong window size=${o0}, should be [1..${e0}]`);
  }, i0 = (o0) => (r0(o0), { windows: Math.ceil(e0 / o0) + 1, windowSize: 2 ** (o0 - 1) });
  return { constTimeNegate: n0, unsafeLadder(o0, s0) {
    let a0 = t0.ZERO, c0 = o0;
    for (; s0 > Sn; )
      s0 & _n && (a0 = a0.add(c0)), c0 = c0.double(), s0 >>= _n;
    return a0;
  }, precomputeWindow(o0, s0) {
    const { windows: a0, windowSize: c0 } = i0(s0), l0 = [];
    let u0 = o0, d0 = u0;
    for (let h0 = 0; h0 < a0; h0++) {
      d0 = u0, l0.push(d0);
      for (let g0 = 1; g0 < c0; g0++)
        d0 = d0.add(u0), l0.push(d0);
      u0 = d0.double();
    }
    return l0;
  }, wNAF(o0, s0, a0) {
    const { windows: c0, windowSize: l0 } = i0(o0);
    let u0 = t0.ZERO, d0 = t0.BASE;
    const h0 = BigInt(2 ** o0 - 1), g0 = 2 ** o0, w0 = BigInt(o0);
    for (let y0 = 0; y0 < c0; y0++) {
      const E0 = y0 * l0;
      let b0 = Number(a0 & h0);
      a0 >>= w0, b0 > l0 && (b0 -= g0, a0 += _n);
      const O0 = E0, S0 = E0 + Math.abs(b0) - 1, k0 = y0 % 2 != 0, D0 = b0 < 0;
      b0 === 0 ? d0 = d0.add(n0(k0, s0[O0])) : u0 = u0.add(n0(D0, s0[S0]));
    }
    return { p: u0, f: d0 };
  }, wNAFCached(o0, s0, a0) {
    const c0 = kn.get(o0) || 1;
    let l0 = Cn.get(o0);
    return l0 || (l0 = this.precomputeWindow(o0, c0), c0 !== 1 && Cn.set(o0, a0(l0))), this.wNAF(c0, l0, s0);
  }, setWindowSize(o0, s0) {
    r0(s0), kn.set(o0, s0), Cn.delete(o0);
  } };
}, Pt$1.pippenger = function(t0, e0, n0, r0) {
  if (!Array.isArray(n0) || !Array.isArray(r0) || r0.length !== n0.length)
    throw new Error("arrays of points and scalars must have equal length");
  r0.forEach((u0, d0) => {
    if (!e0.isValid(u0))
      throw new Error(`wrong scalar at index ${d0}`);
  }), n0.forEach((u0, d0) => {
    if (!(u0 instanceof t0))
      throw new Error(`wrong point at index ${d0}`);
  });
  const i0 = (0, En.bitLen)(BigInt(n0.length)), o0 = i0 > 12 ? i0 - 3 : i0 > 4 ? i0 - 2 : i0 ? 2 : 1, s0 = (1 << o0) - 1, a0 = new Array(s0 + 1).fill(t0.ZERO), c0 = Math.floor((e0.BITS - 1) / o0) * o0;
  let l0 = t0.ZERO;
  for (let u0 = c0; u0 >= 0; u0 -= o0) {
    a0.fill(t0.ZERO);
    for (let h0 = 0; h0 < r0.length; h0++) {
      const g0 = r0[h0], w0 = Number(g0 >> BigInt(u0) & BigInt(s0));
      a0[w0] = a0[w0].add(n0[h0]);
    }
    let d0 = t0.ZERO;
    for (let h0 = a0.length - 1, g0 = t0.ZERO; h0 > 0; h0--)
      g0 = g0.add(a0[h0]), d0 = d0.add(g0);
    if (l0 = l0.add(d0), u0 !== 0)
      for (let h0 = 0; h0 < o0; h0++)
        l0 = l0.double();
  }
  return l0;
}, Pt$1.validateBasic = function(t0) {
  return (0, wn.validateField)(t0.Fp), (0, En.validateObject)(t0, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...(0, wn.nLength)(t0.n, t0.nBitLength), ...t0, p: t0.Fp.ORDER });
};
const wn = Tt$1, En = Ot, Sn = BigInt(0), _n = BigInt(1), Cn = /* @__PURE__ */ new WeakMap(), kn = /* @__PURE__ */ new WeakMap();
Object.defineProperty(Rt$1, "__esModule", { value: !0 }), Rt$1.twistedEdwards = function(t0) {
  const e0 = function(I0) {
    const f0 = (0, xn.validateBasic)(I0);
    return An.validateObject(I0, { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" }, { adjustScalarBytes: "function", domain: "function", uvRatio: "function", mapToCurve: "function" }), Object.freeze({ ...f0 });
  }(t0), { Fp: n0, n: r0, prehash: i0, hash: o0, randomBytes: s0, nByteLength: a0, h: c0 } = e0, l0 = Tn << BigInt(8 * a0) - Pn, u0 = n0.create, d0 = (0, Mn.Field)(e0.n, e0.nBitLength), h0 = e0.uvRatio || ((I0, f0) => {
    try {
      return { isValid: !0, value: n0.sqrt(I0 * n0.inv(f0)) };
    } catch {
      return { isValid: !1, value: Rn };
    }
  }), g0 = e0.adjustScalarBytes || ((I0) => I0), w0 = e0.domain || ((I0, f0, m0) => {
    if ((0, In.abool)("phflag", m0), f0.length || m0)
      throw new Error("Contexts/pre-hash are not supported");
    return I0;
  });
  function y0(I0, f0) {
    An.aInRange("coordinate " + I0, f0, Rn, l0);
  }
  function E0(I0) {
    if (!(I0 instanceof S0))
      throw new Error("ExtendedPoint expected");
  }
  const b0 = (0, In.memoized)((I0, f0) => {
    const { ex: m0, ey: A0, ez: x0 } = I0, _0 = I0.is0();
    f0 == null && (f0 = _0 ? On : n0.inv(x0));
    const $0 = u0(m0 * f0), C0 = u0(A0 * f0), M0 = u0(x0 * f0);
    if (_0)
      return { x: Rn, y: Pn };
    if (M0 !== Pn)
      throw new Error("invZ was invalid");
    return { x: $0, y: C0 };
  }), O0 = (0, In.memoized)((I0) => {
    const { a: f0, d: m0 } = e0;
    if (I0.is0())
      throw new Error("bad point: ZERO");
    const { ex: A0, ey: x0, ez: _0, et: $0 } = I0, C0 = u0(A0 * A0), M0 = u0(x0 * x0), p0 = u0(_0 * _0), v0 = u0(p0 * p0), T0 = u0(C0 * f0);
    if (u0(p0 * u0(T0 + M0)) !== u0(v0 + u0(m0 * u0(C0 * M0))))
      throw new Error("bad point: equation left != right (1)");
    if (u0(A0 * x0) !== u0(_0 * $0))
      throw new Error("bad point: equation left != right (2)");
    return !0;
  });
  class S0 {
    constructor(f0, m0, A0, x0) {
      this.ex = f0, this.ey = m0, this.ez = A0, this.et = x0, y0("x", f0), y0("y", m0), y0("z", A0), y0("t", x0), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(f0) {
      if (f0 instanceof S0)
        throw new Error("extended point not allowed");
      const { x: m0, y: A0 } = f0 || {};
      return y0("x", m0), y0("y", A0), new S0(m0, A0, Pn, u0(m0 * A0));
    }
    static normalizeZ(f0) {
      const m0 = n0.invertBatch(f0.map((A0) => A0.ez));
      return f0.map((A0, x0) => A0.toAffine(m0[x0])).map(S0.fromAffine);
    }
    static msm(f0, m0) {
      return (0, xn.pippenger)(S0, d0, f0, m0);
    }
    _setWindowSize(f0) {
      z0.setWindowSize(this, f0);
    }
    assertValidity() {
      O0(this);
    }
    equals(f0) {
      E0(f0);
      const { ex: m0, ey: A0, ez: x0 } = this, { ex: _0, ey: $0, ez: C0 } = f0, M0 = u0(m0 * C0), p0 = u0(_0 * x0), v0 = u0(A0 * C0), T0 = u0($0 * x0);
      return M0 === p0 && v0 === T0;
    }
    is0() {
      return this.equals(S0.ZERO);
    }
    negate() {
      return new S0(u0(-this.ex), this.ey, this.ez, u0(-this.et));
    }
    double() {
      const { a: f0 } = e0, { ex: m0, ey: A0, ez: x0 } = this, _0 = u0(m0 * m0), $0 = u0(A0 * A0), C0 = u0(Tn * u0(x0 * x0)), M0 = u0(f0 * _0), p0 = m0 + A0, v0 = u0(u0(p0 * p0) - _0 - $0), T0 = M0 + $0, L0 = T0 - C0, B0 = M0 - $0, W0 = u0(v0 * L0), V0 = u0(T0 * B0), Q0 = u0(v0 * B0), X0 = u0(L0 * T0);
      return new S0(W0, V0, X0, Q0);
    }
    add(f0) {
      E0(f0);
      const { a: m0, d: A0 } = e0, { ex: x0, ey: _0, ez: $0, et: C0 } = this, { ex: M0, ey: p0, ez: v0, et: T0 } = f0;
      if (m0 === BigInt(-1)) {
        const bg = u0((_0 - x0) * (p0 + M0)), vg = u0((_0 + x0) * (p0 - M0)), Ag = u0(vg - bg);
        if (Ag === Rn)
          return this.double();
        const Ig = u0($0 * Tn * T0), Mg = u0(C0 * Tn * v0), Sg = Mg + Ig, Ng = vg + bg, Rg = Mg - Ig, kg = u0(Sg * Ag), Dg = u0(Ng * Rg), j0 = u0(Sg * Rg), N0 = u0(Ag * Ng);
        return new S0(kg, Dg, N0, j0);
      }
      const L0 = u0(x0 * M0), B0 = u0(_0 * p0), W0 = u0(C0 * A0 * T0), V0 = u0($0 * v0), Q0 = u0((x0 + _0) * (M0 + p0) - L0 - B0), X0 = V0 - W0, J0 = V0 + W0, yg = u0(B0 - m0 * L0), _g = u0(Q0 * X0), wg = u0(J0 * yg), $g = u0(Q0 * yg), Eg = u0(X0 * J0);
      return new S0(_g, wg, Eg, $g);
    }
    subtract(f0) {
      return this.add(f0.negate());
    }
    wNAF(f0) {
      return z0.wNAFCached(this, f0, S0.normalizeZ);
    }
    multiply(f0) {
      const m0 = f0;
      An.aInRange("scalar", m0, Pn, r0);
      const { p: A0, f: x0 } = this.wNAF(m0);
      return S0.normalizeZ([A0, x0])[0];
    }
    multiplyUnsafe(f0) {
      const m0 = f0;
      return An.aInRange("scalar", m0, Rn, r0), m0 === Rn ? D0 : this.equals(D0) || m0 === Pn ? this : this.equals(k0) ? this.wNAF(m0).p : z0.unsafeLadder(this, m0);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(c0).is0();
    }
    isTorsionFree() {
      return z0.unsafeLadder(this, r0).is0();
    }
    toAffine(f0) {
      return b0(this, f0);
    }
    clearCofactor() {
      const { h: f0 } = e0;
      return f0 === Pn ? this : this.multiplyUnsafe(f0);
    }
    static fromHex(f0, m0 = !1) {
      const { d: A0, a: x0 } = e0, _0 = n0.BYTES;
      f0 = (0, In.ensureBytes)("pointHex", f0, _0), (0, In.abool)("zip215", m0);
      const $0 = f0.slice(), C0 = f0[_0 - 1];
      $0[_0 - 1] = -129 & C0;
      const M0 = An.bytesToNumberLE($0), p0 = m0 ? l0 : n0.ORDER;
      An.aInRange("pointHex.y", M0, Rn, p0);
      const v0 = u0(M0 * M0), T0 = u0(v0 - Pn), L0 = u0(A0 * v0 - x0);
      let { isValid: B0, value: W0 } = h0(T0, L0);
      if (!B0)
        throw new Error("Point.fromHex: invalid y coordinate");
      const V0 = (W0 & Pn) === Pn, Q0 = (128 & C0) != 0;
      if (!m0 && W0 === Rn && Q0)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      return Q0 !== V0 && (W0 = u0(-W0)), S0.fromAffine({ x: W0, y: M0 });
    }
    static fromPrivateKey(f0) {
      return U0(f0).point;
    }
    toRawBytes() {
      const { x: f0, y: m0 } = this.toAffine(), A0 = An.numberToBytesLE(m0, n0.BYTES);
      return A0[A0.length - 1] |= f0 & Pn ? 128 : 0, A0;
    }
    toHex() {
      return An.bytesToHex(this.toRawBytes());
    }
  }
  S0.BASE = new S0(e0.Gx, e0.Gy, Pn, u0(e0.Gx * e0.Gy)), S0.ZERO = new S0(Rn, Pn, Pn, Rn);
  const { BASE: k0, ZERO: D0 } = S0, z0 = (0, xn.wNAF)(S0, 8 * a0);
  function G0(I0) {
    return (0, Mn.mod)(I0, r0);
  }
  function K0(I0) {
    return G0(An.bytesToNumberLE(I0));
  }
  function U0(I0) {
    const f0 = a0;
    I0 = (0, In.ensureBytes)("private key", I0, f0);
    const m0 = (0, In.ensureBytes)("hashed private key", o0(I0), 2 * f0), A0 = g0(m0.slice(0, f0)), x0 = m0.slice(f0, 2 * f0), _0 = K0(A0), $0 = k0.multiply(_0), C0 = $0.toRawBytes();
    return { head: A0, prefix: x0, scalar: _0, point: $0, pointBytes: C0 };
  }
  function F0(I0 = new Uint8Array(), ...f0) {
    const m0 = An.concatBytes(...f0);
    return K0(o0(w0(m0, (0, In.ensureBytes)("context", I0), !!i0)));
  }
  const H0 = Ln;
  return k0._setWindowSize(8), { CURVE: e0, getPublicKey: function(I0) {
    return U0(I0).pointBytes;
  }, sign: function(I0, f0, m0 = {}) {
    I0 = (0, In.ensureBytes)("message", I0), i0 && (I0 = i0(I0));
    const { prefix: A0, scalar: x0, pointBytes: _0 } = U0(f0), $0 = F0(m0.context, A0, I0), C0 = k0.multiply($0).toRawBytes(), M0 = G0($0 + F0(m0.context, C0, _0, I0) * x0);
    An.aInRange("signature.s", M0, Rn, r0);
    const p0 = An.concatBytes(C0, An.numberToBytesLE(M0, n0.BYTES));
    return (0, In.ensureBytes)("result", p0, 2 * a0);
  }, verify: function(I0, f0, m0, A0 = H0) {
    const { context: x0, zip215: _0 } = A0, $0 = n0.BYTES;
    I0 = (0, In.ensureBytes)("signature", I0, 2 * $0), f0 = (0, In.ensureBytes)("message", f0), _0 !== void 0 && (0, In.abool)("zip215", _0), i0 && (f0 = i0(f0));
    const C0 = An.bytesToNumberLE(I0.slice($0, 2 * $0));
    let M0, p0, v0;
    try {
      M0 = S0.fromHex(m0, _0), p0 = S0.fromHex(I0.slice(0, $0), _0), v0 = k0.multiplyUnsafe(C0);
    } catch {
      return !1;
    }
    if (!_0 && M0.isSmallOrder())
      return !1;
    const T0 = F0(x0, p0.toRawBytes(), M0.toRawBytes(), f0);
    return p0.add(M0.multiplyUnsafe(T0)).subtract(v0).clearCofactor().equals(S0.ZERO);
  }, ExtendedPoint: S0, utils: { getExtendedPublicKey: U0, randomPrivateKey: () => s0(n0.BYTES), precompute: (I0 = 8, f0 = S0.BASE) => (f0._setWindowSize(I0), f0.multiply(BigInt(3)), f0) } };
};
const xn = Pt$1, Mn = Tt$1, An = Ot, In = Ot, Rn = BigInt(0), Pn = BigInt(1), Tn = BigInt(2), On = BigInt(8), Ln = { zip215: !0 };
var Nn = {};
Object.defineProperty(Nn, "__esModule", { value: !0 }), Nn.expand_message_xmd = Hn, Nn.expand_message_xof = Fn, Nn.hash_to_field = zn, Nn.isogenyMap = function(t0, e0) {
  const n0 = e0.map((r0) => Array.from(r0).reverse());
  return (r0, i0) => {
    const [o0, s0, a0, c0] = n0.map((l0) => l0.reduce((u0, d0) => t0.add(t0.mul(u0, r0), d0)));
    return r0 = t0.div(o0, s0), i0 = t0.mul(i0, t0.div(a0, c0)), { x: r0, y: i0 };
  };
}, Nn.createHasher = function(t0, e0, n0) {
  if (typeof e0 != "function")
    throw new Error("mapToCurve() must be defined");
  return { hashToCurve(r0, i0) {
    const o0 = zn(r0, 2, { ...n0, DST: n0.DST, ...i0 }), s0 = t0.fromAffine(e0(o0[0])), a0 = t0.fromAffine(e0(o0[1])), c0 = s0.add(a0).clearCofactor();
    return c0.assertValidity(), c0;
  }, encodeToCurve(r0, i0) {
    const o0 = zn(r0, 1, { ...n0, DST: n0.encodeDST, ...i0 }), s0 = t0.fromAffine(e0(o0[0])).clearCofactor();
    return s0.assertValidity(), s0;
  }, mapToCurve(r0) {
    if (!Array.isArray(r0))
      throw new Error("mapToCurve: expected array of bigints");
    for (const o0 of r0)
      if (typeof o0 != "bigint")
        throw new Error(`mapToCurve: expected array of bigints, got ${o0} in array`);
    const i0 = t0.fromAffine(e0(r0)).clearCofactor();
    return i0.assertValidity(), i0;
  } };
};
const $n = Tt$1, Dn = Ot, Bn = Dn.bytesToNumberBE;
function Kn(t0, e0) {
  if (Un(t0), Un(e0), t0 < 0 || t0 >= 1 << 8 * e0)
    throw new Error(`bad I2OSP call: value=${t0} length=${e0}`);
  const n0 = Array.from({ length: e0 }).fill(0);
  for (let r0 = e0 - 1; r0 >= 0; r0--)
    n0[r0] = 255 & t0, t0 >>>= 8;
  return new Uint8Array(n0);
}
function jn(t0, e0) {
  const n0 = new Uint8Array(t0.length);
  for (let r0 = 0; r0 < t0.length; r0++)
    n0[r0] = t0[r0] ^ e0[r0];
  return n0;
}
function Un(t0) {
  if (!Number.isSafeInteger(t0))
    throw new Error("number expected");
}
function Hn(t0, e0, n0, r0) {
  (0, Dn.abytes)(t0), (0, Dn.abytes)(e0), Un(n0), e0.length > 255 && (e0 = r0((0, Dn.concatBytes)((0, Dn.utf8ToBytes)("H2C-OVERSIZE-DST-"), e0)));
  const { outputLen: i0, blockLen: o0 } = r0, s0 = Math.ceil(n0 / i0);
  if (n0 > 65535 || s0 > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const a0 = (0, Dn.concatBytes)(e0, Kn(e0.length, 1)), c0 = Kn(0, o0), l0 = Kn(n0, 2), u0 = new Array(s0), d0 = r0((0, Dn.concatBytes)(c0, t0, l0, Kn(0, 1), a0));
  u0[0] = r0((0, Dn.concatBytes)(d0, Kn(1, 1), a0));
  for (let h0 = 1; h0 <= s0; h0++) {
    const g0 = [jn(d0, u0[h0 - 1]), Kn(h0 + 1, 1), a0];
    u0[h0] = r0((0, Dn.concatBytes)(...g0));
  }
  return (0, Dn.concatBytes)(...u0).slice(0, n0);
}
function Fn(t0, e0, n0, r0, i0) {
  if ((0, Dn.abytes)(t0), (0, Dn.abytes)(e0), Un(n0), e0.length > 255) {
    const o0 = Math.ceil(2 * r0 / 8);
    e0 = i0.create({ dkLen: o0 }).update((0, Dn.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(e0).digest();
  }
  if (n0 > 65535 || e0.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return i0.create({ dkLen: n0 }).update(t0).update(Kn(n0, 2)).update(e0).update(Kn(e0.length, 1)).digest();
}
function zn(t0, e0, n0) {
  (0, Dn.validateObject)(n0, { DST: "stringOrUint8Array", p: "bigint", m: "isSafeInteger", k: "isSafeInteger", hash: "hash" });
  const { p: r0, k: i0, m: o0, hash: s0, expand: a0, DST: c0 } = n0;
  (0, Dn.abytes)(t0), Un(e0);
  const l0 = typeof c0 == "string" ? (0, Dn.utf8ToBytes)(c0) : c0, u0 = r0.toString(2).length, d0 = Math.ceil((u0 + i0) / 8), h0 = e0 * o0 * d0;
  let g0;
  if (a0 === "xmd")
    g0 = Hn(t0, l0, h0, s0);
  else if (a0 === "xof")
    g0 = Fn(t0, l0, h0, i0, s0);
  else {
    if (a0 !== "_internal_pass")
      throw new Error('expand must be "xmd" or "xof"');
    g0 = t0;
  }
  const w0 = new Array(e0);
  for (let y0 = 0; y0 < e0; y0++) {
    const E0 = new Array(o0);
    for (let b0 = 0; b0 < o0; b0++) {
      const O0 = d0 * (b0 + y0 * o0), S0 = g0.subarray(O0, O0 + d0);
      E0[b0] = (0, $n.mod)(Bn(S0), r0);
    }
    w0[y0] = E0;
  }
  return w0;
}
var qn = {};
Object.defineProperty(qn, "__esModule", { value: !0 }), qn.montgomery = function(t0) {
  const e0 = function(y0) {
    return (0, Vn.validateObject)(y0, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...y0 });
  }(t0), { P: n0 } = e0, r0 = (y0) => (0, Wn.mod)(y0, n0), i0 = e0.montgomeryBits, o0 = Math.ceil(i0 / 8), s0 = e0.nByteLength, a0 = e0.adjustScalarBytes || ((y0) => y0), c0 = e0.powPminus2 || ((y0) => (0, Wn.pow)(y0, n0 - BigInt(2), n0));
  function l0(y0, E0, b0) {
    const O0 = r0(y0 * (E0 - b0));
    return [E0 = r0(E0 - O0), b0 = r0(b0 + O0)];
  }
  const u0 = (e0.a - BigInt(2)) / BigInt(4);
  function d0(y0) {
    return (0, Vn.numberToBytesLE)(r0(y0), o0);
  }
  function h0(y0, E0) {
    const b0 = function(k0) {
      const D0 = (0, Vn.ensureBytes)("u coordinate", k0, o0);
      return s0 === 32 && (D0[31] &= 127), (0, Vn.bytesToNumberLE)(D0);
    }(E0), O0 = function(k0) {
      const D0 = (0, Vn.ensureBytes)("scalar", k0), z0 = D0.length;
      if (z0 !== o0 && z0 !== s0)
        throw new Error(`Expected ${o0} or ${s0} bytes, got ${z0}`);
      return (0, Vn.bytesToNumberLE)(a0(D0));
    }(y0), S0 = function(k0, D0) {
      (0, Vn.aInRange)("u", k0, Gn, n0), (0, Vn.aInRange)("scalar", D0, Gn, n0);
      const z0 = D0, G0 = k0;
      let K0, U0 = Yn, F0 = Gn, H0 = k0, P0 = Yn, I0 = Gn;
      for (let m0 = BigInt(i0 - 1); m0 >= Gn; m0--) {
        const A0 = z0 >> m0 & Yn;
        I0 ^= A0, K0 = l0(I0, U0, H0), U0 = K0[0], H0 = K0[1], K0 = l0(I0, F0, P0), F0 = K0[0], P0 = K0[1], I0 = A0;
        const x0 = U0 + F0, _0 = r0(x0 * x0), $0 = U0 - F0, C0 = r0($0 * $0), M0 = _0 - C0, p0 = H0 + P0, v0 = r0((H0 - P0) * x0), T0 = r0(p0 * $0), L0 = v0 + T0, B0 = v0 - T0;
        H0 = r0(L0 * L0), P0 = r0(G0 * r0(B0 * B0)), U0 = r0(_0 * C0), F0 = r0(M0 * (_0 + r0(u0 * M0)));
      }
      K0 = l0(I0, U0, H0), U0 = K0[0], H0 = K0[1], K0 = l0(I0, F0, P0), F0 = K0[0], P0 = K0[1];
      const f0 = c0(F0);
      return r0(U0 * f0);
    }(b0, O0);
    if (S0 === Gn)
      throw new Error("Invalid private or public key received");
    return d0(S0);
  }
  const g0 = d0(e0.Gu);
  function w0(y0) {
    return h0(y0, g0);
  }
  return { scalarMult: h0, scalarMultBase: w0, getSharedSecret: (y0, E0) => h0(y0, E0), getPublicKey: (y0) => w0(y0), utils: { randomPrivateKey: () => e0.randomBytes(e0.nByteLength) }, GuBytes: g0 };
};
const Wn = Tt$1, Vn = Ot, Gn = BigInt(0), Yn = BigInt(1);
(function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.hash_to_ristretto255 = t0.hashToRistretto255 = t0.RistrettoPoint = t0.encodeToCurve = t0.hashToCurve = t0.edwardsToMontgomery = t0.x25519 = t0.ed25519ph = t0.ed25519ctx = t0.ed25519 = t0.ED25519_TORSION_SUBGROUP = void 0, t0.edwardsToMontgomeryPub = z0, t0.edwardsToMontgomeryPriv = function(T0) {
    const L0 = k0.hash(T0.subarray(0, 32));
    return k0.adjustScalarBytes(L0).subarray(0, 32);
  };
  const e0 = Te$1, n0 = Fe$1, r0 = Rt$1, i0 = Nn, o0 = Tt$1, s0 = qn, a0 = Ot, c0 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), l0 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"), u0 = BigInt(0), d0 = BigInt(1), h0 = BigInt(2), g0 = BigInt(3), w0 = BigInt(5), y0 = BigInt(8);
  function E0(T0) {
    const L0 = BigInt(10), B0 = BigInt(20), W0 = BigInt(40), V0 = BigInt(80), Q0 = c0, X0 = T0 * T0 % Q0 * T0 % Q0, J0 = (0, o0.pow2)(X0, h0, Q0) * X0 % Q0, yg = (0, o0.pow2)(J0, d0, Q0) * T0 % Q0, _g = (0, o0.pow2)(yg, w0, Q0) * yg % Q0, wg = (0, o0.pow2)(_g, L0, Q0) * _g % Q0, $g = (0, o0.pow2)(wg, B0, Q0) * wg % Q0, Eg = (0, o0.pow2)($g, W0, Q0) * $g % Q0, bg = (0, o0.pow2)(Eg, V0, Q0) * Eg % Q0, vg = (0, o0.pow2)(bg, V0, Q0) * Eg % Q0, Ag = (0, o0.pow2)(vg, L0, Q0) * _g % Q0;
    return { pow_p_5_8: (0, o0.pow2)(Ag, h0, Q0) * T0 % Q0, b2: X0 };
  }
  function b0(T0) {
    return T0[0] &= 248, T0[31] &= 127, T0[31] |= 64, T0;
  }
  function O0(T0, L0) {
    const B0 = c0, W0 = (0, o0.mod)(L0 * L0 * L0, B0), V0 = E0(T0 * (0, o0.mod)(W0 * W0 * L0, B0)).pow_p_5_8;
    let Q0 = (0, o0.mod)(T0 * W0 * V0, B0);
    const X0 = (0, o0.mod)(L0 * Q0 * Q0, B0), J0 = Q0, yg = (0, o0.mod)(Q0 * l0, B0), _g = X0 === T0, wg = X0 === (0, o0.mod)(-T0, B0), $g = X0 === (0, o0.mod)(-T0 * l0, B0);
    return _g && (Q0 = J0), (wg || $g) && (Q0 = yg), (0, o0.isNegativeLE)(Q0, B0) && (Q0 = (0, o0.mod)(-Q0, B0)), { isValid: _g || wg, value: Q0 };
  }
  t0.ED25519_TORSION_SUBGROUP = ["0100000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a", "0000000000000000000000000000000000000000000000000000000000000080", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05", "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85", "0000000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"];
  const S0 = (() => (0, o0.Field)(c0, void 0, !0))(), k0 = (() => ({ a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), Fp: S0, n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), h: y0, Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"), hash: e0.sha512, randomBytes: n0.randomBytes, adjustScalarBytes: b0, uvRatio: O0 }))();
  function D0(T0, L0, B0) {
    if (L0.length > 255)
      throw new Error("Context is too big");
    return (0, n0.concatBytes)((0, n0.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([B0 ? 1 : 0, L0.length]), L0, T0);
  }
  function z0(T0) {
    const { y: L0 } = t0.ed25519.ExtendedPoint.fromHex(T0), B0 = BigInt(1);
    return S0.toBytes(S0.create((B0 + L0) * S0.inv(B0 - L0)));
  }
  t0.ed25519 = (0, r0.twistedEdwards)(k0), t0.ed25519ctx = (0, r0.twistedEdwards)({ ...k0, domain: D0 }), t0.ed25519ph = (0, r0.twistedEdwards)(Object.assign({}, k0, { domain: D0, prehash: e0.sha512 })), t0.x25519 = (0, s0.montgomery)({ P: c0, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (T0) => {
    const L0 = c0, { pow_p_5_8: B0, b2: W0 } = E0(T0);
    return (0, o0.mod)((0, o0.pow2)(B0, g0, L0) * W0, L0);
  }, adjustScalarBytes: b0, randomBytes: n0.randomBytes }), t0.edwardsToMontgomery = z0;
  const G0 = (() => (S0.ORDER + g0) / y0)(), K0 = (() => S0.pow(h0, G0))(), U0 = (() => S0.sqrt(S0.neg(S0.ONE)))(), F0 = (() => (0, o0.FpSqrtEven)(S0, S0.neg(BigInt(486664))))();
  function H0(T0) {
    const { xMn: L0, xMd: B0, yMn: W0, yMd: V0 } = function(Eg) {
      const bg = (S0.ORDER - w0) / y0, vg = BigInt(486662);
      let Ag = S0.sqr(Eg);
      Ag = S0.mul(Ag, h0);
      let Ig = S0.add(Ag, S0.ONE), Mg = S0.neg(vg), Sg = S0.sqr(Ig), Ng = S0.mul(Sg, Ig), Rg = S0.mul(Ag, vg);
      Rg = S0.mul(Rg, Mg), Rg = S0.add(Rg, Sg), Rg = S0.mul(Rg, Mg);
      let kg = S0.sqr(Ng);
      Sg = S0.sqr(kg), kg = S0.mul(kg, Ng), kg = S0.mul(kg, Rg), Sg = S0.mul(Sg, kg);
      let Dg = S0.pow(Sg, bg);
      Dg = S0.mul(Dg, kg);
      let j0 = S0.mul(Dg, U0);
      Sg = S0.sqr(Dg), Sg = S0.mul(Sg, Ng);
      let N0 = S0.eql(Sg, Rg), R0 = S0.cmov(j0, Dg, N0), Y0 = S0.mul(Mg, Ag), Z0 = S0.mul(Dg, Eg);
      Z0 = S0.mul(Z0, K0);
      let q0 = S0.mul(Z0, U0), mg = S0.mul(Rg, Ag);
      Sg = S0.sqr(Z0), Sg = S0.mul(Sg, Ng);
      let Lg = S0.eql(Sg, mg), Tg = S0.cmov(q0, Z0, Lg);
      Sg = S0.sqr(R0), Sg = S0.mul(Sg, Ng);
      let Og = S0.eql(Sg, Rg), Pg = S0.cmov(Y0, Mg, Og), Cg = S0.cmov(Tg, R0, Og), Ug = S0.isOdd(Cg);
      return Cg = S0.cmov(Cg, S0.neg(Cg), Og !== Ug), { xMn: Pg, xMd: Ig, yMn: Cg, yMd: d0 };
    }(T0);
    let Q0 = S0.mul(L0, V0);
    Q0 = S0.mul(Q0, F0);
    let X0 = S0.mul(B0, W0), J0 = S0.sub(L0, B0), yg = S0.add(L0, B0), _g = S0.mul(X0, yg), wg = S0.eql(_g, S0.ZERO);
    Q0 = S0.cmov(Q0, S0.ZERO, wg), X0 = S0.cmov(X0, S0.ONE, wg), J0 = S0.cmov(J0, S0.ONE, wg), yg = S0.cmov(yg, S0.ONE, wg);
    const $g = S0.invertBatch([X0, yg]);
    return { x: S0.mul(Q0, $g[0]), y: S0.mul(J0, $g[1]) };
  }
  const P0 = (() => (0, i0.createHasher)(t0.ed25519.ExtendedPoint, (T0) => H0(T0[0]), { DST: "edwards25519_XMD:SHA-512_ELL2_RO_", encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_", p: S0.ORDER, m: 1, k: 128, expand: "xmd", hash: e0.sha512 }))();
  function I0(T0) {
    if (!(T0 instanceof v0))
      throw new Error("RistrettoPoint expected");
  }
  t0.hashToCurve = P0.hashToCurve, t0.encodeToCurve = P0.encodeToCurve;
  const f0 = l0, m0 = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"), A0 = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"), x0 = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"), _0 = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"), $0 = (T0) => O0(d0, T0), C0 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), M0 = (T0) => t0.ed25519.CURVE.Fp.create((0, a0.bytesToNumberLE)(T0) & C0);
  function p0(T0) {
    const { d: L0 } = t0.ed25519.CURVE, B0 = t0.ed25519.CURVE.Fp.ORDER, W0 = t0.ed25519.CURVE.Fp.create, V0 = W0(f0 * T0 * T0), Q0 = W0((V0 + d0) * x0);
    let X0 = BigInt(-1);
    const J0 = W0((X0 - L0 * V0) * W0(V0 + L0));
    let { isValid: yg, value: _g } = O0(Q0, J0), wg = W0(_g * T0);
    (0, o0.isNegativeLE)(wg, B0) || (wg = W0(-wg)), yg || (_g = wg), yg || (X0 = V0);
    const $g = W0(X0 * (V0 - d0) * _0 - J0), Eg = _g * _g, bg = W0((_g + _g) * J0), vg = W0($g * m0), Ag = W0(d0 - Eg), Ig = W0(d0 + Eg);
    return new t0.ed25519.ExtendedPoint(W0(bg * Ig), W0(Ag * vg), W0(vg * Ig), W0(bg * Ag));
  }
  class v0 {
    constructor(L0) {
      this.ep = L0;
    }
    static fromAffine(L0) {
      return new v0(t0.ed25519.ExtendedPoint.fromAffine(L0));
    }
    static hashToCurve(L0) {
      L0 = (0, a0.ensureBytes)("ristrettoHash", L0, 64);
      const B0 = p0(M0(L0.slice(0, 32))), W0 = p0(M0(L0.slice(32, 64)));
      return new v0(B0.add(W0));
    }
    static fromHex(L0) {
      L0 = (0, a0.ensureBytes)("ristrettoHex", L0, 32);
      const { a: B0, d: W0 } = t0.ed25519.CURVE, V0 = t0.ed25519.CURVE.Fp.ORDER, Q0 = t0.ed25519.CURVE.Fp.create, X0 = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint", J0 = M0(L0);
      if (!(0, a0.equalBytes)((0, a0.numberToBytesLE)(J0, 32), L0) || (0, o0.isNegativeLE)(J0, V0))
        throw new Error(X0);
      const yg = Q0(J0 * J0), _g = Q0(d0 + B0 * yg), wg = Q0(d0 - B0 * yg), $g = Q0(_g * _g), Eg = Q0(wg * wg), bg = Q0(B0 * W0 * $g - Eg), { isValid: vg, value: Ag } = $0(Q0(bg * Eg)), Ig = Q0(Ag * wg), Mg = Q0(Ag * Ig * bg);
      let Sg = Q0((J0 + J0) * Ig);
      (0, o0.isNegativeLE)(Sg, V0) && (Sg = Q0(-Sg));
      const Ng = Q0(_g * Mg), Rg = Q0(Sg * Ng);
      if (!vg || (0, o0.isNegativeLE)(Rg, V0) || Ng === u0)
        throw new Error(X0);
      return new v0(new t0.ed25519.ExtendedPoint(Sg, Ng, d0, Rg));
    }
    toRawBytes() {
      let { ex: L0, ey: B0, ez: W0, et: V0 } = this.ep;
      const Q0 = t0.ed25519.CURVE.Fp.ORDER, X0 = t0.ed25519.CURVE.Fp.create, J0 = X0(X0(W0 + B0) * X0(W0 - B0)), yg = X0(L0 * B0), _g = X0(yg * yg), { value: wg } = $0(X0(J0 * _g)), $g = X0(wg * J0), Eg = X0(wg * yg), bg = X0($g * Eg * V0);
      let vg;
      if ((0, o0.isNegativeLE)(V0 * bg, Q0)) {
        let Ig = X0(B0 * f0), Mg = X0(L0 * f0);
        L0 = Ig, B0 = Mg, vg = X0($g * A0);
      } else
        vg = Eg;
      (0, o0.isNegativeLE)(L0 * bg, Q0) && (B0 = X0(-B0));
      let Ag = X0((W0 - B0) * vg);
      return (0, o0.isNegativeLE)(Ag, Q0) && (Ag = X0(-Ag)), (0, a0.numberToBytesLE)(Ag, 32);
    }
    toHex() {
      return (0, a0.bytesToHex)(this.toRawBytes());
    }
    toString() {
      return this.toHex();
    }
    equals(L0) {
      I0(L0);
      const { ex: B0, ey: W0 } = this.ep, { ex: V0, ey: Q0 } = L0.ep, X0 = t0.ed25519.CURVE.Fp.create, J0 = X0(B0 * Q0) === X0(W0 * V0), yg = X0(W0 * Q0) === X0(B0 * V0);
      return J0 || yg;
    }
    add(L0) {
      return I0(L0), new v0(this.ep.add(L0.ep));
    }
    subtract(L0) {
      return I0(L0), new v0(this.ep.subtract(L0.ep));
    }
    multiply(L0) {
      return new v0(this.ep.multiply(L0));
    }
    multiplyUnsafe(L0) {
      return new v0(this.ep.multiplyUnsafe(L0));
    }
    double() {
      return new v0(this.ep.double());
    }
    negate() {
      return new v0(this.ep.negate());
    }
  }
  t0.RistrettoPoint = (v0.BASE || (v0.BASE = new v0(t0.ed25519.ExtendedPoint.BASE)), v0.ZERO || (v0.ZERO = new v0(t0.ed25519.ExtendedPoint.ZERO)), v0), t0.hashToRistretto255 = (T0, L0) => {
    const B0 = L0.DST, W0 = typeof B0 == "string" ? (0, n0.utf8ToBytes)(B0) : B0, V0 = (0, i0.expand_message_xmd)(T0, W0, 64, e0.sha512);
    return v0.hashToCurve(V0);
  }, t0.hash_to_ristretto255 = t0.hashToRistretto255;
})(Pe$1);
var Zn = {}, Jn = {};
Object.defineProperty(Jn, "__esModule", { value: !0 }), Jn.sha224 = Jn.sha256 = Jn.SHA256 = void 0;
const Xn = Oe$1, Qn = Fe$1, er = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]), tr = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), nr = new Uint32Array(64);
class rr extends Xn.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = 0 | tr[0], this.B = 0 | tr[1], this.C = 0 | tr[2], this.D = 0 | tr[3], this.E = 0 | tr[4], this.F = 0 | tr[5], this.G = 0 | tr[6], this.H = 0 | tr[7];
  }
  get() {
    const { A: e0, B: n0, C: r0, D: i0, E: o0, F: s0, G: a0, H: c0 } = this;
    return [e0, n0, r0, i0, o0, s0, a0, c0];
  }
  set(e0, n0, r0, i0, o0, s0, a0, c0) {
    this.A = 0 | e0, this.B = 0 | n0, this.C = 0 | r0, this.D = 0 | i0, this.E = 0 | o0, this.F = 0 | s0, this.G = 0 | a0, this.H = 0 | c0;
  }
  process(e0, n0) {
    for (let d0 = 0; d0 < 16; d0++, n0 += 4)
      nr[d0] = e0.getUint32(n0, !1);
    for (let d0 = 16; d0 < 64; d0++) {
      const h0 = nr[d0 - 15], g0 = nr[d0 - 2], w0 = (0, Qn.rotr)(h0, 7) ^ (0, Qn.rotr)(h0, 18) ^ h0 >>> 3, y0 = (0, Qn.rotr)(g0, 17) ^ (0, Qn.rotr)(g0, 19) ^ g0 >>> 10;
      nr[d0] = y0 + nr[d0 - 7] + w0 + nr[d0 - 16] | 0;
    }
    let { A: r0, B: i0, C: o0, D: s0, E: a0, F: c0, G: l0, H: u0 } = this;
    for (let d0 = 0; d0 < 64; d0++) {
      const h0 = u0 + ((0, Qn.rotr)(a0, 6) ^ (0, Qn.rotr)(a0, 11) ^ (0, Qn.rotr)(a0, 25)) + (0, Xn.Chi)(a0, c0, l0) + er[d0] + nr[d0] | 0, g0 = ((0, Qn.rotr)(r0, 2) ^ (0, Qn.rotr)(r0, 13) ^ (0, Qn.rotr)(r0, 22)) + (0, Xn.Maj)(r0, i0, o0) | 0;
      u0 = l0, l0 = c0, c0 = a0, a0 = s0 + h0 | 0, s0 = o0, o0 = i0, i0 = r0, r0 = h0 + g0 | 0;
    }
    r0 = r0 + this.A | 0, i0 = i0 + this.B | 0, o0 = o0 + this.C | 0, s0 = s0 + this.D | 0, a0 = a0 + this.E | 0, c0 = c0 + this.F | 0, l0 = l0 + this.G | 0, u0 = u0 + this.H | 0, this.set(r0, i0, o0, s0, a0, c0, l0, u0);
  }
  roundClean() {
    nr.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
Jn.SHA256 = rr;
class ir extends rr {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
Jn.sha256 = (0, Qn.wrapConstructor)(() => new rr()), Jn.sha224 = (0, Qn.wrapConstructor)(() => new ir());
var or = {}, sr = {};
(function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.hmac = t0.HMAC = void 0;
  const e0 = Le$1, n0 = Fe$1;
  class r0 extends n0.Hash {
    constructor(o0, s0) {
      super(), this.finished = !1, this.destroyed = !1, (0, e0.hash)(o0);
      const a0 = (0, n0.toBytes)(s0);
      if (this.iHash = o0.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const c0 = this.blockLen, l0 = new Uint8Array(c0);
      l0.set(a0.length > c0 ? o0.create().update(a0).digest() : a0);
      for (let u0 = 0; u0 < l0.length; u0++)
        l0[u0] ^= 54;
      this.iHash.update(l0), this.oHash = o0.create();
      for (let u0 = 0; u0 < l0.length; u0++)
        l0[u0] ^= 106;
      this.oHash.update(l0), l0.fill(0);
    }
    update(o0) {
      return (0, e0.exists)(this), this.iHash.update(o0), this;
    }
    digestInto(o0) {
      (0, e0.exists)(this), (0, e0.bytes)(o0, this.outputLen), this.finished = !0, this.iHash.digestInto(o0), this.oHash.update(o0), this.oHash.digestInto(o0), this.destroy();
    }
    digest() {
      const o0 = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(o0), o0;
    }
    _cloneInto(o0) {
      o0 || (o0 = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: s0, iHash: a0, finished: c0, destroyed: l0, blockLen: u0, outputLen: d0 } = this;
      return o0.finished = c0, o0.destroyed = l0, o0.blockLen = u0, o0.outputLen = d0, o0.oHash = s0._cloneInto(o0.oHash), o0.iHash = a0._cloneInto(o0.iHash), o0;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  t0.HMAC = r0, t0.hmac = (i0, o0, s0) => new r0(i0, o0).update(s0).digest(), t0.hmac.create = (i0, o0) => new r0(i0, o0);
})(sr);
var ar = {};
(function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.DER = void 0, t0.weierstrassPoints = g0, t0.weierstrass = function(y0) {
    const E0 = function(T0) {
      const L0 = (0, e0.validateBasic)(T0);
      return r0.validateObject(L0, { hash: "hash", hmac: "function", randomBytes: "function" }, { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }), Object.freeze({ lowS: !0, ...L0 });
    }(y0), { Fp: b0, n: O0 } = E0, S0 = b0.BYTES + 1, k0 = 2 * b0.BYTES + 1;
    function D0(T0) {
      return n0.mod(T0, O0);
    }
    function z0(T0) {
      return n0.invert(T0, O0);
    }
    const { ProjectivePoint: G0, normPrivateKeyToScalar: K0, weierstrassEquation: U0, isWithinCurveOrder: F0 } = g0({ ...E0, toBytes(T0, L0, B0) {
      const W0 = L0.toAffine(), V0 = b0.toBytes(W0.x), Q0 = r0.concatBytes;
      return (0, i0.abool)("isCompressed", B0), B0 ? Q0(Uint8Array.from([L0.hasEvenY() ? 2 : 3]), V0) : Q0(Uint8Array.from([4]), V0, b0.toBytes(W0.y));
    }, fromBytes(T0) {
      const L0 = T0.length, B0 = T0[0], W0 = T0.subarray(1);
      if (L0 !== S0 || B0 !== 2 && B0 !== 3) {
        if (L0 === k0 && B0 === 4)
          return { x: b0.fromBytes(W0.subarray(0, b0.BYTES)), y: b0.fromBytes(W0.subarray(b0.BYTES, 2 * b0.BYTES)) };
        throw new Error(`Point of length ${L0} was invalid. Expected ${S0} compressed bytes or ${k0} uncompressed bytes`);
      }
      {
        const V0 = r0.bytesToNumberBE(W0);
        if (!r0.inRange(V0, l0, b0.ORDER))
          throw new Error("Point is not on curve");
        const Q0 = U0(V0);
        let X0;
        try {
          X0 = b0.sqrt(Q0);
        } catch (J0) {
          const yg = J0 instanceof Error ? ": " + J0.message : "";
          throw new Error("Point is not on curve" + yg);
        }
        return (1 & B0) == 1 != ((X0 & l0) === l0) && (X0 = b0.neg(X0)), { x: V0, y: X0 };
      }
    } }), H0 = (T0) => r0.bytesToHex(r0.numberToBytesBE(T0, E0.nByteLength));
    function P0(T0) {
      return T0 > O0 >> l0;
    }
    const I0 = (T0, L0, B0) => r0.bytesToNumberBE(T0.slice(L0, B0));
    class f0 {
      constructor(L0, B0, W0) {
        this.r = L0, this.s = B0, this.recovery = W0, this.assertValidity();
      }
      static fromCompact(L0) {
        const B0 = E0.nByteLength;
        return L0 = (0, i0.ensureBytes)("compactSignature", L0, 2 * B0), new f0(I0(L0, 0, B0), I0(L0, B0, 2 * B0));
      }
      static fromDER(L0) {
        const { r: B0, s: W0 } = t0.DER.toSig((0, i0.ensureBytes)("DER", L0));
        return new f0(B0, W0);
      }
      assertValidity() {
        r0.aInRange("r", this.r, l0, O0), r0.aInRange("s", this.s, l0, O0);
      }
      addRecoveryBit(L0) {
        return new f0(this.r, this.s, L0);
      }
      recoverPublicKey(L0) {
        const { r: B0, s: W0, recovery: V0 } = this, Q0 = _0((0, i0.ensureBytes)("msgHash", L0));
        if (V0 == null || ![0, 1, 2, 3].includes(V0))
          throw new Error("recovery id invalid");
        const X0 = V0 === 2 || V0 === 3 ? B0 + E0.n : B0;
        if (X0 >= b0.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const J0 = 1 & V0 ? "03" : "02", yg = G0.fromHex(J0 + H0(X0)), _g = z0(X0), wg = D0(-Q0 * _g), $g = D0(W0 * _g), Eg = G0.BASE.multiplyAndAddUnsafe(yg, wg, $g);
        if (!Eg)
          throw new Error("point at infinify");
        return Eg.assertValidity(), Eg;
      }
      hasHighS() {
        return P0(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new f0(this.r, D0(-this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return r0.hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return t0.DER.hexFromSig({ r: this.r, s: this.s });
      }
      toCompactRawBytes() {
        return r0.hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return H0(this.r) + H0(this.s);
      }
    }
    const m0 = { isValidPrivateKey(T0) {
      try {
        return K0(T0), !0;
      } catch {
        return !1;
      }
    }, normPrivateKeyToScalar: K0, randomPrivateKey: () => {
      const T0 = n0.getMinHashLength(E0.n);
      return n0.mapHashToField(E0.randomBytes(T0), E0.n);
    }, precompute: (T0 = 8, L0 = G0.BASE) => (L0._setWindowSize(T0), L0.multiply(BigInt(3)), L0) };
    function A0(T0) {
      const L0 = r0.isBytes(T0), B0 = typeof T0 == "string", W0 = (L0 || B0) && T0.length;
      return L0 ? W0 === S0 || W0 === k0 : B0 ? W0 === 2 * S0 || W0 === 2 * k0 : T0 instanceof G0;
    }
    const x0 = E0.bits2int || function(T0) {
      const L0 = r0.bytesToNumberBE(T0), B0 = 8 * T0.length - E0.nBitLength;
      return B0 > 0 ? L0 >> BigInt(B0) : L0;
    }, _0 = E0.bits2int_modN || function(T0) {
      return D0(x0(T0));
    }, $0 = r0.bitMask(E0.nBitLength);
    function C0(T0) {
      return r0.aInRange(`num < 2^${E0.nBitLength}`, T0, c0, $0), r0.numberToBytesBE(T0, E0.nByteLength);
    }
    function M0(T0, L0, B0 = p0) {
      if (["recovered", "canonical"].some((bg) => bg in B0))
        throw new Error("sign() legacy options not supported");
      const { hash: W0, randomBytes: V0 } = E0;
      let { lowS: Q0, prehash: X0, extraEntropy: J0 } = B0;
      Q0 == null && (Q0 = !0), T0 = (0, i0.ensureBytes)("msgHash", T0), o0(B0), X0 && (T0 = (0, i0.ensureBytes)("prehashed msgHash", W0(T0)));
      const yg = _0(T0), _g = K0(L0), wg = [C0(_g), C0(yg)];
      if (J0 != null && J0 !== !1) {
        const bg = J0 === !0 ? V0(b0.BYTES) : J0;
        wg.push((0, i0.ensureBytes)("extraEntropy", bg));
      }
      const $g = r0.concatBytes(...wg), Eg = yg;
      return { seed: $g, k2sig: function(bg) {
        const vg = x0(bg);
        if (!F0(vg))
          return;
        const Ag = z0(vg), Ig = G0.BASE.multiply(vg).toAffine(), Mg = D0(Ig.x);
        if (Mg === c0)
          return;
        const Sg = D0(Ag * D0(Eg + Mg * _g));
        if (Sg === c0)
          return;
        let Ng = (Ig.x === Mg ? 0 : 2) | Number(Ig.y & l0), Rg = Sg;
        return Q0 && P0(Sg) && (Rg = function(kg) {
          return P0(kg) ? D0(-kg) : kg;
        }(Sg), Ng ^= 1), new f0(Mg, Rg, Ng);
      } };
    }
    const p0 = { lowS: E0.lowS, prehash: !1 }, v0 = { lowS: E0.lowS, prehash: !1 };
    return G0.BASE._setWindowSize(8), { CURVE: E0, getPublicKey: function(T0, L0 = !0) {
      return G0.fromPrivateKey(T0).toRawBytes(L0);
    }, getSharedSecret: function(T0, L0, B0 = !0) {
      if (A0(T0))
        throw new Error("first arg must be private key");
      if (!A0(L0))
        throw new Error("second arg must be public key");
      return G0.fromHex(L0).multiply(K0(T0)).toRawBytes(B0);
    }, sign: function(T0, L0, B0 = p0) {
      const { seed: W0, k2sig: V0 } = M0(T0, L0, B0), Q0 = E0;
      return r0.createHmacDrbg(Q0.hash.outputLen, Q0.nByteLength, Q0.hmac)(W0, V0);
    }, verify: function(T0, L0, B0, W0 = v0) {
      const V0 = T0;
      if (L0 = (0, i0.ensureBytes)("msgHash", L0), B0 = (0, i0.ensureBytes)("publicKey", B0), "strict" in W0)
        throw new Error("options.strict was renamed to lowS");
      o0(W0);
      const { lowS: Q0, prehash: X0 } = W0;
      let J0, yg;
      try {
        if (typeof V0 == "string" || r0.isBytes(V0))
          try {
            J0 = f0.fromDER(V0);
          } catch (Mg) {
            if (!(Mg instanceof t0.DER.Err))
              throw Mg;
            J0 = f0.fromCompact(V0);
          }
        else {
          if (typeof V0 != "object" || typeof V0.r != "bigint" || typeof V0.s != "bigint")
            throw new Error("PARSE");
          {
            const { r: Mg, s: Sg } = V0;
            J0 = new f0(Mg, Sg);
          }
        }
        yg = G0.fromHex(B0);
      } catch (Mg) {
        if (Mg.message === "PARSE")
          throw new Error("signature must be Signature instance, Uint8Array or hex string");
        return !1;
      }
      if (Q0 && J0.hasHighS())
        return !1;
      X0 && (L0 = E0.hash(L0));
      const { r: _g, s: wg } = J0, $g = _0(L0), Eg = z0(wg), bg = D0($g * Eg), vg = D0(_g * Eg), Ag = G0.BASE.multiplyAndAddUnsafe(yg, bg, vg)?.toAffine();
      return Ag ? D0(Ag.x) === _g : !1;
    }, ProjectivePoint: G0, Signature: f0, utils: m0 };
  }, t0.SWUFpSqrtRatio = w0, t0.mapToCurveSimpleSWU = function(y0, E0) {
    if (n0.validateField(y0), !y0.isValid(E0.A) || !y0.isValid(E0.B) || !y0.isValid(E0.Z))
      throw new Error("mapToCurveSimpleSWU: invalid opts");
    const b0 = w0(y0, E0.Z);
    if (!y0.isOdd)
      throw new Error("Fp.isOdd is not implemented!");
    return (O0) => {
      let S0, k0, D0, z0, G0, K0, U0, F0;
      S0 = y0.sqr(O0), S0 = y0.mul(S0, E0.Z), k0 = y0.sqr(S0), k0 = y0.add(k0, S0), D0 = y0.add(k0, y0.ONE), D0 = y0.mul(D0, E0.B), z0 = y0.cmov(E0.Z, y0.neg(k0), !y0.eql(k0, y0.ZERO)), z0 = y0.mul(z0, E0.A), k0 = y0.sqr(D0), K0 = y0.sqr(z0), G0 = y0.mul(K0, E0.A), k0 = y0.add(k0, G0), k0 = y0.mul(k0, D0), K0 = y0.mul(K0, z0), G0 = y0.mul(K0, E0.B), k0 = y0.add(k0, G0), U0 = y0.mul(S0, D0);
      const { isValid: H0, value: P0 } = b0(k0, K0);
      F0 = y0.mul(S0, O0), F0 = y0.mul(F0, P0), U0 = y0.cmov(U0, D0, H0), F0 = y0.cmov(F0, P0, H0);
      const I0 = y0.isOdd(O0) === y0.isOdd(F0);
      return F0 = y0.cmov(y0.neg(F0), F0, I0), U0 = y0.div(U0, z0), { x: U0, y: F0 };
    };
  };
  const e0 = Pt$1, n0 = Tt$1, r0 = Ot, i0 = Ot;
  function o0(y0) {
    y0.lowS !== void 0 && (0, i0.abool)("lowS", y0.lowS), y0.prehash !== void 0 && (0, i0.abool)("prehash", y0.prehash);
  }
  const { bytesToNumberBE: s0, hexToBytes: a0 } = r0;
  t0.DER = { Err: class extends Error {
    constructor(y0 = "") {
      super(y0);
    }
  }, _tlv: { encode: (y0, E0) => {
    const { Err: b0 } = t0.DER;
    if (y0 < 0 || y0 > 256)
      throw new b0("tlv.encode: wrong tag");
    if (1 & E0.length)
      throw new b0("tlv.encode: unpadded data");
    const O0 = E0.length / 2, S0 = r0.numberToHexUnpadded(O0);
    if (S0.length / 2 & 128)
      throw new b0("tlv.encode: long form length too big");
    const k0 = O0 > 127 ? r0.numberToHexUnpadded(S0.length / 2 | 128) : "";
    return `${r0.numberToHexUnpadded(y0)}${k0}${S0}${E0}`;
  }, decode(y0, E0) {
    const { Err: b0 } = t0.DER;
    let O0 = 0;
    if (y0 < 0 || y0 > 256)
      throw new b0("tlv.encode: wrong tag");
    if (E0.length < 2 || E0[O0++] !== y0)
      throw new b0("tlv.decode: wrong tlv");
    const S0 = E0[O0++];
    let k0 = 0;
    if (128 & S0) {
      const z0 = 127 & S0;
      if (!z0)
        throw new b0("tlv.decode(long): indefinite length not supported");
      if (z0 > 4)
        throw new b0("tlv.decode(long): byte length is too big");
      const G0 = E0.subarray(O0, O0 + z0);
      if (G0.length !== z0)
        throw new b0("tlv.decode: length bytes not complete");
      if (G0[0] === 0)
        throw new b0("tlv.decode(long): zero leftmost byte");
      for (const K0 of G0)
        k0 = k0 << 8 | K0;
      if (O0 += z0, k0 < 128)
        throw new b0("tlv.decode(long): not minimal encoding");
    } else
      k0 = S0;
    const D0 = E0.subarray(O0, O0 + k0);
    if (D0.length !== k0)
      throw new b0("tlv.decode: wrong value length");
    return { v: D0, l: E0.subarray(O0 + k0) };
  } }, _int: { encode(y0) {
    const { Err: E0 } = t0.DER;
    if (y0 < c0)
      throw new E0("integer: negative integers are not allowed");
    let b0 = r0.numberToHexUnpadded(y0);
    if (8 & Number.parseInt(b0[0], 16) && (b0 = "00" + b0), 1 & b0.length)
      throw new E0("unexpected assertion");
    return b0;
  }, decode(y0) {
    const { Err: E0 } = t0.DER;
    if (128 & y0[0])
      throw new E0("Invalid signature integer: negative");
    if (y0[0] === 0 && !(128 & y0[1]))
      throw new E0("Invalid signature integer: unnecessary leading zero");
    return s0(y0);
  } }, toSig(y0) {
    const { Err: E0, _int: b0, _tlv: O0 } = t0.DER, S0 = typeof y0 == "string" ? a0(y0) : y0;
    r0.abytes(S0);
    const { v: k0, l: D0 } = O0.decode(48, S0);
    if (D0.length)
      throw new E0("Invalid signature: left bytes after parsing");
    const { v: z0, l: G0 } = O0.decode(2, k0), { v: K0, l: U0 } = O0.decode(2, G0);
    if (U0.length)
      throw new E0("Invalid signature: left bytes after parsing");
    return { r: b0.decode(z0), s: b0.decode(K0) };
  }, hexFromSig(y0) {
    const { _tlv: E0, _int: b0 } = t0.DER, O0 = `${E0.encode(2, b0.encode(y0.r))}${E0.encode(2, b0.encode(y0.s))}`;
    return E0.encode(48, O0);
  } };
  const c0 = BigInt(0), l0 = BigInt(1), u0 = BigInt(2), d0 = BigInt(3), h0 = BigInt(4);
  function g0(y0) {
    const E0 = function(I0) {
      const f0 = (0, e0.validateBasic)(I0);
      r0.validateObject(f0, { a: "field", b: "field" }, { allowedPrivateKeyLengths: "array", wrapPrivateKey: "boolean", isTorsionFree: "function", clearCofactor: "function", allowInfinityPoint: "boolean", fromBytes: "function", toBytes: "function" });
      const { endo: m0, Fp: A0, a: x0 } = f0;
      if (m0) {
        if (!A0.eql(x0, A0.ZERO))
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof m0 != "object" || typeof m0.beta != "bigint" || typeof m0.splitScalar != "function")
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
      return Object.freeze({ ...f0 });
    }(y0), { Fp: b0 } = E0, O0 = n0.Field(E0.n, E0.nBitLength), S0 = E0.toBytes || ((I0, f0, m0) => {
      const A0 = f0.toAffine();
      return r0.concatBytes(Uint8Array.from([4]), b0.toBytes(A0.x), b0.toBytes(A0.y));
    }), k0 = E0.fromBytes || ((I0) => {
      const f0 = I0.subarray(1);
      return { x: b0.fromBytes(f0.subarray(0, b0.BYTES)), y: b0.fromBytes(f0.subarray(b0.BYTES, 2 * b0.BYTES)) };
    });
    function D0(I0) {
      const { a: f0, b: m0 } = E0, A0 = b0.sqr(I0), x0 = b0.mul(A0, I0);
      return b0.add(b0.add(x0, b0.mul(I0, f0)), m0);
    }
    if (!b0.eql(b0.sqr(E0.Gy), D0(E0.Gx)))
      throw new Error("bad generator point: equation left != right");
    function z0(I0) {
      const { allowedPrivateKeyLengths: f0, nByteLength: m0, wrapPrivateKey: A0, n: x0 } = E0;
      if (f0 && typeof I0 != "bigint") {
        if (r0.isBytes(I0) && (I0 = r0.bytesToHex(I0)), typeof I0 != "string" || !f0.includes(I0.length))
          throw new Error("Invalid key");
        I0 = I0.padStart(2 * m0, "0");
      }
      let _0;
      try {
        _0 = typeof I0 == "bigint" ? I0 : r0.bytesToNumberBE((0, i0.ensureBytes)("private key", I0, m0));
      } catch {
        throw new Error(`private key must be ${m0} bytes, hex or bigint, not ${typeof I0}`);
      }
      return A0 && (_0 = n0.mod(_0, x0)), r0.aInRange("private key", _0, l0, x0), _0;
    }
    function G0(I0) {
      if (!(I0 instanceof F0))
        throw new Error("ProjectivePoint expected");
    }
    const K0 = (0, i0.memoized)((I0, f0) => {
      const { px: m0, py: A0, pz: x0 } = I0;
      if (b0.eql(x0, b0.ONE))
        return { x: m0, y: A0 };
      const _0 = I0.is0();
      f0 == null && (f0 = _0 ? b0.ONE : b0.inv(x0));
      const $0 = b0.mul(m0, f0), C0 = b0.mul(A0, f0), M0 = b0.mul(x0, f0);
      if (_0)
        return { x: b0.ZERO, y: b0.ZERO };
      if (!b0.eql(M0, b0.ONE))
        throw new Error("invZ was invalid");
      return { x: $0, y: C0 };
    }), U0 = (0, i0.memoized)((I0) => {
      if (I0.is0()) {
        if (E0.allowInfinityPoint && !b0.is0(I0.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: f0, y: m0 } = I0.toAffine();
      if (!b0.isValid(f0) || !b0.isValid(m0))
        throw new Error("bad point: x or y not FE");
      const A0 = b0.sqr(m0), x0 = D0(f0);
      if (!b0.eql(A0, x0))
        throw new Error("bad point: equation left != right");
      if (!I0.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return !0;
    });
    class F0 {
      constructor(f0, m0, A0) {
        if (this.px = f0, this.py = m0, this.pz = A0, f0 == null || !b0.isValid(f0))
          throw new Error("x required");
        if (m0 == null || !b0.isValid(m0))
          throw new Error("y required");
        if (A0 == null || !b0.isValid(A0))
          throw new Error("z required");
        Object.freeze(this);
      }
      static fromAffine(f0) {
        const { x: m0, y: A0 } = f0 || {};
        if (!f0 || !b0.isValid(m0) || !b0.isValid(A0))
          throw new Error("invalid affine point");
        if (f0 instanceof F0)
          throw new Error("projective point not allowed");
        const x0 = (_0) => b0.eql(_0, b0.ZERO);
        return x0(m0) && x0(A0) ? F0.ZERO : new F0(m0, A0, b0.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(f0) {
        const m0 = b0.invertBatch(f0.map((A0) => A0.pz));
        return f0.map((A0, x0) => A0.toAffine(m0[x0])).map(F0.fromAffine);
      }
      static fromHex(f0) {
        const m0 = F0.fromAffine(k0((0, i0.ensureBytes)("pointHex", f0)));
        return m0.assertValidity(), m0;
      }
      static fromPrivateKey(f0) {
        return F0.BASE.multiply(z0(f0));
      }
      static msm(f0, m0) {
        return (0, e0.pippenger)(F0, O0, f0, m0);
      }
      _setWindowSize(f0) {
        P0.setWindowSize(this, f0);
      }
      assertValidity() {
        U0(this);
      }
      hasEvenY() {
        const { y: f0 } = this.toAffine();
        if (b0.isOdd)
          return !b0.isOdd(f0);
        throw new Error("Field doesn't support isOdd");
      }
      equals(f0) {
        G0(f0);
        const { px: m0, py: A0, pz: x0 } = this, { px: _0, py: $0, pz: C0 } = f0, M0 = b0.eql(b0.mul(m0, C0), b0.mul(_0, x0)), p0 = b0.eql(b0.mul(A0, C0), b0.mul($0, x0));
        return M0 && p0;
      }
      negate() {
        return new F0(this.px, b0.neg(this.py), this.pz);
      }
      double() {
        const { a: f0, b: m0 } = E0, A0 = b0.mul(m0, d0), { px: x0, py: _0, pz: $0 } = this;
        let C0 = b0.ZERO, M0 = b0.ZERO, p0 = b0.ZERO, v0 = b0.mul(x0, x0), T0 = b0.mul(_0, _0), L0 = b0.mul($0, $0), B0 = b0.mul(x0, _0);
        return B0 = b0.add(B0, B0), p0 = b0.mul(x0, $0), p0 = b0.add(p0, p0), C0 = b0.mul(f0, p0), M0 = b0.mul(A0, L0), M0 = b0.add(C0, M0), C0 = b0.sub(T0, M0), M0 = b0.add(T0, M0), M0 = b0.mul(C0, M0), C0 = b0.mul(B0, C0), p0 = b0.mul(A0, p0), L0 = b0.mul(f0, L0), B0 = b0.sub(v0, L0), B0 = b0.mul(f0, B0), B0 = b0.add(B0, p0), p0 = b0.add(v0, v0), v0 = b0.add(p0, v0), v0 = b0.add(v0, L0), v0 = b0.mul(v0, B0), M0 = b0.add(M0, v0), L0 = b0.mul(_0, $0), L0 = b0.add(L0, L0), v0 = b0.mul(L0, B0), C0 = b0.sub(C0, v0), p0 = b0.mul(L0, T0), p0 = b0.add(p0, p0), p0 = b0.add(p0, p0), new F0(C0, M0, p0);
      }
      add(f0) {
        G0(f0);
        const { px: m0, py: A0, pz: x0 } = this, { px: _0, py: $0, pz: C0 } = f0;
        let M0 = b0.ZERO, p0 = b0.ZERO, v0 = b0.ZERO;
        const T0 = E0.a, L0 = b0.mul(E0.b, d0);
        let B0 = b0.mul(m0, _0), W0 = b0.mul(A0, $0), V0 = b0.mul(x0, C0), Q0 = b0.add(m0, A0), X0 = b0.add(_0, $0);
        Q0 = b0.mul(Q0, X0), X0 = b0.add(B0, W0), Q0 = b0.sub(Q0, X0), X0 = b0.add(m0, x0);
        let J0 = b0.add(_0, C0);
        return X0 = b0.mul(X0, J0), J0 = b0.add(B0, V0), X0 = b0.sub(X0, J0), J0 = b0.add(A0, x0), M0 = b0.add($0, C0), J0 = b0.mul(J0, M0), M0 = b0.add(W0, V0), J0 = b0.sub(J0, M0), v0 = b0.mul(T0, X0), M0 = b0.mul(L0, V0), v0 = b0.add(M0, v0), M0 = b0.sub(W0, v0), v0 = b0.add(W0, v0), p0 = b0.mul(M0, v0), W0 = b0.add(B0, B0), W0 = b0.add(W0, B0), V0 = b0.mul(T0, V0), X0 = b0.mul(L0, X0), W0 = b0.add(W0, V0), V0 = b0.sub(B0, V0), V0 = b0.mul(T0, V0), X0 = b0.add(X0, V0), B0 = b0.mul(W0, X0), p0 = b0.add(p0, B0), B0 = b0.mul(J0, X0), M0 = b0.mul(Q0, M0), M0 = b0.sub(M0, B0), B0 = b0.mul(Q0, W0), v0 = b0.mul(J0, v0), v0 = b0.add(v0, B0), new F0(M0, p0, v0);
      }
      subtract(f0) {
        return this.add(f0.negate());
      }
      is0() {
        return this.equals(F0.ZERO);
      }
      wNAF(f0) {
        return P0.wNAFCached(this, f0, F0.normalizeZ);
      }
      multiplyUnsafe(f0) {
        r0.aInRange("scalar", f0, c0, E0.n);
        const m0 = F0.ZERO;
        if (f0 === c0)
          return m0;
        if (f0 === l0)
          return this;
        const { endo: A0 } = E0;
        if (!A0)
          return P0.unsafeLadder(this, f0);
        let { k1neg: x0, k1: _0, k2neg: $0, k2: C0 } = A0.splitScalar(f0), M0 = m0, p0 = m0, v0 = this;
        for (; _0 > c0 || C0 > c0; )
          _0 & l0 && (M0 = M0.add(v0)), C0 & l0 && (p0 = p0.add(v0)), v0 = v0.double(), _0 >>= l0, C0 >>= l0;
        return x0 && (M0 = M0.negate()), $0 && (p0 = p0.negate()), p0 = new F0(b0.mul(p0.px, A0.beta), p0.py, p0.pz), M0.add(p0);
      }
      multiply(f0) {
        const { endo: m0, n: A0 } = E0;
        let x0, _0;
        if (r0.aInRange("scalar", f0, l0, A0), m0) {
          const { k1neg: $0, k1: C0, k2neg: M0, k2: p0 } = m0.splitScalar(f0);
          let { p: v0, f: T0 } = this.wNAF(C0), { p: L0, f: B0 } = this.wNAF(p0);
          v0 = P0.constTimeNegate($0, v0), L0 = P0.constTimeNegate(M0, L0), L0 = new F0(b0.mul(L0.px, m0.beta), L0.py, L0.pz), x0 = v0.add(L0), _0 = T0.add(B0);
        } else {
          const { p: $0, f: C0 } = this.wNAF(f0);
          x0 = $0, _0 = C0;
        }
        return F0.normalizeZ([x0, _0])[0];
      }
      multiplyAndAddUnsafe(f0, m0, A0) {
        const x0 = F0.BASE, _0 = (C0, M0) => M0 !== c0 && M0 !== l0 && C0.equals(x0) ? C0.multiply(M0) : C0.multiplyUnsafe(M0), $0 = _0(this, m0).add(_0(f0, A0));
        return $0.is0() ? void 0 : $0;
      }
      toAffine(f0) {
        return K0(this, f0);
      }
      isTorsionFree() {
        const { h: f0, isTorsionFree: m0 } = E0;
        if (f0 === l0)
          return !0;
        if (m0)
          return m0(F0, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: f0, clearCofactor: m0 } = E0;
        return f0 === l0 ? this : m0 ? m0(F0, this) : this.multiplyUnsafe(E0.h);
      }
      toRawBytes(f0 = !0) {
        return (0, i0.abool)("isCompressed", f0), this.assertValidity(), S0(F0, this, f0);
      }
      toHex(f0 = !0) {
        return (0, i0.abool)("isCompressed", f0), r0.bytesToHex(this.toRawBytes(f0));
      }
    }
    F0.BASE = new F0(E0.Gx, E0.Gy, b0.ONE), F0.ZERO = new F0(b0.ZERO, b0.ONE, b0.ZERO);
    const H0 = E0.nBitLength, P0 = (0, e0.wNAF)(F0, E0.endo ? Math.ceil(H0 / 2) : H0);
    return { CURVE: E0, ProjectivePoint: F0, normPrivateKeyToScalar: z0, weierstrassEquation: D0, isWithinCurveOrder: function(I0) {
      return r0.inRange(I0, l0, E0.n);
    } };
  }
  function w0(y0, E0) {
    const b0 = y0.ORDER;
    let O0 = c0;
    for (let I0 = b0 - l0; I0 % u0 === c0; I0 /= u0)
      O0 += l0;
    const S0 = O0, k0 = u0 << S0 - l0 - l0, D0 = k0 * u0, z0 = (b0 - l0) / D0, G0 = (z0 - l0) / u0, K0 = D0 - l0, U0 = k0, F0 = y0.pow(E0, z0), H0 = y0.pow(E0, (z0 + l0) / u0);
    let P0 = (I0, f0) => {
      let m0 = F0, A0 = y0.pow(f0, K0), x0 = y0.sqr(A0);
      x0 = y0.mul(x0, f0);
      let _0 = y0.mul(I0, x0);
      _0 = y0.pow(_0, G0), _0 = y0.mul(_0, A0), A0 = y0.mul(_0, f0), x0 = y0.mul(_0, I0);
      let $0 = y0.mul(x0, A0);
      _0 = y0.pow($0, U0);
      let C0 = y0.eql(_0, y0.ONE);
      A0 = y0.mul(x0, H0), _0 = y0.mul($0, m0), x0 = y0.cmov(A0, x0, C0), $0 = y0.cmov(_0, $0, C0);
      for (let M0 = S0; M0 > l0; M0--) {
        let p0 = M0 - u0;
        p0 = u0 << p0 - l0;
        let v0 = y0.pow($0, p0);
        const T0 = y0.eql(v0, y0.ONE);
        A0 = y0.mul(x0, m0), m0 = y0.mul(m0, m0), v0 = y0.mul($0, m0), x0 = y0.cmov(A0, x0, T0), $0 = y0.cmov(v0, $0, T0);
      }
      return { isValid: C0, value: x0 };
    };
    if (y0.ORDER % h0 === d0) {
      const I0 = (y0.ORDER - d0) / h0, f0 = y0.sqrt(y0.neg(E0));
      P0 = (m0, A0) => {
        let x0 = y0.sqr(A0);
        const _0 = y0.mul(m0, A0);
        x0 = y0.mul(x0, _0);
        let $0 = y0.pow(x0, I0);
        $0 = y0.mul($0, _0);
        const C0 = y0.mul($0, f0), M0 = y0.mul(y0.sqr($0), A0), p0 = y0.eql(M0, m0);
        return { isValid: p0, value: y0.cmov(C0, $0, p0) };
      };
    }
    return P0;
  }
})(ar), Object.defineProperty(or, "__esModule", { value: !0 }), or.getHash = ur, or.createCurve = function(t0, e0) {
  const n0 = (r0) => (0, dr.weierstrass)({ ...t0, ...ur(r0) });
  return Object.freeze({ ...n0(e0), create: n0 });
};
const cr = sr, lr = Fe$1, dr = ar;
function ur(t0) {
  return { hash: t0, hmac: (e0, ...n0) => (0, cr.hmac)(t0, e0, (0, lr.concatBytes)(...n0)), randomBytes: lr.randomBytes };
}
(function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.encodeToCurve = t0.hashToCurve = t0.schnorr = t0.secp256k1 = void 0;
  const e0 = Jn, n0 = Fe$1, r0 = or, i0 = Nn, o0 = Tt$1, s0 = Ot, a0 = ar, c0 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), l0 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), u0 = BigInt(1), d0 = BigInt(2), h0 = (_0, $0) => (_0 + $0 / d0) / $0;
  function g0(_0) {
    const $0 = c0, C0 = BigInt(3), M0 = BigInt(6), p0 = BigInt(11), v0 = BigInt(22), T0 = BigInt(23), L0 = BigInt(44), B0 = BigInt(88), W0 = _0 * _0 * _0 % $0, V0 = W0 * W0 * _0 % $0, Q0 = (0, o0.pow2)(V0, C0, $0) * V0 % $0, X0 = (0, o0.pow2)(Q0, C0, $0) * V0 % $0, J0 = (0, o0.pow2)(X0, d0, $0) * W0 % $0, yg = (0, o0.pow2)(J0, p0, $0) * J0 % $0, _g = (0, o0.pow2)(yg, v0, $0) * yg % $0, wg = (0, o0.pow2)(_g, L0, $0) * _g % $0, $g = (0, o0.pow2)(wg, B0, $0) * wg % $0, Eg = (0, o0.pow2)($g, L0, $0) * _g % $0, bg = (0, o0.pow2)(Eg, C0, $0) * V0 % $0, vg = (0, o0.pow2)(bg, T0, $0) * yg % $0, Ag = (0, o0.pow2)(vg, M0, $0) * W0 % $0, Ig = (0, o0.pow2)(Ag, d0, $0);
    if (!w0.eql(w0.sqr(Ig), _0))
      throw new Error("Cannot find square root");
    return Ig;
  }
  const w0 = (0, o0.Field)(c0, void 0, void 0, { sqrt: g0 });
  t0.secp256k1 = (0, r0.createCurve)({ a: BigInt(0), b: BigInt(7), Fp: w0, n: l0, Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"), Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"), h: BigInt(1), lowS: !0, endo: { beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"), splitScalar: (_0) => {
    const $0 = l0, C0 = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), M0 = -u0 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), p0 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), v0 = C0, T0 = BigInt("0x100000000000000000000000000000000"), L0 = h0(v0 * _0, $0), B0 = h0(-M0 * _0, $0);
    let W0 = (0, o0.mod)(_0 - L0 * C0 - B0 * p0, $0), V0 = (0, o0.mod)(-L0 * M0 - B0 * v0, $0);
    const Q0 = W0 > T0, X0 = V0 > T0;
    if (Q0 && (W0 = $0 - W0), X0 && (V0 = $0 - V0), W0 > T0 || V0 > T0)
      throw new Error("splitScalar: Endomorphism failed, k=" + _0);
    return { k1neg: Q0, k1: W0, k2neg: X0, k2: V0 };
  } } }, e0.sha256);
  const y0 = BigInt(0), E0 = {};
  function b0(_0, ...$0) {
    let C0 = E0[_0];
    if (C0 === void 0) {
      const M0 = (0, e0.sha256)(Uint8Array.from(_0, (p0) => p0.charCodeAt(0)));
      C0 = (0, s0.concatBytes)(M0, M0), E0[_0] = C0;
    }
    return (0, e0.sha256)((0, s0.concatBytes)(C0, ...$0));
  }
  const O0 = (_0) => _0.toRawBytes(!0).slice(1), S0 = (_0) => (0, s0.numberToBytesBE)(_0, 32), k0 = (_0) => (0, o0.mod)(_0, c0), D0 = (_0) => (0, o0.mod)(_0, l0), z0 = t0.secp256k1.ProjectivePoint, G0 = (_0, $0, C0) => z0.BASE.multiplyAndAddUnsafe(_0, $0, C0);
  function K0(_0) {
    let $0 = t0.secp256k1.utils.normPrivateKeyToScalar(_0), C0 = z0.fromPrivateKey($0);
    return { scalar: C0.hasEvenY() ? $0 : D0(-$0), bytes: O0(C0) };
  }
  function U0(_0) {
    (0, s0.aInRange)("x", _0, u0, c0);
    const $0 = k0(_0 * _0);
    let C0 = g0(k0($0 * _0 + BigInt(7)));
    C0 % d0 !== y0 && (C0 = k0(-C0));
    const M0 = new z0(_0, C0, u0);
    return M0.assertValidity(), M0;
  }
  const F0 = s0.bytesToNumberBE;
  function H0(..._0) {
    return D0(F0(b0("BIP0340/challenge", ..._0)));
  }
  function P0(_0) {
    return K0(_0).bytes;
  }
  function I0(_0, $0, C0 = (0, n0.randomBytes)(32)) {
    const M0 = (0, s0.ensureBytes)("message", _0), { bytes: p0, scalar: v0 } = K0($0), T0 = (0, s0.ensureBytes)("auxRand", C0, 32), L0 = S0(v0 ^ F0(b0("BIP0340/aux", T0))), B0 = b0("BIP0340/nonce", L0, p0, M0), W0 = D0(F0(B0));
    if (W0 === y0)
      throw new Error("sign failed: k is zero");
    const { bytes: V0, scalar: Q0 } = K0(W0), X0 = H0(V0, p0, M0), J0 = new Uint8Array(64);
    if (J0.set(V0, 0), J0.set(S0(D0(Q0 + X0 * v0)), 32), !f0(J0, M0, p0))
      throw new Error("sign: Invalid signature produced");
    return J0;
  }
  function f0(_0, $0, C0) {
    const M0 = (0, s0.ensureBytes)("signature", _0, 64), p0 = (0, s0.ensureBytes)("message", $0), v0 = (0, s0.ensureBytes)("publicKey", C0, 32);
    try {
      const T0 = U0(F0(v0)), L0 = F0(M0.subarray(0, 32));
      if (!(0, s0.inRange)(L0, u0, c0))
        return !1;
      const B0 = F0(M0.subarray(32, 64));
      if (!(0, s0.inRange)(B0, u0, l0))
        return !1;
      const W0 = H0(S0(L0), O0(T0), p0), V0 = G0(T0, B0, D0(-W0));
      return !(!V0 || !V0.hasEvenY() || V0.toAffine().x !== L0);
    } catch {
      return !1;
    }
  }
  t0.schnorr = { getPublicKey: P0, sign: I0, verify: f0, utils: { randomPrivateKey: t0.secp256k1.utils.randomPrivateKey, lift_x: U0, pointToBytes: O0, numberToBytesBE: s0.numberToBytesBE, bytesToNumberBE: s0.bytesToNumberBE, taggedHash: b0, mod: o0.mod } };
  const m0 = (() => (0, i0.isogenyMap)(w0, [["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7", "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581", "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262", "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"], ["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b", "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14", "0x0000000000000000000000000000000000000000000000000000000000000001"], ["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c", "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3", "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931", "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"], ["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b", "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573", "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f", "0x0000000000000000000000000000000000000000000000000000000000000001"]].map((_0) => _0.map(($0) => BigInt($0)))))(), A0 = (() => (0, a0.mapToCurveSimpleSWU)(w0, { A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"), B: BigInt("1771"), Z: w0.create(BigInt("-11")) }))(), x0 = (() => (0, i0.createHasher)(t0.secp256k1.ProjectivePoint, (_0) => {
    const { x: $0, y: C0 } = A0(w0.create(_0[0]));
    return m0($0, C0);
  }, { DST: "secp256k1_XMD:SHA-256_SSWU_RO_", encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_", p: w0.ORDER, m: 1, k: 128, expand: "xmd", hash: e0.sha256 }))();
  t0.hashToCurve = x0.hashToCurve, t0.encodeToCurve = x0.encodeToCurve;
})(Zn);
var hr = {};
(function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.decodeHex = t0.remove0x = void 0;
  var e0 = fe$1;
  t0.remove0x = function(n0) {
    return n0.startsWith("0x") || n0.startsWith("0X") ? n0.slice(2) : n0;
  }, t0.decodeHex = function(n0) {
    return (0, e0.hexToBytes)((0, t0.remove0x)(n0));
  };
})(hr), function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.hexToPublicKey = t0.convertPublicKeyFormat = t0.getSharedPoint = t0.getPublicKey = t0.isValidPrivateKey = t0.getValidSecret = void 0;
  var e0 = Ie, n0 = Pe$1, r0 = Zn, i0 = _e, o0 = Ce, s0 = hr;
  t0.getValidSecret = function() {
    var u0;
    do
      u0 = (0, e0.randomBytes)(o0.SECRET_KEY_LENGTH);
    while (!(0, t0.isValidPrivateKey)(u0));
    return u0;
  }, t0.isValidPrivateKey = function(u0) {
    return a0((0, i0.ellipticCurve)(), function(d0) {
      return d0.utils.isValidPrivateKey(u0);
    }, function() {
      return !0;
    }, function() {
      return !0;
    });
  }, t0.getPublicKey = function(u0) {
    return a0((0, i0.ellipticCurve)(), function(d0) {
      return d0.getPublicKey(u0);
    }, function(d0) {
      return d0.getPublicKey(u0);
    }, function(d0) {
      return d0.getPublicKey(u0);
    });
  }, t0.getSharedPoint = function(u0, d0, h0) {
    return a0((0, i0.ellipticCurve)(), function(g0) {
      return g0.getSharedSecret(u0, d0, h0);
    }, function(g0) {
      return g0.getSharedSecret(u0, d0);
    }, function(g0) {
      return l0(g0, u0, d0);
    });
  }, t0.convertPublicKeyFormat = function(u0, d0) {
    return a0((0, i0.ellipticCurve)(), function(h0) {
      return h0.getSharedSecret(BigInt(1), u0, d0);
    }, function() {
      return u0;
    }, function() {
      return u0;
    });
  };
  function a0(u0, d0, h0, g0) {
    if (u0 === "secp256k1")
      return d0(r0.secp256k1);
    if (u0 === "x25519")
      return h0(n0.x25519);
    if (u0 === "ed25519")
      return g0(n0.ed25519);
    throw new Error("Not implemented");
  }
  t0.hexToPublicKey = function(u0) {
    var d0 = (0, s0.decodeHex)(u0);
    return a0((0, i0.ellipticCurve)(), function() {
      return c0(d0);
    }, function() {
      return d0;
    }, function() {
      return d0;
    });
  };
  var c0 = function(u0) {
    if (u0.length === o0.ETH_PUBLIC_KEY_SIZE) {
      var d0 = new Uint8Array(1 + u0.length);
      return d0.set([4]), d0.set(u0, 1), d0;
    }
    return u0;
  }, l0 = function(u0, d0, h0) {
    var g0 = u0.utils.getExtendedPublicKey(d0).scalar;
    return u0.ExtendedPoint.fromHex(h0).multiply(g0).toRawBytes();
  };
}(Ae);
var fr = {}, pr = {};
Object.defineProperty(pr, "__esModule", { value: !0 }), pr.hkdf = void 0, pr.extract = vr, pr.expand = Er;
const gr = Le$1, mr = Fe$1, yr = sr;
function vr(t0, e0, n0) {
  return (0, gr.hash)(t0), n0 === void 0 && (n0 = new Uint8Array(t0.outputLen)), (0, yr.hmac)(t0, (0, mr.toBytes)(n0), (0, mr.toBytes)(e0));
}
const br = new Uint8Array([0]), wr = new Uint8Array();
function Er(t0, e0, n0, r0 = 32) {
  if ((0, gr.hash)(t0), (0, gr.number)(r0), r0 > 255 * t0.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const i0 = Math.ceil(r0 / t0.outputLen);
  n0 === void 0 && (n0 = wr);
  const o0 = new Uint8Array(i0 * t0.outputLen), s0 = yr.hmac.create(t0, e0), a0 = s0._cloneInto(), c0 = new Uint8Array(s0.outputLen);
  for (let l0 = 0; l0 < i0; l0++)
    br[0] = l0 + 1, a0.update(l0 === 0 ? wr : c0).update(n0).update(br).digestInto(c0), o0.set(c0, t0.outputLen * l0), s0._cloneInto(a0);
  return s0.destroy(), a0.destroy(), c0.fill(0), br.fill(0), o0.slice(0, r0);
}
pr.hkdf = (t0, e0, n0, r0, i0) => Er(t0, vr(t0, e0, n0), r0, i0), function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.getSharedKey = t0.deriveKey = void 0;
  var e0 = fe$1, n0 = pr, r0 = Jn;
  t0.deriveKey = function(i0, o0, s0) {
    return (0, n0.hkdf)(r0.sha256, i0, o0, s0, 32);
  }, t0.getSharedKey = function() {
    for (var i0 = [], o0 = 0; o0 < arguments.length; o0++)
      i0[o0] = arguments[o0];
    return (0, t0.deriveKey)(e0.concatBytes.apply(void 0, i0));
  };
}(fr);
var Sr = {}, _r = {}, Cr = {}, kr = {};
Object.defineProperty(kr, "__esModule", { value: !0 }), kr.polyval = kr.ghash = void 0, kr._toGHASHKey = Tr;
const xr = pe, Mr = fe$1, Ar = 16, Ir = new Uint8Array(16), Rr = (0, Mr.u32)(Ir), Pr = (t0) => (t0 >>> 0 & 255) << 24 | (t0 >>> 8 & 255) << 16 | (t0 >>> 16 & 255) << 8 | t0 >>> 24 & 255 | 0;
function Tr(t0) {
  t0.reverse();
  const e0 = 1 & t0[15];
  let n0 = 0;
  for (let r0 = 0; r0 < t0.length; r0++) {
    const i0 = t0[r0];
    t0[r0] = i0 >>> 1 | n0, n0 = (1 & i0) << 7;
  }
  return t0[0] ^= 225 & -e0, t0;
}
class Or {
  constructor(e0, n0) {
    this.blockLen = Ar, this.outputLen = Ar, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.s3 = 0, this.finished = !1, e0 = (0, Mr.toBytes)(e0), (0, xr.bytes)(e0, 16);
    const r0 = (0, Mr.createView)(e0);
    let i0 = r0.getUint32(0, !1), o0 = r0.getUint32(4, !1), s0 = r0.getUint32(8, !1), a0 = r0.getUint32(12, !1);
    const c0 = [];
    for (let b0 = 0; b0 < 128; b0++)
      c0.push({ s0: Pr(i0), s1: Pr(o0), s2: Pr(s0), s3: Pr(a0) }), { s0: i0, s1: o0, s2: s0, s3: a0 } = { s3: (d0 = s0) << 31 | (h0 = a0) >>> 1, s2: (u0 = o0) << 31 | d0 >>> 1, s1: (l0 = i0) << 31 | u0 >>> 1, s0: l0 >>> 1 ^ 225 << 24 & -(1 & h0) };
    var l0, u0, d0, h0;
    const g0 = ((b0) => b0 > 65536 ? 8 : b0 > 1024 ? 4 : 2)(n0 || 1024);
    if (![1, 2, 4, 8].includes(g0))
      throw new Error(`ghash: wrong window size=${g0}, should be 2, 4 or 8`);
    this.W = g0;
    const w0 = 128 / g0, y0 = this.windowSize = 2 ** g0, E0 = [];
    for (let b0 = 0; b0 < w0; b0++)
      for (let O0 = 0; O0 < y0; O0++) {
        let S0 = 0, k0 = 0, D0 = 0, z0 = 0;
        for (let G0 = 0; G0 < g0; G0++) {
          if (!(O0 >>> g0 - G0 - 1 & 1))
            continue;
          const { s0: K0, s1: U0, s2: F0, s3: H0 } = c0[g0 * b0 + G0];
          S0 ^= K0, k0 ^= U0, D0 ^= F0, z0 ^= H0;
        }
        E0.push({ s0: S0, s1: k0, s2: D0, s3: z0 });
      }
    this.t = E0;
  }
  _updateBlock(e0, n0, r0, i0) {
    e0 ^= this.s0, n0 ^= this.s1, r0 ^= this.s2, i0 ^= this.s3;
    const { W: o0, t: s0, windowSize: a0 } = this;
    let c0 = 0, l0 = 0, u0 = 0, d0 = 0;
    const h0 = (1 << o0) - 1;
    let g0 = 0;
    for (const w0 of [e0, n0, r0, i0])
      for (let y0 = 0; y0 < 4; y0++) {
        const E0 = w0 >>> 8 * y0 & 255;
        for (let b0 = 8 / o0 - 1; b0 >= 0; b0--) {
          const O0 = E0 >>> o0 * b0 & h0, { s0: S0, s1: k0, s2: D0, s3: z0 } = s0[g0 * a0 + O0];
          c0 ^= S0, l0 ^= k0, u0 ^= D0, d0 ^= z0, g0 += 1;
        }
      }
    this.s0 = c0, this.s1 = l0, this.s2 = u0, this.s3 = d0;
  }
  update(e0) {
    e0 = (0, Mr.toBytes)(e0), (0, xr.exists)(this);
    const n0 = (0, Mr.u32)(e0), r0 = Math.floor(e0.length / Ar), i0 = e0.length % Ar;
    for (let o0 = 0; o0 < r0; o0++)
      this._updateBlock(n0[4 * o0 + 0], n0[4 * o0 + 1], n0[4 * o0 + 2], n0[4 * o0 + 3]);
    return i0 && (Ir.set(e0.subarray(r0 * Ar)), this._updateBlock(Rr[0], Rr[1], Rr[2], Rr[3]), (0, Mr.clean)(Rr)), this;
  }
  destroy() {
    const { t: e0 } = this;
    for (const n0 of e0)
      n0.s0 = 0, n0.s1 = 0, n0.s2 = 0, n0.s3 = 0;
  }
  digestInto(e0) {
    (0, xr.exists)(this), (0, xr.output)(e0, this), this.finished = !0;
    const { s0: n0, s1: r0, s2: i0, s3: o0 } = this, s0 = (0, Mr.u32)(e0);
    return s0[0] = n0, s0[1] = r0, s0[2] = i0, s0[3] = o0, e0;
  }
  digest() {
    const e0 = new Uint8Array(Ar);
    return this.digestInto(e0), this.destroy(), e0;
  }
}
class Lr extends Or {
  constructor(e0, n0) {
    e0 = (0, Mr.toBytes)(e0);
    const r0 = Tr((0, Mr.copyBytes)(e0));
    super(r0, n0), (0, Mr.clean)(r0);
  }
  update(e0) {
    e0 = (0, Mr.toBytes)(e0), (0, xr.exists)(this);
    const n0 = (0, Mr.u32)(e0), r0 = e0.length % Ar, i0 = Math.floor(e0.length / Ar);
    for (let o0 = 0; o0 < i0; o0++)
      this._updateBlock(Pr(n0[4 * o0 + 3]), Pr(n0[4 * o0 + 2]), Pr(n0[4 * o0 + 1]), Pr(n0[4 * o0 + 0]));
    return r0 && (Ir.set(e0.subarray(i0 * Ar)), this._updateBlock(Pr(Rr[3]), Pr(Rr[2]), Pr(Rr[1]), Pr(Rr[0])), (0, Mr.clean)(Rr)), this;
  }
  digestInto(e0) {
    (0, xr.exists)(this), (0, xr.output)(e0, this), this.finished = !0;
    const { s0: n0, s1: r0, s2: i0, s3: o0 } = this, s0 = (0, Mr.u32)(e0);
    return s0[0] = n0, s0[1] = r0, s0[2] = i0, s0[3] = o0, e0.reverse();
  }
}
function Nr(t0) {
  const e0 = (r0, i0) => t0(i0, r0.length).update((0, Mr.toBytes)(r0)).digest(), n0 = t0(new Uint8Array(16), 0);
  return e0.outputLen = n0.outputLen, e0.blockLen = n0.blockLen, e0.create = (r0, i0) => t0(r0, i0), e0;
}
kr.ghash = Nr((t0, e0) => new Or(t0, e0)), kr.polyval = Nr((t0, e0) => new Lr(t0, e0)), Object.defineProperty(Cr, "__esModule", { value: !0 }), Cr.unsafe = Cr.aeskwp = Cr.aeskw = Cr.siv = Cr.gcm = Cr.cfb = Cr.cbc = Cr.ecb = Cr.ctr = void 0, Cr.expandKeyLE = Qr, Cr.expandKeyDecLE = ei;
const $r = pe, Dr = kr, Br = fe$1, Kr = 16, jr = new Uint8Array(Kr), Ur = 283;
function Hr(t0) {
  return t0 << 1 ^ Ur & -(t0 >> 7);
}
function Fr(t0, e0) {
  let n0 = 0;
  for (; e0 > 0; e0 >>= 1)
    n0 ^= t0 & -(1 & e0), t0 = Hr(t0);
  return n0;
}
const zr = (() => {
  const t0 = new Uint8Array(256);
  for (let n0 = 0, r0 = 1; n0 < 256; n0++, r0 ^= Hr(r0))
    t0[n0] = r0;
  const e0 = new Uint8Array(256);
  e0[0] = 99;
  for (let n0 = 0; n0 < 255; n0++) {
    let r0 = t0[255 - n0];
    r0 |= r0 << 8, e0[t0[n0]] = 255 & (r0 ^ r0 >> 4 ^ r0 >> 5 ^ r0 >> 6 ^ r0 >> 7 ^ 99);
  }
  return (0, Br.clean)(t0), e0;
})(), qr = zr.map((t0, e0) => zr.indexOf(e0)), Wr = (t0) => t0 << 24 | t0 >>> 8, Vr = (t0) => t0 << 8 | t0 >>> 24, Gr = (t0) => t0 << 24 & 4278190080 | t0 << 8 & 16711680 | t0 >>> 8 & 65280 | t0 >>> 24 & 255;
function Yr(t0, e0) {
  if (t0.length !== 256)
    throw new Error("Wrong sbox length");
  const n0 = new Uint32Array(256).map((l0, u0) => e0(t0[u0])), r0 = n0.map(Vr), i0 = r0.map(Vr), o0 = i0.map(Vr), s0 = new Uint32Array(65536), a0 = new Uint32Array(65536), c0 = new Uint16Array(65536);
  for (let l0 = 0; l0 < 256; l0++)
    for (let u0 = 0; u0 < 256; u0++) {
      const d0 = 256 * l0 + u0;
      s0[d0] = n0[l0] ^ r0[u0], a0[d0] = i0[l0] ^ o0[u0], c0[d0] = t0[l0] << 8 | t0[u0];
    }
  return { sbox: t0, sbox2: c0, T0: n0, T1: r0, T2: i0, T3: o0, T01: s0, T23: a0 };
}
const Zr = Yr(zr, (t0) => Fr(t0, 3) << 24 | t0 << 16 | t0 << 8 | Fr(t0, 2)), Jr = Yr(qr, (t0) => Fr(t0, 11) << 24 | Fr(t0, 13) << 16 | Fr(t0, 9) << 8 | Fr(t0, 14)), Xr = (() => {
  const t0 = new Uint8Array(16);
  for (let e0 = 0, n0 = 1; e0 < 16; e0++, n0 = Hr(n0))
    t0[e0] = n0;
  return t0;
})();
function Qr(t0) {
  (0, $r.bytes)(t0);
  const e0 = t0.length;
  if (![16, 24, 32].includes(e0))
    throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${e0}`);
  const { sbox2: n0 } = Zr, r0 = [];
  (0, Br.isAligned32)(t0) || r0.push(t0 = (0, Br.copyBytes)(t0));
  const i0 = (0, Br.u32)(t0), o0 = i0.length, s0 = (c0) => ni(n0, c0, c0, c0, c0), a0 = new Uint32Array(e0 + 28);
  a0.set(i0);
  for (let c0 = o0; c0 < a0.length; c0++) {
    let l0 = a0[c0 - 1];
    c0 % o0 == 0 ? l0 = s0(Wr(l0)) ^ Xr[c0 / o0 - 1] : o0 > 6 && c0 % o0 == 4 && (l0 = s0(l0)), a0[c0] = a0[c0 - o0] ^ l0;
  }
  return (0, Br.clean)(...r0), a0;
}
function ei(t0) {
  const e0 = Qr(t0), n0 = e0.slice(), r0 = e0.length, { sbox2: i0 } = Zr, { T0: o0, T1: s0, T2: a0, T3: c0 } = Jr;
  for (let l0 = 0; l0 < r0; l0 += 4)
    for (let u0 = 0; u0 < 4; u0++)
      n0[l0 + u0] = e0[r0 - l0 - 4 + u0];
  (0, Br.clean)(e0);
  for (let l0 = 4; l0 < r0 - 4; l0++) {
    const u0 = n0[l0], d0 = ni(i0, u0, u0, u0, u0);
    n0[l0] = o0[255 & d0] ^ s0[d0 >>> 8 & 255] ^ a0[d0 >>> 16 & 255] ^ c0[d0 >>> 24];
  }
  return n0;
}
function ti(t0, e0, n0, r0, i0, o0) {
  return t0[n0 << 8 & 65280 | r0 >>> 8 & 255] ^ e0[i0 >>> 8 & 65280 | o0 >>> 24 & 255];
}
function ni(t0, e0, n0, r0, i0) {
  return t0[255 & e0 | 65280 & n0] | t0[r0 >>> 16 & 255 | i0 >>> 16 & 65280] << 16;
}
function ri(t0, e0, n0, r0, i0) {
  const { sbox2: o0, T01: s0, T23: a0 } = Zr;
  let c0 = 0;
  e0 ^= t0[c0++], n0 ^= t0[c0++], r0 ^= t0[c0++], i0 ^= t0[c0++];
  const l0 = t0.length / 4 - 2;
  for (let u0 = 0; u0 < l0; u0++) {
    const d0 = t0[c0++] ^ ti(s0, a0, e0, n0, r0, i0), h0 = t0[c0++] ^ ti(s0, a0, n0, r0, i0, e0), g0 = t0[c0++] ^ ti(s0, a0, r0, i0, e0, n0), w0 = t0[c0++] ^ ti(s0, a0, i0, e0, n0, r0);
    e0 = d0, n0 = h0, r0 = g0, i0 = w0;
  }
  return { s0: t0[c0++] ^ ni(o0, e0, n0, r0, i0), s1: t0[c0++] ^ ni(o0, n0, r0, i0, e0), s2: t0[c0++] ^ ni(o0, r0, i0, e0, n0), s3: t0[c0++] ^ ni(o0, i0, e0, n0, r0) };
}
function ii(t0, e0, n0, r0, i0) {
  const { sbox2: o0, T01: s0, T23: a0 } = Jr;
  let c0 = 0;
  e0 ^= t0[c0++], n0 ^= t0[c0++], r0 ^= t0[c0++], i0 ^= t0[c0++];
  const l0 = t0.length / 4 - 2;
  for (let u0 = 0; u0 < l0; u0++) {
    const d0 = t0[c0++] ^ ti(s0, a0, e0, i0, r0, n0), h0 = t0[c0++] ^ ti(s0, a0, n0, e0, i0, r0), g0 = t0[c0++] ^ ti(s0, a0, r0, n0, e0, i0), w0 = t0[c0++] ^ ti(s0, a0, i0, r0, n0, e0);
    e0 = d0, n0 = h0, r0 = g0, i0 = w0;
  }
  return { s0: t0[c0++] ^ ni(o0, e0, i0, r0, n0), s1: t0[c0++] ^ ni(o0, n0, e0, i0, r0), s2: t0[c0++] ^ ni(o0, r0, n0, e0, i0), s3: t0[c0++] ^ ni(o0, i0, r0, n0, e0) };
}
function oi(t0, e0) {
  if (e0 === void 0)
    return new Uint8Array(t0);
  if ((0, $r.bytes)(e0), e0.length < t0)
    throw new Error(`aes: wrong destination length, expected at least ${t0}, got: ${e0.length}`);
  if (!(0, Br.isAligned32)(e0))
    throw new Error("unaligned dst");
  return e0;
}
function si(t0, e0, n0, r0) {
  (0, $r.bytes)(e0, Kr), (0, $r.bytes)(n0);
  const i0 = n0.length;
  r0 = oi(i0, r0);
  const o0 = e0, s0 = (0, Br.u32)(o0);
  let { s0: a0, s1: c0, s2: l0, s3: u0 } = ri(t0, s0[0], s0[1], s0[2], s0[3]);
  const d0 = (0, Br.u32)(n0), h0 = (0, Br.u32)(r0);
  for (let w0 = 0; w0 + 4 <= d0.length; w0 += 4) {
    h0[w0 + 0] = d0[w0 + 0] ^ a0, h0[w0 + 1] = d0[w0 + 1] ^ c0, h0[w0 + 2] = d0[w0 + 2] ^ l0, h0[w0 + 3] = d0[w0 + 3] ^ u0;
    let y0 = 1;
    for (let E0 = o0.length - 1; E0 >= 0; E0--)
      y0 = y0 + (255 & o0[E0]) | 0, o0[E0] = 255 & y0, y0 >>>= 8;
    ({ s0: a0, s1: c0, s2: l0, s3: u0 } = ri(t0, s0[0], s0[1], s0[2], s0[3]));
  }
  const g0 = Kr * Math.floor(d0.length / 4);
  if (g0 < i0) {
    const w0 = new Uint32Array([a0, c0, l0, u0]), y0 = (0, Br.u8)(w0);
    for (let E0 = g0, b0 = 0; E0 < i0; E0++, b0++)
      r0[E0] = n0[E0] ^ y0[b0];
    (0, Br.clean)(w0);
  }
  return r0;
}
function ai(t0, e0, n0, r0, i0) {
  (0, $r.bytes)(n0, Kr), (0, $r.bytes)(r0), i0 = oi(r0.length, i0);
  const o0 = n0, s0 = (0, Br.u32)(o0), a0 = (0, Br.createView)(o0), c0 = (0, Br.u32)(r0), l0 = (0, Br.u32)(i0), u0 = e0 ? 0 : 12, d0 = r0.length;
  let h0 = a0.getUint32(u0, e0), { s0: g0, s1: w0, s2: y0, s3: E0 } = ri(t0, s0[0], s0[1], s0[2], s0[3]);
  for (let O0 = 0; O0 + 4 <= c0.length; O0 += 4)
    l0[O0 + 0] = c0[O0 + 0] ^ g0, l0[O0 + 1] = c0[O0 + 1] ^ w0, l0[O0 + 2] = c0[O0 + 2] ^ y0, l0[O0 + 3] = c0[O0 + 3] ^ E0, h0 = h0 + 1 >>> 0, a0.setUint32(u0, h0, e0), { s0: g0, s1: w0, s2: y0, s3: E0 } = ri(t0, s0[0], s0[1], s0[2], s0[3]);
  const b0 = Kr * Math.floor(c0.length / 4);
  if (b0 < d0) {
    const O0 = new Uint32Array([g0, w0, y0, E0]), S0 = (0, Br.u8)(O0);
    for (let k0 = b0, D0 = 0; k0 < d0; k0++, D0++)
      i0[k0] = r0[k0] ^ S0[D0];
    (0, Br.clean)(O0);
  }
  return i0;
}
function ci(t0) {
  if ((0, $r.bytes)(t0), t0.length % Kr != 0)
    throw new Error("aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size 16");
}
function li(t0, e0, n0) {
  (0, $r.bytes)(t0);
  let r0 = t0.length;
  const i0 = r0 % Kr;
  if (!e0 && i0 !== 0)
    throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
  (0, Br.isAligned32)(t0) || (t0 = (0, Br.copyBytes)(t0));
  const o0 = (0, Br.u32)(t0);
  if (e0) {
    let a0 = Kr - i0;
    a0 || (a0 = Kr), r0 += a0;
  }
  const s0 = oi(r0, n0);
  return { b: o0, o: (0, Br.u32)(s0), out: s0 };
}
function di(t0, e0) {
  if (!e0)
    return t0;
  const n0 = t0.length;
  if (!n0)
    throw new Error("aes/pcks5: empty ciphertext not allowed");
  const r0 = t0[n0 - 1];
  if (r0 <= 0 || r0 > 16)
    throw new Error("aes/pcks5: wrong padding");
  const i0 = t0.subarray(0, -r0);
  for (let o0 = 0; o0 < r0; o0++)
    if (t0[n0 - o0 - 1] !== r0)
      throw new Error("aes/pcks5: wrong padding");
  return i0;
}
function ui(t0) {
  const e0 = new Uint8Array(16), n0 = (0, Br.u32)(e0);
  e0.set(t0);
  const r0 = Kr - t0.length;
  for (let i0 = Kr - r0; i0 < Kr; i0++)
    e0[i0] = r0;
  return n0;
}
function hi(t0, e0, n0, r0, i0) {
  const o0 = i0 == null ? 0 : i0.length, s0 = t0.create(n0, r0.length + o0);
  i0 && s0.update(i0), s0.update(r0);
  const a0 = new Uint8Array(16), c0 = (0, Br.createView)(a0);
  i0 && (0, Br.setBigUint64)(c0, 0, BigInt(8 * o0), e0), (0, Br.setBigUint64)(c0, 8, BigInt(8 * r0.length), e0), s0.update(a0);
  const l0 = s0.digest();
  return (0, Br.clean)(a0), l0;
}
Cr.ctr = (0, Br.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function(t0, e0) {
  function n0(r0, i0) {
    if ((0, $r.bytes)(r0), i0 !== void 0 && ((0, $r.bytes)(i0), !(0, Br.isAligned32)(i0)))
      throw new Error("unaligned destination");
    const o0 = Qr(t0), s0 = (0, Br.copyBytes)(e0), a0 = [o0, s0];
    (0, Br.isAligned32)(r0) || a0.push(r0 = (0, Br.copyBytes)(r0));
    const c0 = si(o0, s0, r0, i0);
    return (0, Br.clean)(...a0), c0;
  }
  return (0, $r.bytes)(t0), (0, $r.bytes)(e0, Kr), { encrypt: (r0, i0) => n0(r0, i0), decrypt: (r0, i0) => n0(r0, i0) };
}), Cr.ecb = (0, Br.wrapCipher)({ blockSize: 16 }, function(t0, e0 = {}) {
  (0, $r.bytes)(t0);
  const n0 = !e0.disablePadding;
  return { encrypt(r0, i0) {
    const { b: o0, o: s0, out: a0 } = li(r0, n0, i0), c0 = Qr(t0);
    let l0 = 0;
    for (; l0 + 4 <= o0.length; ) {
      const { s0: u0, s1: d0, s2: h0, s3: g0 } = ri(c0, o0[l0 + 0], o0[l0 + 1], o0[l0 + 2], o0[l0 + 3]);
      s0[l0++] = u0, s0[l0++] = d0, s0[l0++] = h0, s0[l0++] = g0;
    }
    if (n0) {
      const u0 = ui(r0.subarray(4 * l0)), { s0: d0, s1: h0, s2: g0, s3: w0 } = ri(c0, u0[0], u0[1], u0[2], u0[3]);
      s0[l0++] = d0, s0[l0++] = h0, s0[l0++] = g0, s0[l0++] = w0;
    }
    return (0, Br.clean)(c0), a0;
  }, decrypt(r0, i0) {
    ci(r0);
    const o0 = ei(t0), s0 = oi(r0.length, i0), a0 = [o0];
    (0, Br.isAligned32)(r0) || a0.push(r0 = (0, Br.copyBytes)(r0));
    const c0 = (0, Br.u32)(r0), l0 = (0, Br.u32)(s0);
    for (let u0 = 0; u0 + 4 <= c0.length; ) {
      const { s0: d0, s1: h0, s2: g0, s3: w0 } = ii(o0, c0[u0 + 0], c0[u0 + 1], c0[u0 + 2], c0[u0 + 3]);
      l0[u0++] = d0, l0[u0++] = h0, l0[u0++] = g0, l0[u0++] = w0;
    }
    return (0, Br.clean)(...a0), di(s0, n0);
  } };
}), Cr.cbc = (0, Br.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function(t0, e0, n0 = {}) {
  (0, $r.bytes)(t0), (0, $r.bytes)(e0, 16);
  const r0 = !n0.disablePadding;
  return { encrypt(i0, o0) {
    const s0 = Qr(t0), { b: a0, o: c0, out: l0 } = li(i0, r0, o0);
    let u0 = e0;
    const d0 = [s0];
    (0, Br.isAligned32)(u0) || d0.push(u0 = (0, Br.copyBytes)(u0));
    const h0 = (0, Br.u32)(u0);
    let g0 = h0[0], w0 = h0[1], y0 = h0[2], E0 = h0[3], b0 = 0;
    for (; b0 + 4 <= a0.length; )
      g0 ^= a0[b0 + 0], w0 ^= a0[b0 + 1], y0 ^= a0[b0 + 2], E0 ^= a0[b0 + 3], { s0: g0, s1: w0, s2: y0, s3: E0 } = ri(s0, g0, w0, y0, E0), c0[b0++] = g0, c0[b0++] = w0, c0[b0++] = y0, c0[b0++] = E0;
    if (r0) {
      const O0 = ui(i0.subarray(4 * b0));
      g0 ^= O0[0], w0 ^= O0[1], y0 ^= O0[2], E0 ^= O0[3], { s0: g0, s1: w0, s2: y0, s3: E0 } = ri(s0, g0, w0, y0, E0), c0[b0++] = g0, c0[b0++] = w0, c0[b0++] = y0, c0[b0++] = E0;
    }
    return (0, Br.clean)(...d0), l0;
  }, decrypt(i0, o0) {
    ci(i0);
    const s0 = ei(t0);
    let a0 = e0;
    const c0 = [s0];
    (0, Br.isAligned32)(a0) || c0.push(a0 = (0, Br.copyBytes)(a0));
    const l0 = (0, Br.u32)(a0), u0 = oi(i0.length, o0);
    (0, Br.isAligned32)(i0) || c0.push(i0 = (0, Br.copyBytes)(i0));
    const d0 = (0, Br.u32)(i0), h0 = (0, Br.u32)(u0);
    let g0 = l0[0], w0 = l0[1], y0 = l0[2], E0 = l0[3];
    for (let b0 = 0; b0 + 4 <= d0.length; ) {
      const O0 = g0, S0 = w0, k0 = y0, D0 = E0;
      g0 = d0[b0 + 0], w0 = d0[b0 + 1], y0 = d0[b0 + 2], E0 = d0[b0 + 3];
      const { s0: z0, s1: G0, s2: K0, s3: U0 } = ii(s0, g0, w0, y0, E0);
      h0[b0++] = z0 ^ O0, h0[b0++] = G0 ^ S0, h0[b0++] = K0 ^ k0, h0[b0++] = U0 ^ D0;
    }
    return (0, Br.clean)(...c0), di(u0, r0);
  } };
}), Cr.cfb = (0, Br.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function(t0, e0) {
  function n0(r0, i0, o0) {
    (0, $r.bytes)(r0);
    const s0 = r0.length;
    o0 = oi(s0, o0);
    const a0 = Qr(t0);
    let c0 = e0;
    const l0 = [a0];
    (0, Br.isAligned32)(c0) || l0.push(c0 = (0, Br.copyBytes)(c0)), (0, Br.isAligned32)(r0) || l0.push(r0 = (0, Br.copyBytes)(r0));
    const u0 = (0, Br.u32)(r0), d0 = (0, Br.u32)(o0), h0 = i0 ? d0 : u0, g0 = (0, Br.u32)(c0);
    let w0 = g0[0], y0 = g0[1], E0 = g0[2], b0 = g0[3];
    for (let S0 = 0; S0 + 4 <= u0.length; ) {
      const { s0: k0, s1: D0, s2: z0, s3: G0 } = ri(a0, w0, y0, E0, b0);
      d0[S0 + 0] = u0[S0 + 0] ^ k0, d0[S0 + 1] = u0[S0 + 1] ^ D0, d0[S0 + 2] = u0[S0 + 2] ^ z0, d0[S0 + 3] = u0[S0 + 3] ^ G0, w0 = h0[S0++], y0 = h0[S0++], E0 = h0[S0++], b0 = h0[S0++];
    }
    const O0 = Kr * Math.floor(u0.length / 4);
    if (O0 < s0) {
      ({ s0: w0, s1: y0, s2: E0, s3: b0 } = ri(a0, w0, y0, E0, b0));
      const S0 = (0, Br.u8)(new Uint32Array([w0, y0, E0, b0]));
      for (let k0 = O0, D0 = 0; k0 < s0; k0++, D0++)
        o0[k0] = r0[k0] ^ S0[D0];
      (0, Br.clean)(S0);
    }
    return (0, Br.clean)(...l0), o0;
  }
  return (0, $r.bytes)(t0), (0, $r.bytes)(e0, 16), { encrypt: (r0, i0) => n0(r0, !0, i0), decrypt: (r0, i0) => n0(r0, !1, i0) };
}), Cr.gcm = (0, Br.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function(t0, e0, n0) {
  if ((0, $r.bytes)(t0), (0, $r.bytes)(e0), n0 !== void 0 && (0, $r.bytes)(n0), e0.length < 8)
    throw new Error("aes/gcm: invalid nonce length");
  const r0 = 16;
  function i0(s0, a0, c0) {
    const l0 = hi(Dr.ghash, !1, s0, c0, n0);
    for (let u0 = 0; u0 < a0.length; u0++)
      l0[u0] ^= a0[u0];
    return l0;
  }
  function o0() {
    const s0 = Qr(t0), a0 = jr.slice(), c0 = jr.slice();
    if (ai(s0, !1, c0, c0, a0), e0.length === 12)
      c0.set(e0);
    else {
      const l0 = jr.slice(), u0 = (0, Br.createView)(l0);
      (0, Br.setBigUint64)(u0, 8, BigInt(8 * e0.length), !1);
      const d0 = Dr.ghash.create(a0).update(e0).update(l0);
      d0.digestInto(c0), d0.destroy();
    }
    return { xk: s0, authKey: a0, counter: c0, tagMask: ai(s0, !1, c0, jr) };
  }
  return { encrypt(s0) {
    (0, $r.bytes)(s0);
    const { xk: a0, authKey: c0, counter: l0, tagMask: u0 } = o0(), d0 = new Uint8Array(s0.length + r0), h0 = [a0, c0, l0, u0];
    (0, Br.isAligned32)(s0) || h0.push(s0 = (0, Br.copyBytes)(s0)), ai(a0, !1, l0, s0, d0);
    const g0 = i0(c0, u0, d0.subarray(0, d0.length - r0));
    return h0.push(g0), d0.set(g0, s0.length), (0, Br.clean)(...h0), d0;
  }, decrypt(s0) {
    if ((0, $r.bytes)(s0), s0.length < r0)
      throw new Error("aes/gcm: ciphertext less than tagLen (16)");
    const { xk: a0, authKey: c0, counter: l0, tagMask: u0 } = o0(), d0 = [a0, c0, u0, l0];
    (0, Br.isAligned32)(s0) || d0.push(s0 = (0, Br.copyBytes)(s0));
    const h0 = s0.subarray(0, -16), g0 = s0.subarray(-16), w0 = i0(c0, u0, h0);
    if (d0.push(w0), !(0, Br.equalBytes)(w0, g0))
      throw new Error("aes/gcm: invalid ghash tag");
    const y0 = ai(a0, !1, l0, h0);
    return (0, Br.clean)(...d0), y0;
  } };
});
const fi = (t0, e0, n0) => (r0) => {
  if (!Number.isSafeInteger(r0) || e0 > r0 || r0 > n0)
    throw new Error(`${t0}: invalid value=${r0}, must be [${e0}..${n0}]`);
};
function pi(t0) {
  return t0 != null && typeof t0 == "object" && (t0 instanceof Uint32Array || t0.constructor.name === "Uint32Array");
}
function gi(t0, e0) {
  if ((0, $r.bytes)(e0, 16), !pi(t0))
    throw new Error("_encryptBlock accepts result of expandKeyLE");
  const n0 = (0, Br.u32)(e0);
  let { s0: r0, s1: i0, s2: o0, s3: s0 } = ri(t0, n0[0], n0[1], n0[2], n0[3]);
  return n0[0] = r0, n0[1] = i0, n0[2] = o0, n0[3] = s0, e0;
}
function mi(t0, e0) {
  if ((0, $r.bytes)(e0, 16), !pi(t0))
    throw new Error("_decryptBlock accepts result of expandKeyLE");
  const n0 = (0, Br.u32)(e0);
  let { s0: r0, s1: i0, s2: o0, s3: s0 } = ii(t0, n0[0], n0[1], n0[2], n0[3]);
  return n0[0] = r0, n0[1] = i0, n0[2] = o0, n0[3] = s0, e0;
}
Cr.siv = (0, Br.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function(t0, e0, n0) {
  const r0 = fi("AAD", 0, 68719476736), i0 = fi("plaintext", 0, 2 ** 36), o0 = fi("nonce", 12, 12), s0 = fi("ciphertext", 16, 2 ** 36 + 16);
  function a0() {
    const u0 = Qr(t0), d0 = new Uint8Array(t0.length), h0 = new Uint8Array(16), g0 = [u0, d0];
    let w0 = e0;
    (0, Br.isAligned32)(w0) || g0.push(w0 = (0, Br.copyBytes)(w0));
    const y0 = (0, Br.u32)(w0);
    let E0 = 0, b0 = y0[0], O0 = y0[1], S0 = y0[2], k0 = 0;
    for (const z0 of [h0, d0].map(Br.u32)) {
      const G0 = (0, Br.u32)(z0);
      for (let K0 = 0; K0 < G0.length; K0 += 2) {
        const { s0: U0, s1: F0 } = ri(u0, E0, b0, O0, S0);
        G0[K0 + 0] = U0, G0[K0 + 1] = F0, E0 = ++k0;
      }
    }
    const D0 = { authKey: h0, encKey: Qr(d0) };
    return (0, Br.clean)(...g0), D0;
  }
  function c0(u0, d0, h0) {
    const g0 = hi(Dr.polyval, !0, d0, h0, n0);
    for (let S0 = 0; S0 < 12; S0++)
      g0[S0] ^= e0[S0];
    g0[15] &= 127;
    const w0 = (0, Br.u32)(g0);
    let y0 = w0[0], E0 = w0[1], b0 = w0[2], O0 = w0[3];
    return { s0: y0, s1: E0, s2: b0, s3: O0 } = ri(u0, y0, E0, b0, O0), w0[0] = y0, w0[1] = E0, w0[2] = b0, w0[3] = O0, g0;
  }
  function l0(u0, d0, h0) {
    let g0 = (0, Br.copyBytes)(d0);
    g0[15] |= 128;
    const w0 = ai(u0, !0, g0, h0);
    return (0, Br.clean)(g0), w0;
  }
  return (0, $r.bytes)(t0, 16, 24, 32), (0, $r.bytes)(e0), o0(e0.length), n0 !== void 0 && ((0, $r.bytes)(n0), r0(n0.length)), { encrypt(u0) {
    (0, $r.bytes)(u0), i0(u0.length);
    const { encKey: d0, authKey: h0 } = a0(), g0 = c0(d0, h0, u0), w0 = [d0, h0, g0];
    (0, Br.isAligned32)(u0) || w0.push(u0 = (0, Br.copyBytes)(u0));
    const y0 = new Uint8Array(u0.length + 16);
    return y0.set(g0, u0.length), y0.set(l0(d0, g0, u0)), (0, Br.clean)(...w0), y0;
  }, decrypt(u0) {
    (0, $r.bytes)(u0), s0(u0.length);
    const d0 = u0.subarray(-16), { encKey: h0, authKey: g0 } = a0(), w0 = [h0, g0];
    (0, Br.isAligned32)(u0) || w0.push(u0 = (0, Br.copyBytes)(u0));
    const y0 = l0(h0, d0, u0.subarray(0, -16)), E0 = c0(h0, g0, y0);
    if (w0.push(E0), !(0, Br.equalBytes)(d0, E0))
      throw (0, Br.clean)(...w0), new Error("invalid polyval tag");
    return (0, Br.clean)(...w0), y0;
  } };
});
const yi = { encrypt(t0, e0) {
  if (e0.length >= 2 ** 32)
    throw new Error("plaintext should be less than 4gb");
  const n0 = Qr(t0);
  if (e0.length === 16)
    gi(n0, e0);
  else {
    const r0 = (0, Br.u32)(e0);
    let i0 = r0[0], o0 = r0[1];
    for (let s0 = 0, a0 = 1; s0 < 6; s0++)
      for (let c0 = 2; c0 < r0.length; c0 += 2, a0++) {
        const { s0: l0, s1: u0, s2: d0, s3: h0 } = ri(n0, i0, o0, r0[c0], r0[c0 + 1]);
        i0 = l0, o0 = u0 ^ Gr(a0), r0[c0] = d0, r0[c0 + 1] = h0;
      }
    r0[0] = i0, r0[1] = o0;
  }
  n0.fill(0);
}, decrypt(t0, e0) {
  if (e0.length - 8 >= 2 ** 32)
    throw new Error("ciphertext should be less than 4gb");
  const n0 = ei(t0), r0 = e0.length / 8 - 1;
  if (r0 === 1)
    mi(n0, e0);
  else {
    const i0 = (0, Br.u32)(e0);
    let o0 = i0[0], s0 = i0[1];
    for (let a0 = 0, c0 = 6 * r0; a0 < 6; a0++)
      for (let l0 = 2 * r0; l0 >= 1; l0 -= 2, c0--) {
        s0 ^= Gr(c0);
        const { s0: u0, s1: d0, s2: h0, s3: g0 } = ii(n0, o0, s0, i0[l0], i0[l0 + 1]);
        o0 = u0, s0 = d0, i0[l0] = h0, i0[l0 + 1] = g0;
      }
    i0[0] = o0, i0[1] = s0;
  }
  n0.fill(0);
} }, vi = new Uint8Array(8).fill(166);
Cr.aeskw = (0, Br.wrapCipher)({ blockSize: 8 }, (t0) => ({ encrypt(e0) {
  if ((0, $r.bytes)(e0), !e0.length || e0.length % 8 != 0)
    throw new Error("invalid plaintext length");
  if (e0.length === 8)
    throw new Error("8-byte keys not allowed in AESKW, use AESKWP instead");
  const n0 = (0, Br.concatBytes)(vi, e0);
  return yi.encrypt(t0, n0), n0;
}, decrypt(e0) {
  if ((0, $r.bytes)(e0), e0.length % 8 != 0 || e0.length < 24)
    throw new Error("invalid ciphertext length");
  const n0 = (0, Br.copyBytes)(e0);
  if (yi.decrypt(t0, n0), !(0, Br.equalBytes)(n0.subarray(0, 8), vi))
    throw new Error("integrity check failed");
  return n0.subarray(0, 8).fill(0), n0.subarray(8);
} }));
const bi = 2790873510;
Cr.aeskwp = (0, Br.wrapCipher)({ blockSize: 8 }, (t0) => ({ encrypt(e0) {
  if ((0, $r.bytes)(e0), !e0.length)
    throw new Error("invalid plaintext length");
  const n0 = 8 * Math.ceil(e0.length / 8), r0 = new Uint8Array(8 + n0);
  r0.set(e0, 8);
  const i0 = (0, Br.u32)(r0);
  return i0[0] = bi, i0[1] = Gr(e0.length), yi.encrypt(t0, r0), r0;
}, decrypt(e0) {
  if ((0, $r.bytes)(e0), e0.length < 16)
    throw new Error("invalid ciphertext length");
  const n0 = (0, Br.copyBytes)(e0), r0 = (0, Br.u32)(n0);
  yi.decrypt(t0, n0);
  const i0 = Gr(r0[1]) >>> 0, o0 = 8 * Math.ceil(i0 / 8);
  if (r0[0] !== bi || n0.length - 8 !== o0)
    throw new Error("integrity check failed");
  for (let s0 = i0; s0 < o0; s0++)
    if (n0[8 + s0] !== 0)
      throw new Error("integrity check failed");
  return n0.subarray(0, 8).fill(0), n0.subarray(8, 8 + i0);
} })), Cr.unsafe = { expandKeyLE: Qr, expandKeyDecLE: ei, encrypt: ri, decrypt: ii, encryptBlock: gi, decryptBlock: mi, ctrCounter: si, ctr32: ai }, Object.defineProperty(_r, "__esModule", { value: !0 }), _r.aes256cbc = _r.aes256gcm = void 0;
var wi = Cr;
_r.aes256gcm = function(t0, e0, n0) {
  return (0, wi.gcm)(t0, e0, n0);
};
_r.aes256cbc = function(t0, e0, n0) {
  return (0, wi.cbc)(t0, e0);
};
var Ei = {}, Si = {}, _i = {};
Object.defineProperty(_i, "__esModule", { value: !0 }), _i.sigma = void 0, _i.rotl = function(t0, e0) {
  return t0 << e0 | t0 >>> 32 - e0;
}, _i.createCipher = function(t0, e0) {
  const { allowShortKeys: n0, extendNonceFn: r0, counterLength: i0, counterRight: o0, rounds: s0 } = (0, ki.checkOpts)({ allowShortKeys: !1, counterLength: 8, counterRight: !1, rounds: 20 }, e0);
  if (typeof t0 != "function")
    throw new Error("core must be a function");
  return (0, Ci.number)(i0), (0, Ci.number)(s0), (0, Ci.bool)(o0), (0, Ci.bool)(n0), (a0, c0, l0, u0, d0 = 0) => {
    (0, Ci.bytes)(a0), (0, Ci.bytes)(c0), (0, Ci.bytes)(l0);
    const h0 = l0.length;
    if (u0 === void 0 && (u0 = new Uint8Array(h0)), (0, Ci.bytes)(u0), (0, Ci.number)(d0), d0 < 0 || d0 >= Li)
      throw new Error("arx: counter overflow");
    if (u0.length < h0)
      throw new Error(`arx: output (${u0.length}) is shorter than data (${h0})`);
    const g0 = [];
    let w0, y0, E0 = a0.length;
    if (E0 === 32)
      g0.push(w0 = (0, ki.copyBytes)(a0)), y0 = Ri;
    else {
      if (E0 !== 16 || !n0)
        throw new Error(`arx: invalid 32-byte key, got length=${E0}`);
      w0 = new Uint8Array(32), w0.set(a0), w0.set(a0, 16), y0 = Ii, g0.push(w0);
    }
    Pi(c0) || g0.push(c0 = (0, ki.copyBytes)(c0));
    const b0 = (0, ki.u32)(w0);
    if (r0) {
      if (c0.length !== 24)
        throw new Error("arx: extended nonce must be 24 bytes");
      r0(y0, b0, (0, ki.u32)(c0.subarray(0, 16)), b0), c0 = c0.subarray(16);
    }
    const O0 = 16 - i0;
    if (O0 !== c0.length)
      throw new Error(`arx: nonce must be ${O0} or 16 bytes`);
    if (O0 !== 12) {
      const k0 = new Uint8Array(12);
      k0.set(c0, o0 ? 0 : 12 - c0.length), c0 = k0, g0.push(c0);
    }
    const S0 = (0, ki.u32)(c0);
    return function(k0, D0, z0, G0, K0, U0, F0, H0) {
      const P0 = K0.length, I0 = new Uint8Array(Ti), f0 = (0, ki.u32)(I0), m0 = Pi(K0) && Pi(U0), A0 = m0 ? (0, ki.u32)(K0) : Ni, x0 = m0 ? (0, ki.u32)(U0) : Ni;
      for (let _0 = 0; _0 < P0; F0++) {
        if (k0(D0, z0, G0, f0, F0, H0), F0 >= Li)
          throw new Error("arx: counter overflow");
        const $0 = Math.min(Ti, P0 - _0);
        if (m0 && $0 === Ti) {
          const C0 = _0 / 4;
          if (_0 % 4 != 0)
            throw new Error("arx: invalid block position");
          for (let M0, p0 = 0; p0 < Oi; p0++)
            M0 = C0 + p0, x0[M0] = A0[M0] ^ f0[p0];
          _0 += Ti;
        } else {
          for (let C0, M0 = 0; M0 < $0; M0++)
            C0 = _0 + M0, U0[C0] = K0[C0] ^ I0[M0];
          _0 += $0;
        }
      }
    }(t0, y0, b0, S0, l0, u0, d0, s0), (0, ki.clean)(...g0), u0;
  };
};
const Ci = pe, ki = fe$1, xi = (t0) => Uint8Array.from(t0.split("").map((e0) => e0.charCodeAt(0))), Mi = xi("expand 16-byte k"), Ai = xi("expand 32-byte k"), Ii = (0, ki.u32)(Mi), Ri = (0, ki.u32)(Ai);
function Pi(t0) {
  return t0.byteOffset % 4 == 0;
}
_i.sigma = Ri.slice();
const Ti = 64, Oi = 16, Li = 2 ** 32 - 1, Ni = new Uint32Array();
var $i = {};
Object.defineProperty($i, "__esModule", { value: !0 }), $i.poly1305 = void 0, $i.wrapConstructorWithKey = Ui;
const Di = pe, Bi = fe$1, Ki = (t0, e0) => 255 & t0[e0++] | (255 & t0[e0++]) << 8;
class ji {
  constructor(e0) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, e0 = (0, Bi.toBytes)(e0), (0, Di.bytes)(e0, 32);
    const n0 = Ki(e0, 0), r0 = Ki(e0, 2), i0 = Ki(e0, 4), o0 = Ki(e0, 6), s0 = Ki(e0, 8), a0 = Ki(e0, 10), c0 = Ki(e0, 12), l0 = Ki(e0, 14);
    this.r[0] = 8191 & n0, this.r[1] = 8191 & (n0 >>> 13 | r0 << 3), this.r[2] = 7939 & (r0 >>> 10 | i0 << 6), this.r[3] = 8191 & (i0 >>> 7 | o0 << 9), this.r[4] = 255 & (o0 >>> 4 | s0 << 12), this.r[5] = s0 >>> 1 & 8190, this.r[6] = 8191 & (s0 >>> 14 | a0 << 2), this.r[7] = 8065 & (a0 >>> 11 | c0 << 5), this.r[8] = 8191 & (c0 >>> 8 | l0 << 8), this.r[9] = l0 >>> 5 & 127;
    for (let u0 = 0; u0 < 8; u0++)
      this.pad[u0] = Ki(e0, 16 + 2 * u0);
  }
  process(e0, n0, r0 = !1) {
    const i0 = r0 ? 0 : 2048, { h: o0, r: s0 } = this, a0 = s0[0], c0 = s0[1], l0 = s0[2], u0 = s0[3], d0 = s0[4], h0 = s0[5], g0 = s0[6], w0 = s0[7], y0 = s0[8], E0 = s0[9], b0 = Ki(e0, n0 + 0), O0 = Ki(e0, n0 + 2), S0 = Ki(e0, n0 + 4), k0 = Ki(e0, n0 + 6), D0 = Ki(e0, n0 + 8), z0 = Ki(e0, n0 + 10), G0 = Ki(e0, n0 + 12), K0 = Ki(e0, n0 + 14);
    let U0 = o0[0] + (8191 & b0), F0 = o0[1] + (8191 & (b0 >>> 13 | O0 << 3)), H0 = o0[2] + (8191 & (O0 >>> 10 | S0 << 6)), P0 = o0[3] + (8191 & (S0 >>> 7 | k0 << 9)), I0 = o0[4] + (8191 & (k0 >>> 4 | D0 << 12)), f0 = o0[5] + (D0 >>> 1 & 8191), m0 = o0[6] + (8191 & (D0 >>> 14 | z0 << 2)), A0 = o0[7] + (8191 & (z0 >>> 11 | G0 << 5)), x0 = o0[8] + (8191 & (G0 >>> 8 | K0 << 8)), _0 = o0[9] + (K0 >>> 5 | i0), $0 = 0, C0 = $0 + U0 * a0 + F0 * (5 * E0) + H0 * (5 * y0) + P0 * (5 * w0) + I0 * (5 * g0);
    $0 = C0 >>> 13, C0 &= 8191, C0 += f0 * (5 * h0) + m0 * (5 * d0) + A0 * (5 * u0) + x0 * (5 * l0) + _0 * (5 * c0), $0 += C0 >>> 13, C0 &= 8191;
    let M0 = $0 + U0 * c0 + F0 * a0 + H0 * (5 * E0) + P0 * (5 * y0) + I0 * (5 * w0);
    $0 = M0 >>> 13, M0 &= 8191, M0 += f0 * (5 * g0) + m0 * (5 * h0) + A0 * (5 * d0) + x0 * (5 * u0) + _0 * (5 * l0), $0 += M0 >>> 13, M0 &= 8191;
    let p0 = $0 + U0 * l0 + F0 * c0 + H0 * a0 + P0 * (5 * E0) + I0 * (5 * y0);
    $0 = p0 >>> 13, p0 &= 8191, p0 += f0 * (5 * w0) + m0 * (5 * g0) + A0 * (5 * h0) + x0 * (5 * d0) + _0 * (5 * u0), $0 += p0 >>> 13, p0 &= 8191;
    let v0 = $0 + U0 * u0 + F0 * l0 + H0 * c0 + P0 * a0 + I0 * (5 * E0);
    $0 = v0 >>> 13, v0 &= 8191, v0 += f0 * (5 * y0) + m0 * (5 * w0) + A0 * (5 * g0) + x0 * (5 * h0) + _0 * (5 * d0), $0 += v0 >>> 13, v0 &= 8191;
    let T0 = $0 + U0 * d0 + F0 * u0 + H0 * l0 + P0 * c0 + I0 * a0;
    $0 = T0 >>> 13, T0 &= 8191, T0 += f0 * (5 * E0) + m0 * (5 * y0) + A0 * (5 * w0) + x0 * (5 * g0) + _0 * (5 * h0), $0 += T0 >>> 13, T0 &= 8191;
    let L0 = $0 + U0 * h0 + F0 * d0 + H0 * u0 + P0 * l0 + I0 * c0;
    $0 = L0 >>> 13, L0 &= 8191, L0 += f0 * a0 + m0 * (5 * E0) + A0 * (5 * y0) + x0 * (5 * w0) + _0 * (5 * g0), $0 += L0 >>> 13, L0 &= 8191;
    let B0 = $0 + U0 * g0 + F0 * h0 + H0 * d0 + P0 * u0 + I0 * l0;
    $0 = B0 >>> 13, B0 &= 8191, B0 += f0 * c0 + m0 * a0 + A0 * (5 * E0) + x0 * (5 * y0) + _0 * (5 * w0), $0 += B0 >>> 13, B0 &= 8191;
    let W0 = $0 + U0 * w0 + F0 * g0 + H0 * h0 + P0 * d0 + I0 * u0;
    $0 = W0 >>> 13, W0 &= 8191, W0 += f0 * l0 + m0 * c0 + A0 * a0 + x0 * (5 * E0) + _0 * (5 * y0), $0 += W0 >>> 13, W0 &= 8191;
    let V0 = $0 + U0 * y0 + F0 * w0 + H0 * g0 + P0 * h0 + I0 * d0;
    $0 = V0 >>> 13, V0 &= 8191, V0 += f0 * u0 + m0 * l0 + A0 * c0 + x0 * a0 + _0 * (5 * E0), $0 += V0 >>> 13, V0 &= 8191;
    let Q0 = $0 + U0 * E0 + F0 * y0 + H0 * w0 + P0 * g0 + I0 * h0;
    $0 = Q0 >>> 13, Q0 &= 8191, Q0 += f0 * d0 + m0 * u0 + A0 * l0 + x0 * c0 + _0 * a0, $0 += Q0 >>> 13, Q0 &= 8191, $0 = ($0 << 2) + $0 | 0, $0 = $0 + C0 | 0, C0 = 8191 & $0, $0 >>>= 13, M0 += $0, o0[0] = C0, o0[1] = M0, o0[2] = p0, o0[3] = v0, o0[4] = T0, o0[5] = L0, o0[6] = B0, o0[7] = W0, o0[8] = V0, o0[9] = Q0;
  }
  finalize() {
    const { h: e0, pad: n0 } = this, r0 = new Uint16Array(10);
    let i0 = e0[1] >>> 13;
    e0[1] &= 8191;
    for (let a0 = 2; a0 < 10; a0++)
      e0[a0] += i0, i0 = e0[a0] >>> 13, e0[a0] &= 8191;
    e0[0] += 5 * i0, i0 = e0[0] >>> 13, e0[0] &= 8191, e0[1] += i0, i0 = e0[1] >>> 13, e0[1] &= 8191, e0[2] += i0, r0[0] = e0[0] + 5, i0 = r0[0] >>> 13, r0[0] &= 8191;
    for (let a0 = 1; a0 < 10; a0++)
      r0[a0] = e0[a0] + i0, i0 = r0[a0] >>> 13, r0[a0] &= 8191;
    r0[9] -= 8192;
    let o0 = (1 ^ i0) - 1;
    for (let a0 = 0; a0 < 10; a0++)
      r0[a0] &= o0;
    o0 = ~o0;
    for (let a0 = 0; a0 < 10; a0++)
      e0[a0] = e0[a0] & o0 | r0[a0];
    e0[0] = 65535 & (e0[0] | e0[1] << 13), e0[1] = 65535 & (e0[1] >>> 3 | e0[2] << 10), e0[2] = 65535 & (e0[2] >>> 6 | e0[3] << 7), e0[3] = 65535 & (e0[3] >>> 9 | e0[4] << 4), e0[4] = 65535 & (e0[4] >>> 12 | e0[5] << 1 | e0[6] << 14), e0[5] = 65535 & (e0[6] >>> 2 | e0[7] << 11), e0[6] = 65535 & (e0[7] >>> 5 | e0[8] << 8), e0[7] = 65535 & (e0[8] >>> 8 | e0[9] << 5);
    let s0 = e0[0] + n0[0];
    e0[0] = 65535 & s0;
    for (let a0 = 1; a0 < 8; a0++)
      s0 = (e0[a0] + n0[a0] | 0) + (s0 >>> 16) | 0, e0[a0] = 65535 & s0;
    (0, Bi.clean)(r0);
  }
  update(e0) {
    (0, Di.exists)(this);
    const { buffer: n0, blockLen: r0 } = this, i0 = (e0 = (0, Bi.toBytes)(e0)).length;
    for (let o0 = 0; o0 < i0; ) {
      const s0 = Math.min(r0 - this.pos, i0 - o0);
      if (s0 !== r0)
        n0.set(e0.subarray(o0, o0 + s0), this.pos), this.pos += s0, o0 += s0, this.pos === r0 && (this.process(n0, 0, !1), this.pos = 0);
      else
        for (; r0 <= i0 - o0; o0 += r0)
          this.process(e0, o0);
    }
    return this;
  }
  destroy() {
    (0, Bi.clean)(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e0) {
    (0, Di.exists)(this), (0, Di.output)(e0, this), this.finished = !0;
    const { buffer: n0, h: r0 } = this;
    let { pos: i0 } = this;
    if (i0) {
      for (n0[i0++] = 1; i0 < 16; i0++)
        n0[i0] = 0;
      this.process(n0, 0, !0);
    }
    this.finalize();
    let o0 = 0;
    for (let s0 = 0; s0 < 8; s0++)
      e0[o0++] = r0[s0] >>> 0, e0[o0++] = r0[s0] >>> 8;
    return e0;
  }
  digest() {
    const { buffer: e0, outputLen: n0 } = this;
    this.digestInto(e0);
    const r0 = e0.slice(0, n0);
    return this.destroy(), r0;
  }
}
function Ui(t0) {
  const e0 = (r0, i0) => t0(i0).update((0, Bi.toBytes)(r0)).digest(), n0 = t0(new Uint8Array(32));
  return e0.outputLen = n0.outputLen, e0.blockLen = n0.blockLen, e0.create = (r0) => t0(r0), e0;
}
$i.poly1305 = Ui((t0) => new ji(t0)), function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.xchacha20poly1305 = t0.chacha20poly1305 = t0._poly1305_aead = t0.chacha12 = t0.chacha8 = t0.xchacha20 = t0.chacha20 = t0.chacha20orig = void 0, t0.hchacha = s0;
  const e0 = _i, n0 = pe, r0 = $i, i0 = fe$1;
  function o0(d0, h0, g0, w0, y0, E0 = 20) {
    let b0 = d0[0], O0 = d0[1], S0 = d0[2], k0 = d0[3], D0 = h0[0], z0 = h0[1], G0 = h0[2], K0 = h0[3], U0 = h0[4], F0 = h0[5], H0 = h0[6], P0 = h0[7], I0 = y0, f0 = g0[0], m0 = g0[1], A0 = g0[2], x0 = b0, _0 = O0, $0 = S0, C0 = k0, M0 = D0, p0 = z0, v0 = G0, T0 = K0, L0 = U0, B0 = F0, W0 = H0, V0 = P0, Q0 = I0, X0 = f0, J0 = m0, yg = A0;
    for (let wg = 0; wg < E0; wg += 2)
      x0 = x0 + M0 | 0, Q0 = (0, e0.rotl)(Q0 ^ x0, 16), L0 = L0 + Q0 | 0, M0 = (0, e0.rotl)(M0 ^ L0, 12), x0 = x0 + M0 | 0, Q0 = (0, e0.rotl)(Q0 ^ x0, 8), L0 = L0 + Q0 | 0, M0 = (0, e0.rotl)(M0 ^ L0, 7), _0 = _0 + p0 | 0, X0 = (0, e0.rotl)(X0 ^ _0, 16), B0 = B0 + X0 | 0, p0 = (0, e0.rotl)(p0 ^ B0, 12), _0 = _0 + p0 | 0, X0 = (0, e0.rotl)(X0 ^ _0, 8), B0 = B0 + X0 | 0, p0 = (0, e0.rotl)(p0 ^ B0, 7), $0 = $0 + v0 | 0, J0 = (0, e0.rotl)(J0 ^ $0, 16), W0 = W0 + J0 | 0, v0 = (0, e0.rotl)(v0 ^ W0, 12), $0 = $0 + v0 | 0, J0 = (0, e0.rotl)(J0 ^ $0, 8), W0 = W0 + J0 | 0, v0 = (0, e0.rotl)(v0 ^ W0, 7), C0 = C0 + T0 | 0, yg = (0, e0.rotl)(yg ^ C0, 16), V0 = V0 + yg | 0, T0 = (0, e0.rotl)(T0 ^ V0, 12), C0 = C0 + T0 | 0, yg = (0, e0.rotl)(yg ^ C0, 8), V0 = V0 + yg | 0, T0 = (0, e0.rotl)(T0 ^ V0, 7), x0 = x0 + p0 | 0, yg = (0, e0.rotl)(yg ^ x0, 16), W0 = W0 + yg | 0, p0 = (0, e0.rotl)(p0 ^ W0, 12), x0 = x0 + p0 | 0, yg = (0, e0.rotl)(yg ^ x0, 8), W0 = W0 + yg | 0, p0 = (0, e0.rotl)(p0 ^ W0, 7), _0 = _0 + v0 | 0, Q0 = (0, e0.rotl)(Q0 ^ _0, 16), V0 = V0 + Q0 | 0, v0 = (0, e0.rotl)(v0 ^ V0, 12), _0 = _0 + v0 | 0, Q0 = (0, e0.rotl)(Q0 ^ _0, 8), V0 = V0 + Q0 | 0, v0 = (0, e0.rotl)(v0 ^ V0, 7), $0 = $0 + T0 | 0, X0 = (0, e0.rotl)(X0 ^ $0, 16), L0 = L0 + X0 | 0, T0 = (0, e0.rotl)(T0 ^ L0, 12), $0 = $0 + T0 | 0, X0 = (0, e0.rotl)(X0 ^ $0, 8), L0 = L0 + X0 | 0, T0 = (0, e0.rotl)(T0 ^ L0, 7), C0 = C0 + M0 | 0, J0 = (0, e0.rotl)(J0 ^ C0, 16), B0 = B0 + J0 | 0, M0 = (0, e0.rotl)(M0 ^ B0, 12), C0 = C0 + M0 | 0, J0 = (0, e0.rotl)(J0 ^ C0, 8), B0 = B0 + J0 | 0, M0 = (0, e0.rotl)(M0 ^ B0, 7);
    let _g = 0;
    w0[_g++] = b0 + x0 | 0, w0[_g++] = O0 + _0 | 0, w0[_g++] = S0 + $0 | 0, w0[_g++] = k0 + C0 | 0, w0[_g++] = D0 + M0 | 0, w0[_g++] = z0 + p0 | 0, w0[_g++] = G0 + v0 | 0, w0[_g++] = K0 + T0 | 0, w0[_g++] = U0 + L0 | 0, w0[_g++] = F0 + B0 | 0, w0[_g++] = H0 + W0 | 0, w0[_g++] = P0 + V0 | 0, w0[_g++] = I0 + Q0 | 0, w0[_g++] = f0 + X0 | 0, w0[_g++] = m0 + J0 | 0, w0[_g++] = A0 + yg | 0;
  }
  function s0(d0, h0, g0, w0) {
    let y0 = d0[0], E0 = d0[1], b0 = d0[2], O0 = d0[3], S0 = h0[0], k0 = h0[1], D0 = h0[2], z0 = h0[3], G0 = h0[4], K0 = h0[5], U0 = h0[6], F0 = h0[7], H0 = g0[0], P0 = g0[1], I0 = g0[2], f0 = g0[3];
    for (let A0 = 0; A0 < 20; A0 += 2)
      y0 = y0 + S0 | 0, H0 = (0, e0.rotl)(H0 ^ y0, 16), G0 = G0 + H0 | 0, S0 = (0, e0.rotl)(S0 ^ G0, 12), y0 = y0 + S0 | 0, H0 = (0, e0.rotl)(H0 ^ y0, 8), G0 = G0 + H0 | 0, S0 = (0, e0.rotl)(S0 ^ G0, 7), E0 = E0 + k0 | 0, P0 = (0, e0.rotl)(P0 ^ E0, 16), K0 = K0 + P0 | 0, k0 = (0, e0.rotl)(k0 ^ K0, 12), E0 = E0 + k0 | 0, P0 = (0, e0.rotl)(P0 ^ E0, 8), K0 = K0 + P0 | 0, k0 = (0, e0.rotl)(k0 ^ K0, 7), b0 = b0 + D0 | 0, I0 = (0, e0.rotl)(I0 ^ b0, 16), U0 = U0 + I0 | 0, D0 = (0, e0.rotl)(D0 ^ U0, 12), b0 = b0 + D0 | 0, I0 = (0, e0.rotl)(I0 ^ b0, 8), U0 = U0 + I0 | 0, D0 = (0, e0.rotl)(D0 ^ U0, 7), O0 = O0 + z0 | 0, f0 = (0, e0.rotl)(f0 ^ O0, 16), F0 = F0 + f0 | 0, z0 = (0, e0.rotl)(z0 ^ F0, 12), O0 = O0 + z0 | 0, f0 = (0, e0.rotl)(f0 ^ O0, 8), F0 = F0 + f0 | 0, z0 = (0, e0.rotl)(z0 ^ F0, 7), y0 = y0 + k0 | 0, f0 = (0, e0.rotl)(f0 ^ y0, 16), U0 = U0 + f0 | 0, k0 = (0, e0.rotl)(k0 ^ U0, 12), y0 = y0 + k0 | 0, f0 = (0, e0.rotl)(f0 ^ y0, 8), U0 = U0 + f0 | 0, k0 = (0, e0.rotl)(k0 ^ U0, 7), E0 = E0 + D0 | 0, H0 = (0, e0.rotl)(H0 ^ E0, 16), F0 = F0 + H0 | 0, D0 = (0, e0.rotl)(D0 ^ F0, 12), E0 = E0 + D0 | 0, H0 = (0, e0.rotl)(H0 ^ E0, 8), F0 = F0 + H0 | 0, D0 = (0, e0.rotl)(D0 ^ F0, 7), b0 = b0 + z0 | 0, P0 = (0, e0.rotl)(P0 ^ b0, 16), G0 = G0 + P0 | 0, z0 = (0, e0.rotl)(z0 ^ G0, 12), b0 = b0 + z0 | 0, P0 = (0, e0.rotl)(P0 ^ b0, 8), G0 = G0 + P0 | 0, z0 = (0, e0.rotl)(z0 ^ G0, 7), O0 = O0 + S0 | 0, I0 = (0, e0.rotl)(I0 ^ O0, 16), K0 = K0 + I0 | 0, S0 = (0, e0.rotl)(S0 ^ K0, 12), O0 = O0 + S0 | 0, I0 = (0, e0.rotl)(I0 ^ O0, 8), K0 = K0 + I0 | 0, S0 = (0, e0.rotl)(S0 ^ K0, 7);
    let m0 = 0;
    w0[m0++] = y0, w0[m0++] = E0, w0[m0++] = b0, w0[m0++] = O0, w0[m0++] = H0, w0[m0++] = P0, w0[m0++] = I0, w0[m0++] = f0;
  }
  t0.chacha20orig = (0, e0.createCipher)(o0, { counterRight: !1, counterLength: 8, allowShortKeys: !0 }), t0.chacha20 = (0, e0.createCipher)(o0, { counterRight: !1, counterLength: 4, allowShortKeys: !1 }), t0.xchacha20 = (0, e0.createCipher)(o0, { counterRight: !1, counterLength: 8, extendNonceFn: s0, allowShortKeys: !1 }), t0.chacha8 = (0, e0.createCipher)(o0, { counterRight: !1, counterLength: 4, rounds: 8 }), t0.chacha12 = (0, e0.createCipher)(o0, { counterRight: !1, counterLength: 4, rounds: 12 });
  const a0 = new Uint8Array(16), c0 = (d0, h0) => {
    d0.update(h0);
    const g0 = h0.length % 16;
    g0 && d0.update(a0.subarray(g0));
  }, l0 = new Uint8Array(32);
  function u0(d0, h0, g0, w0, y0) {
    const E0 = d0(h0, g0, l0), b0 = r0.poly1305.create(E0);
    y0 && c0(b0, y0), c0(b0, w0);
    const O0 = new Uint8Array(16), S0 = (0, i0.createView)(O0);
    (0, i0.setBigUint64)(S0, 0, BigInt(y0 ? y0.length : 0), !0), (0, i0.setBigUint64)(S0, 8, BigInt(w0.length), !0), b0.update(O0);
    const k0 = b0.digest();
    return (0, i0.clean)(E0, O0), k0;
  }
  t0._poly1305_aead = (d0) => (h0, g0, w0) => ((0, n0.bytes)(h0, 32), (0, n0.bytes)(g0), { encrypt(E0, b0) {
    const O0 = E0.length, S0 = O0 + 16;
    b0 ? (0, n0.bytes)(b0, S0) : b0 = new Uint8Array(S0), d0(h0, g0, E0, b0, 1);
    const k0 = u0(d0, h0, g0, b0.subarray(0, -16), w0);
    return b0.set(k0, O0), (0, i0.clean)(k0), b0;
  }, decrypt(E0, b0) {
    const O0 = E0.length, S0 = O0 - 16;
    if (O0 < 16)
      throw new Error("encrypted data must be at least 16 bytes");
    b0 ? (0, n0.bytes)(b0, S0) : b0 = new Uint8Array(S0);
    const k0 = E0.subarray(0, -16), D0 = E0.subarray(-16), z0 = u0(d0, h0, g0, k0, w0);
    if (!(0, i0.equalBytes)(D0, z0))
      throw new Error("invalid tag");
    return d0(h0, g0, k0, b0, 1), (0, i0.clean)(z0), b0;
  } }), t0.chacha20poly1305 = (0, i0.wrapCipher)({ blockSize: 64, nonceLength: 12, tagLength: 16 }, (0, t0._poly1305_aead)(t0.chacha20)), t0.xchacha20poly1305 = (0, i0.wrapCipher)({ blockSize: 64, nonceLength: 24, tagLength: 16 }, (0, t0._poly1305_aead)(t0.xchacha20));
}(Si), Object.defineProperty(Ei, "__esModule", { value: !0 }), Ei.xchacha20 = void 0;
var Hi, Fi, zi, qi = Si;
Ei.xchacha20 = function(t0, e0, n0) {
  return (0, qi.xchacha20poly1305)(t0, e0, n0);
}, function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.aesDecrypt = t0.aesEncrypt = t0.symDecrypt = t0.symEncrypt = void 0;
  var e0 = fe$1, n0 = Ie, r0 = _r, i0 = Ei, o0 = _e, s0 = Ce;
  t0.symEncrypt = function(u0, d0, h0) {
    return a0(c0, u0, d0, h0);
  };
  function a0(u0, d0, h0, g0) {
    var w0 = (0, o0.symmetricAlgorithm)();
    if (w0 === "aes-256-gcm")
      return u0(r0.aes256gcm, d0, h0, (0, o0.symmetricNonceLength)(), s0.AEAD_TAG_LENGTH, g0);
    if (w0 === "xchacha20")
      return u0(i0.xchacha20, d0, h0, s0.XCHACHA20_NONCE_LENGTH, s0.AEAD_TAG_LENGTH, g0);
    if (w0 === "aes-256-cbc")
      return u0(r0.aes256cbc, d0, h0, 16, 0);
    throw new Error("Not implemented");
  }
  function c0(u0, d0, h0, g0, w0, y0) {
    var E0 = (0, n0.randomBytes)(g0), b0 = u0(d0, E0, y0).encrypt(h0);
    if (w0 === 0)
      return (0, e0.concatBytes)(E0, b0);
    var O0 = b0.length - w0, S0 = b0.subarray(0, O0), k0 = b0.subarray(O0);
    return (0, e0.concatBytes)(E0, k0, S0);
  }
  function l0(u0, d0, h0, g0, w0, y0) {
    var E0 = h0.subarray(0, g0), b0 = u0(d0, Uint8Array.from(E0), y0), O0 = h0.subarray(g0);
    if (w0 === 0)
      return b0.decrypt(O0);
    var S0 = O0.subarray(0, w0), k0 = O0.subarray(w0);
    return b0.decrypt((0, e0.concatBytes)(k0, S0));
  }
  t0.symDecrypt = function(u0, d0, h0) {
    return a0(l0, u0, d0, h0);
  }, t0.aesEncrypt = t0.symEncrypt, t0.aesDecrypt = t0.symDecrypt;
}(Sr), Hi = Me$1, Fi = le$1 && le$1.__createBinding || (Object.create ? function(t0, e0, n0, r0) {
  r0 === void 0 && (r0 = n0);
  var i0 = Object.getOwnPropertyDescriptor(e0, n0);
  i0 && !("get" in i0 ? !e0.__esModule : i0.writable || i0.configurable) || (i0 = { enumerable: !0, get: function() {
    return e0[n0];
  } }), Object.defineProperty(t0, r0, i0);
} : function(t0, e0, n0, r0) {
  r0 === void 0 && (r0 = n0), t0[r0] = e0[n0];
}), zi = le$1 && le$1.__exportStar || function(t0, e0) {
  for (var n0 in t0)
    n0 === "default" || Object.prototype.hasOwnProperty.call(e0, n0) || Fi(e0, t0, n0);
}, Object.defineProperty(Hi, "__esModule", { value: !0 }), zi(Ae, Hi), zi(fr, Hi), zi(hr, Hi), zi(Sr, Hi);
var Wi = {};
Object.defineProperty(Wi, "__esModule", { value: !0 }), Wi.PublicKey = void 0;
var Vi = fe$1, Gi = Me$1, Yi = function() {
  function t0(e0) {
    this.data = (0, Gi.convertPublicKeyFormat)(e0, !0);
  }
  return t0.fromHex = function(e0) {
    return new t0((0, Gi.hexToPublicKey)(e0));
  }, Object.defineProperty(t0.prototype, "uncompressed", { get: function() {
    return _.from((0, Gi.convertPublicKeyFormat)(this.data, !1));
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t0.prototype, "compressed", { get: function() {
    return _.from(this.data);
  }, enumerable: !1, configurable: !0 }), t0.prototype.toHex = function(e0) {
    return e0 === void 0 && (e0 = !0), (0, Vi.bytesToHex)(e0 ? this.data : this.uncompressed);
  }, t0.prototype.decapsulate = function(e0, n0) {
    n0 === void 0 && (n0 = !1);
    var r0 = n0 ? this.data : this.uncompressed, i0 = e0.multiply(this, n0);
    return (0, Gi.getSharedKey)(r0, i0);
  }, t0.prototype.equals = function(e0) {
    return (0, Vi.equalBytes)(this.data, e0.data);
  }, t0;
}();
Wi.PublicKey = Yi, Object.defineProperty(xe, "__esModule", { value: !0 }), xe.PrivateKey = void 0;
var Zi = fe$1, Ji = Me$1, Xi = Wi, Qi = function() {
  function t0(e0) {
    if (e0 === void 0)
      this.data = (0, Ji.getValidSecret)();
    else {
      if (!(0, Ji.isValidPrivateKey)(e0))
        throw new Error("Invalid private key");
      this.data = e0;
    }
    this.publicKey = new Xi.PublicKey((0, Ji.getPublicKey)(this.data));
  }
  return t0.fromHex = function(e0) {
    return new t0((0, Ji.decodeHex)(e0));
  }, Object.defineProperty(t0.prototype, "secret", { get: function() {
    return _.from(this.data);
  }, enumerable: !1, configurable: !0 }), t0.prototype.toHex = function() {
    return (0, Zi.bytesToHex)(this.data);
  }, t0.prototype.encapsulate = function(e0, n0) {
    n0 === void 0 && (n0 = !1);
    var r0 = n0 ? this.publicKey.compressed : this.publicKey.uncompressed, i0 = this.multiply(e0, n0);
    return (0, Ji.getSharedKey)(r0, i0);
  }, t0.prototype.multiply = function(e0, n0) {
    return n0 === void 0 && (n0 = !1), (0, Ji.getSharedPoint)(this.data, e0.compressed, n0);
  }, t0.prototype.equals = function(e0) {
    return (0, Zi.equalBytes)(this.data, e0.data);
  }, t0;
}();
xe.PrivateKey = Qi, function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.PublicKey = t0.PrivateKey = void 0;
  var e0 = xe;
  Object.defineProperty(t0, "PrivateKey", { enumerable: !0, get: function() {
    return e0.PrivateKey;
  } });
  var n0 = Wi;
  Object.defineProperty(t0, "PublicKey", { enumerable: !0, get: function() {
    return n0.PublicKey;
  } });
}(ke), function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.utils = t0.PublicKey = t0.PrivateKey = t0.ECIES_CONFIG = void 0, t0.encrypt = function(a0, c0) {
    var l0 = new r0.PrivateKey(), u0 = a0 instanceof Uint8Array ? new r0.PublicKey(a0) : r0.PublicKey.fromHex(a0), d0 = l0.encapsulate(u0, (0, n0.isHkdfKeyCompressed)()), h0 = (0, n0.isEphemeralKeyCompressed)() ? l0.publicKey.compressed : l0.publicKey.uncompressed, g0 = (0, i0.symEncrypt)(d0, c0);
    return _.from((0, e0.concatBytes)(h0, g0));
  }, t0.decrypt = function(a0, c0) {
    var l0 = a0 instanceof Uint8Array ? new r0.PrivateKey(a0) : r0.PrivateKey.fromHex(a0), u0 = (0, n0.ephemeralKeySize)(), d0 = new r0.PublicKey(c0.subarray(0, u0)), h0 = c0.subarray(u0), g0 = d0.decapsulate(l0, (0, n0.isHkdfKeyCompressed)());
    return _.from((0, i0.symDecrypt)(g0, h0));
  };
  var e0 = fe$1, n0 = _e, r0 = ke, i0 = Me$1, o0 = _e;
  Object.defineProperty(t0, "ECIES_CONFIG", { enumerable: !0, get: function() {
    return o0.ECIES_CONFIG;
  } });
  var s0 = ke;
  Object.defineProperty(t0, "PrivateKey", { enumerable: !0, get: function() {
    return s0.PrivateKey;
  } }), Object.defineProperty(t0, "PublicKey", { enumerable: !0, get: function() {
    return s0.PublicKey;
  } }), t0.utils = { aesEncrypt: i0.aesEncrypt, aesDecrypt: i0.aesDecrypt, symEncrypt: i0.symEncrypt, symDecrypt: i0.symDecrypt, decodeHex: i0.decodeHex, getValidSecret: i0.getValidSecret, remove0x: i0.remove0x };
}(he$1);
const eo = t("KeyExchange:Layer"), to = t("SocketService:Layer"), no = t("Ecies:Layer"), ro = t("RemoteCommunication:Layer");
eo.color = "##95c44e", to.color = "#f638d7", no.color = "#465b9c", ro.color = "#47a2be";
const io = { KeyExchange: eo, SocketService: to, Ecies: no, RemoteCommunication: ro };
let oo, so = [], ao = [];
const co = (t0, e0) => a(void 0, void 0, void 0, function* () {
  oo = e0, ao.push(t0), function(n0) {
    return a(this, void 0, void 0, function* () {
      if (!oo || !n0)
        return;
      (function() {
        const s0 = ao;
        ao = so, so = s0;
      })();
      const r0 = oo.endsWith("/") ? `${oo}evt` : `${oo}/evt`, i0 = Object.assign({}, n0);
      if (delete i0.params, n0.params)
        for (const [s0, a0] of Object.entries(n0.params))
          i0[s0] = a0;
      const o0 = JSON.stringify(i0);
      io.RemoteCommunication(`[sendBufferedEvents] Sending ${so.length} analytics events to ${r0}`);
      try {
        const s0 = yield e(r0, { method: "POST", headers: { Accept: "application/json", "Content-Type": "application/json" }, body: o0 }), a0 = yield s0.text();
        io.RemoteCommunication(`[sendBufferedEvents] Response: ${a0}`), so.length = 0;
      } catch {
      }
    });
  }(t0).catch(() => {
  });
});
class lo {
  constructor(e0) {
    this.enabled = !0, e0?.debug && t.enable("Ecies:Layer"), this.ecies = e0?.privateKey ? he$1.PrivateKey.fromHex(e0.privateKey) : new he$1.PrivateKey(), io.Ecies("[ECIES constructor()] initialized secret: ", this.ecies.toHex()), io.Ecies("[ECIES constructor()] initialized public: ", this.ecies.publicKey.toHex()), io.Ecies("[ECIES constructor()] init with", this);
  }
  generateECIES() {
    this.ecies = new he$1.PrivateKey();
  }
  getPublicKey() {
    return this.ecies.publicKey.toHex();
  }
  encrypt(e0, n0) {
    let r0 = e0;
    if (this.enabled)
      try {
        io.Ecies("[ECIES: encrypt()] using otherPublicKey", n0);
        const i0 = _.from(e0), o0 = he$1.encrypt(n0, i0);
        r0 = _.from(o0).toString("base64");
      } catch (i0) {
        throw io.Ecies("[ECIES: encrypt()] error encrypt:", i0), io.Ecies("[ECIES: encrypt()] private: ", this.ecies.toHex()), io.Ecies("[ECIES: encrypt()] data: ", e0), io.Ecies("[ECIES: encrypt()] otherkey: ", n0), i0;
      }
    return r0;
  }
  decrypt(e0) {
    let n0 = e0;
    if (this.enabled)
      try {
        io.Ecies("[ECIES: decrypt()] using privateKey", this.ecies.toHex());
        const r0 = _.from(e0.toString(), "base64");
        n0 = he$1.decrypt(this.ecies.toHex(), r0).toString();
      } catch (r0) {
        throw io.Ecies("[ECIES: decrypt()] error decrypt", r0), io.Ecies("[ECIES: decrypt()] private: ", this.ecies.toHex()), io.Ecies("[ECIES: decrypt()] encryptedData: ", e0), r0;
      }
    return n0;
  }
  getKeyInfo() {
    return { private: this.ecies.toHex(), public: this.ecies.publicKey.toHex() };
  }
  toString() {
    io.Ecies("[ECIES: toString()]", this.getKeyInfo());
  }
}
var uo = { name: "@metamask/sdk-communication-layer", version: "0.32.0", description: "", homepage: "https://github.com/MetaMask/metamask-sdk#readme", bugs: { url: "https://github.com/MetaMask/metamask-sdk/issues" }, repository: { type: "git", url: "https://github.com/MetaMask/metamask-sdk.git", directory: "packages/sdk-communication-layer" }, main: "dist/node/cjs/metamask-sdk-communication-layer.js", unpkg: "dist/browser/umd/metamask-sdk-communication-layer.js", module: "dist/node/es/metamask-sdk-communication-layer.js", browser: "dist/browser/es/metamask-sdk-communication-layer.js", "react-native": "dist/react-native/es/metamask-sdk-communication-layer.js", types: "dist/types/src/index.d.ts", files: ["/dist"], scripts: { "build:types": "tsc --project tsconfig.build.json --emitDeclarationOnly --outDir dist/types", "build:clean": "yarn clean && yarn build", build: "yarn build:types && rollup -c --bundleConfigAsCjs", "build:dev": "yarn build:types && NODE_ENV=dev rollup -c --bundleConfigAsCjs", dev: 'concurrently "tsc --watch" "rollup -c --bundleConfigAsCjs -w"', "build:post-tsc": "echo 'N/A'", "build:pre-tsc": "echo 'N/A'", size: "size-limit", clean: "rimraf ./dist", lint: "yarn lint:eslint && yarn lint:misc --check", "lint:changelog": "../../scripts/validate-changelog.sh @metamask/sdk-communication-layer", "lint:eslint": "eslint . --cache --ext js,ts", "lint:fix": "yarn lint:eslint --fix && yarn lint:misc --write", "lint:misc": "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore", "publish:preview": "yarn npm publish --tag preview", prepack: "../../scripts/prepack.sh", reset: "yarn clean && rimraf ./node_modules/", test: 'jest --testPathIgnorePatterns "/e2e/"', "test:e2e": 'jest --testPathPattern "/e2e/"', "test:coverage": "jest --coverage", "test:ci": 'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns "/e2e/"', "test:dev": "jest", watch: "rollup -c --bundleConfigAsCjs -w" }, dependencies: { bufferutil: "^4.0.8", "date-fns": "^2.29.3", debug: "^4.3.4", "utf-8-validate": "^5.0.2", uuid: "^8.3.2" }, devDependencies: { "@jest/globals": "^29.3.1", "@lavamoat/allow-scripts": "^2.3.1", "@metamask/auto-changelog": "3.1.0", "@metamask/eslint-config": "^6.0.0", "@metamask/eslint-config-nodejs": "^6.0.0", "@metamask/eslint-config-typescript": "^6.0.0", "@rollup/plugin-commonjs": "^25.0.0", "@rollup/plugin-json": "^6.0.0", "@rollup/plugin-node-resolve": "^15.0.2", "@rollup/plugin-replace": "^6.0.1", "@rollup/plugin-terser": "^0.4.4", "@size-limit/preset-big-lib": "^11.0.2", "@types/jest": "^29.2.4", "@types/node": "^20.1.3", "@types/uuid": "^9.0.0", "@typescript-eslint/eslint-plugin": "^4.26.0", "@typescript-eslint/parser": "^4.26.0", concurrently: "^9.1.2", "cross-fetch": "^4.0.0", eciesjs: "^0.4.11", eslint: "^7.30.0", "eslint-config-prettier": "^8.3.0", "eslint-plugin-import": "^2.23.4", "eslint-plugin-jest": "^24.4.0", "eslint-plugin-jsdoc": "^36.1.0", "eslint-plugin-node": "^11.1.0", "eslint-plugin-prettier": "^3.4.0", eventemitter2: "^6.4.9", jest: "^29.3.1", prettier: "^2.3.0", rimraf: "^3.0.2", rollup: "^4.26.0", "rollup-plugin-jscc": "^2.0.0", "rollup-plugin-natives": "^0.7.5", "rollup-plugin-node-builtins": "^2.1.2", "rollup-plugin-node-globals": "^1.4.0", "rollup-plugin-peer-deps-external": "^2.2.4", "rollup-plugin-polyfill-node": "^0.13.0", "rollup-plugin-sizes": "^1.0.6", "rollup-plugin-typescript2": "^0.31.2", "rollup-plugin-visualizer": "^5.12.0", "size-limit": "^11.1.6", "socket.io-client": "^4.5.1", "stream-browserify": "^3.0.0", "ts-jest": "^29.0.3", "ts-node": "^10.9.1", typescript: "^5.6.3" }, peerDependencies: { "cross-fetch": "^4.0.0", eciesjs: "*", eventemitter2: "^6.4.9", "readable-stream": "^3.6.2", "socket.io-client": "^4.5.1" }, publishConfig: { access: "public", registry: "https://registry.npmjs.org/" }, lavamoat: { allowScripts: { "@lavamoat/preinstall-always-fail": !1, canvas: !0, "eciesjs>secp256k1": !1, "socket.io-client>engine.io-client>ws>bufferutil": !1, "socket.io-client>engine.io-client>ws>utf-8-validate": !1, bufferutil: !1, "utf-8-validate": !1 } } };
const ho = "https://metamask-sdk.api.cx.metamask.io/", fo = ["websocket"], po = 6048e5, go = 3e3, mo = { METAMASK_GETPROVIDERSTATE: "metamask_getProviderState", ETH_REQUESTACCOUNTS: "eth_requestAccounts" };
function yo(t0) {
  const { context: e0 } = t0;
  io.RemoteCommunication(`[RemoteCommunication: clean()] context=${e0}`), t0.channelConfig = void 0, t0.ready = !1, t0.originatorConnectStarted = !1;
}
var vo, bo, wo, Eo, So, _o, Co;
(Co = vo || (vo = {})).DISCONNECTED = "disconnected", Co.WAITING = "waiting", Co.TIMEOUT = "timeout", Co.LINKED = "linked", Co.PAUSED = "paused", Co.TERMINATED = "terminated", function(t0) {
  t0.KEY_INFO = "key_info", t0.SERVICE_STATUS = "service_status", t0.PROVIDER_UPDATE = "provider_update", t0.RPC_UPDATE = "rpc_update", t0.KEYS_EXCHANGED = "keys_exchanged", t0.JOIN_CHANNEL = "join_channel", t0.PUBLIC_KEY = "public_key", t0.CHANNEL_CREATED = "channel_created", t0.CLIENTS_CONNECTED = "clients_connected", t0.CLIENTS_DISCONNECTED = "clients_disconnected", t0.CLIENTS_WAITING = "clients_waiting", t0.CLIENTS_READY = "clients_ready", t0.REJECTED = "rejected", t0.WALLET_INIT = "wallet_init", t0.CHANNEL_PERSISTENCE = "channel_persistence", t0.CONFIG = "config", t0.MESSAGE_ACK = "ack", t0.SOCKET_DISCONNECTED = "socket_disconnected", t0.SOCKET_RECONNECT = "socket_reconnect", t0.OTP = "otp", t0.SDK_RPC_CALL = "sdk_rpc_call", t0.AUTHORIZED = "authorized", t0.CONNECTION_STATUS = "connection_status", t0.MESSAGE = "message", t0.TERMINATE = "terminate";
}(bo || (bo = {})), (wo || (wo = {})).KEY_EXCHANGE = "key_exchange", function(t0) {
  t0.KEY_HANDSHAKE_START = "key_handshake_start", t0.KEY_HANDSHAKE_CHECK = "key_handshake_check", t0.KEY_HANDSHAKE_SYN = "key_handshake_SYN", t0.KEY_HANDSHAKE_SYNACK = "key_handshake_SYNACK", t0.KEY_HANDSHAKE_ACK = "key_handshake_ACK", t0.KEY_HANDSHAKE_WALLET = "key_handshake_wallet", t0.KEY_HANDSHAKE_NONE = "none";
}(Eo || (Eo = {}));
class ko extends eventemitter2Exports.EventEmitter2 {
  constructor({ communicationLayer: e0, otherPublicKey: n0, context: r0, ecies: i0, logging: o0 }) {
    super(), this.keysExchanged = !1, this.step = Eo.KEY_HANDSHAKE_NONE, this.debug = !1, this.context = r0, this.communicationLayer = e0, i0?.privateKey && n0 && (io.KeyExchange(`[KeyExchange: constructor()] otherPubKey=${n0} set keysExchanged to true!`, i0), this.keysExchanged = !0), this.myECIES = new lo(Object.assign(Object.assign({}, i0), { debug: o0?.eciesLayer })), this.communicationLayer.state.eciesInstance = this.myECIES, this.myPublicKey = this.myECIES.getPublicKey(), this.debug = o0?.keyExchangeLayer === !0, n0 && this.setOtherPublicKey(n0), this.communicationLayer.on(wo.KEY_EXCHANGE, this.onKeyExchangeMessage.bind(this));
  }
  onKeyExchangeMessage(e0) {
    const { relayPersistence: n0 } = this.communicationLayer.remote.state;
    if (io.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} keysExchanged=${this.keysExchanged} relayPersistence=${n0}`, e0), n0)
      return void io.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Ignoring key exchange message because relay persistence is activated");
    const { message: r0 } = e0;
    this.keysExchanged && io.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} received handshake while already exchanged. step=${this.step} otherPubKey=${this.otherPublicKey}`), this.emit(bo.KEY_INFO, r0.type), r0.type === Eo.KEY_HANDSHAKE_SYN ? (this.checkStep([Eo.KEY_HANDSHAKE_NONE, Eo.KEY_HANDSHAKE_ACK]), io.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYN", r0), r0.pubkey && this.setOtherPublicKey(r0.pubkey), this.communicationLayer.sendMessage({ type: Eo.KEY_HANDSHAKE_SYNACK, pubkey: this.myPublicKey }).catch((i0) => {
      io.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_SYNACK", i0);
    }), this.setStep(Eo.KEY_HANDSHAKE_ACK)) : r0.type === Eo.KEY_HANDSHAKE_SYNACK ? (this.checkStep([Eo.KEY_HANDSHAKE_SYNACK, Eo.KEY_HANDSHAKE_ACK, Eo.KEY_HANDSHAKE_NONE]), io.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYNACK"), r0.pubkey && this.setOtherPublicKey(r0.pubkey), this.communicationLayer.sendMessage({ type: Eo.KEY_HANDSHAKE_ACK }).catch((i0) => {
      io.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_ACK", i0);
    }), this.keysExchanged = !0, this.setStep(Eo.KEY_HANDSHAKE_ACK), this.emit(bo.KEYS_EXCHANGED)) : r0.type === Eo.KEY_HANDSHAKE_ACK && (io.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_ACK set keysExchanged to true!"), this.checkStep([Eo.KEY_HANDSHAKE_ACK, Eo.KEY_HANDSHAKE_NONE]), this.keysExchanged = !0, this.setStep(Eo.KEY_HANDSHAKE_ACK), this.emit(bo.KEYS_EXCHANGED));
  }
  resetKeys(e0) {
    this.clean(), this.myECIES = new lo(e0);
  }
  clean() {
    io.KeyExchange(`[KeyExchange: clean()] context=${this.context} reset handshake state`), this.setStep(Eo.KEY_HANDSHAKE_NONE), this.emit(bo.KEY_INFO, this.step), this.keysExchanged = !1;
  }
  start({ isOriginator: e0, force: n0 }) {
    const { relayPersistence: r0, protocolVersion: i0 } = this.communicationLayer.remote.state, o0 = i0 >= 2;
    r0 ? io.KeyExchange("[KeyExchange: start()] Ignoring key exchange message because relay persistence is activated") : (io.KeyExchange(`[KeyExchange: start()] context=${this.context} protocolVersion=${i0} isOriginator=${e0} step=${this.step} force=${n0} relayPersistence=${r0} keysExchanged=${this.keysExchanged}`), e0 ? !(this.keysExchanged || this.step !== Eo.KEY_HANDSHAKE_NONE && this.step !== Eo.KEY_HANDSHAKE_SYNACK) || n0 ? (io.KeyExchange(`[KeyExchange: start()] context=${this.context} -- start key exchange (force=${n0}) -- step=${this.step}`, this.step), this.clean(), this.setStep(Eo.KEY_HANDSHAKE_SYNACK), this.communicationLayer.sendMessage({ type: Eo.KEY_HANDSHAKE_SYN, pubkey: this.myPublicKey, v: 2 }).catch((s0) => {
      io.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYN", s0);
    })) : io.KeyExchange(`[KeyExchange: start()] context=${this.context} -- key exchange already ${this.keysExchanged ? "done" : "in progress"} -- aborted.`, this.step) : this.keysExchanged && n0 !== !0 ? io.KeyExchange("[KeyExchange: start()] don't send KEY_HANDSHAKE_START -- exchange already done.") : o0 ? this.communicationLayer.sendMessage({ type: Eo.KEY_HANDSHAKE_SYNACK, pubkey: this.myPublicKey, v: 2 }).catch((s0) => {
      io.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYNACK", s0);
    }) : (this.communicationLayer.sendMessage({ type: Eo.KEY_HANDSHAKE_START }).catch((s0) => {
      io.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_START", s0);
    }), this.clean()));
  }
  setStep(e0) {
    this.step = e0, this.emit(bo.KEY_INFO, e0);
  }
  checkStep(e0) {
    e0.length > 0 && e0.indexOf(this.step.toString());
  }
  setRelayPersistence({ localKey: e0, otherKey: n0 }) {
    this.otherPublicKey = n0, this.myECIES = new lo({ privateKey: e0, debug: this.debug }), this.keysExchanged = !0;
  }
  setKeysExchanged(e0) {
    this.keysExchanged = e0;
  }
  areKeysExchanged() {
    return this.keysExchanged;
  }
  getMyPublicKey() {
    return this.myPublicKey;
  }
  getOtherPublicKey() {
    return this.otherPublicKey;
  }
  setOtherPublicKey(e0) {
    io.KeyExchange("[KeyExchange: setOtherPubKey()]", e0), this.otherPublicKey = e0;
  }
  encryptMessage(e0) {
    if (!this.otherPublicKey)
      throw new Error("encryptMessage: Keys not exchanged - missing otherPubKey");
    return this.myECIES.encrypt(e0, this.otherPublicKey);
  }
  decryptMessage(e0) {
    if (!this.otherPublicKey)
      throw new Error("decryptMessage: Keys not exchanged - missing otherPubKey");
    return this.myECIES.decrypt(e0);
  }
  getKeyInfo() {
    return { ecies: Object.assign(Object.assign({}, this.myECIES.getKeyInfo()), { otherPubKey: this.otherPublicKey }), step: this.step, keysExchanged: this.areKeysExchanged() };
  }
  toString() {
    const e0 = { keyInfo: this.getKeyInfo(), keysExchanged: this.keysExchanged, step: this.step };
    return JSON.stringify(e0);
  }
}
(function(t0) {
  t0.TERMINATE = "terminate", t0.ANSWER = "answer", t0.OFFER = "offer", t0.CANDIDATE = "candidate", t0.JSONRPC = "jsonrpc", t0.WALLET_INFO = "wallet_info", t0.WALLET_INIT = "wallet_init", t0.ORIGINATOR_INFO = "originator_info", t0.PAUSE = "pause", t0.OTP = "otp", t0.AUTHORIZED = "authorized", t0.PING = "ping", t0.READY = "ready";
})(So || (So = {})), function(t0) {
  t0.REQUEST = "sdk_connect_request_started", t0.REQUEST_MOBILE = "sdk_connect_request_started_mobile", t0.RECONNECT = "sdk_reconnect_request_started", t0.CONNECTED = "sdk_connection_established", t0.CONNECTED_MOBILE = "sdk_connection_established_mobile", t0.AUTHORIZED = "sdk_connection_authorized", t0.REJECTED = "sdk_connection_rejected", t0.TERMINATED = "sdk_connection_terminated", t0.DISCONNECTED = "sdk_disconnected", t0.SDK_USE_EXTENSION = "sdk_use_extension", t0.SDK_RPC_REQUEST = "sdk_rpc_request", t0.SDK_RPC_REQUEST_RECEIVED = "sdk_rpc_request_received", t0.SDK_RPC_REQUEST_DONE = "sdk_rpc_request_done", t0.SDK_EXTENSION_UTILIZED = "sdk_extension_utilized", t0.SDK_USE_INAPP_BROWSER = "sdk_use_inapp_browser";
}(_o || (_o = {}));
const xo = (t0, e0, n0) => a(void 0, void 0, void 0, function* () {
  var r0, i0, o0, s0, a0, c0;
  const { remote: l0, state: u0 } = t0, { channelId: d0, isOriginator: h0 } = u0;
  if (e0 === "error_terminated")
    return io.SocketService(`handleJoinChannelResults: Channel ${d0} terminated`), void t0.emit(bo.TERMINATE);
  if (!n0)
    return void io.SocketService(`handleJoinChannelResults: No result for channel ${d0}`);
  const { persistence: g0, walletKey: w0, rejected: y0 } = n0;
  if (io.SocketService(`handleJoinChannelResults: Channel ${d0} persistence=${g0} walletKey=${w0} rejected=${y0}`), y0)
    return io.SocketService(`handleJoinChannelResults: Channel ${d0} rejected`), yield t0.remote.disconnect({ terminate: !0 }), t0.remote.emit(bo.REJECTED, { channelId: d0 }), void t0.remote.emitServiceStatusEvent();
  if (w0 && !(!((r0 = l0.state.channelConfig) === null || r0 === void 0) && r0.otherKey)) {
    t0.getKeyExchange().setOtherPublicKey(w0), (i0 = t0.state.keyExchange) === null || i0 === void 0 || i0.setKeysExchanged(!0), l0.state.ready = !0, l0.state.authorized = !0, l0.emit(bo.AUTHORIZED);
    const { communicationLayer: E0, storageManager: b0 } = l0.state, O0 = Object.assign(Object.assign({}, l0.state.channelConfig), { channelId: (o0 = l0.state.channelId) !== null && o0 !== void 0 ? o0 : "", validUntil: Date.now() + po, localKey: E0?.getKeyInfo().ecies.private, otherKey: w0 });
    t0.sendMessage({ type: Eo.KEY_HANDSHAKE_ACK }).catch((S0) => {
    }), (s0 = t0.state.socket) === null || s0 === void 0 || s0.emit(So.PING, { id: d0, clientType: h0 ? "dapp" : "wallet", context: "on_channel_reconnect", message: "" }), yield b0?.persistChannelConfig(O0), l0.emitServiceStatusEvent(), l0.setConnectionStatus(vo.LINKED);
  }
  g0 && (t0.emit(bo.CHANNEL_PERSISTENCE), (a0 = t0.state.keyExchange) === null || a0 === void 0 || a0.setKeysExchanged(!0), l0.state.ready = !0, l0.state.authorized = !0, l0.emit(bo.AUTHORIZED), co(Object.assign(Object.assign({ id: d0 ?? "", event: h0 ? _o.CONNECTED : _o.CONNECTED_MOBILE }, t0.remote.state.originatorInfo), { sdkVersion: t0.remote.state.sdkVersion, commLayer: t0.state.communicationLayerPreference, commLayerVersion: uo.version, walletVersion: (c0 = t0.remote.state.walletInfo) === null || c0 === void 0 ? void 0 : c0.version }), u0.communicationServerUrl).catch((E0) => {
  }));
}), Mo = (t0) => new Promise((e0) => {
  setTimeout(e0, t0);
}), Ao = (t0, e0, ...n0) => a(void 0, [t0, e0, ...n0], void 0, function* (r0, i0, o0 = 200) {
  let s0;
  const a0 = Date.now();
  let c0 = !1;
  for (; !c0; ) {
    if (c0 = Date.now() - a0 > 3e5, s0 = i0[r0], s0.elapsedTime !== void 0)
      return s0;
    yield Mo(o0);
  }
  throw new Error(`RPC ${r0} timed out`);
}), Io = (t0) => a(void 0, void 0, void 0, function* () {
  const { state: e0 } = t0, { socket: n0, channelId: r0, context: i0, isOriginator: o0, isReconnecting: s0 } = e0;
  if (s0)
    return io.SocketService("[SocketService: reconnectSocket()] Reconnection already in progress, skipping", t0), !1;
  if (!n0)
    return io.SocketService("[SocketService: reconnectSocket()] socket is not defined", t0), !1;
  if (!r0)
    return !1;
  const { connected: a0 } = n0;
  e0.isReconnecting = !0, e0.reconnectionAttempts = 0, io.SocketService(`[SocketService: reconnectSocket()] connected=${a0} trying to reconnect after socketio disconnection`, t0);
  try {
    for (; 3 > e0.reconnectionAttempts; ) {
      if (io.SocketService(`[SocketService: reconnectSocket()] Attempt ${e0.reconnectionAttempts + 1} of 3`, t0), yield Mo(200), n0.connected)
        return io.SocketService("Socket already connected --- ping to retrieve messages"), n0.emit(So.PING, { id: r0, clientType: o0 ? "dapp" : "wallet", context: "on_channel_config", message: "" }), !0;
      e0.resumed = !0, n0.connect(), t0.emit(bo.SOCKET_RECONNECT);
      try {
        if (yield new Promise((c0, l0) => {
          n0.emit(bo.JOIN_CHANNEL, { channelId: r0, context: `${i0}connect_again`, clientType: o0 ? "dapp" : "wallet" }, (u0, d0) => a(void 0, void 0, void 0, function* () {
            try {
              yield xo(t0, u0, d0), c0();
            } catch (h0) {
              l0(h0);
            }
          }));
        }), yield Mo(100), n0.connected)
          return io.SocketService(`Reconnection successful on attempt ${e0.reconnectionAttempts + 1}`), !0;
      } catch (c0) {
        io.SocketService(`Error during reconnection attempt ${e0.reconnectionAttempts + 1}:`, c0);
      }
      e0.reconnectionAttempts += 1, 3 > e0.reconnectionAttempts && (yield Mo(200));
    }
    return io.SocketService("Failed to reconnect after 3 attempts"), !1;
  } finally {
    e0.isReconnecting = !1, e0.reconnectionAttempts = 0;
  }
});
function Ro(t0, e0) {
  return a(this, void 0, void 0, function* () {
    var n0;
    const r0 = (n0 = t0.state.keyExchange) === null || n0 === void 0 ? void 0 : n0.encryptMessage(JSON.stringify(e0)), i0 = { id: t0.state.channelId, context: t0.state.context, clientType: t0.state.isOriginator ? "dapp" : "wallet", message: r0, plaintext: t0.state.hasPlaintext ? JSON.stringify(e0) : void 0 };
    return io.SocketService(`[SocketService: encryptAndSendMessage()] context=${t0.state.context}`, i0), e0.type === So.TERMINATE && (t0.state.manualDisconnect = !0), new Promise((o0, s0) => {
      var a0;
      (a0 = t0.state.socket) === null || a0 === void 0 || a0.emit(bo.MESSAGE, i0, (c0, l0) => {
        var u0;
        c0 && (io.SocketService(`[SocketService: encryptAndSendMessage()] error=${c0}`), s0(c0)), io.SocketService("[encryptAndSendMessage] response", l0), o0((u0 = l0?.success) !== null && u0 !== void 0 && u0);
      });
    });
  });
}
var Po;
(function(t0) {
  t0.RPC_CHECK = "rpcCheck", t0.SKIPPED_RPC = "skippedRpc";
})(Po || (Po = {}));
const To = ["eth_sendTransaction", "eth_signTypedData", "eth_signTransaction", "personal_sign", "wallet_requestPermissions", "wallet_switchEthereumChain", "eth_signTypedData_v3", "eth_signTypedData_v4", "metamask_connectSign", "metamask_connectWith", "metamask_batch"].map((t0) => t0.toLowerCase()), Oo = [{ event: bo.CLIENTS_CONNECTED, handler: function(t0, e0) {
  return (n0) => a(this, void 0, void 0, function* () {
    var r0, i0, o0, s0, a0, c0, l0, u0, d0, h0, g0;
    const w0 = (i0 = (r0 = t0.remote.state.channelConfig) === null || r0 === void 0 ? void 0 : r0.relayPersistence) !== null && i0 !== void 0 && i0;
    if (io.SocketService(`[SocketService: handleClientsConnected()] context=${t0.state.context} on 'clients_connected-${e0}' relayPersistence=${w0} resumed=${t0.state.resumed}  clientsPaused=${t0.state.clientsPaused} keysExchanged=${(o0 = t0.state.keyExchange) === null || o0 === void 0 ? void 0 : o0.areKeysExchanged()} isOriginator=${t0.state.isOriginator}`), t0.emit(bo.CLIENTS_CONNECTED, { isOriginator: t0.state.isOriginator, keysExchanged: (s0 = t0.state.keyExchange) === null || s0 === void 0 ? void 0 : s0.areKeysExchanged(), context: t0.state.context }), t0.state.resumed)
      t0.state.isOriginator || (io.SocketService(`[SocketService: handleClientsConnected()] context=${t0.state.context} 'clients_connected' / keysExchanged=${(a0 = t0.state.keyExchange) === null || a0 === void 0 ? void 0 : a0.areKeysExchanged()} -- backward compatibility`), (c0 = t0.state.keyExchange) === null || c0 === void 0 || c0.start({ isOriginator: (l0 = t0.state.isOriginator) !== null && l0 !== void 0 && l0 })), t0.state.resumed = !1;
    else if (t0.state.clientsPaused)
      io.SocketService("[SocketService: handleClientsConnected()] 'clients_connected' skip sending originatorInfo on pause");
    else if (!t0.state.isOriginator) {
      const y0 = !w0;
      io.SocketService(`[SocketService: handleClientsConnected()] context=${t0.state.context} on 'clients_connected' / keysExchanged=${(u0 = t0.state.keyExchange) === null || u0 === void 0 ? void 0 : u0.areKeysExchanged()} -- force=${y0} -- backward compatibility`), io.SocketService(`[SocketService: handleClientsConnected()] context=${t0.state.context} on 'clients_connected' / keysExchanged=${(d0 = t0.state.keyExchange) === null || d0 === void 0 ? void 0 : d0.areKeysExchanged()} -- force=${y0} -- backward compatibility`), (h0 = t0.state.keyExchange) === null || h0 === void 0 || h0.start({ isOriginator: (g0 = t0.state.isOriginator) !== null && g0 !== void 0 && g0, force: y0 });
    }
    t0.state.clientsConnected = !0, t0.state.clientsPaused = !1;
  });
} }, { event: bo.CHANNEL_CREATED, handler: function(t0, e0) {
  return (n0) => {
    io.SocketService(`[SocketService: handleChannelCreated()] context=${t0.state.context} on 'channel_created-${e0}'`, n0), t0.emit(bo.CHANNEL_CREATED, n0);
  };
} }, { event: bo.CLIENTS_DISCONNECTED, handler: function(t0, e0) {
  return () => {
    var n0;
    t0.state.clientsConnected = !1, io.SocketService(`[SocketService: handlesClientsDisconnected()] context=${t0.state.context} on 'clients_disconnected-${e0}'`), t0.remote.state.relayPersistence ? io.SocketService(`[SocketService: handlesClientsDisconnected()] context=${t0.state.context} on 'clients_disconnected-${e0}' - relayPersistence enabled, skipping key exchange cleanup.`) : (t0.state.isOriginator && !t0.state.clientsPaused && ((n0 = t0.state.keyExchange) === null || n0 === void 0 || n0.clean()), t0.emit(bo.CLIENTS_DISCONNECTED, e0));
  };
} }, { event: bo.CONFIG, handler: function(t0, e0) {
  return (n0) => a(this, void 0, void 0, function* () {
    var r0, i0, o0;
    io.SocketService(`[SocketService: handleChannelConfig()] update relayPersistence on 'config-${e0}'`, n0);
    const { persistence: s0, walletKey: a0 } = n0;
    t0.state.isOriginator && t0.remote.state.channelConfig ? (n0.walletKey && !t0.remote.state.channelConfig.otherKey && (io.SocketService(`Setting wallet key ${a0}`), t0.remote.state.channelConfig.otherKey = a0, t0.getKeyExchange().setOtherPublicKey(n0.walletKey), (r0 = t0.state.keyExchange) === null || r0 === void 0 || r0.setKeysExchanged(!0), yield t0.remote.sendMessage({ type: Eo.KEY_HANDSHAKE_ACK }), yield t0.remote.sendMessage({ type: So.PING }), yield (i0 = t0.remote.state.storageManager) === null || i0 === void 0 ? void 0 : i0.persistChannelConfig(t0.remote.state.channelConfig)), s0 !== !0 || t0.remote.state.channelConfig.relayPersistence || (io.SocketService(`Setting relay persistence ${s0}`), t0.remote.state.channelConfig.relayPersistence = s0, t0.remote.state.relayPersistence = !0, t0.remote.emit(bo.CHANNEL_PERSISTENCE), t0.remote.state.authorized = !0, t0.remote.state.ready = !0, t0.remote.emit(bo.AUTHORIZED), yield (o0 = t0.remote.state.storageManager) === null || o0 === void 0 ? void 0 : o0.persistChannelConfig(t0.remote.state.channelConfig))) : t0.state.isOriginator || n0.persistence && (t0.remote.state.relayPersistence = !0, t0.remote.emit(bo.CHANNEL_PERSISTENCE));
  });
} }, { event: bo.MESSAGE, handler: function(t0, e0) {
  return (n0) => {
    var r0, i0, o0, s0, a0, c0, l0, u0, d0, h0, g0, w0, y0, E0, b0, O0, S0, k0;
    const { ackId: D0, message: z0, error: G0 } = n0, K0 = (r0 = t0.remote.state.relayPersistence) !== null && r0 !== void 0 && r0;
    if (io.SocketService(`[SocketService handleMessage()]  relayPersistence=${K0}  context=${t0.state.context} on 'message' ${e0} keysExchanged=${(i0 = t0.state.keyExchange) === null || i0 === void 0 ? void 0 : i0.areKeysExchanged()}`, n0), G0)
      throw io.SocketService(`
      [SocketService handleMessage()] context=${t0.state.context}::on 'message' error=${G0}`), new Error(G0);
    const U0 = typeof z0 == "string";
    if (!U0 && z0?.type === Eo.KEY_HANDSHAKE_START)
      return K0 ? void 0 : (io.SocketService(`[SocketService handleMessage()] context=${t0.state.context}::on 'message' received HANDSHAKE_START isOriginator=${t0.state.isOriginator}`, z0), void ((o0 = t0.state.keyExchange) === null || o0 === void 0 || o0.start({ isOriginator: (s0 = t0.state.isOriginator) !== null && s0 !== void 0 && s0, force: !0 })));
    if (!U0 && (!((a0 = z0?.type) === null || a0 === void 0) && a0.startsWith("key_handshake")))
      return K0 ? void 0 : (io.SocketService(`[SocketService handleMessage()] context=${t0.state.context}::on 'message' emit KEY_EXCHANGE`, z0), void t0.emit(wo.KEY_EXCHANGE, { message: z0, context: t0.state.context }));
    if (U0 && !(!((c0 = t0.state.keyExchange) === null || c0 === void 0) && c0.areKeysExchanged())) {
      let P0 = !1;
      try {
        io.SocketService(`[SocketService handleMessage()] context=${t0.state.context}::on 'message' trying to decrypt message`), (l0 = t0.state.keyExchange) === null || l0 === void 0 || l0.decryptMessage(z0), P0 = !0;
      } catch (I0) {
        io.SocketService(`[SocketService handleMessage()] context=${t0.state.context}::on 'message' error`, I0);
      }
      if (!P0)
        return t0.state.isOriginator ? (d0 = t0.state.keyExchange) === null || d0 === void 0 || d0.start({ isOriginator: (h0 = t0.state.isOriginator) !== null && h0 !== void 0 && h0 }) : t0.sendMessage({ type: Eo.KEY_HANDSHAKE_START }).catch((I0) => {
        }), void io.SocketService(`Message ignored because invalid key exchange status. step=${(g0 = t0.state.keyExchange) === null || g0 === void 0 ? void 0 : g0.getKeyInfo().step}`, (w0 = t0.state.keyExchange) === null || w0 === void 0 ? void 0 : w0.getKeyInfo(), z0);
      io.SocketService("Invalid key exchange status detected --- updating it."), (u0 = t0.state.keyExchange) === null || u0 === void 0 || u0.setKeysExchanged(!0);
    } else if (!U0 && z0?.type)
      return void t0.emit(bo.MESSAGE, z0);
    if (!U0)
      return void t0.emit(bo.MESSAGE, z0);
    const F0 = (y0 = t0.state.keyExchange) === null || y0 === void 0 ? void 0 : y0.decryptMessage(z0), H0 = JSON.parse(F0 ?? "{}");
    if (D0 && D0?.length > 0 && (io.SocketService(`[SocketService handleMessage()] context=${t0.state.context}::on 'message' ackid=${D0} channelId=${e0}`), (E0 = t0.state.socket) === null || E0 === void 0 || E0.emit(bo.MESSAGE_ACK, { ackId: D0, channelId: e0, clientType: t0.state.isOriginator ? "dapp" : "wallet" })), t0.state.clientsPaused = H0?.type === So.PAUSE, t0.state.isOriginator && H0.data) {
      const P0 = H0.data, I0 = t0.state.rpcMethodTracker[P0.id];
      if (I0) {
        const f0 = Date.now() - I0.timestamp;
        io.SocketService(`[SocketService handleMessage()] context=${t0.state.context}::on 'message' received answer for id=${P0.id} method=${I0.method} responseTime=${f0}`, H0), t0.remote.state.analytics && To.includes(I0.method.toLowerCase()) && co(Object.assign(Object.assign({ id: (b0 = t0.remote.state.channelId) !== null && b0 !== void 0 ? b0 : "", event: _o.SDK_RPC_REQUEST_DONE, sdkVersion: t0.remote.state.sdkVersion, commLayerVersion: uo.version }, t0.remote.state.originatorInfo), { walletVersion: (O0 = t0.remote.state.walletInfo) === null || O0 === void 0 ? void 0 : O0.version, params: { method: I0.method, from: "mobile" } }), t0.remote.state.communicationServerUrl).catch((A0) => {
        });
        const m0 = Object.assign(Object.assign({}, I0), { result: P0.result, error: P0.error ? { code: (S0 = P0.error) === null || S0 === void 0 ? void 0 : S0.code, message: (k0 = P0.error) === null || k0 === void 0 ? void 0 : k0.message } : void 0, elapsedTime: f0 });
        t0.state.rpcMethodTracker[P0.id] = m0, t0.emit(bo.RPC_UPDATE, m0);
      }
    }
    t0.emit(bo.MESSAGE, { message: H0 });
  };
} }, { event: bo.REJECTED, handler: function(t0, e0) {
  return (n0) => a(this, void 0, void 0, function* () {
    var r0;
    t0.state.isOriginator && !t0.remote.state.ready ? (io.SocketService(`[SocketService: handleChannelRejected()] context=${t0.state.context} channelId=${e0} isOriginator=${t0.state.isOriginator} ready=${t0.remote.state.ready}`, t0.remote.state.originatorInfo), co(Object.assign(Object.assign({ id: e0, event: _o.REJECTED }, t0.remote.state.originatorInfo), { sdkVersion: t0.remote.state.sdkVersion, commLayer: t0.state.communicationLayerPreference, commLayerVersion: uo.version, walletVersion: (r0 = t0.remote.state.walletInfo) === null || r0 === void 0 ? void 0 : r0.version }), t0.remote.state.communicationServerUrl).catch((i0) => {
    }), yield t0.remote.disconnect({ terminate: !0 }), t0.remote.emit(bo.REJECTED, { channelId: e0 }), t0.remote.setConnectionStatus(vo.DISCONNECTED)) : io.SocketService(`[SocketService: handleChannelRejected()] SKIP -- channelId=${e0} isOriginator=${t0.state.isOriginator} ready=${t0.remote.state.ready}`);
  });
} }, { event: "clients_waiting_to_join", handler: function(t0, e0) {
  return (n0) => {
    io.SocketService(`[SocketService: handleClientsWaitingToJoin()] context=${t0.state.context} on 'clients_waiting_to_join-${e0}'`, n0), t0.emit(bo.CLIENTS_WAITING, n0);
  };
} }], Lo = [{ event: bo.KEY_INFO, handler: function(t0) {
  return (e0) => {
    io.SocketService("[SocketService: handleKeyInfo()] on 'KEY_INFO'", e0), t0.emit(bo.KEY_INFO, e0);
  };
} }, { event: bo.KEYS_EXCHANGED, handler: function(t0) {
  return () => {
    var e0, n0, r0;
    io.SocketService(`[SocketService: handleKeysExchanged()] on 'keys_exchanged' keyschanged=${(e0 = t0.state.keyExchange) === null || e0 === void 0 ? void 0 : e0.areKeysExchanged()}`);
    const { channelConfig: i0 } = t0.remote.state;
    if (i0) {
      const s0 = t0.getKeyExchange().getKeyInfo().ecies;
      i0.localKey = s0.private, i0.otherKey = s0.otherPubKey, t0.remote.state.channelConfig = i0, (n0 = t0.remote.state.storageManager) === null || n0 === void 0 || n0.persistChannelConfig(i0).catch((a0) => {
      });
    }
    t0.emit(bo.KEYS_EXCHANGED, { keysExchanged: (r0 = t0.state.keyExchange) === null || r0 === void 0 ? void 0 : r0.areKeysExchanged(), isOriginator: t0.state.isOriginator });
    const o0 = { keyInfo: t0.getKeyInfo() };
    t0.emit(bo.SERVICE_STATUS, o0);
  };
} }];
function No(t0, e0) {
  io.SocketService(`[SocketService: setupChannelListener()] context=${t0.state.context} setting socket listeners for channel ${e0}...`);
  const { socket: n0 } = t0.state, { keyExchange: r0 } = t0.state;
  n0 && t0.state.isOriginator && (t0.state.debug && (n0?.io.on("error", (i0) => {
    io.SocketService(`[SocketService: setupChannelListener()] context=${t0.state.context} socket event=error`, i0);
  }), n0?.io.on("reconnect", (i0) => {
    io.SocketService(`[SocketService: setupChannelListener()] context=${t0.state.context} socket event=reconnect`, i0), Io(t0).catch((o0) => {
    });
  }), n0?.io.on("reconnect_error", (i0) => {
    io.SocketService(`[SocketService: setupChannelListener()] context=${t0.state.context} socket event=reconnect_error`, i0);
  }), n0?.io.on("reconnect_failed", () => {
    io.SocketService(`[SocketService: setupChannelListener()] context=${t0.state.context} socket event=reconnect_failed`);
  })), n0?.on("disconnect", (i0) => (io.SocketService(`[SocketService: setupChannelListener()] on 'disconnect' -- MetaMaskSDK socket disconnected '${i0}' begin recovery...`), function(o0) {
    return (s0) => {
      io.SocketService(`[SocketService: handleDisconnect()] on 'disconnect' manualDisconnect=${o0.state.manualDisconnect}`, s0), o0.state.manualDisconnect || (o0.emit(bo.SOCKET_DISCONNECTED), Io(o0).catch((a0) => {
      }));
    };
  }(t0)(i0)))), Oo.forEach(({ event: i0, handler: o0 }) => {
    n0?.on(`${i0}-${e0}`, o0(t0, e0));
  }), Lo.forEach(({ event: i0, handler: o0 }) => {
    r0?.on(i0, o0(t0));
  }), t0.state.setupChannelListeners = !0;
}
class $o extends eventemitter2Exports.EventEmitter2 {
  constructor(e0) {
    super(), this.state = { clientsConnected: !1, clientsPaused: !1, manualDisconnect: !1, lastRpcId: void 0, rpcMethodTracker: {}, hasPlaintext: !1, communicationServerUrl: "", focusListenerAdded: !1, removeFocusListener: void 0, isReconnecting: !1, reconnectionAttempts: 0 }, this.options = e0;
    const { reconnect: n0, communicationLayerPreference: r0, communicationServerUrl: i0, context: o0, remote: s0, logging: a0 } = e0;
    this.state.resumed = n0, this.state.context = o0, this.state.isOriginator = s0.state.isOriginator, this.state.communicationLayerPreference = r0, this.state.debug = a0?.serviceLayer === !0, this.remote = s0, a0?.serviceLayer === !0 && t.enable("SocketService:Layer"), this.state.communicationServerUrl = i0, this.state.hasPlaintext = this.state.communicationServerUrl !== ho && a0?.plaintext === !0, io.SocketService(`[SocketService: constructor()] Socket IO url: ${this.state.communicationServerUrl}`), this.initSocket();
  }
  initSocket() {
    var e0;
    const { otherPublicKey: n0, ecies: r0, logging: i0 } = this.options, o0 = { autoConnect: !1, transports: fo, withCredentials: !0 }, s0 = this.state.communicationServerUrl;
    io.SocketService(`[SocketService: initSocket()] Socket IO url: ${s0}`), this.state.socket = lookup$1(s0, o0), function(c0) {
      if (typeof window < "u" && typeof document < "u" && (io.SocketService(`[SocketService: setupSocketFocusListener()] hasFocus=${document.hasFocus()}`, c0), !c0.state.focusListenerAdded)) {
        const l0 = () => {
          io.SocketService("Document has focus --- reconnecting socket"), Io(c0).catch((u0) => {
          });
        };
        window.addEventListener("focus", l0), c0.state.focusListenerAdded = !0, c0.state.removeFocusListener = () => {
          window.removeEventListener("focus", l0), c0.state.focusListenerAdded = !1;
        };
      }
    }(this);
    const a0 = { communicationLayer: this, otherPublicKey: n0, sendPublicKey: !1, context: (e0 = this.state.context) !== null && e0 !== void 0 ? e0 : "", ecies: r0, logging: i0 };
    this.state.keyExchange = new ko(a0);
  }
  resetKeys() {
    return io.SocketService("[SocketService: resetKeys()] Resetting keys."), void ((e0 = this.state.keyExchange) === null || e0 === void 0 || e0.resetKeys());
    var e0;
  }
  createChannel() {
    return a(this, void 0, void 0, function* () {
      return function(e0) {
        return a(this, void 0, void 0, function* () {
          var n0, r0, i0;
          if (io.SocketService(`[SocketService: createChannel()] context=${e0.state.context}`), e0.state.socket || e0.initSocket(), (n0 = e0.state.socket) === null || n0 === void 0 ? void 0 : n0.connected)
            throw new Error("socket already connected");
          (r0 = e0.state.socket) === null || r0 === void 0 || r0.connect(), e0.state.manualDisconnect = !1, e0.state.isOriginator = !0;
          const o0 = v4();
          e0.state.channelId = o0, No(e0, o0), yield new Promise((a0, c0) => {
            var l0;
            (l0 = e0.state.socket) === null || l0 === void 0 || l0.emit(bo.JOIN_CHANNEL, { channelId: o0, context: `${e0.state.context}createChannel`, clientType: "dapp" }, (u0, d0) => a(this, void 0, void 0, function* () {
              try {
                yield xo(e0, u0, d0), a0();
              } catch (h0) {
                c0(h0);
              }
            }));
          });
          const s0 = (i0 = e0.state.keyExchange) === null || i0 === void 0 ? void 0 : i0.getKeyInfo();
          return { channelId: o0, pubKey: s0?.ecies.public || "", privKey: s0?.ecies.private || "" };
        });
      }(this);
    });
  }
  connectToChannel({ channelId: e0, withKeyExchange: n0 = !1, authorized: r0 }) {
    return function(i0) {
      return a(this, arguments, void 0, function* ({ options: o0, instance: s0 }) {
        const { channelId: a0, authorized: c0, withKeyExchange: l0 } = o0, { state: u0, remote: d0 } = s0, { isOriginator: h0 = !1, socket: g0, keyExchange: w0 } = u0, { channelConfig: y0 } = d0.state;
        if (g0?.connected)
          throw new Error("socket already connected");
        if (h0 && y0?.relayPersistence) {
          const { localKey: E0, otherKey: b0 } = y0;
          E0 && b0 && w0?.setRelayPersistence({ localKey: E0, otherKey: b0 });
        }
        return Object.assign(u0, { manualDisconnect: !1, withKeyExchange: l0, isOriginator: h0, channelId: a0 }), g0?.connect(), No(s0, a0), !h0 && c0 && (w0?.setKeysExchanged(!0), Object.assign(d0.state, { ready: !0, authorized: !0 })), new Promise((E0) => {
          var b0;
          const O0 = (b0 = w0?.getKeyInfo()) === null || b0 === void 0 ? void 0 : b0.ecies.public;
          g0?.emit(bo.JOIN_CHANNEL, { channelId: a0, context: `${u0.context}_connectToChannel`, clientType: h0 ? "dapp" : "wallet", publicKey: c0 && !h0 ? O0 : void 0 }, (S0, k0) => a(this, void 0, void 0, function* () {
            yield xo(s0, S0, k0), E0();
          }));
        });
      });
    }({ options: { channelId: e0, withKeyExchange: n0, authorized: r0 }, instance: this });
  }
  getKeyInfo() {
    return this.state.keyExchange.getKeyInfo();
  }
  keyCheck() {
    var e0, n0;
    (n0 = (e0 = this).state.socket) === null || n0 === void 0 || n0.emit(bo.MESSAGE, { id: e0.state.channelId, context: e0.state.context, message: { type: Eo.KEY_HANDSHAKE_CHECK, pubkey: e0.getKeyInfo().ecies.otherPubKey } });
  }
  getKeyExchange() {
    return this.state.keyExchange;
  }
  sendMessage(e0) {
    return a(this, void 0, void 0, function* () {
      return function(n0, r0) {
        return a(this, void 0, void 0, function* () {
          var i0, o0, s0;
          if (!n0.state.channelId)
            throw io.SocketService("handleSendMessage: no channelId - Create a channel first"), new Error("Create a channel first");
          if (io.SocketService(`[SocketService: handleSendMessage()] context=${n0.state.context} areKeysExchanged=${(i0 = n0.state.keyExchange) === null || i0 === void 0 ? void 0 : i0.areKeysExchanged()}`, r0), (o0 = r0?.type) === null || o0 === void 0 ? void 0 : o0.startsWith("key_handshake"))
            return function(c0, l0) {
              var u0;
              io.SocketService(`[SocketService: handleKeyHandshake()] context=${c0.state.context}`, l0), (u0 = c0.state.socket) === null || u0 === void 0 || u0.emit(bo.MESSAGE, { id: c0.state.channelId, context: c0.state.context, clientType: c0.state.isOriginator ? "dapp" : "wallet", message: l0 });
            }(n0, r0), !0;
          (function(c0, l0) {
            var u0;
            if (!(!((u0 = c0.state.keyExchange) === null || u0 === void 0) && u0.areKeysExchanged()) && !c0.remote.state.relayPersistence)
              throw io.SocketService(`[SocketService: validateKeyExchange()] context=${c0.state.context} ERROR keys not exchanged`, l0), new Error("Keys not exchanged BBB");
          })(n0, r0), function(c0, l0) {
            var u0;
            const d0 = (u0 = l0?.method) !== null && u0 !== void 0 ? u0 : "", h0 = l0?.id;
            c0.state.isOriginator && h0 && (c0.state.rpcMethodTracker[h0] = { id: h0, timestamp: Date.now(), method: d0 }, c0.emit(bo.RPC_UPDATE, c0.state.rpcMethodTracker[h0]));
          }(n0, r0);
          const a0 = yield Ro(n0, r0);
          return n0.remote.state.analytics && n0.remote.state.isOriginator && r0.method && To.includes(r0.method.toLowerCase()) && co({ id: (s0 = n0.remote.state.channelId) !== null && s0 !== void 0 ? s0 : "", event: _o.SDK_RPC_REQUEST, params: { method: r0.method, from: "mobile" } }, n0.remote.state.communicationServerUrl).catch((c0) => {
          }), function(c0, l0) {
            return a(this, void 0, void 0, function* () {
              var u0;
              const d0 = l0?.id, h0 = (u0 = l0?.method) !== null && u0 !== void 0 ? u0 : "";
              if (c0.state.isOriginator && d0)
                try {
                  const g0 = Ao(d0, c0.state.rpcMethodTracker, 200).then((E0) => ({ type: Po.RPC_CHECK, result: E0 })), w0 = (() => a(this, void 0, void 0, function* () {
                    const E0 = yield ((O0) => a(void 0, [O0], void 0, function* ({ rpcId: S0, instance: k0 }) {
                      for (; k0.state.lastRpcId === S0 || k0.state.lastRpcId === void 0; )
                        yield Mo(200);
                      return k0.state.lastRpcId;
                    }))({ instance: c0, rpcId: d0 }), b0 = yield Ao(E0, c0.state.rpcMethodTracker, 200);
                    return { type: Po.SKIPPED_RPC, result: b0 };
                  }))(), y0 = yield Promise.race([g0, w0]);
                  if (y0.type === Po.RPC_CHECK) {
                    const E0 = y0.result;
                    io.SocketService(`[SocketService:handleRpcReplies()] id=${l0.id} ${h0} ( ${E0.elapsedTime} ms)`, E0.result);
                  } else {
                    if (y0.type !== Po.SKIPPED_RPC)
                      throw new Error(`Error handling RPC replies for ${d0}`);
                    {
                      const E0 = Object.assign(Object.assign({}, c0.state.rpcMethodTracker[d0]), { error: new Error("SDK_CONNECTION_ISSUE") });
                      c0.emit(bo.RPC_UPDATE, E0);
                      const b0 = { data: Object.assign(Object.assign({}, E0), { jsonrpc: "2.0" }), name: "metamask-provider" };
                      c0.emit(bo.MESSAGE, { message: b0 });
                    }
                  }
                } catch (g0) {
                  throw g0;
                }
            });
          }(n0, r0).catch((c0) => {
          }), a0;
        });
      }(this, e0);
    });
  }
  ping() {
    return function(e0) {
      return a(this, void 0, void 0, function* () {
        var n0, r0;
        io.SocketService(`[SocketService: ping()] context=${e0.state.context} originator=${e0.state.isOriginator} keysExchanged=${(n0 = e0.state.keyExchange) === null || n0 === void 0 ? void 0 : n0.areKeysExchanged()}`), (r0 = e0.state.socket) === null || r0 === void 0 || r0.emit(So.PING, { id: e0.state.channelId, context: "ping", clientType: e0.remote.state.isOriginator ? "dapp" : "wallet", message: "" });
      });
    }(this);
  }
  pause() {
    return function(e0) {
      return a(this, void 0, void 0, function* () {
        var n0, r0;
        io.SocketService(`[SocketService: pause()] context=${e0.state.context}`), e0.state.manualDisconnect = !0, !((n0 = e0.state.keyExchange) === null || n0 === void 0) && n0.areKeysExchanged() && (yield e0.sendMessage({ type: So.PAUSE })), (r0 = e0.state.socket) === null || r0 === void 0 || r0.disconnect();
      });
    }(this);
  }
  isConnected() {
    var e0;
    return (e0 = this.state.socket) === null || e0 === void 0 ? void 0 : e0.connected;
  }
  resume() {
    return function(e0) {
      return a(this, void 0, void 0, function* () {
        const { state: n0, remote: r0 } = e0, { socket: i0, channelId: o0, context: s0, keyExchange: a0, isOriginator: c0 } = n0, { isOriginator: l0 } = r0.state;
        if (io.SocketService(`[SocketService: resume()] channelId=${o0} context=${s0} connected=${i0?.connected} manualDisconnect=${n0.manualDisconnect} resumed=${n0.resumed} keysExchanged=${a0?.areKeysExchanged()}`), !o0)
          throw io.SocketService("[SocketService: resume()] channelId is not defined"), new Error("ChannelId is not defined");
        i0?.connected ? (io.SocketService("[SocketService: resume()] already connected."), i0.emit(So.PING, { id: o0, clientType: l0 ? "dapp" : "wallet", context: "on_channel_config", message: "" }), r0.hasRelayPersistence() || a0?.areKeysExchanged() || (c0 ? yield e0.sendMessage({ type: So.READY }) : a0?.start({ isOriginator: !1 }))) : (i0?.connect(), io.SocketService(`[SocketService: resume()] after connecting socket --> connected=${i0?.connected}`), i0?.emit(bo.JOIN_CHANNEL, { channelId: o0, context: `${s0}_resume`, clientType: l0 ? "dapp" : "wallet" }, (u0, d0) => a(this, void 0, void 0, function* () {
          try {
            yield xo(e0, u0, d0);
          } catch {
          }
        }))), n0.manualDisconnect = !1, n0.resumed = !0;
      });
    }(this);
  }
  getRPCMethodTracker() {
    return this.state.rpcMethodTracker;
  }
  disconnect(e0) {
    return function(n0, r0) {
      var i0, o0, s0, a0, c0;
      io.SocketService(`[SocketService: disconnect()] context=${n0.state.context}`, r0), r0?.terminate && ((o0 = (i0 = n0.state).removeFocusListener) === null || o0 === void 0 || o0.call(i0), n0.state.channelId = r0.channelId, (s0 = n0.state.socket) === null || s0 === void 0 || s0.removeAllListeners(), (a0 = n0.state.keyExchange) === null || a0 === void 0 || a0.clean(), n0.remote.state.ready = !1, n0.state.socket = void 0, n0.state.rpcMethodTracker = {}), n0.state.manualDisconnect = !0, (c0 = n0.state.socket) === null || c0 === void 0 || c0.disconnect();
    }(this, e0);
  }
}
var Do, Bo, Ko;
function jo(t0) {
  return () => a(this, void 0, void 0, function* () {
    var e0, n0, r0;
    const { state: i0 } = t0;
    if (i0.authorized)
      return;
    yield (() => a(this, void 0, void 0, function* () {
      for (; !i0.walletInfo; )
        yield Mo(500);
    }))();
    const o0 = "7.3".localeCompare(((e0 = i0.walletInfo) === null || e0 === void 0 ? void 0 : e0.version) || "");
    if (io.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' version=${(n0 = i0.walletInfo) === null || n0 === void 0 ? void 0 : n0.version} compareValue=${o0}`), o0 !== 1)
      return;
    const s0 = i0.platformType === Bo.MobileWeb || i0.platformType === Bo.ReactNative || i0.platformType === Bo.MetaMaskMobileWebview;
    io.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' platform=${i0.platformType} secure=${s0} channel=${i0.channelId} walletVersion=${(r0 = i0.walletInfo) === null || r0 === void 0 ? void 0 : r0.version}`), s0 && (i0.authorized = !0, t0.emit(bo.AUTHORIZED));
  });
}
function Uo(t0) {
  return (e0) => {
    const { state: n0 } = t0;
    io.RemoteCommunication(`[RemoteCommunication: handleChannelCreatedEvent()] context=${n0.context} on 'channel_created' channelId=${e0}`), t0.emit(bo.CHANNEL_CREATED, e0);
  };
}
function Ho(t0, e0) {
  return () => {
    var n0, r0, i0, o0;
    const { state: s0 } = t0;
    io.RemoteCommunication(`[RemoteCommunication: handleClientsConnectedEvent()] on 'clients_connected' channel=${s0.channelId} keysExchanged=${(r0 = (n0 = s0.communicationLayer) === null || n0 === void 0 ? void 0 : n0.getKeyInfo()) === null || r0 === void 0 ? void 0 : r0.keysExchanged}`), s0.analytics && co(Object.assign(Object.assign({ id: (i0 = s0.channelId) !== null && i0 !== void 0 ? i0 : "", event: s0.reconnection ? _o.RECONNECT : s0.isOriginator ? _o.REQUEST : _o.REQUEST_MOBILE }, s0.originatorInfo), { commLayer: e0, sdkVersion: s0.sdkVersion, walletVersion: (o0 = s0.walletInfo) === null || o0 === void 0 ? void 0 : o0.version, commLayerVersion: uo.version }), s0.communicationServerUrl).catch((a0) => {
    }), s0.clientsConnected = !0, s0.originatorInfoSent = !1, t0.emit(bo.CLIENTS_CONNECTED);
  };
}
function Fo(t0) {
  return (e0) => {
    const { state: n0 } = t0;
    io.RemoteCommunication(`[RemoteCommunication: handleClientsDisconnectedEvent()] context=${n0.context} on 'clients_disconnected' channelId=${e0}`), n0.relayPersistence || (n0.clientsConnected = !1, n0.ready = !1, n0.authorized = !1), t0.emit(bo.CLIENTS_DISCONNECTED, n0.channelId), t0.setConnectionStatus(vo.DISCONNECTED);
  };
}
function zo(t0) {
  return (e0) => {
    var n0;
    const { state: r0 } = t0;
    if (io.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] context=${r0.context} on 'clients_waiting' numberUsers=${e0} ready=${r0.ready} autoStarted=${r0.originatorConnectStarted}`), t0.setConnectionStatus(vo.WAITING), t0.emit(bo.CLIENTS_WAITING, e0), r0.originatorConnectStarted) {
      io.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] on 'clients_waiting' watch autoStarted=${r0.originatorConnectStarted} timeout`, r0.autoConnectOptions);
      const i0 = ((n0 = r0.autoConnectOptions) === null || n0 === void 0 ? void 0 : n0.timeout) || 3e3, o0 = setTimeout(() => {
        io.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] setTimeout(${i0}) terminate channelConfig`, r0.autoConnectOptions), r0.originatorConnectStarted = !1, r0.ready || t0.setConnectionStatus(vo.TIMEOUT), clearTimeout(o0);
      }, i0);
    }
  };
}
function qo(t0, e0) {
  return (n0) => {
    var r0, i0, o0, s0, a0, c0, l0, u0;
    const { state: d0 } = t0;
    if (io.RemoteCommunication(`[RemoteCommunication: handleKeysExchangedEvent()] context=${d0.context} on commLayer.'keys_exchanged' channel=${d0.channelId}`, n0), (i0 = (r0 = d0.communicationLayer) === null || r0 === void 0 ? void 0 : r0.getKeyInfo()) === null || i0 === void 0 ? void 0 : i0.keysExchanged) {
      const h0 = Object.assign(Object.assign({}, d0.channelConfig), { channelId: (o0 = d0.channelId) !== null && o0 !== void 0 ? o0 : "", validUntil: ((s0 = d0.channelConfig) === null || s0 === void 0 ? void 0 : s0.validUntil) || po, localKey: d0.communicationLayer.getKeyInfo().ecies.private, otherKey: d0.communicationLayer.getKeyInfo().ecies.otherPubKey });
      (a0 = d0.storageManager) === null || a0 === void 0 || a0.persistChannelConfig(h0).catch((g0) => {
      }), t0.setConnectionStatus(vo.LINKED);
    }
    (function(h0, g0) {
      var w0, y0, E0, b0, O0, S0, k0, D0;
      const { state: z0 } = h0;
      io.RemoteCommunication(`[RemoteCommunication: setLastActiveDate()] channel=${z0.channelId}`, g0);
      const G0 = Object.assign(Object.assign({}, z0.channelConfig), { channelId: (w0 = z0.channelId) !== null && w0 !== void 0 ? w0 : "", validUntil: (E0 = (y0 = z0.channelConfig) === null || y0 === void 0 ? void 0 : y0.validUntil) !== null && E0 !== void 0 ? E0 : 0, relayPersistence: z0.relayPersistence, localKey: (O0 = (b0 = z0.communicationLayer) === null || b0 === void 0 ? void 0 : b0.state.keyExchange) === null || O0 === void 0 ? void 0 : O0.getKeyInfo().ecies.private, otherKey: (k0 = (S0 = z0.communicationLayer) === null || S0 === void 0 ? void 0 : S0.state.keyExchange) === null || k0 === void 0 ? void 0 : k0.getKeyInfo().ecies.otherPubKey, lastActive: g0.getTime() });
      (D0 = z0.storageManager) === null || D0 === void 0 || D0.persistChannelConfig(G0);
    })(t0, /* @__PURE__ */ new Date()), d0.analytics && d0.channelId && co(Object.assign(Object.assign({ id: d0.channelId, event: n0.isOriginator ? _o.CONNECTED : _o.CONNECTED_MOBILE }, d0.originatorInfo), { sdkVersion: d0.sdkVersion, commLayer: e0, commLayerVersion: uo.version, walletVersion: (c0 = d0.walletInfo) === null || c0 === void 0 ? void 0 : c0.version }), d0.communicationServerUrl).catch((h0) => {
    }), d0.isOriginator = n0.isOriginator, n0.isOriginator || ((l0 = d0.communicationLayer) === null || l0 === void 0 || l0.sendMessage({ type: So.READY }), d0.ready = !0, d0.paused = !1), n0.isOriginator && !d0.originatorInfoSent && ((u0 = d0.communicationLayer) === null || u0 === void 0 || u0.sendMessage({ type: So.ORIGINATOR_INFO, originatorInfo: d0.originatorInfo, originator: d0.originatorInfo }), d0.originatorInfoSent = !0);
  };
}
function Wo(t0) {
  return (e0) => {
    let n0 = e0;
    e0.message && (n0 = n0.message), function(r0, i0) {
      const { state: o0 } = i0;
      if (io.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] context=${o0.context} on 'message' typeof=${typeof r0}`, r0), i0.state.ready = !0, o0.isOriginator || r0.type !== So.ORIGINATOR_INFO)
        if (o0.isOriginator && r0.type === So.WALLET_INFO)
          (function(s0, a0) {
            const { state: c0 } = s0;
            c0.walletInfo = a0.walletInfo, c0.paused = !1;
          })(i0, r0);
        else {
          if (o0.isOriginator && r0.type === So.WALLET_INIT)
            (function(s0, a0) {
              return a(this, void 0, void 0, function* () {
                var c0, l0, u0;
                const { state: d0 } = s0;
                if (d0.isOriginator) {
                  const h0 = a0.data || {};
                  if (typeof h0 == "object" && "accounts" in h0 && "chainId" in h0 && "walletKey" in h0)
                    try {
                      const { channelConfig: g0 } = s0.state;
                      if (io.RemoteCommunication("WALLET_INIT: channelConfig", JSON.stringify(g0, null, 2)), g0) {
                        const w0 = h0.accounts, y0 = h0.chainId, E0 = h0.walletKey;
                        let b0, O0 = !1;
                        "deeplinkProtocol" in h0 && (O0 = !!h0.deeplinkProtocol, s0.state.deeplinkProtocolAvailable = O0), "walletVersion" in h0 && (b0 = h0.walletVersion), yield (c0 = s0.state.storageManager) === null || c0 === void 0 ? void 0 : c0.persistChannelConfig(Object.assign(Object.assign({}, g0), { otherKey: E0, walletVersion: b0, deeplinkProtocolAvailable: O0, relayPersistence: !0 })), yield (l0 = s0.state.storageManager) === null || l0 === void 0 ? void 0 : l0.persistAccounts(w0), yield (u0 = s0.state.storageManager) === null || u0 === void 0 ? void 0 : u0.persistChainId(y0);
                      }
                      s0.emit(bo.WALLET_INIT, { accounts: h0.accounts, chainId: h0.chainId });
                    } catch {
                    }
                }
              });
            })(i0, r0).catch((s0) => {
              io.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] error=${s0}`);
            });
          else if (r0.type === So.TERMINATE)
            (function(s0) {
              return a(this, void 0, void 0, function* () {
                const { state: a0 } = s0;
                a0.isOriginator && (yield Jo({ options: { terminate: !0, sendMessage: !1 }, instance: s0 }), s0.emit(bo.TERMINATE));
              });
            })(i0).catch((s0) => {
              io.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] error=${s0}`);
            });
          else if (r0.type === So.PAUSE)
            (function(s0) {
              const { state: a0 } = s0;
              a0.paused = !0, s0.setConnectionStatus(vo.PAUSED);
            })(i0);
          else if (r0.type === So.READY && o0.isOriginator)
            (function(s0) {
              const { state: a0 } = s0;
              s0.setConnectionStatus(vo.LINKED);
              const c0 = a0.paused;
              a0.paused = !1, s0.emit(bo.CLIENTS_READY, { isOriginator: a0.isOriginator, walletInfo: a0.walletInfo }), c0 && (a0.authorized = !0, s0.emit(bo.AUTHORIZED));
            })(i0);
          else {
            if (r0.type === So.OTP && o0.isOriginator)
              return void function(s0, a0) {
                var c0;
                const { state: l0 } = s0;
                s0.emit(bo.OTP, a0.otpAnswer), "6.6".localeCompare(((c0 = l0.walletInfo) === null || c0 === void 0 ? void 0 : c0.version) || "") === 1 && s0.emit(bo.SDK_RPC_CALL, { method: mo.ETH_REQUESTACCOUNTS, params: [] });
              }(i0, r0);
            r0.type === So.AUTHORIZED && o0.isOriginator && function(s0) {
              const { state: a0 } = s0;
              a0.authorized = !0, s0.emit(bo.AUTHORIZED);
            }(i0);
          }
          i0.emit(bo.MESSAGE, r0);
        }
      else
        (function(s0, a0) {
          var c0;
          const { state: l0 } = s0;
          (c0 = l0.communicationLayer) === null || c0 === void 0 || c0.sendMessage({ type: So.WALLET_INFO, walletInfo: l0.walletInfo }), l0.originatorInfo = a0.originatorInfo || a0.originator, s0.emit(bo.CLIENTS_READY, { isOriginator: l0.isOriginator, originatorInfo: l0.originatorInfo }), l0.paused = !1;
        })(i0, r0);
    }(n0, t0);
  };
}
function Vo(t0) {
  return () => {
    const { state: e0 } = t0;
    io.RemoteCommunication("[RemoteCommunication: handleSocketReconnectEvent()] on 'socket_reconnect' -- reset key exchange status / set ready to false"), e0.ready = !1, e0.authorized = !1, yo(e0), t0.emitServiceStatusEvent({ context: "socket_reconnect" });
  };
}
function Go(t0) {
  return () => {
    const { state: e0 } = t0;
    io.RemoteCommunication("[RemoteCommunication: handleSocketDisconnectedEvent()] on 'socket_Disconnected' set ready to false"), e0.ready = !1;
  };
}
function Yo(t0) {
  return () => a(this, void 0, void 0, function* () {
    var e0, n0, r0, i0, o0, s0, a0;
    const { state: c0 } = t0;
    io.RemoteCommunication(`[RemoteCommunication: handleFullPersistenceEvent()] context=${c0.context}`), t0.state.ready = !0, t0.state.clientsConnected = !0, t0.state.authorized = !0, t0.state.relayPersistence = !0, (e0 = t0.state.communicationLayer) === null || e0 === void 0 || e0.getKeyExchange().setKeysExchanged(!0), t0.emit(bo.KEYS_EXCHANGED, { keysExchanged: !0, isOriginator: !0 }), t0.emit(bo.AUTHORIZED), t0.emit(bo.CLIENTS_READY), t0.emit(bo.CHANNEL_PERSISTENCE);
    try {
      c0.channelConfig = Object.assign(Object.assign({}, c0.channelConfig), { localKey: (n0 = c0.communicationLayer) === null || n0 === void 0 ? void 0 : n0.getKeyExchange().getKeyInfo().ecies.private, otherKey: (r0 = c0.communicationLayer) === null || r0 === void 0 ? void 0 : r0.getKeyExchange().getOtherPublicKey(), channelId: (i0 = c0.channelId) !== null && i0 !== void 0 ? i0 : "", validUntil: (s0 = (o0 = c0.channelConfig) === null || o0 === void 0 ? void 0 : o0.validUntil) !== null && s0 !== void 0 ? s0 : po, relayPersistence: !0 }), yield (a0 = c0.storageManager) === null || a0 === void 0 ? void 0 : a0.persistChannelConfig(c0.channelConfig);
    } catch {
    }
  });
}
function Zo({ communicationLayerPreference: t0, otherPublicKey: e0, reconnect: n0, ecies: r0, communicationServerUrl: i0 = ho, instance: o0 }) {
  var s0, a0, c0, l0, u0, d0, h0, g0, w0, y0, E0;
  const { state: b0 } = o0;
  if (io.RemoteCommunication("[initCommunicationLayer()] ", JSON.stringify(b0, null, 2)), t0 !== Do.SOCKET)
    throw new Error("Invalid communication protocol");
  b0.communicationLayer = new $o({ communicationLayerPreference: t0, otherPublicKey: e0, reconnect: n0, transports: b0.transports, communicationServerUrl: i0, context: b0.context, ecies: r0, logging: b0.logging, remote: o0 });
  let O0 = typeof document < "u" && document.URL || "", S0 = typeof document < "u" && document.title || "";
  !((s0 = b0.dappMetadata) === null || s0 === void 0) && s0.url && (O0 = b0.dappMetadata.url), !((a0 = b0.dappMetadata) === null || a0 === void 0) && a0.name && (S0 = b0.dappMetadata.name);
  const k0 = (d0 = (l0 = (c0 = b0.dappMetadata) === null || c0 === void 0 ? void 0 : c0.name) !== null && l0 !== void 0 ? l0 : (u0 = b0.dappMetadata) === null || u0 === void 0 ? void 0 : u0.url) !== null && d0 !== void 0 ? d0 : "N/A", D0 = typeof window < "u" && window.location !== void 0 && (h0 = window.location.hostname) !== null && h0 !== void 0 ? h0 : k0, z0 = { url: O0, title: S0, source: (g0 = b0.dappMetadata) === null || g0 === void 0 ? void 0 : g0.source, dappId: D0, icon: ((w0 = b0.dappMetadata) === null || w0 === void 0 ? void 0 : w0.iconUrl) || ((y0 = b0.dappMetadata) === null || y0 === void 0 ? void 0 : y0.base64Icon), platform: b0.platformType, apiVersion: uo.version, connector: (E0 = b0.dappMetadata) === null || E0 === void 0 ? void 0 : E0.connector };
  b0.originatorInfo = z0;
  const G0 = { [bo.AUTHORIZED]: jo(o0), [bo.MESSAGE]: Wo(o0), [bo.CHANNEL_PERSISTENCE]: Yo(o0), [bo.CLIENTS_CONNECTED]: Ho(o0, t0), [bo.KEYS_EXCHANGED]: qo(o0, t0), [bo.SOCKET_DISCONNECTED]: Go(o0), [bo.SOCKET_RECONNECT]: Vo(o0), [bo.CLIENTS_DISCONNECTED]: Fo(o0), [bo.KEY_INFO]: () => {
  }, [bo.CHANNEL_CREATED]: Uo(o0), [bo.CLIENTS_WAITING]: zo(o0), [bo.RPC_UPDATE]: (K0) => {
    o0.emit(bo.RPC_UPDATE, K0);
  } };
  for (const [K0, U0] of Object.entries(G0))
    try {
      b0.communicationLayer.on(K0, U0);
    } catch {
    }
}
function Jo(t0) {
  return a(this, arguments, void 0, function* ({ options: e0, instance: n0 }) {
    const { state: r0 } = n0;
    return io.RemoteCommunication(`[RemoteCommunication: disconnect()] channel=${r0.channelId}`, e0), new Promise((i0, o0) => {
      var s0, a0, c0, l0, u0, d0;
      e0?.terminate ? (n0.state.ready && co({ id: (s0 = n0.state.channelId) !== null && s0 !== void 0 ? s0 : "", event: _o.TERMINATED }, n0.state.communicationServerUrl).catch((h0) => {
      }), r0.ready = !1, r0.paused = !1, (a0 = r0.storageManager) === null || a0 === void 0 || a0.terminate((c0 = r0.channelId) !== null && c0 !== void 0 ? c0 : ""), n0.state.terminated = !0, e0.sendMessage ? !((l0 = r0.communicationLayer) === null || l0 === void 0) && l0.getKeyInfo().keysExchanged && n0.state.communicationLayer && Ro(n0.state.communicationLayer, { type: So.TERMINATE }).then(() => {
        i0(!0);
      }).catch((h0) => {
        o0(h0);
      }) : i0(!0), r0.authorized = !1, r0.relayPersistence = !1, r0.channelId = v4(), e0.channelId = r0.channelId, r0.channelConfig = void 0, r0.originatorConnectStarted = !1, (u0 = r0.communicationLayer) === null || u0 === void 0 || u0.disconnect(e0), n0.setConnectionStatus(vo.TERMINATED)) : ((d0 = r0.communicationLayer) === null || d0 === void 0 || d0.disconnect(e0), n0.setConnectionStatus(vo.DISCONNECTED), i0(!0));
    });
  });
}
(Do || (Do = {})).SOCKET = "socket", function(t0) {
  t0.NonBrowser = "nodejs", t0.MetaMaskMobileWebview = "in-app-browser", t0.DesktopWeb = "web-desktop", t0.MobileWeb = "web-mobile", t0.ReactNative = "react-native";
}(Bo || (Bo = {}));
class Xo extends eventemitter2Exports.EventEmitter2 {
  constructor(e0) {
    super(), this.state = { ready: !1, authorized: !1, isOriginator: !1, terminated: !1, protocolVersion: 1, paused: !1, deeplinkProtocolAvailable: !1, platformType: "metamask-mobile", analytics: !1, reconnection: !1, originatorInfoSent: !1, communicationServerUrl: ho, context: "", persist: !1, clientsConnected: !1, sessionDuration: po, originatorConnectStarted: !1, debug: !1, _connectionStatus: vo.DISCONNECTED }, this._options = e0;
    const { platformType: n0, communicationLayerPreference: r0, otherPublicKey: i0, reconnect: o0, walletInfo: s0, dappMetadata: a0, protocolVersion: c0, transports: l0, context: u0, relayPersistence: d0, ecies: h0, analytics: g0 = !1, storage: w0, sdkVersion: y0, communicationServerUrl: E0 = ho, logging: b0, autoConnect: O0 = { timeout: go } } = e0;
    this.state.otherPublicKey = i0, this.state.dappMetadata = a0, this.state.walletInfo = s0, this.state.transports = l0, this.state.platformType = n0, this.state.analytics = g0, this.state.protocolVersion = c0 ?? 1, this.state.isOriginator = !i0, this.state.relayPersistence = d0, this.state.communicationServerUrl = E0, this.state.context = u0, this.state.terminated = !1, this.state.sdkVersion = y0, this.setMaxListeners(50), this.setConnectionStatus(vo.DISCONNECTED), w0?.duration && (this.state.sessionDuration = po), this.state.storageOptions = w0, this.state.autoConnectOptions = O0, this.state.debug = b0?.remoteLayer === !0, b0?.remoteLayer === !0 && t.enable("RemoteCommunication:Layer"), b0?.serviceLayer === !0 && t.enable("SocketService:Layer"), b0?.eciesLayer === !0 && t.enable("ECIES:Layer"), b0?.keyExchangeLayer === !0 && t.enable("KeyExchange:Layer"), this.state.logging = b0, w0?.storageManager && (this.state.storageManager = w0.storageManager), io.RemoteCommunication(`[RemoteCommunication: constructor()] protocolVersion=${c0} relayPersistence=${d0} isOriginator=${this.state.isOriginator} communicationLayerPreference=${r0} otherPublicKey=${i0} reconnect=${o0}`), this.state.isOriginator || Zo({ communicationLayerPreference: r0, otherPublicKey: i0, reconnect: o0, ecies: h0, communicationServerUrl: E0, instance: this }), this.emitServiceStatusEvent({ context: "constructor" });
  }
  initFromDappStorage() {
    return a(this, void 0, void 0, function* () {
      var e0;
      if (this.state.storageManager) {
        const n0 = yield this.state.storageManager.getPersistedChannelConfig({});
        n0 && (this.state.channelConfig = n0, this.state.channelId = n0.channelId, this.state.deeplinkProtocolAvailable = (e0 = n0.deeplinkProtocolAvailable) !== null && e0 !== void 0 && e0, n0.relayPersistence && (this.state.authorized = !0, this.state.ready = !0, this.setConnectionStatus(vo.LINKED), yield this.connectToChannel({ channelId: n0.channelId })));
      }
      Zo({ communicationLayerPreference: Do.SOCKET, otherPublicKey: this.state.otherPublicKey, reconnect: this._options.reconnect, ecies: this._options.ecies, communicationServerUrl: this.state.communicationServerUrl, instance: this });
    });
  }
  originatorSessionConnect() {
    return a(this, void 0, void 0, function* () {
      return yield function(e0) {
        return a(this, void 0, void 0, function* () {
          var n0;
          const { state: r0 } = e0;
          if (!r0.storageManager)
            return void io.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] no storage manager defined - skip");
          const i0 = yield r0.storageManager.getPersistedChannelConfig({});
          if (io.RemoteCommunication(`[RemoteCommunication: originatorSessionConnect()] autoStarted=${r0.originatorConnectStarted} channelConfig`, i0), (n0 = r0.communicationLayer) === null || n0 === void 0 ? void 0 : n0.isConnected())
            return io.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] socket already connected - skip"), i0;
          if (i0) {
            if (i0.validUntil > Date.now())
              return r0.channelConfig = i0, r0.originatorConnectStarted = !0, r0.channelId = i0?.channelId, r0.reconnection = !0, i0;
            io.RemoteCommunication("[RemoteCommunication: autoConnect()] Session has expired");
          }
          r0.originatorConnectStarted = !1;
        });
      }(this);
    });
  }
  generateChannelIdConnect() {
    return a(this, void 0, void 0, function* () {
      return function(e0) {
        return a(this, void 0, void 0, function* () {
          var n0, r0, i0, o0, s0, a0;
          if (!e0.communicationLayer)
            throw new Error("communication layer not initialized");
          if (e0.ready)
            throw new Error("Channel already connected");
          if (e0.channelId && (!((n0 = e0.communicationLayer) === null || n0 === void 0) && n0.isConnected()))
            return e0.channelConfig = Object.assign(Object.assign({}, e0.channelConfig), { channelId: e0.channelId, validUntil: Date.now() + e0.sessionDuration }), (r0 = e0.storageManager) === null || r0 === void 0 || r0.persistChannelConfig(e0.channelConfig), { channelId: e0.channelId, privKey: (o0 = (i0 = e0.communicationLayer) === null || i0 === void 0 ? void 0 : i0.getKeyInfo()) === null || o0 === void 0 ? void 0 : o0.ecies.private, pubKey: (a0 = (s0 = e0.communicationLayer) === null || s0 === void 0 ? void 0 : s0.getKeyInfo()) === null || a0 === void 0 ? void 0 : a0.ecies.public };
          io.RemoteCommunication("[RemoteCommunication: generateChannelId()]");
          const c0 = yield e0.communicationLayer.createChannel();
          io.RemoteCommunication("[RemoteCommunication: generateChannelId()] channel created", c0);
          const l0 = Object.assign(Object.assign({}, e0.channelConfig), { channelId: c0.channelId, localKey: c0.privKey, validUntil: Date.now() + e0.sessionDuration });
          return e0.channelId = c0.channelId, e0.channelConfig = l0, { channelId: e0.channelId, pubKey: c0.pubKey, privKey: c0.privKey };
        });
      }(this.state);
    });
  }
  clean() {
    return yo(this.state);
  }
  connectToChannel({ channelId: e0, withKeyExchange: n0, authorized: r0 }) {
    return function(i0) {
      return a(this, arguments, void 0, function* ({ channelId: o0, withKeyExchange: s0, authorized: a0, state: c0 }) {
        var l0, u0, d0;
        if (!validate$1(o0))
          throw io.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${c0.context} invalid channel channelId=${o0}`), new Error(`Invalid channel ${o0}`);
        if (io.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${c0.context} channelId=${o0} withKeyExchange=${s0}`), (l0 = c0.communicationLayer) === null || l0 === void 0 ? void 0 : l0.isConnected())
          return void io.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${c0.context} already connected - interrupt connection.`);
        c0.channelId = o0, yield (u0 = c0.communicationLayer) === null || u0 === void 0 ? void 0 : u0.connectToChannel({ channelId: o0, authorized: a0, withKeyExchange: s0 });
        const h0 = Object.assign(Object.assign({}, c0.channelConfig), { channelId: o0, validUntil: Date.now() + c0.sessionDuration });
        c0.channelConfig = h0, (d0 = c0.storageManager) === null || d0 === void 0 || d0.persistChannelConfig(h0);
      });
    }({ channelId: e0, authorized: r0, withKeyExchange: n0, state: this.state });
  }
  sendMessage(e0) {
    return function(n0, r0) {
      return a(this, void 0, void 0, function* () {
        var i0, o0;
        const { state: s0 } = n0;
        io.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${s0.context} paused=${s0.paused} ready=${s0.ready} relayPersistence=${s0.relayPersistence} authorized=${s0.authorized} socket=${(i0 = s0.communicationLayer) === null || i0 === void 0 ? void 0 : i0.isConnected()} clientsConnected=${s0.clientsConnected} status=${s0._connectionStatus}`, r0), s0.relayPersistence || s0.ready && (!((o0 = s0.communicationLayer) === null || o0 === void 0) && o0.isConnected()) && s0.clientsConnected || (io.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${s0.context}  SKIP message waiting for MM mobile readiness.`), yield new Promise((a0) => {
          n0.once(bo.CLIENTS_READY, a0);
        }), io.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${s0.context}  AFTER SKIP / READY -- sending pending message`));
        try {
          return yield function(c0, l0) {
            return a(this, void 0, void 0, function* () {
              return new Promise((u0) => {
                var d0;
                const { state: h0 } = c0;
                io.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${h0.context} ready=${h0.ready} authorized=${h0.authorized} method=${l0.method}`), !h0.isOriginator || h0.authorized || h0.relayPersistence ? (d0 = h0.communicationLayer) === null || d0 === void 0 || d0.sendMessage(l0).then((g0) => {
                  u0(g0);
                }).catch((g0) => {
                  u0(!1);
                }) : c0.once(bo.AUTHORIZED, () => {
                  var g0;
                  io.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${h0.context}  AFTER SKIP / AUTHORIZED -- sending pending message`), (g0 = h0.communicationLayer) === null || g0 === void 0 || g0.sendMessage(l0).then((w0) => {
                    u0(w0);
                  }).catch((w0) => {
                    u0(!1);
                  });
                });
              });
            });
          }(n0, r0);
        } catch (a0) {
          throw a0;
        }
      });
    }(this, e0);
  }
  testStorage() {
    return a(this, void 0, void 0, function* () {
      return function(e0) {
        return a(this, void 0, void 0, function* () {
          var n0;
          const r0 = yield (n0 = e0.storageManager) === null || n0 === void 0 ? void 0 : n0.getPersistedChannelConfig();
          io.RemoteCommunication("[RemoteCommunication: testStorage()] res", r0);
        });
      }(this.state);
    });
  }
  hasDeeplinkProtocol() {
    return this.state.deeplinkProtocolAvailable;
  }
  getChannelConfig() {
    return this.state.channelConfig;
  }
  isReady() {
    return this.state.ready;
  }
  isConnected() {
    var e0;
    return (e0 = this.state.communicationLayer) === null || e0 === void 0 ? void 0 : e0.isConnected();
  }
  isAuthorized() {
    return this.state.authorized;
  }
  isPaused() {
    return this.state.paused;
  }
  getCommunicationLayer() {
    return this.state.communicationLayer;
  }
  ping() {
    return a(this, void 0, void 0, function* () {
      var e0;
      io.RemoteCommunication(`[RemoteCommunication: ping()] channel=${this.state.channelId}`), yield (e0 = this.state.communicationLayer) === null || e0 === void 0 ? void 0 : e0.ping();
    });
  }
  testLogger() {
    io.RemoteCommunication(`testLogger() channel=${this.state.channelId}`), io.SocketService(`testLogger() channel=${this.state.channelId}`), io.Ecies(`testLogger() channel=${this.state.channelId}`), io.KeyExchange(`testLogger() channel=${this.state.channelId}`);
  }
  keyCheck() {
    var e0;
    io.RemoteCommunication(`[RemoteCommunication: keyCheck()] channel=${this.state.channelId}`), (e0 = this.state.communicationLayer) === null || e0 === void 0 || e0.keyCheck();
  }
  setConnectionStatus(e0) {
    this.state._connectionStatus !== e0 && (this.state._connectionStatus = e0, this.emit(bo.CONNECTION_STATUS, e0), this.emitServiceStatusEvent({ context: "setConnectionStatus" }));
  }
  emitServiceStatusEvent(e0 = {}) {
    this.emit(bo.SERVICE_STATUS, this.getServiceStatus());
  }
  getConnectionStatus() {
    return this.state._connectionStatus;
  }
  getServiceStatus() {
    return { originatorInfo: this.state.originatorInfo, keyInfo: this.getKeyInfo(), connectionStatus: this.state._connectionStatus, channelConfig: this.state.channelConfig, channelId: this.state.channelId };
  }
  getKeyInfo() {
    var e0;
    return (e0 = this.state.communicationLayer) === null || e0 === void 0 ? void 0 : e0.getKeyInfo();
  }
  resetKeys() {
    var e0;
    (e0 = this.state.communicationLayer) === null || e0 === void 0 || e0.resetKeys();
  }
  setOtherPublicKey(e0) {
    var n0;
    const r0 = (n0 = this.state.communicationLayer) === null || n0 === void 0 ? void 0 : n0.getKeyExchange();
    if (!r0)
      throw new Error("KeyExchange is not initialized.");
    r0.getOtherPublicKey() !== e0 && r0.setOtherPublicKey(e0);
  }
  pause() {
    return a(this, void 0, void 0, function* () {
      var e0;
      io.RemoteCommunication(`[RemoteCommunication: pause()] channel=${this.state.channelId}`), yield (e0 = this.state.communicationLayer) === null || e0 === void 0 ? void 0 : e0.pause(), this.setConnectionStatus(vo.PAUSED);
    });
  }
  getVersion() {
    return uo.version;
  }
  hasRelayPersistence() {
    var e0;
    return (e0 = this.state.relayPersistence) !== null && e0 !== void 0 && e0;
  }
  resume() {
    return a(this, void 0, void 0, function* () {
      return function(e0) {
        return a(this, void 0, void 0, function* () {
          var n0;
          const { state: r0 } = e0;
          io.RemoteCommunication(`[RemoteCommunication: resume()] channel=${r0.channelId}`), yield (n0 = r0.communicationLayer) === null || n0 === void 0 ? void 0 : n0.resume(), e0.setConnectionStatus(vo.LINKED);
        });
      }(this);
    });
  }
  encrypt(e0) {
    var n0, r0, i0;
    const o0 = (n0 = this.state.communicationLayer) === null || n0 === void 0 ? void 0 : n0.getKeyExchange(), s0 = o0?.getOtherPublicKey();
    if (!s0)
      throw new Error("KeyExchange not completed");
    return (i0 = (r0 = this.state.communicationLayer) === null || r0 === void 0 ? void 0 : r0.state.eciesInstance) === null || i0 === void 0 ? void 0 : i0.encrypt(e0, s0);
  }
  decrypt(e0) {
    var n0, r0, i0;
    if (!(!((n0 = this.state.communicationLayer) === null || n0 === void 0) && n0.state.eciesInstance))
      throw new Error("ECIES instance is not initialized");
    return (i0 = (r0 = this.state.communicationLayer) === null || r0 === void 0 ? void 0 : r0.state.eciesInstance) === null || i0 === void 0 ? void 0 : i0.decrypt(e0);
  }
  getChannelId() {
    return this.state.channelId;
  }
  getRPCMethodTracker() {
    var e0;
    return (e0 = this.state.communicationLayer) === null || e0 === void 0 ? void 0 : e0.getRPCMethodTracker();
  }
  reject({ channelId: e0 }) {
    return function(n0) {
      return a(this, arguments, void 0, function* ({ channelId: r0, state: i0 }) {
        var o0, s0, a0;
        if (!validate$1(r0))
          throw io.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${i0.context} invalid channel channelId=${r0}`), new Error(`Invalid channel ${r0}`);
        if (i0.isOriginator)
          return void io.RemoteCommunication(`[RemoteCommunication: reject()] context=${i0.context} isOriginator=${i0.isOriginator} channelId=${r0}`);
        const { socket: c0 } = (s0 = (o0 = i0.communicationLayer) === null || o0 === void 0 ? void 0 : o0.state) !== null && s0 !== void 0 ? s0 : {};
        c0?.connected || (io.RemoteCommunication(`[RemoteCommunication: reject()] context=${i0.context} socket already connected`), c0?.connect()), co(Object.assign(Object.assign({ id: r0, event: _o.REJECTED }, i0.originatorInfo), { sdkVersion: i0.sdkVersion, commLayerVersion: uo.version, walletVersion: (a0 = i0.walletInfo) === null || a0 === void 0 ? void 0 : a0.version }), i0.communicationServerUrl).catch((l0) => {
        }), yield new Promise((l0, u0) => {
          c0?.emit(bo.REJECTED, { channelId: r0 }, (d0, h0) => {
            io.RemoteCommunication(`[RemoteCommunication: reject()] context=${i0.context} socket=${c0?.id}`, { error: d0, response: h0 }), d0 ? u0(d0) : l0(h0);
          });
        });
      });
    }({ channelId: e0, state: this.state });
  }
  disconnect(e0) {
    return a(this, void 0, void 0, function* () {
      return Jo({ options: e0, instance: this });
    });
  }
}
(function(t0) {
  t0.RENEW = "renew", t0.LINK = "link";
})(Ko || (Ko = {}));
var Qo = "ERC721", es = "ERC1155", ts = { errors: { disconnected: () => "MetaMask: Disconnected from chain. Attempting to connect.", permanentlyDisconnected: () => "MetaMask: Disconnected from MetaMask background. Page reload required.", sendSiteMetadata: () => "MetaMask: Failed to send site metadata. This is an internal error, please report this bug.", unsupportedSync: (t0) => `MetaMask: The MetaMask Ethereum provider does not support synchronous methods like ${t0} without a callback parameter.`, invalidDuplexStream: () => "Must provide a Node.js-style duplex stream.", invalidNetworkParams: () => "MetaMask: Received invalid network parameters. Please report this bug.", invalidRequestArgs: () => "Expected a single, non-array, object argument.", invalidRequestMethod: () => "'args.method' must be a non-empty string.", invalidRequestParams: () => "'args.params' must be an object or array if provided.", invalidLoggerObject: () => "'args.logger' must be an object if provided.", invalidLoggerMethod: (t0) => `'args.logger' must include required method '${t0}'.` }, info: { connected: (t0) => `MetaMask: Connected to chain with ID "${t0}".` }, warnings: { chainIdDeprecation: `MetaMask: 'ethereum.chainId' is deprecated and may be removed in the future. Please use the 'eth_chainId' RPC method instead.
For more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23`, networkVersionDeprecation: `MetaMask: 'ethereum.networkVersion' is deprecated and may be removed in the future. Please use the 'net_version' RPC method instead.
For more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23`, selectedAddressDeprecation: `MetaMask: 'ethereum.selectedAddress' is deprecated and may be removed in the future. Please use the 'eth_accounts' RPC method instead.
For more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23`, enableDeprecation: `MetaMask: 'ethereum.enable()' is deprecated and may be removed in the future. Please use the 'eth_requestAccounts' RPC method instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1102`, sendDeprecation: `MetaMask: 'ethereum.send(...)' is deprecated and may be removed in the future. Please use 'ethereum.sendAsync(...)' or 'ethereum.request(...)' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193`, events: { close: `MetaMask: The event 'close' is deprecated and may be removed in the future. Please use 'disconnect' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193#disconnect`, data: `MetaMask: The event 'data' is deprecated and will be removed in the future. Use 'message' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193#message`, networkChanged: `MetaMask: The event 'networkChanged' is deprecated and may be removed in the future. Use 'chainChanged' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193#chainchanged`, notification: `MetaMask: The event 'notification' is deprecated and may be removed in the future. Use 'message' instead.
For more information, see: https://eips.ethereum.org/EIPS/eip-1193#message` }, rpc: { ethDecryptDeprecation: `MetaMask: The RPC method 'eth_decrypt' is deprecated and may be removed in the future.
For more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686`, ethGetEncryptionPublicKeyDeprecation: `MetaMask: The RPC method 'eth_getEncryptionPublicKey' is deprecated and may be removed in the future.
For more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686`, walletWatchAssetNFTExperimental: `MetaMask: The RPC method 'wallet_watchAsset' is experimental for ERC721/ERC1155 assets and may change in the future.
For more information, see: https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-1.md and https://github.com/MetaMask/metamask-improvement-proposals/blob/main/PROCESS-GUIDE.md#proposal-lifecycle` }, experimentalMethods: "MetaMask: 'ethereum._metamask' exposes non-standard, experimental methods. They may be removed or changed without warning." } };
function ns(t0) {
  const e0 = { ethDecryptDeprecation: !1, ethGetEncryptionPublicKeyDeprecation: !1, walletWatchAssetNFTExperimental: !1 };
  return (n0, r0, i0) => {
    e0.ethDecryptDeprecation || n0.method !== "eth_decrypt" ? e0.ethGetEncryptionPublicKeyDeprecation || n0.method !== "eth_getEncryptionPublicKey" ? !e0.walletWatchAssetNFTExperimental && n0.method === "wallet_watchAsset" && [Qo, es].includes(n0.params?.type || "") && (t0.warn(ts.warnings.rpc.walletWatchAssetNFTExperimental), e0.walletWatchAssetNFTExperimental = !0) : (t0.warn(ts.warnings.rpc.ethGetEncryptionPublicKeyDeprecation), e0.ethGetEncryptionPublicKeyDeprecation = !0) : (t0.warn(ts.warnings.rpc.ethDecryptDeprecation), e0.ethDecryptDeprecation = !0), i0();
  };
}
var rs = 4294967295, is$1 = Math.floor(Math.random() * rs);
function os() {
  return (t0, e0, n0, r0) => {
    const i0 = t0.id, o0 = is$1 = (is$1 + 1) % rs;
    t0.id = o0, e0.id = o0, n0((s0) => {
      t0.id = i0, e0.id = i0, s0();
    });
  };
}
var ss = (t0, e0, n0) => {
  if (!e0.has(t0))
    throw TypeError("Cannot " + n0);
}, as = (t0, e0, n0) => (ss(t0, e0, "read from private field"), n0 ? n0.call(t0) : e0.get(t0)), cs = (t0, e0, n0) => {
  if (e0.has(t0))
    throw TypeError("Cannot add the same private member more than once");
  e0 instanceof WeakSet ? e0.add(t0) : e0.set(t0, n0);
}, ls = (t0, e0, n0, r0) => (ss(t0, e0, "write to private field"), e0.set(t0, n0), n0), ds = (t0, e0, n0) => (ss(t0, e0, "access private method"), n0), us = { invalidInput: -32e3, resourceNotFound: -32001, resourceUnavailable: -32002, transactionRejected: -32003, methodNotSupported: -32004, limitExceeded: -32005, parse: -32700, invalidRequest: -32600, methodNotFound: -32601, invalidParams: -32602, internal: -32603 }, hs = { "-32700": { standard: "JSON RPC 2.0", message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text." }, "-32600": { standard: "JSON RPC 2.0", message: "The JSON sent is not a valid Request object." }, "-32601": { standard: "JSON RPC 2.0", message: "The method does not exist / is not available." }, "-32602": { standard: "JSON RPC 2.0", message: "Invalid method parameter(s)." }, "-32603": { standard: "JSON RPC 2.0", message: "Internal JSON-RPC error." }, "-32000": { standard: "EIP-1474", message: "Invalid input." }, "-32001": { standard: "EIP-1474", message: "Resource not found." }, "-32002": { standard: "EIP-1474", message: "Resource unavailable." }, "-32003": { standard: "EIP-1474", message: "Transaction rejected." }, "-32004": { standard: "EIP-1474", message: "Method not supported." }, "-32005": { standard: "EIP-1474", message: "Request limit exceeded." }, 4001: { standard: "EIP-1193", message: "User rejected the request." }, 4100: { standard: "EIP-1193", message: "The requested account and/or method has not been authorized by the user." }, 4200: { standard: "EIP-1193", message: "The requested method is not supported by this Ethereum provider." }, 4900: { standard: "EIP-1193", message: "The provider is disconnected from all chains." }, 4901: { standard: "EIP-1193", message: "The provider is disconnected from the specified chain." } };
function fs(t0) {
  return !!t0 && typeof t0 == "object" && !Array.isArray(t0);
}
var ps = (t0, e0) => Object.hasOwnProperty.call(t0, e0);
class gs extends TypeError {
  constructor(e0, n0) {
    let r0;
    const { message: i0, explanation: o0, ...s0 } = e0, { path: a0 } = e0, c0 = a0.length === 0 ? i0 : `At path: ${a0.join(".")} -- ${i0}`;
    super(o0 ?? c0), o0 != null && (this.cause = c0), Object.assign(this, s0), this.name = this.constructor.name, this.failures = () => r0 ?? (r0 = [e0, ...n0()]);
  }
}
function ms(t0) {
  return typeof t0 == "object" && t0 != null;
}
function ys(t0) {
  return typeof t0 == "symbol" ? t0.toString() : typeof t0 == "string" ? JSON.stringify(t0) : `${t0}`;
}
function vs(t0, e0, n0, r0) {
  if (t0 === !0)
    return;
  t0 === !1 ? t0 = {} : typeof t0 == "string" && (t0 = { message: t0 });
  const { path: i0, branch: o0 } = e0, { type: s0 } = n0, { refinement: a0, message: c0 = `Expected a value of type \`${s0}\`${a0 ? ` with refinement \`${a0}\`` : ""}, but received: \`${ys(r0)}\`` } = t0;
  return { value: r0, type: s0, refinement: a0, key: i0[i0.length - 1], path: i0, branch: o0, ...t0, message: c0 };
}
function* bs(t0, e0, n0, r0) {
  (function(i0) {
    return ms(i0) && typeof i0[Symbol.iterator] == "function";
  })(t0) || (t0 = [t0]);
  for (const i0 of t0) {
    const o0 = vs(i0, e0, n0, r0);
    o0 && (yield o0);
  }
}
function* ws(t0, e0, n0 = {}) {
  const { path: r0 = [], branch: i0 = [t0], coerce: o0 = !1, mask: s0 = !1 } = n0, a0 = { path: r0, branch: i0 };
  if (o0 && (t0 = e0.coercer(t0, a0), s0 && e0.type !== "type" && ms(e0.schema) && ms(t0) && !Array.isArray(t0)))
    for (const l0 in t0)
      e0.schema[l0] === void 0 && delete t0[l0];
  let c0 = "valid";
  for (const l0 of e0.validator(t0, a0))
    l0.explanation = n0.message, c0 = "not_valid", yield [l0, void 0];
  for (let [l0, u0, d0] of e0.entries(t0, a0)) {
    const h0 = ws(u0, d0, { path: l0 === void 0 ? r0 : [...r0, l0], branch: l0 === void 0 ? i0 : [...i0, u0], coerce: o0, mask: s0, message: n0.message });
    for (const g0 of h0)
      g0[0] ? (c0 = g0[0].refinement != null ? "not_refined" : "not_valid", yield [g0[0], void 0]) : o0 && (u0 = g0[1], l0 === void 0 ? t0 = u0 : t0 instanceof Map ? t0.set(l0, u0) : t0 instanceof Set ? t0.add(u0) : ms(t0) && (u0 !== void 0 || l0 in t0) && (t0[l0] = u0));
  }
  if (c0 !== "not_valid")
    for (const l0 of e0.refiner(t0, a0))
      l0.explanation = n0.message, c0 = "not_refined", yield [l0, void 0];
  c0 === "valid" && (yield [void 0, t0]);
}
class Es {
  constructor(e0) {
    const { type: n0, schema: r0, validator: i0, refiner: o0, coercer: s0 = (c0) => c0, entries: a0 = function* () {
    } } = e0;
    this.type = n0, this.schema = r0, this.entries = a0, this.coercer = s0, this.validator = i0 ? (c0, l0) => bs(i0(c0, l0), l0, this, c0) : () => [], this.refiner = o0 ? (c0, l0) => bs(o0(c0, l0), l0, this, c0) : () => [];
  }
  assert(e0, n0) {
    return Ss(e0, this, n0);
  }
  create(e0, n0) {
    return _s(e0, this, n0);
  }
  is(e0) {
    return Cs(e0, this);
  }
  mask(e0, n0) {
    return function(r0, i0, o0) {
      const s0 = ks(r0, i0, { coerce: !0, mask: !0, message: o0 });
      if (s0[0])
        throw s0[0];
      return s0[1];
    }(e0, this, n0);
  }
  validate(e0, n0 = {}) {
    return ks(e0, this, n0);
  }
}
function Ss(t0, e0, n0) {
  const r0 = ks(t0, e0, { message: n0 });
  if (r0[0])
    throw r0[0];
}
function _s(t0, e0, n0) {
  const r0 = ks(t0, e0, { coerce: !0, message: n0 });
  if (r0[0])
    throw r0[0];
  return r0[1];
}
function Cs(t0, e0) {
  return !ks(t0, e0)[0];
}
function ks(t0, e0, n0 = {}) {
  const r0 = ws(t0, e0, n0), i0 = function(o0) {
    const { done: s0, value: a0 } = o0.next();
    return s0 ? void 0 : a0;
  }(r0);
  return i0[0] ? [new gs(i0[0], function* () {
    for (const s0 of r0)
      s0[0] && (yield s0[0]);
  }), void 0] : [void 0, i0[1]];
}
function xs(t0, e0) {
  return new Es({ type: t0, schema: null, validator: e0 });
}
function Ms(t0) {
  let e0;
  return new Es({ type: "lazy", schema: null, *entries(n0, r0) {
    e0 ?? (e0 = t0()), yield* e0.entries(n0, r0);
  }, validator: (n0, r0) => (e0 ?? (e0 = t0()), e0.validator(n0, r0)), coercer: (n0, r0) => (e0 ?? (e0 = t0()), e0.coercer(n0, r0)), refiner: (n0, r0) => (e0 ?? (e0 = t0()), e0.refiner(n0, r0)) });
}
function As(t0) {
  return new Es({ type: "array", schema: t0, *entries(e0) {
    if (t0 && Array.isArray(e0))
      for (const [n0, r0] of e0.entries())
        yield [n0, r0, t0];
  }, coercer: (e0) => Array.isArray(e0) ? e0.slice() : e0, validator: (e0) => Array.isArray(e0) || `Expected an array value, but received: ${ys(e0)}` });
}
function Is(t0) {
  const e0 = ys(t0), n0 = typeof t0;
  return new Es({ type: "literal", schema: n0 === "string" || n0 === "number" || n0 === "boolean" ? t0 : null, validator: (r0) => r0 === t0 || `Expected the literal \`${e0}\`, but received: ${ys(r0)}` });
}
function Rs() {
  return xs("number", (t0) => typeof t0 == "number" && !isNaN(t0) || `Expected a number, but received: ${ys(t0)}`);
}
function Ps(t0) {
  const e0 = t0 ? Object.keys(t0) : [], n0 = xs("never", () => !1);
  return new Es({ type: "object", schema: t0 || null, *entries(r0) {
    if (t0 && ms(r0)) {
      const i0 = new Set(Object.keys(r0));
      for (const o0 of e0)
        i0.delete(o0), yield [o0, r0[o0], t0[o0]];
      for (const o0 of i0)
        yield [o0, r0[o0], n0];
    }
  }, validator: (r0) => ms(r0) || `Expected an object, but received: ${ys(r0)}`, coercer: (r0) => ms(r0) ? { ...r0 } : r0 });
}
function Ts(t0) {
  return new Es({ ...t0, validator: (e0, n0) => e0 === void 0 || t0.validator(e0, n0), refiner: (e0, n0) => e0 === void 0 || t0.refiner(e0, n0) });
}
function Os(t0, e0) {
  return new Es({ type: "record", schema: null, *entries(n0) {
    if (ms(n0))
      for (const r0 in n0) {
        const i0 = n0[r0];
        yield [r0, r0, t0], yield [r0, i0, e0];
      }
  }, validator: (n0) => ms(n0) || `Expected an object, but received: ${ys(n0)}` });
}
function Ls() {
  return xs("string", (t0) => typeof t0 == "string" || `Expected a string, but received: ${ys(t0)}`);
}
function Ns(t0) {
  const e0 = t0.map((n0) => n0.type).join(" | ");
  return new Es({ type: "union", schema: null, coercer(n0) {
    for (const r0 of t0) {
      const [i0, o0] = r0.validate(n0, { coerce: !0 });
      if (!i0)
        return o0;
    }
    return n0;
  }, validator(n0, r0) {
    const i0 = [];
    for (const o0 of t0) {
      const [...s0] = ws(n0, o0, r0), [a0] = s0;
      if (!a0[0])
        return [];
      for (const [c0] of s0)
        c0 && i0.push(c0);
    }
    return [`Expected the value to satisfy a union of \`${e0}\`, but received: ${ys(n0)}`, ...i0];
  } });
}
function $s(t0) {
  return function(e0) {
    return function(n0) {
      return typeof n0 == "object" && n0 !== null && "message" in n0;
    }(e0) && typeof e0.message == "string" ? e0.message : e0 == null ? "" : String(e0);
  }(t0).replace(/\.$/u, "");
}
function Ds(t0, e0) {
  return n0 = t0, typeof n0?.prototype?.constructor?.name == "string" ? new t0({ message: e0 }) : t0({ message: e0 });
  var n0;
}
var Bs = class extends Error {
  constructor(t0) {
    super(t0.message), this.code = "ERR_ASSERTION";
  }
};
function Ks() {
  throw new Error("setTimeout has not been defined");
}
function js() {
  throw new Error("clearTimeout has not been defined");
}
var Us = Ks, Hs = js;
function Fs(t0) {
  if (Us === setTimeout)
    return setTimeout(t0, 0);
  if ((Us === Ks || !Us) && setTimeout)
    return Us = setTimeout, setTimeout(t0, 0);
  try {
    return Us(t0, 0);
  } catch {
    try {
      return Us.call(null, t0, 0);
    } catch {
      return Us.call(this, t0, 0);
    }
  }
}
typeof c.setTimeout == "function" && (Us = setTimeout), typeof c.clearTimeout == "function" && (Hs = clearTimeout);
var zs, qs = [], Ws = !1, Vs = -1;
function Gs() {
  Ws && zs && (Ws = !1, zs.length ? qs = zs.concat(qs) : Vs = -1, qs.length && Ys());
}
function Ys() {
  if (!Ws) {
    var t0 = Fs(Gs);
    Ws = !0;
    for (var e0 = qs.length; e0; ) {
      for (zs = qs, qs = []; ++Vs < e0; )
        zs && zs[Vs].run();
      Vs = -1, e0 = qs.length;
    }
    zs = null, Ws = !1, function(n0) {
      if (Hs === clearTimeout)
        return clearTimeout(n0);
      if ((Hs === js || !Hs) && clearTimeout)
        return Hs = clearTimeout, clearTimeout(n0);
      try {
        return Hs(n0);
      } catch {
        try {
          return Hs.call(null, n0);
        } catch {
          return Hs.call(this, n0);
        }
      }
    }(t0);
  }
}
function Zs(t0, e0) {
  this.fun = t0, this.array = e0;
}
Zs.prototype.run = function() {
  this.fun.apply(null, this.array);
};
function Js() {
}
var Xs = Js, Qs = Js, ea = Js, ta = Js, na = Js, ra = Js, ia = Js, oa = c.performance || {}, sa = oa.now || oa.mozNow || oa.msNow || oa.oNow || oa.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
}, aa = /* @__PURE__ */ new Date(), ca = { nextTick: function(t0) {
  var e0 = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var n0 = 1; n0 < arguments.length; n0++)
      e0[n0 - 1] = arguments[n0];
  qs.push(new Zs(t0, e0)), qs.length !== 1 || Ws || Fs(Ys);
}, title: "browser", browser: !0, env: {}, argv: [], version: "", versions: {}, on: Xs, addListener: Qs, once: ea, off: ta, removeListener: na, removeAllListeners: ra, emit: ia, binding: function(t0) {
  throw new Error("process.binding is not supported");
}, cwd: function() {
  return "/";
}, chdir: function(t0) {
  throw new Error("process.chdir is not supported");
}, umask: function() {
  return 0;
}, hrtime: function(t0) {
  var e0 = 1e-3 * sa.call(oa), n0 = Math.floor(e0), r0 = Math.floor(e0 % 1 * 1e9);
  return t0 && (n0 -= t0[0], (r0 -= t0[1]) < 0 && (n0--, r0 += 1e9)), [n0, r0];
}, platform: "browser", release: {}, config: {}, uptime: function() {
  return (/* @__PURE__ */ new Date() - aa) / 1e3;
} }, la = (t0) => Ps(t0);
function da({ path: t0, branch: e0 }) {
  const n0 = t0[t0.length - 1];
  return ps(e0[e0.length - 2], n0);
}
function ua(t0) {
  return new Es({ ...t0, type: `optional ${t0.type}`, validator: (e0, n0) => !da(n0) || t0.validator(e0, n0), refiner: (e0, n0) => !da(n0) || t0.refiner(e0, n0) });
}
var ha, fa, pa, ga = Ns([Is(null), xs("boolean", (t0) => typeof t0 == "boolean"), xs("finite number", (t0) => Cs(t0, Rs()) && Number.isFinite(t0)), Ls(), As(Ms(() => ga)), Os(Ls(), Ms(() => ga))]), ma = (ha = ga, fa = xs("any", () => !0), pa = (t0) => (function(e0, n0, r0 = "Assertion failed", i0 = Bs) {
  try {
    Ss(e0, n0);
  } catch (o0) {
    throw Ds(i0, `${r0}: ${$s(o0)}.`);
  }
}(t0, ga), JSON.parse(JSON.stringify(t0, (e0, n0) => {
  if (e0 !== "__proto__" && e0 !== "constructor")
    return n0;
}))), new Es({ ...ha, coercer: (t0, e0) => Cs(t0, fa) ? ha.coercer(pa(t0, e0), e0) : ha.coercer(t0, e0) }));
function ya(t0) {
  try {
    return function(e0) {
      _s(e0, ma);
    }(t0), !0;
  } catch {
    return !1;
  }
}
var va = Is("2.0"), ba = function(t0) {
  return new Es({ ...t0, validator: (e0, n0) => e0 === null || t0.validator(e0, n0), refiner: (e0, n0) => e0 === null || t0.refiner(e0, n0) });
}(Ns([Rs(), Ls()])), wa = la({ code: xs("integer", (t0) => typeof t0 == "number" && !isNaN(t0) && Number.isInteger(t0) || `Expected an integer, but received: ${ys(t0)}`), message: Ls(), data: ua(ma), stack: ua(Ls()) }), Ea = Ns([Os(Ls(), ma), As(ma)]), Sa = la({ id: ba, jsonrpc: va, method: Ls(), params: ua(Ea) }), _a = la({ jsonrpc: va, method: Ls(), params: ua(Ea) });
function Ca(t0) {
  return Cs(t0, Sa);
}
function ka(t0) {
  return Cs(t0, wa);
}
Ps({ id: ba, jsonrpc: va, result: Ts(xs("unknown", () => !0)), error: Ts(wa) }), Ns([la({ id: ba, jsonrpc: va, result: ma }), la({ id: ba, jsonrpc: va, error: wa })]);
var xa = us.internal, Ma = "Unspecified error message. This is a bug, please report it.", Aa = { code: xa, message: Ra(xa) }, Ia = "Unspecified server error.";
function Ra(t0, e0 = Ma) {
  if (function(n0) {
    return Number.isInteger(n0);
  }(t0)) {
    const n0 = t0.toString();
    if (ps(hs, n0))
      return hs[n0].message;
    if (function(r0) {
      return r0 >= -32099 && r0 <= -32e3;
    }(t0))
      return Ia;
  }
  return e0;
}
function Pa(t0, { fallbackError: e0 = Aa, shouldIncludeStack: n0 = !0 } = {}) {
  if (!ka(e0))
    throw new Error("Must provide fallback error with integer number code and string message.");
  const r0 = function(i0, o0) {
    if (i0 && typeof i0 == "object" && "serialize" in i0 && typeof i0.serialize == "function")
      return i0.serialize();
    if (ka(i0))
      return i0;
    const s0 = Ta(i0);
    return { ...o0, data: { cause: s0 } };
  }(t0, e0);
  return n0 || delete r0.stack, r0;
}
function Ta(t0) {
  return Array.isArray(t0) ? t0.map((e0) => ya(e0) ? e0 : fs(e0) ? Oa(e0) : null) : fs(t0) ? Oa(t0) : ya(t0) ? t0 : null;
}
function Oa(t0) {
  return Object.getOwnPropertyNames(t0).reduce((e0, n0) => {
    const r0 = t0[n0];
    return ya(r0) && (e0[n0] = r0), e0;
  }, {});
}
var La = ja;
ja.default = ja, ja.stable = za, ja.stableStringify = za;
var Na = "[...]", $a = "[Circular]", Da = [], Ba = [];
function Ka() {
  return { depthLimit: Number.MAX_SAFE_INTEGER, edgesLimit: Number.MAX_SAFE_INTEGER };
}
function ja(t0, e0, n0, r0) {
  var i0;
  r0 === void 0 && (r0 = Ka()), Ha(t0, "", 0, [], void 0, 0, r0);
  try {
    i0 = Ba.length === 0 ? JSON.stringify(t0, e0, n0) : JSON.stringify(t0, Wa(e0), n0);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; Da.length !== 0; ) {
      var o0 = Da.pop();
      o0.length === 4 ? Object.defineProperty(o0[0], o0[1], o0[3]) : o0[0][o0[1]] = o0[2];
    }
  }
  return i0;
}
function Ua(t0, e0, n0, r0) {
  var i0 = Object.getOwnPropertyDescriptor(r0, n0);
  i0.get !== void 0 ? i0.configurable ? (Object.defineProperty(r0, n0, { value: t0 }), Da.push([r0, n0, e0, i0])) : Ba.push([e0, n0, t0]) : (r0[n0] = t0, Da.push([r0, n0, e0]));
}
function Ha(t0, e0, n0, r0, i0, o0, s0) {
  var a0;
  if (o0 += 1, typeof t0 == "object" && t0 !== null) {
    for (a0 = 0; a0 < r0.length; a0++)
      if (r0[a0] === t0)
        return void Ua($a, t0, e0, i0);
    if (s0.depthLimit !== void 0 && o0 > s0.depthLimit || s0.edgesLimit !== void 0 && n0 + 1 > s0.edgesLimit)
      return void Ua(Na, t0, e0, i0);
    if (r0.push(t0), Array.isArray(t0))
      for (a0 = 0; a0 < t0.length; a0++)
        Ha(t0[a0], a0, a0, r0, t0, o0, s0);
    else {
      var c0 = Object.keys(t0);
      for (a0 = 0; a0 < c0.length; a0++) {
        var l0 = c0[a0];
        Ha(t0[l0], l0, a0, r0, t0, o0, s0);
      }
    }
    r0.pop();
  }
}
function Fa(t0, e0) {
  return t0 < e0 ? -1 : t0 > e0 ? 1 : 0;
}
function za(t0, e0, n0, r0) {
  r0 === void 0 && (r0 = Ka());
  var i0, o0 = qa(t0, "", 0, [], void 0, 0, r0) || t0;
  try {
    i0 = Ba.length === 0 ? JSON.stringify(o0, e0, n0) : JSON.stringify(o0, Wa(e0), n0);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; Da.length !== 0; ) {
      var s0 = Da.pop();
      s0.length === 4 ? Object.defineProperty(s0[0], s0[1], s0[3]) : s0[0][s0[1]] = s0[2];
    }
  }
  return i0;
}
function qa(t0, e0, n0, r0, i0, o0, s0) {
  var a0;
  if (o0 += 1, typeof t0 == "object" && t0 !== null) {
    for (a0 = 0; a0 < r0.length; a0++)
      if (r0[a0] === t0)
        return void Ua($a, t0, e0, i0);
    try {
      if (typeof t0.toJSON == "function")
        return;
    } catch {
      return;
    }
    if (s0.depthLimit !== void 0 && o0 > s0.depthLimit || s0.edgesLimit !== void 0 && n0 + 1 > s0.edgesLimit)
      return void Ua(Na, t0, e0, i0);
    if (r0.push(t0), Array.isArray(t0))
      for (a0 = 0; a0 < t0.length; a0++)
        qa(t0[a0], a0, a0, r0, t0, o0, s0);
    else {
      var c0 = {}, l0 = Object.keys(t0).sort(Fa);
      for (a0 = 0; a0 < l0.length; a0++) {
        var u0 = l0[a0];
        qa(t0[u0], u0, a0, r0, t0, o0, s0), c0[u0] = t0[u0];
      }
      if (i0 === void 0)
        return c0;
      Da.push([i0, e0, t0]), i0[e0] = c0;
    }
    r0.pop();
  }
}
function Wa(t0) {
  return t0 = t0 !== void 0 ? t0 : function(e0, n0) {
    return n0;
  }, function(e0, n0) {
    if (Ba.length > 0)
      for (var r0 = 0; r0 < Ba.length; r0++) {
        var i0 = Ba[r0];
        if (i0[1] === e0 && i0[0] === n0) {
          n0 = i0[2], Ba.splice(r0, 1);
          break;
        }
      }
    return t0.call(this, e0, n0);
  };
}
var Va = de$1(La), Ga = class extends Error {
  constructor(t0, e0, n0) {
    if (!Number.isInteger(t0))
      throw new Error('"code" must be an integer.');
    if (!e0 || typeof e0 != "string")
      throw new Error('"message" must be a non-empty string.');
    super(e0), this.code = t0, n0 !== void 0 && (this.data = n0);
  }
  serialize() {
    const t0 = { code: this.code, message: this.message };
    return this.data !== void 0 && (t0.data = this.data, function(e0) {
      if (typeof e0 != "object" || e0 === null)
        return !1;
      try {
        let n0 = e0;
        for (; Object.getPrototypeOf(n0) !== null; )
          n0 = Object.getPrototypeOf(n0);
        return Object.getPrototypeOf(e0) === n0;
      } catch {
        return !1;
      }
    }(this.data) && (t0.data.cause = Ta(this.data.cause))), this.stack && (t0.stack = this.stack), t0;
  }
  toString() {
    return Va(this.serialize(), Ya, 2);
  }
};
function Ya(t0, e0) {
  if (e0 !== "[Circular]")
    return e0;
}
var Za = (t0) => Ja(us.invalidRequest, t0);
function Ja(t0, e0) {
  const [n0, r0] = function(i0) {
    if (i0) {
      if (typeof i0 == "string")
        return [i0];
      if (typeof i0 == "object" && !Array.isArray(i0)) {
        const { message: o0, data: s0 } = i0;
        if (o0 && typeof o0 != "string")
          throw new Error("Must specify string message.");
        return [o0 ?? void 0, s0];
      }
    }
    return [];
  }(e0);
  return new Ga(t0, n0 ?? Ra(t0), r0);
}
var Xa = {};
function Qa() {
}
function ec() {
  ec.init.call(this);
}
function tc(t0) {
  return t0._maxListeners === void 0 ? ec.defaultMaxListeners : t0._maxListeners;
}
function nc(t0, e0, n0, r0) {
  var i0, o0, s0;
  if (typeof n0 != "function")
    throw new TypeError('"listener" argument must be a function');
  if ((o0 = t0._events) ? (o0.newListener && (t0.emit("newListener", e0, n0.listener ? n0.listener : n0), o0 = t0._events), s0 = o0[e0]) : (o0 = t0._events = new Qa(), t0._eventsCount = 0), s0) {
    if (typeof s0 == "function" ? s0 = o0[e0] = r0 ? [n0, s0] : [s0, n0] : r0 ? s0.unshift(n0) : s0.push(n0), !s0.warned && (i0 = tc(t0)) && i0 > 0 && s0.length > i0) {
      s0.warned = !0;
      var a0 = new Error("Possible EventEmitter memory leak detected. " + s0.length + " " + e0 + " listeners added. Use emitter.setMaxListeners() to increase limit");
      a0.name = "MaxListenersExceededWarning", a0.emitter = t0, a0.type = e0, a0.count = s0.length, function(c0) {
        typeof console.warn == "function" ? console.warn(c0) : console.log(c0);
      }(a0);
    }
  } else
    s0 = o0[e0] = n0, ++t0._eventsCount;
  return t0;
}
function rc(t0, e0, n0) {
  var r0 = !1;
  function i0() {
    t0.removeListener(e0, i0), r0 || (r0 = !0, n0.apply(t0, arguments));
  }
  return i0.listener = n0, i0;
}
function ic(t0) {
  var e0 = this._events;
  if (e0) {
    var n0 = e0[t0];
    if (typeof n0 == "function")
      return 1;
    if (n0)
      return n0.length;
  }
  return 0;
}
function oc(t0, e0) {
  for (var n0 = new Array(e0); e0--; )
    n0[e0] = t0[e0];
  return n0;
}
Qa.prototype = /* @__PURE__ */ Object.create(null), ec.EventEmitter = ec, ec.usingDomains = !1, ec.prototype.domain = void 0, ec.prototype._events = void 0, ec.prototype._maxListeners = void 0, ec.defaultMaxListeners = 10, ec.init = function() {
  this.domain = null, ec.usingDomains && (void 0).active, this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = new Qa(), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, ec.prototype.setMaxListeners = function(t0) {
  if (typeof t0 != "number" || t0 < 0 || isNaN(t0))
    throw new TypeError('"n" argument must be a positive number');
  return this._maxListeners = t0, this;
}, ec.prototype.getMaxListeners = function() {
  return tc(this);
}, ec.prototype.emit = function(t0) {
  var e0, n0, r0, i0, o0, s0, a0, c0 = t0 === "error";
  if (s0 = this._events)
    c0 = c0 && s0.error == null;
  else if (!c0)
    return !1;
  if (a0 = this.domain, c0) {
    if (e0 = arguments[1], !a0) {
      if (e0 instanceof Error)
        throw e0;
      var l0 = new Error('Uncaught, unspecified "error" event. (' + e0 + ")");
      throw l0.context = e0, l0;
    }
    return e0 || (e0 = new Error('Uncaught, unspecified "error" event')), e0.domainEmitter = this, e0.domain = a0, e0.domainThrown = !1, a0.emit("error", e0), !1;
  }
  if (!(n0 = s0[t0]))
    return !1;
  var u0 = typeof n0 == "function";
  switch (r0 = arguments.length) {
    case 1:
      (function(d0, h0, g0) {
        if (h0)
          d0.call(g0);
        else
          for (var w0 = d0.length, y0 = oc(d0, w0), E0 = 0; E0 < w0; ++E0)
            y0[E0].call(g0);
      })(n0, u0, this);
      break;
    case 2:
      (function(d0, h0, g0, w0) {
        if (h0)
          d0.call(g0, w0);
        else
          for (var y0 = d0.length, E0 = oc(d0, y0), b0 = 0; b0 < y0; ++b0)
            E0[b0].call(g0, w0);
      })(n0, u0, this, arguments[1]);
      break;
    case 3:
      (function(d0, h0, g0, w0, y0) {
        if (h0)
          d0.call(g0, w0, y0);
        else
          for (var E0 = d0.length, b0 = oc(d0, E0), O0 = 0; O0 < E0; ++O0)
            b0[O0].call(g0, w0, y0);
      })(n0, u0, this, arguments[1], arguments[2]);
      break;
    case 4:
      (function(d0, h0, g0, w0, y0, E0) {
        if (h0)
          d0.call(g0, w0, y0, E0);
        else
          for (var b0 = d0.length, O0 = oc(d0, b0), S0 = 0; S0 < b0; ++S0)
            O0[S0].call(g0, w0, y0, E0);
      })(n0, u0, this, arguments[1], arguments[2], arguments[3]);
      break;
    default:
      for (i0 = new Array(r0 - 1), o0 = 1; o0 < r0; o0++)
        i0[o0 - 1] = arguments[o0];
      (function(d0, h0, g0, w0) {
        if (h0)
          d0.apply(g0, w0);
        else
          for (var y0 = d0.length, E0 = oc(d0, y0), b0 = 0; b0 < y0; ++b0)
            E0[b0].apply(g0, w0);
      })(n0, u0, this, i0);
  }
  return !0;
}, ec.prototype.addListener = function(t0, e0) {
  return nc(this, t0, e0, !1);
}, ec.prototype.on = ec.prototype.addListener, ec.prototype.prependListener = function(t0, e0) {
  return nc(this, t0, e0, !0);
}, ec.prototype.once = function(t0, e0) {
  if (typeof e0 != "function")
    throw new TypeError('"listener" argument must be a function');
  return this.on(t0, rc(this, t0, e0)), this;
}, ec.prototype.prependOnceListener = function(t0, e0) {
  if (typeof e0 != "function")
    throw new TypeError('"listener" argument must be a function');
  return this.prependListener(t0, rc(this, t0, e0)), this;
}, ec.prototype.removeListener = function(t0, e0) {
  var n0, r0, i0, o0, s0;
  if (typeof e0 != "function")
    throw new TypeError('"listener" argument must be a function');
  if (!(r0 = this._events))
    return this;
  if (!(n0 = r0[t0]))
    return this;
  if (n0 === e0 || n0.listener && n0.listener === e0)
    --this._eventsCount == 0 ? this._events = new Qa() : (delete r0[t0], r0.removeListener && this.emit("removeListener", t0, n0.listener || e0));
  else if (typeof n0 != "function") {
    for (i0 = -1, o0 = n0.length; o0-- > 0; )
      if (n0[o0] === e0 || n0[o0].listener && n0[o0].listener === e0) {
        s0 = n0[o0].listener, i0 = o0;
        break;
      }
    if (i0 < 0)
      return this;
    if (n0.length === 1) {
      if (n0[0] = void 0, --this._eventsCount == 0)
        return this._events = new Qa(), this;
      delete r0[t0];
    } else
      (function(a0, c0) {
        for (var l0 = c0, u0 = l0 + 1, d0 = a0.length; u0 < d0; l0 += 1, u0 += 1)
          a0[l0] = a0[u0];
        a0.pop();
      })(n0, i0);
    r0.removeListener && this.emit("removeListener", t0, s0 || e0);
  }
  return this;
}, ec.prototype.off = function(t0, e0) {
  return this.removeListener(t0, e0);
}, ec.prototype.removeAllListeners = function(t0) {
  var e0, n0;
  if (!(n0 = this._events))
    return this;
  if (!n0.removeListener)
    return arguments.length === 0 ? (this._events = new Qa(), this._eventsCount = 0) : n0[t0] && (--this._eventsCount == 0 ? this._events = new Qa() : delete n0[t0]), this;
  if (arguments.length === 0) {
    for (var r0, i0 = Object.keys(n0), o0 = 0; o0 < i0.length; ++o0)
      (r0 = i0[o0]) !== "removeListener" && this.removeAllListeners(r0);
    return this.removeAllListeners("removeListener"), this._events = new Qa(), this._eventsCount = 0, this;
  }
  if (typeof (e0 = n0[t0]) == "function")
    this.removeListener(t0, e0);
  else if (e0)
    do
      this.removeListener(t0, e0[e0.length - 1]);
    while (e0[0]);
  return this;
}, ec.prototype.listeners = function(t0) {
  var e0, n0, r0 = this._events;
  return n0 = r0 && (e0 = r0[t0]) ? typeof e0 == "function" ? [e0.listener || e0] : function(i0) {
    for (var o0 = new Array(i0.length), s0 = 0; s0 < o0.length; ++s0)
      o0[s0] = i0[s0].listener || i0[s0];
    return o0;
  }(e0) : [], n0;
}, ec.listenerCount = function(t0, e0) {
  return typeof t0.listenerCount == "function" ? t0.listenerCount(e0) : ic.call(t0, e0);
}, ec.prototype.listenerCount = ic, ec.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
var sc = ue$1(Object.freeze({ __proto__: null, EventEmitter: ec, default: ec }));
Object.defineProperty(Xa, "__esModule", { value: !0 });
const ac = sc;
function cc(t0, e0, n0) {
  try {
    Reflect.apply(t0, e0, n0);
  } catch (r0) {
    setTimeout(() => {
      throw r0;
    });
  }
}
let lc = class extends ac.EventEmitter {
  emit(t0, ...e0) {
    let n0 = t0 === "error";
    const r0 = this._events;
    if (r0 !== void 0)
      n0 = n0 && r0.error === void 0;
    else if (!n0)
      return !1;
    if (n0) {
      let o0;
      if (e0.length > 0 && ([o0] = e0), o0 instanceof Error)
        throw o0;
      const s0 = new Error("Unhandled error." + (o0 ? ` (${o0.message})` : ""));
      throw s0.context = o0, s0;
    }
    const i0 = r0[t0];
    if (i0 === void 0)
      return !1;
    if (typeof i0 == "function")
      cc(i0, this, e0);
    else {
      const o0 = i0.length, s0 = function(a0) {
        const c0 = a0.length, l0 = new Array(c0);
        for (let u0 = 0; u0 < c0; u0 += 1)
          l0[u0] = a0[u0];
        return l0;
      }(i0);
      for (let a0 = 0; a0 < o0; a0 += 1)
        cc(s0[a0], this, e0);
    }
    return !0;
  }
};
var dc, uc, hc, fc, pc, gc, mc, yc, vc, bc, wc, Ec, Sc, _c, Cc, kc, xc, Mc, Ac, Ic = Xa.default = lc, Rc = class fm extends Ic {
  constructor({ notificationHandler: e0 } = {}) {
    super(), cs(this, fc), cs(this, gc), cs(this, yc), cs(this, dc, !1), cs(this, uc, void 0), cs(this, hc, void 0), ls(this, uc, []), ls(this, hc, e0);
  }
  destroy() {
    as(this, uc).forEach((e0) => {
      "destroy" in e0 && typeof e0.destroy == "function" && e0.destroy();
    }), ls(this, uc, []), ls(this, dc, !0);
  }
  push(e0) {
    ds(this, fc, pc).call(this), as(this, uc).push(e0);
  }
  handle(e0, n0) {
    if (ds(this, fc, pc).call(this), n0 && typeof n0 != "function")
      throw new Error('"callback" must be a function if provided.');
    return Array.isArray(e0) ? n0 ? ds(this, gc, mc).call(this, e0, n0) : ds(this, gc, mc).call(this, e0) : n0 ? ds(this, yc, vc).call(this, e0, n0) : this._promiseHandle(e0);
  }
  asMiddleware() {
    return ds(this, fc, pc).call(this), async (e0, n0, r0, i0) => {
      var o0, s0;
      try {
        const [a0, c0, l0] = await ds(o0 = fm, Ec, Sc).call(o0, e0, n0, as(this, uc));
        return c0 ? (await ds(s0 = fm, kc, xc).call(s0, l0), i0(a0)) : r0(async (u0) => {
          var d0;
          try {
            await ds(d0 = fm, kc, xc).call(d0, l0);
          } catch (h0) {
            return u0(h0);
          }
          return u0();
        });
      } catch (a0) {
        return i0(a0);
      }
    };
  }
  async _promiseHandle(e0) {
    return new Promise((n0, r0) => {
      ds(this, yc, vc).call(this, e0, (i0, o0) => {
        i0 && o0 === void 0 ? r0(i0) : n0(o0);
      }).catch(r0);
    });
  }
};
dc = /* @__PURE__ */ new WeakMap(), uc = /* @__PURE__ */ new WeakMap(), hc = /* @__PURE__ */ new WeakMap(), fc = /* @__PURE__ */ new WeakSet(), pc = function() {
  if (as(this, dc))
    throw new Error("This engine is destroyed and can no longer be used.");
}, gc = /* @__PURE__ */ new WeakSet(), mc = async function(t0, e0) {
  try {
    if (t0.length === 0) {
      const r0 = [{ id: null, jsonrpc: "2.0", error: new Ga(us.invalidRequest, "Request batch must contain plain objects. Received an empty array") }];
      return e0 ? e0(null, r0) : r0;
    }
    const n0 = (await Promise.all(t0.map(this._promiseHandle.bind(this)))).filter((r0) => r0 !== void 0);
    return e0 ? e0(null, n0) : n0;
  } catch (n0) {
    if (e0)
      return e0(n0);
    throw n0;
  }
}, yc = /* @__PURE__ */ new WeakSet(), vc = async function(t0, e0) {
  var n0;
  if (!t0 || Array.isArray(t0) || typeof t0 != "object") {
    const s0 = new Ga(us.invalidRequest, "Requests must be plain objects. Received: " + typeof t0, { request: t0 });
    return e0(s0, { id: null, jsonrpc: "2.0", error: s0 });
  }
  if (typeof t0.method != "string") {
    const s0 = new Ga(us.invalidRequest, "Must specify a string method. Received: " + typeof t0.method, { request: t0 });
    return as(this, hc) && !Ca(t0) ? e0(null) : e0(s0, { id: t0.id ?? null, jsonrpc: "2.0", error: s0 });
  }
  if (as(this, hc) && Cs(t0, _a) && !Ca(t0)) {
    try {
      await as(this, hc).call(this, t0);
    } catch (s0) {
      return e0(s0);
    }
    return e0(null);
  }
  let r0 = null;
  const i0 = { ...t0 }, o0 = { id: i0.id, jsonrpc: i0.jsonrpc };
  try {
    await ds(n0 = Rc, bc, wc).call(n0, i0, o0, as(this, uc));
  } catch (s0) {
    r0 = s0;
  }
  return r0 && (delete o0.result, o0.error || (o0.error = Pa(r0))), e0(r0, o0);
}, bc = /* @__PURE__ */ new WeakSet(), wc = async function(t0, e0, n0) {
  var r0, i0, o0;
  const [s0, a0, c0] = await ds(r0 = Rc, Ec, Sc).call(r0, t0, e0, n0);
  if (ds(i0 = Rc, Mc, Ac).call(i0, t0, e0, a0), await ds(o0 = Rc, kc, xc).call(o0, c0), s0)
    throw s0;
}, Ec = /* @__PURE__ */ new WeakSet(), Sc = async function(t0, e0, n0) {
  var r0;
  const i0 = [];
  let o0 = null, s0 = !1;
  for (const a0 of n0)
    if ([o0, s0] = await ds(r0 = Rc, _c, Cc).call(r0, t0, e0, a0, i0), s0)
      break;
  return [o0, s0, i0.reverse()];
}, _c = /* @__PURE__ */ new WeakSet(), Cc = async function(t0, e0, n0, r0) {
  return new Promise((i0) => {
    const o0 = (a0) => {
      const c0 = a0 || e0.error;
      c0 && (e0.error = Pa(c0)), i0([c0, !0]);
    }, s0 = (a0) => {
      e0.error ? o0(e0.error) : (a0 && (typeof a0 != "function" && o0(new Ga(us.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof a0}" for request:
${Tc(t0)}`, { request: t0 })), r0.push(a0)), i0([null, !1]));
    };
    try {
      n0(t0, e0, s0, o0);
    } catch (a0) {
      o0(a0);
    }
  });
}, kc = /* @__PURE__ */ new WeakSet(), xc = async function(t0) {
  for (const e0 of t0)
    await new Promise((n0, r0) => {
      e0((i0) => i0 ? r0(i0) : n0());
    });
}, Mc = /* @__PURE__ */ new WeakSet(), Ac = function(t0, e0, n0) {
  if (!ps(e0, "result") && !ps(e0, "error"))
    throw new Ga(us.internal, `JsonRpcEngine: Response has no error or result for request:
${Tc(t0)}`, { request: t0 });
  if (!n0)
    throw new Ga(us.internal, `JsonRpcEngine: Nothing ended request:
${Tc(t0)}`, { request: t0 });
}, cs(Rc, bc), cs(Rc, Ec), cs(Rc, _c), cs(Rc, kc), cs(Rc, Mc);
var Pc = Rc;
function Tc(t0) {
  return JSON.stringify(t0, null, 2);
}
var Oc = Object.freeze(["eth_subscription"]), Lc = (t0 = console) => [os(), Nc(t0), ns(t0)];
function Nc(t0) {
  return (e0, n0, r0) => {
    typeof e0.method == "string" && e0.method || (n0.error = Za({ message: "The request 'method' must be a non-empty string.", data: e0 })), r0((i0) => {
      const { error: o0 } = n0;
      return o0 && t0.error(`MetaMask - RPC Error: ${o0.message}`, o0), i0();
    });
  };
}
var $c = (t0, e0, n0 = !0) => (r0, i0) => {
  r0 || i0.error ? e0(r0 || i0.error) : !n0 || Array.isArray(i0) ? t0(i0) : t0(i0.result);
}, Dc = (t0) => !!t0 && typeof t0 == "string" && t0.startsWith("0x"), Bc = () => {
};
async function Kc(t0, e0) {
  try {
    const n0 = await async function() {
      return { name: jc(window), icon: await Uc(window) };
    }();
    t0.handle({ jsonrpc: "2.0", id: 1, method: "metamask_sendDomainMetadata", params: n0 }, Bc);
  } catch (n0) {
    e0.error({ message: ts.errors.sendSiteMetadata(), originalError: n0 });
  }
}
function jc(t0) {
  const { document: e0 } = t0, n0 = e0.querySelector('head > meta[property="og:site_name"]');
  if (n0)
    return n0.content;
  const r0 = e0.querySelector('head > meta[name="title"]');
  return r0 ? r0.content : e0.title && e0.title.length > 0 ? e0.title : window.location.hostname;
}
async function Uc(t0) {
  const { document: e0 } = t0, n0 = e0.querySelectorAll('head > link[rel~="icon"]');
  for (const r0 of Array.from(n0))
    if (r0 && await Hc(r0.href))
      return r0.href;
  return null;
}
async function Hc(t0) {
  return new Promise((e0, n0) => {
    try {
      const r0 = document.createElement("img");
      r0.onload = () => e0(!0), r0.onerror = () => e0(!1), r0.src = t0;
    } catch (r0) {
      n0(r0);
    }
  });
}
var Fc = (t0, e0, n0) => {
  if (!e0.has(t0))
    throw TypeError("Cannot " + n0);
}, zc = (t0, e0, n0) => (Fc(t0, e0, "read from private field"), n0 ? n0.call(t0) : e0.get(t0)), qc = (t0, e0, n0) => {
  if (e0.has(t0))
    throw TypeError("Cannot add the same private member more than once");
  e0 instanceof WeakSet ? e0.add(t0) : e0.set(t0, n0);
}, Wc = (t0, e0, n0, r0) => (Fc(t0, e0, "write to private field"), e0.set(t0, n0), n0);
function Vc(t0, e0, n0) {
  try {
    Reflect.apply(t0, e0, n0);
  } catch (r0) {
    setTimeout(() => {
      throw r0;
    });
  }
}
class Gc extends ec {
  emit(e0, ...n0) {
    let r0 = e0 === "error";
    const i0 = this._events;
    if (i0 !== void 0)
      r0 = r0 && i0.error === void 0;
    else if (!r0)
      return !1;
    if (r0) {
      let s0;
      if (n0.length > 0 && ([s0] = n0), s0 instanceof Error)
        throw s0;
      const a0 = new Error("Unhandled error." + (s0 ? ` (${s0.message})` : ""));
      throw a0.context = s0, a0;
    }
    const o0 = i0[e0];
    if (o0 === void 0)
      return !1;
    if (typeof o0 == "function")
      Vc(o0, this, n0);
    else {
      const s0 = o0.length, a0 = function(c0) {
        const l0 = c0.length, u0 = new Array(l0);
        for (let d0 = 0; d0 < l0; d0 += 1)
          u0[d0] = c0[d0];
        return u0;
      }(o0);
      for (let c0 = 0; c0 < s0; c0 += 1)
        Vc(a0[c0], this, n0);
    }
    return !0;
  }
}
var Yc, Zc, Jc = function t0(e0, n0) {
  if (e0 === n0)
    return !0;
  if (e0 && n0 && typeof e0 == "object" && typeof n0 == "object") {
    if (e0.constructor !== n0.constructor)
      return !1;
    var r0, i0, o0;
    if (Array.isArray(e0)) {
      if ((r0 = e0.length) != n0.length)
        return !1;
      for (i0 = r0; i0-- != 0; )
        if (!t0(e0[i0], n0[i0]))
          return !1;
      return !0;
    }
    if (e0.constructor === RegExp)
      return e0.source === n0.source && e0.flags === n0.flags;
    if (e0.valueOf !== Object.prototype.valueOf)
      return e0.valueOf() === n0.valueOf();
    if (e0.toString !== Object.prototype.toString)
      return e0.toString() === n0.toString();
    if ((r0 = (o0 = Object.keys(e0)).length) !== Object.keys(n0).length)
      return !1;
    for (i0 = r0; i0-- != 0; )
      if (!Object.prototype.hasOwnProperty.call(n0, o0[i0]))
        return !1;
    for (i0 = r0; i0-- != 0; ) {
      var s0 = o0[i0];
      if (!t0(e0[s0], n0[s0]))
        return !1;
    }
    return !0;
  }
  return e0 != e0 && n0 != n0;
}, Xc = de$1(Jc), Qc = class Xm extends Gc {
  constructor({ logger: e0 = console, maxEventListeners: n0 = 100, rpcMiddleware: r0 = [] } = {}) {
    super(), qc(this, Yc, void 0), qc(this, Zc, void 0), this._log = e0, this.setMaxListeners(n0), this._state = { ...Xm._defaultState }, Wc(this, Zc, null), Wc(this, Yc, null), this._handleAccountsChanged = this._handleAccountsChanged.bind(this), this._handleConnect = this._handleConnect.bind(this), this._handleChainChanged = this._handleChainChanged.bind(this), this._handleDisconnect = this._handleDisconnect.bind(this), this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this), this._rpcRequest = this._rpcRequest.bind(this), this.request = this.request.bind(this);
    const i0 = new Pc();
    r0.forEach((o0) => i0.push(o0)), this._rpcEngine = i0;
  }
  get chainId() {
    return zc(this, Yc);
  }
  get selectedAddress() {
    return zc(this, Zc);
  }
  isConnected() {
    return this._state.isConnected;
  }
  async request(e0) {
    if (!e0 || typeof e0 != "object" || Array.isArray(e0))
      throw Za({ message: ts.errors.invalidRequestArgs(), data: e0 });
    const { method: n0, params: r0 } = e0;
    if (typeof n0 != "string" || n0.length === 0)
      throw Za({ message: ts.errors.invalidRequestMethod(), data: e0 });
    if (r0 !== void 0 && !Array.isArray(r0) && (typeof r0 != "object" || r0 === null))
      throw Za({ message: ts.errors.invalidRequestParams(), data: e0 });
    const i0 = r0 == null ? { method: n0 } : { method: n0, params: r0 };
    return new Promise((o0, s0) => {
      this._rpcRequest(i0, $c(o0, s0));
    });
  }
  _initializeState(e0) {
    if (this._state.initialized)
      throw new Error("Provider already initialized.");
    if (e0) {
      const { accounts: n0, chainId: r0, isUnlocked: i0, networkVersion: o0 } = e0;
      this._handleConnect(r0), this._handleChainChanged({ chainId: r0, networkVersion: o0 }), this._handleUnlockStateChanged({ accounts: n0, isUnlocked: i0 }), this._handleAccountsChanged(n0);
    }
    this._state.initialized = !0, this.emit("_initialized");
  }
  _rpcRequest(e0, n0) {
    let r0 = n0;
    return Array.isArray(e0) || (e0.jsonrpc || (e0.jsonrpc = "2.0"), e0.method !== "eth_accounts" && e0.method !== "eth_requestAccounts" || (r0 = (i0, o0) => {
      this._handleAccountsChanged(o0.result ?? [], e0.method === "eth_accounts"), n0(i0, o0);
    })), this._rpcEngine.handle(e0, r0);
  }
  _handleConnect(e0) {
    this._state.isConnected || (this._state.isConnected = !0, this.emit("connect", { chainId: e0 }), this._log.debug(ts.info.connected(e0)));
  }
  _handleDisconnect(e0, n0) {
    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !e0) {
      let r0;
      this._state.isConnected = !1, e0 ? (r0 = new Ga(1013, n0 ?? ts.errors.disconnected()), this._log.debug(r0)) : (r0 = new Ga(1011, n0 ?? ts.errors.permanentlyDisconnected()), this._log.error(r0), Wc(this, Yc, null), this._state.accounts = null, Wc(this, Zc, null), this._state.isUnlocked = !1, this._state.isPermanentlyDisconnected = !0), this.emit("disconnect", r0);
    }
  }
  _handleChainChanged({ chainId: e0 } = {}) {
    Dc(e0) ? (this._handleConnect(e0), e0 !== zc(this, Yc) && (Wc(this, Yc, e0), this._state.initialized && this.emit("chainChanged", zc(this, Yc)))) : this._log.error(ts.errors.invalidNetworkParams(), { chainId: e0 });
  }
  _handleAccountsChanged(e0, n0 = !1) {
    let r0 = e0;
    Array.isArray(e0) || (this._log.error("MetaMask: Received invalid accounts parameter. Please report this bug.", e0), r0 = []);
    for (const i0 of e0)
      if (typeof i0 != "string") {
        this._log.error("MetaMask: Received non-string account. Please report this bug.", e0), r0 = [];
        break;
      }
    if (!Xc(this._state.accounts, r0) && (n0 && this._state.accounts !== null && this._log.error("MetaMask: 'eth_accounts' unexpectedly updated accounts. Please report this bug.", r0), this._state.accounts = r0, zc(this, Zc) !== r0[0] && Wc(this, Zc, r0[0] || null), this._state.initialized)) {
      const i0 = [...r0];
      this.emit("accountsChanged", i0);
    }
  }
  _handleUnlockStateChanged({ accounts: e0, isUnlocked: n0 } = {}) {
    typeof n0 == "boolean" ? n0 !== this._state.isUnlocked && (this._state.isUnlocked = n0, this._handleAccountsChanged(e0 ?? [])) : this._log.error("MetaMask: Received invalid isUnlocked parameter. Please report this bug.");
  }
};
Yc = /* @__PURE__ */ new WeakMap(), Zc = /* @__PURE__ */ new WeakMap(), Qc._defaultState = { accounts: null, isConnected: !1, isUnlocked: !1, initialized: !1, isPermanentlyDisconnected: !1 };
var el, tl, nl = Qc, rl = { exports: {} };
function il() {
  return tl ? el : (tl = 1, el = sc.EventEmitter);
}
var ol, sl = ue$1(ce$1);
ol = typeof Object.create == "function" ? function(t0, e0) {
  t0.super_ = e0, t0.prototype = Object.create(e0.prototype, { constructor: { value: t0, enumerable: !1, writable: !0, configurable: !0 } });
} : function(t0, e0) {
  t0.super_ = e0;
  var n0 = function() {
  };
  n0.prototype = e0.prototype, t0.prototype = new n0(), t0.prototype.constructor = t0;
};
var al = Object.getOwnPropertyDescriptors || function(t0) {
  for (var e0 = Object.keys(t0), n0 = {}, r0 = 0; r0 < e0.length; r0++)
    n0[e0[r0]] = Object.getOwnPropertyDescriptor(t0, e0[r0]);
  return n0;
}, cl = /%[sdj%]/g;
function ll(t0) {
  if (!kl(t0)) {
    for (var e0 = [], n0 = 0; n0 < arguments.length; n0++)
      e0.push(pl(arguments[n0]));
    return e0.join(" ");
  }
  n0 = 1;
  for (var r0 = arguments, i0 = r0.length, o0 = String(t0).replace(cl, function(a0) {
    if (a0 === "%%")
      return "%";
    if (n0 >= i0)
      return a0;
    switch (a0) {
      case "%s":
        return String(r0[n0++]);
      case "%d":
        return Number(r0[n0++]);
      case "%j":
        try {
          return JSON.stringify(r0[n0++]);
        } catch {
          return "[Circular]";
        }
      default:
        return a0;
    }
  }), s0 = r0[n0]; n0 < i0; s0 = r0[++n0])
    Sl(s0) || !Il(s0) ? o0 += " " + s0 : o0 += " " + pl(s0);
  return o0;
}
function dl(t0, e0) {
  if (Ml(c.process))
    return function() {
      return dl(t0, e0).apply(this, arguments);
    };
  if (ca.noDeprecation === !0)
    return t0;
  var n0 = !1;
  return function() {
    if (!n0) {
      if (ca.throwDeprecation)
        throw new Error(e0);
      ca.traceDeprecation ? console.trace(e0) : console.error(e0), n0 = !0;
    }
    return t0.apply(this, arguments);
  };
}
var ul, hl = {};
function fl(t0) {
  return Ml(ul) && (ul = ca.env.NODE_DEBUG || ""), t0 = t0.toUpperCase(), !hl[t0] && (new RegExp("\\b" + t0 + "\\b", "i").test(ul) ? hl[t0] = function() {
    var e0 = ll.apply(null, arguments);
    console.error("%s %d: %s", t0, 0, e0);
  } : hl[t0] = function() {
  }), hl[t0];
}
function pl(t0, e0) {
  var n0 = { seen: [], stylize: ml };
  return arguments.length >= 3 && (n0.depth = arguments[2]), arguments.length >= 4 && (n0.colors = arguments[3]), El(e0) ? n0.showHidden = e0 : e0 && Kl(n0, e0), Ml(n0.showHidden) && (n0.showHidden = !1), Ml(n0.depth) && (n0.depth = 2), Ml(n0.colors) && (n0.colors = !1), Ml(n0.customInspect) && (n0.customInspect = !0), n0.colors && (n0.stylize = gl), yl(n0, t0, n0.depth);
}
function gl(t0, e0) {
  var n0 = pl.styles[e0];
  return n0 ? "\x1B[" + pl.colors[n0][0] + "m" + t0 + "\x1B[" + pl.colors[n0][1] + "m" : t0;
}
function ml(t0, e0) {
  return t0;
}
function yl(t0, e0, n0) {
  if (t0.customInspect && e0 && Tl(e0.inspect) && e0.inspect !== pl && (!e0.constructor || e0.constructor.prototype !== e0)) {
    var r0 = e0.inspect(n0, t0);
    return kl(r0) || (r0 = yl(t0, r0, n0)), r0;
  }
  var i0 = function(h0, g0) {
    if (Ml(g0))
      return h0.stylize("undefined", "undefined");
    if (kl(g0)) {
      var w0 = "'" + JSON.stringify(g0).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return h0.stylize(w0, "string");
    }
    if (Cl(g0))
      return h0.stylize("" + g0, "number");
    if (El(g0))
      return h0.stylize("" + g0, "boolean");
    if (Sl(g0))
      return h0.stylize("null", "null");
  }(t0, e0);
  if (i0)
    return i0;
  var o0 = Object.keys(e0), s0 = function(h0) {
    var g0 = {};
    return h0.forEach(function(w0, y0) {
      g0[w0] = !0;
    }), g0;
  }(o0);
  if (t0.showHidden && (o0 = Object.getOwnPropertyNames(e0)), Pl(e0) && (o0.indexOf("message") >= 0 || o0.indexOf("description") >= 0))
    return vl(e0);
  if (o0.length === 0) {
    if (Tl(e0)) {
      var a0 = e0.name ? ": " + e0.name : "";
      return t0.stylize("[Function" + a0 + "]", "special");
    }
    if (Al(e0))
      return t0.stylize(RegExp.prototype.toString.call(e0), "regexp");
    if (Rl(e0))
      return t0.stylize(Date.prototype.toString.call(e0), "date");
    if (Pl(e0))
      return vl(e0);
  }
  var c0, l0 = "", u0 = !1, d0 = ["{", "}"];
  return wl(e0) && (u0 = !0, d0 = ["[", "]"]), Tl(e0) && (l0 = " [Function" + (e0.name ? ": " + e0.name : "") + "]"), Al(e0) && (l0 = " " + RegExp.prototype.toString.call(e0)), Rl(e0) && (l0 = " " + Date.prototype.toUTCString.call(e0)), Pl(e0) && (l0 = " " + vl(e0)), o0.length !== 0 || u0 && e0.length != 0 ? n0 < 0 ? Al(e0) ? t0.stylize(RegExp.prototype.toString.call(e0), "regexp") : t0.stylize("[Object]", "special") : (t0.seen.push(e0), c0 = u0 ? function(h0, g0, w0, y0, E0) {
    for (var b0 = [], O0 = 0, S0 = g0.length; O0 < S0; ++O0)
      jl(g0, String(O0)) ? b0.push(bl(h0, g0, w0, y0, String(O0), !0)) : b0.push("");
    return E0.forEach(function(k0) {
      k0.match(/^\d+$/) || b0.push(bl(h0, g0, w0, y0, k0, !0));
    }), b0;
  }(t0, e0, n0, s0, o0) : o0.map(function(h0) {
    return bl(t0, e0, n0, s0, h0, u0);
  }), t0.seen.pop(), function(h0, g0, w0) {
    var y0 = h0.reduce(function(E0, b0) {
      return b0.indexOf(`
`), E0 + b0.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return y0 > 60 ? w0[0] + (g0 === "" ? "" : g0 + `
 `) + " " + h0.join(`,
  `) + " " + w0[1] : w0[0] + g0 + " " + h0.join(", ") + " " + w0[1];
  }(c0, l0, d0)) : d0[0] + l0 + d0[1];
}
function vl(t0) {
  return "[" + Error.prototype.toString.call(t0) + "]";
}
function bl(t0, e0, n0, r0, i0, o0) {
  var s0, a0, c0;
  if ((c0 = Object.getOwnPropertyDescriptor(e0, i0) || { value: e0[i0] }).get ? a0 = c0.set ? t0.stylize("[Getter/Setter]", "special") : t0.stylize("[Getter]", "special") : c0.set && (a0 = t0.stylize("[Setter]", "special")), jl(r0, i0) || (s0 = "[" + i0 + "]"), a0 || (t0.seen.indexOf(c0.value) < 0 ? (a0 = Sl(n0) ? yl(t0, c0.value, null) : yl(t0, c0.value, n0 - 1)).indexOf(`
`) > -1 && (a0 = o0 ? a0.split(`
`).map(function(l0) {
    return "  " + l0;
  }).join(`
`).substr(2) : `
` + a0.split(`
`).map(function(l0) {
    return "   " + l0;
  }).join(`
`)) : a0 = t0.stylize("[Circular]", "special")), Ml(s0)) {
    if (o0 && i0.match(/^\d+$/))
      return a0;
    (s0 = JSON.stringify("" + i0)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s0 = s0.substr(1, s0.length - 2), s0 = t0.stylize(s0, "name")) : (s0 = s0.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s0 = t0.stylize(s0, "string"));
  }
  return s0 + ": " + a0;
}
function wl(t0) {
  return Array.isArray(t0);
}
function El(t0) {
  return typeof t0 == "boolean";
}
function Sl(t0) {
  return t0 === null;
}
function _l(t0) {
  return t0 == null;
}
function Cl(t0) {
  return typeof t0 == "number";
}
function kl(t0) {
  return typeof t0 == "string";
}
function xl(t0) {
  return typeof t0 == "symbol";
}
function Ml(t0) {
  return t0 === void 0;
}
function Al(t0) {
  return Il(t0) && Nl(t0) === "[object RegExp]";
}
function Il(t0) {
  return typeof t0 == "object" && t0 !== null;
}
function Rl(t0) {
  return Il(t0) && Nl(t0) === "[object Date]";
}
function Pl(t0) {
  return Il(t0) && (Nl(t0) === "[object Error]" || t0 instanceof Error);
}
function Tl(t0) {
  return typeof t0 == "function";
}
function Ol(t0) {
  return t0 === null || typeof t0 == "boolean" || typeof t0 == "number" || typeof t0 == "string" || typeof t0 == "symbol" || t0 === void 0;
}
function Ll(t0) {
  return _.isBuffer(t0);
}
function Nl(t0) {
  return Object.prototype.toString.call(t0);
}
function $l(t0) {
  return t0 < 10 ? "0" + t0.toString(10) : t0.toString(10);
}
pl.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, pl.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
var Dl = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function Bl() {
  console.log("%s - %s", function() {
    var t0 = /* @__PURE__ */ new Date(), e0 = [$l(t0.getHours()), $l(t0.getMinutes()), $l(t0.getSeconds())].join(":");
    return [t0.getDate(), Dl[t0.getMonth()], e0].join(" ");
  }(), ll.apply(null, arguments));
}
function Kl(t0, e0) {
  if (!e0 || !Il(e0))
    return t0;
  for (var n0 = Object.keys(e0), r0 = n0.length; r0--; )
    t0[n0[r0]] = e0[n0[r0]];
  return t0;
}
function jl(t0, e0) {
  return Object.prototype.hasOwnProperty.call(t0, e0);
}
var Ul = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
function Hl(t0) {
  if (typeof t0 != "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (Ul && t0[Ul]) {
    var e0;
    if (typeof (e0 = t0[Ul]) != "function")
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    return Object.defineProperty(e0, Ul, { value: e0, enumerable: !1, writable: !1, configurable: !0 }), e0;
  }
  function e0() {
    for (var n0, r0, i0 = new Promise(function(a0, c0) {
      n0 = a0, r0 = c0;
    }), o0 = [], s0 = 0; s0 < arguments.length; s0++)
      o0.push(arguments[s0]);
    o0.push(function(a0, c0) {
      a0 ? r0(a0) : n0(c0);
    });
    try {
      t0.apply(this, o0);
    } catch (a0) {
      r0(a0);
    }
    return i0;
  }
  return Object.setPrototypeOf(e0, Object.getPrototypeOf(t0)), Ul && Object.defineProperty(e0, Ul, { value: e0, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(e0, al(t0));
}
function Fl(t0, e0) {
  if (!t0) {
    var n0 = new Error("Promise was rejected with a falsy value");
    n0.reason = t0, t0 = n0;
  }
  return e0(t0);
}
function zl(t0) {
  if (typeof t0 != "function")
    throw new TypeError('The "original" argument must be of type Function');
  function e0() {
    for (var n0 = [], r0 = 0; r0 < arguments.length; r0++)
      n0.push(arguments[r0]);
    var i0 = n0.pop();
    if (typeof i0 != "function")
      throw new TypeError("The last argument must be of type Function");
    var o0 = this, s0 = function() {
      return i0.apply(o0, arguments);
    };
    t0.apply(this, n0).then(function(a0) {
      ca.nextTick(s0.bind(null, null, a0));
    }, function(a0) {
      ca.nextTick(Fl.bind(null, a0, s0));
    });
  }
  return Object.setPrototypeOf(e0, Object.getPrototypeOf(t0)), Object.defineProperties(e0, al(t0)), e0;
}
Hl.custom = Ul;
var ql, Wl, Vl, Gl, Yl = { inherits: ol, _extend: Kl, log: Bl, isBuffer: Ll, isPrimitive: Ol, isFunction: Tl, isError: Pl, isDate: Rl, isObject: Il, isRegExp: Al, isUndefined: Ml, isSymbol: xl, isString: kl, isNumber: Cl, isNullOrUndefined: _l, isNull: Sl, isBoolean: El, isArray: wl, inspect: pl, deprecate: dl, format: ll, debuglog: fl, promisify: Hl, callbackify: zl }, Zl = ue$1(Object.freeze({ __proto__: null, _extend: Kl, callbackify: zl, debuglog: fl, default: Yl, deprecate: dl, format: ll, inherits: ol, inspect: pl, isArray: wl, isBoolean: El, isBuffer: Ll, isDate: Rl, isError: Pl, isFunction: Tl, isNull: Sl, isNullOrUndefined: _l, isNumber: Cl, isObject: Il, isPrimitive: Ol, isRegExp: Al, isString: kl, isSymbol: xl, isUndefined: Ml, log: Bl, promisify: Hl }));
function Jl() {
  if (Wl)
    return ql;
  function t0(c0, l0) {
    var u0 = Object.keys(c0);
    if (Object.getOwnPropertySymbols) {
      var d0 = Object.getOwnPropertySymbols(c0);
      l0 && (d0 = d0.filter(function(h0) {
        return Object.getOwnPropertyDescriptor(c0, h0).enumerable;
      })), u0.push.apply(u0, d0);
    }
    return u0;
  }
  function e0(c0) {
    for (var l0 = 1; l0 < arguments.length; l0++) {
      var u0 = arguments[l0] != null ? arguments[l0] : {};
      l0 % 2 ? t0(Object(u0), !0).forEach(function(d0) {
        n0(c0, d0, u0[d0]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(c0, Object.getOwnPropertyDescriptors(u0)) : t0(Object(u0)).forEach(function(d0) {
        Object.defineProperty(c0, d0, Object.getOwnPropertyDescriptor(u0, d0));
      });
    }
    return c0;
  }
  function n0(c0, l0, u0) {
    return (l0 = i0(l0)) in c0 ? Object.defineProperty(c0, l0, { value: u0, enumerable: !0, configurable: !0, writable: !0 }) : c0[l0] = u0, c0;
  }
  function r0(c0, l0, u0) {
    return l0 && function(d0, h0) {
      for (var g0 = 0; g0 < h0.length; g0++) {
        var w0 = h0[g0];
        w0.enumerable = w0.enumerable || !1, w0.configurable = !0, "value" in w0 && (w0.writable = !0), Object.defineProperty(d0, i0(w0.key), w0);
      }
    }(c0.prototype, l0), Object.defineProperty(c0, "prototype", { writable: !1 }), c0;
  }
  function i0(c0) {
    var l0 = function(u0, d0) {
      if (typeof u0 != "object" || u0 === null)
        return u0;
      var h0 = u0[Symbol.toPrimitive];
      if (h0 !== void 0) {
        var g0 = h0.call(u0, d0 || "default");
        if (typeof g0 != "object")
          return g0;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (d0 === "string" ? String : Number)(u0);
    }(c0, "string");
    return typeof l0 == "symbol" ? l0 : String(l0);
  }
  Wl = 1;
  var o0 = sl.Buffer, s0 = Zl.inspect, a0 = s0 && s0.custom || "inspect";
  return ql = function() {
    function c0() {
      (function(l0, u0) {
        if (!(l0 instanceof u0))
          throw new TypeError("Cannot call a class as a function");
      })(this, c0), this.head = null, this.tail = null, this.length = 0;
    }
    return r0(c0, [{ key: "push", value: function(l0) {
      var u0 = { data: l0, next: null };
      this.length > 0 ? this.tail.next = u0 : this.head = u0, this.tail = u0, ++this.length;
    } }, { key: "unshift", value: function(l0) {
      var u0 = { data: l0, next: this.head };
      this.length === 0 && (this.tail = u0), this.head = u0, ++this.length;
    } }, { key: "shift", value: function() {
      if (this.length !== 0) {
        var l0 = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, l0;
      }
    } }, { key: "clear", value: function() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function(l0) {
      if (this.length === 0)
        return "";
      for (var u0 = this.head, d0 = "" + u0.data; u0 = u0.next; )
        d0 += l0 + u0.data;
      return d0;
    } }, { key: "concat", value: function(l0) {
      if (this.length === 0)
        return o0.alloc(0);
      for (var u0, d0, h0, g0 = o0.allocUnsafe(l0 >>> 0), w0 = this.head, y0 = 0; w0; )
        u0 = w0.data, d0 = g0, h0 = y0, o0.prototype.copy.call(u0, d0, h0), y0 += w0.data.length, w0 = w0.next;
      return g0;
    } }, { key: "consume", value: function(l0, u0) {
      var d0;
      return l0 < this.head.data.length ? (d0 = this.head.data.slice(0, l0), this.head.data = this.head.data.slice(l0)) : d0 = l0 === this.head.data.length ? this.shift() : u0 ? this._getString(l0) : this._getBuffer(l0), d0;
    } }, { key: "first", value: function() {
      return this.head.data;
    } }, { key: "_getString", value: function(l0) {
      var u0 = this.head, d0 = 1, h0 = u0.data;
      for (l0 -= h0.length; u0 = u0.next; ) {
        var g0 = u0.data, w0 = l0 > g0.length ? g0.length : l0;
        if (w0 === g0.length ? h0 += g0 : h0 += g0.slice(0, l0), (l0 -= w0) === 0) {
          w0 === g0.length ? (++d0, u0.next ? this.head = u0.next : this.head = this.tail = null) : (this.head = u0, u0.data = g0.slice(w0));
          break;
        }
        ++d0;
      }
      return this.length -= d0, h0;
    } }, { key: "_getBuffer", value: function(l0) {
      var u0 = o0.allocUnsafe(l0), d0 = this.head, h0 = 1;
      for (d0.data.copy(u0), l0 -= d0.data.length; d0 = d0.next; ) {
        var g0 = d0.data, w0 = l0 > g0.length ? g0.length : l0;
        if (g0.copy(u0, u0.length - l0, 0, w0), (l0 -= w0) === 0) {
          w0 === g0.length ? (++h0, d0.next ? this.head = d0.next : this.head = this.tail = null) : (this.head = d0, d0.data = g0.slice(w0));
          break;
        }
        ++h0;
      }
      return this.length -= h0, u0;
    } }, { key: a0, value: function(l0, u0) {
      return s0(this, e0(e0({}, u0), {}, { depth: 0, customInspect: !1 }));
    } }]), c0;
  }(), ql;
}
function Xl() {
  if (Gl)
    return Vl;
  function t0(r0, i0) {
    n0(r0, i0), e0(r0);
  }
  function e0(r0) {
    r0._writableState && !r0._writableState.emitClose || r0._readableState && !r0._readableState.emitClose || r0.emit("close");
  }
  function n0(r0, i0) {
    r0.emit("error", i0);
  }
  return Gl = 1, Vl = { destroy: function(r0, i0) {
    var o0 = this, s0 = this._readableState && this._readableState.destroyed, a0 = this._writableState && this._writableState.destroyed;
    return s0 || a0 ? (i0 ? i0(r0) : r0 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, ca.nextTick(n0, this, r0)) : ca.nextTick(n0, this, r0)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(r0 || null, function(c0) {
      !i0 && c0 ? o0._writableState ? o0._writableState.errorEmitted ? ca.nextTick(e0, o0) : (o0._writableState.errorEmitted = !0, ca.nextTick(t0, o0, c0)) : ca.nextTick(t0, o0, c0) : i0 ? (ca.nextTick(e0, o0), i0(c0)) : ca.nextTick(e0, o0);
    }), this);
  }, undestroy: function() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }, errorOrDestroy: function(r0, i0) {
    var o0 = r0._readableState, s0 = r0._writableState;
    o0 && o0.autoDestroy || s0 && s0.autoDestroy ? r0.destroy(i0) : r0.emit("error", i0);
  } }, Vl;
}
var Ql = {}, ed, td, nd = {};
function rd(t0, e0, n0) {
  n0 || (n0 = Error);
  var r0 = function(i0) {
    var o0, s0;
    function a0(c0, l0, u0) {
      return i0.call(this, function(d0, h0, g0) {
        return typeof e0 == "string" ? e0 : e0(d0, h0, g0);
      }(c0, l0, u0)) || this;
    }
    return s0 = i0, (o0 = a0).prototype = Object.create(s0.prototype), o0.prototype.constructor = o0, o0.__proto__ = s0, a0;
  }(n0);
  r0.prototype.name = n0.name, r0.prototype.code = t0, nd[t0] = r0;
}
function id(t0, e0) {
  if (Array.isArray(t0)) {
    var n0 = t0.length;
    return t0 = t0.map(function(r0) {
      return String(r0);
    }), n0 > 2 ? "one of ".concat(e0, " ").concat(t0.slice(0, n0 - 1).join(", "), ", or ") + t0[n0 - 1] : n0 === 2 ? "one of ".concat(e0, " ").concat(t0[0], " or ").concat(t0[1]) : "of ".concat(e0, " ").concat(t0[0]);
  }
  return "of ".concat(e0, " ").concat(String(t0));
}
function od() {
  if (td)
    return ed;
  td = 1;
  var t0 = Ql.codes.ERR_INVALID_OPT_VALUE;
  return ed = { getHighWaterMark: function(e0, n0, r0, i0) {
    var o0 = function(s0, a0, c0) {
      return s0.highWaterMark != null ? s0.highWaterMark : a0 ? s0[c0] : null;
    }(n0, i0, r0);
    if (o0 != null) {
      if (!isFinite(o0) || Math.floor(o0) !== o0 || o0 < 0)
        throw new t0(i0 ? r0 : "highWaterMark", o0);
      return Math.floor(o0);
    }
    return e0.objectMode ? 16 : 16384;
  } };
}
rd("ERR_INVALID_OPT_VALUE", function(t0, e0) {
  return 'The value "' + e0 + '" is invalid for option "' + t0 + '"';
}, TypeError), rd("ERR_INVALID_ARG_TYPE", function(t0, e0, n0) {
  var r0, i0, o0;
  if (typeof e0 == "string" && (i0 = "not ", e0.substr(0, i0.length) === i0) ? (r0 = "must not be", e0 = e0.replace(/^not /, "")) : r0 = "must be", function(a0, c0, l0) {
    return (l0 === void 0 || l0 > a0.length) && (l0 = a0.length), a0.substring(l0 - c0.length, l0) === c0;
  }(t0, " argument"))
    o0 = "The ".concat(t0, " ").concat(r0, " ").concat(id(e0, "type"));
  else {
    var s0 = function(a0, c0, l0) {
      return typeof l0 != "number" && (l0 = 0), !(l0 + c0.length > a0.length) && a0.indexOf(c0, l0) !== -1;
    }(t0, ".") ? "property" : "argument";
    o0 = 'The "'.concat(t0, '" ').concat(s0, " ").concat(r0, " ").concat(id(e0, "type"));
  }
  return o0 += ". Received type ".concat(typeof n0);
}, TypeError), rd("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), rd("ERR_METHOD_NOT_IMPLEMENTED", function(t0) {
  return "The " + t0 + " method is not implemented";
}), rd("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), rd("ERR_STREAM_DESTROYED", function(t0) {
  return "Cannot call " + t0 + " after a stream was destroyed";
}), rd("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), rd("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), rd("ERR_STREAM_WRITE_AFTER_END", "write after end"), rd("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), rd("ERR_UNKNOWN_ENCODING", function(t0) {
  return "Unknown encoding: " + t0;
}, TypeError), rd("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), Ql.codes = nd;
var sd, ad, cd, ld, dd, ud, hd = typeof Object.create == "function" ? function(t0, e0) {
  t0.super_ = e0, t0.prototype = Object.create(e0.prototype, { constructor: { value: t0, enumerable: !1, writable: !0, configurable: !0 } });
} : function(t0, e0) {
  t0.super_ = e0;
  var n0 = function() {
  };
  n0.prototype = e0.prototype, t0.prototype = new n0(), t0.prototype.constructor = t0;
}, fd = ue$1(Object.freeze({ __proto__: null, default: hd }));
function pd() {
  if (ad)
    return sd;
  function t0(e0) {
    try {
      if (!le$1.localStorage)
        return !1;
    } catch {
      return !1;
    }
    var n0 = le$1.localStorage[e0];
    return n0 != null && String(n0).toLowerCase() === "true";
  }
  return ad = 1, sd = function(e0, n0) {
    if (t0("noDeprecation"))
      return e0;
    var r0 = !1;
    return function() {
      if (!r0) {
        if (t0("throwDeprecation"))
          throw new Error(n0);
        t0("traceDeprecation") ? console.trace(n0) : console.warn(n0), r0 = !0;
      }
      return e0.apply(this, arguments);
    };
  }, sd;
}
function gd() {
  if (ld)
    return cd;
  function t0(P0) {
    var I0 = this;
    this.next = null, this.entry = null, this.finish = function() {
      (function(f0, m0, A0) {
        var x0 = f0.entry;
        for (f0.entry = null; x0; ) {
          var _0 = x0.callback;
          m0.pendingcb--, _0(A0), x0 = x0.next;
        }
        m0.corkedRequestsFree.next = f0;
      })(I0, P0);
    };
  }
  var e0;
  ld = 1, cd = D0, D0.WritableState = k0;
  var n0 = { deprecate: pd() }, r0 = il(), i0 = sl.Buffer, o0 = (le$1 !== void 0 ? le$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  }, s0, a0 = Xl(), c0 = od().getHighWaterMark, l0 = Ql.codes, u0 = l0.ERR_INVALID_ARG_TYPE, d0 = l0.ERR_METHOD_NOT_IMPLEMENTED, h0 = l0.ERR_MULTIPLE_CALLBACK, g0 = l0.ERR_STREAM_CANNOT_PIPE, w0 = l0.ERR_STREAM_DESTROYED, y0 = l0.ERR_STREAM_NULL_VALUES, E0 = l0.ERR_STREAM_WRITE_AFTER_END, b0 = l0.ERR_UNKNOWN_ENCODING, O0 = a0.errorOrDestroy;
  function S0() {
  }
  function k0(P0, I0, f0) {
    e0 = e0 || md(), P0 = P0 || {}, typeof f0 != "boolean" && (f0 = I0 instanceof e0), this.objectMode = !!P0.objectMode, f0 && (this.objectMode = this.objectMode || !!P0.writableObjectMode), this.highWaterMark = c0(this, P0, "writableHighWaterMark", f0), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var m0 = P0.decodeStrings === !1;
    this.decodeStrings = !m0, this.defaultEncoding = P0.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(A0) {
      (function(x0, _0) {
        var $0 = x0._writableState, C0 = $0.sync, M0 = $0.writecb;
        if (typeof M0 != "function")
          throw new h0();
        if (function(v0) {
          v0.writing = !1, v0.writecb = null, v0.length -= v0.writelen, v0.writelen = 0;
        }($0), _0)
          (function(v0, T0, L0, B0, W0) {
            --T0.pendingcb, L0 ? (ca.nextTick(W0, B0), ca.nextTick(H0, v0, T0), v0._writableState.errorEmitted = !0, O0(v0, B0)) : (W0(B0), v0._writableState.errorEmitted = !0, O0(v0, B0), H0(v0, T0));
          })(x0, $0, C0, _0, M0);
        else {
          var p0 = U0($0) || x0.destroyed;
          p0 || $0.corked || $0.bufferProcessing || !$0.bufferedRequest || K0(x0, $0), C0 ? ca.nextTick(G0, x0, $0, p0, M0) : G0(x0, $0, p0, M0);
        }
      })(I0, A0);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = P0.emitClose !== !1, this.autoDestroy = !!P0.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t0(this);
  }
  function D0(P0) {
    var I0 = this instanceof (e0 = e0 || md());
    if (!I0 && !s0.call(D0, this))
      return new D0(P0);
    this._writableState = new k0(P0, this, I0), this.writable = !0, P0 && (typeof P0.write == "function" && (this._write = P0.write), typeof P0.writev == "function" && (this._writev = P0.writev), typeof P0.destroy == "function" && (this._destroy = P0.destroy), typeof P0.final == "function" && (this._final = P0.final)), r0.call(this);
  }
  function z0(P0, I0, f0, m0, A0, x0, _0) {
    I0.writelen = m0, I0.writecb = _0, I0.writing = !0, I0.sync = !0, I0.destroyed ? I0.onwrite(new w0("write")) : f0 ? P0._writev(A0, I0.onwrite) : P0._write(A0, x0, I0.onwrite), I0.sync = !1;
  }
  function G0(P0, I0, f0, m0) {
    f0 || function(A0, x0) {
      x0.length === 0 && x0.needDrain && (x0.needDrain = !1, A0.emit("drain"));
    }(P0, I0), I0.pendingcb--, m0(), H0(P0, I0);
  }
  function K0(P0, I0) {
    I0.bufferProcessing = !0;
    var f0 = I0.bufferedRequest;
    if (P0._writev && f0 && f0.next) {
      var m0 = I0.bufferedRequestCount, A0 = new Array(m0), x0 = I0.corkedRequestsFree;
      x0.entry = f0;
      for (var _0 = 0, $0 = !0; f0; )
        A0[_0] = f0, f0.isBuf || ($0 = !1), f0 = f0.next, _0 += 1;
      A0.allBuffers = $0, z0(P0, I0, !0, I0.length, A0, "", x0.finish), I0.pendingcb++, I0.lastBufferedRequest = null, x0.next ? (I0.corkedRequestsFree = x0.next, x0.next = null) : I0.corkedRequestsFree = new t0(I0), I0.bufferedRequestCount = 0;
    } else {
      for (; f0; ) {
        var C0 = f0.chunk, M0 = f0.encoding, p0 = f0.callback;
        if (z0(P0, I0, !1, I0.objectMode ? 1 : C0.length, C0, M0, p0), f0 = f0.next, I0.bufferedRequestCount--, I0.writing)
          break;
      }
      f0 === null && (I0.lastBufferedRequest = null);
    }
    I0.bufferedRequest = f0, I0.bufferProcessing = !1;
  }
  function U0(P0) {
    return P0.ending && P0.length === 0 && P0.bufferedRequest === null && !P0.finished && !P0.writing;
  }
  function F0(P0, I0) {
    P0._final(function(f0) {
      I0.pendingcb--, f0 && O0(P0, f0), I0.prefinished = !0, P0.emit("prefinish"), H0(P0, I0);
    });
  }
  function H0(P0, I0) {
    var f0 = U0(I0);
    if (f0 && (function(A0, x0) {
      x0.prefinished || x0.finalCalled || (typeof A0._final != "function" || x0.destroyed ? (x0.prefinished = !0, A0.emit("prefinish")) : (x0.pendingcb++, x0.finalCalled = !0, ca.nextTick(F0, A0, x0)));
    }(P0, I0), I0.pendingcb === 0 && (I0.finished = !0, P0.emit("finish"), I0.autoDestroy))) {
      var m0 = P0._readableState;
      (!m0 || m0.autoDestroy && m0.endEmitted) && P0.destroy();
    }
    return f0;
  }
  return fd(D0, r0), k0.prototype.getBuffer = function() {
    for (var P0 = this.bufferedRequest, I0 = []; P0; )
      I0.push(P0), P0 = P0.next;
    return I0;
  }, function() {
    try {
      Object.defineProperty(k0.prototype, "buffer", { get: n0.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch {
    }
  }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (s0 = Function.prototype[Symbol.hasInstance], Object.defineProperty(D0, Symbol.hasInstance, { value: function(P0) {
    return !!s0.call(this, P0) || this === D0 && P0 && P0._writableState instanceof k0;
  } })) : s0 = function(P0) {
    return P0 instanceof this;
  }, D0.prototype.pipe = function() {
    O0(this, new g0());
  }, D0.prototype.write = function(P0, I0, f0) {
    var m0, A0 = this._writableState, x0 = !1, _0 = !A0.objectMode && (m0 = P0, i0.isBuffer(m0) || m0 instanceof o0);
    return _0 && !i0.isBuffer(P0) && (P0 = function($0) {
      return i0.from($0);
    }(P0)), typeof I0 == "function" && (f0 = I0, I0 = null), _0 ? I0 = "buffer" : I0 || (I0 = A0.defaultEncoding), typeof f0 != "function" && (f0 = S0), A0.ending ? function($0, C0) {
      var M0 = new E0();
      O0($0, M0), ca.nextTick(C0, M0);
    }(this, f0) : (_0 || function($0, C0, M0, p0) {
      var v0;
      return M0 === null ? v0 = new y0() : typeof M0 == "string" || C0.objectMode || (v0 = new u0("chunk", ["string", "Buffer"], M0)), !v0 || (O0($0, v0), ca.nextTick(p0, v0), !1);
    }(this, A0, P0, f0)) && (A0.pendingcb++, x0 = function($0, C0, M0, p0, v0, T0) {
      if (!M0) {
        var L0 = function(Q0, X0, J0) {
          return Q0.objectMode || Q0.decodeStrings === !1 || typeof X0 != "string" || (X0 = i0.from(X0, J0)), X0;
        }(C0, p0, v0);
        p0 !== L0 && (M0 = !0, v0 = "buffer", p0 = L0);
      }
      var B0 = C0.objectMode ? 1 : p0.length;
      C0.length += B0;
      var W0 = C0.length < C0.highWaterMark;
      if (W0 || (C0.needDrain = !0), C0.writing || C0.corked) {
        var V0 = C0.lastBufferedRequest;
        C0.lastBufferedRequest = { chunk: p0, encoding: v0, isBuf: M0, callback: T0, next: null }, V0 ? V0.next = C0.lastBufferedRequest : C0.bufferedRequest = C0.lastBufferedRequest, C0.bufferedRequestCount += 1;
      } else
        z0($0, C0, !1, B0, p0, v0, T0);
      return W0;
    }(this, A0, _0, P0, I0, f0)), x0;
  }, D0.prototype.cork = function() {
    this._writableState.corked++;
  }, D0.prototype.uncork = function() {
    var P0 = this._writableState;
    P0.corked && (P0.corked--, P0.writing || P0.corked || P0.bufferProcessing || !P0.bufferedRequest || K0(this, P0));
  }, D0.prototype.setDefaultEncoding = function(P0) {
    if (typeof P0 == "string" && (P0 = P0.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((P0 + "").toLowerCase()) > -1))
      throw new b0(P0);
    return this._writableState.defaultEncoding = P0, this;
  }, Object.defineProperty(D0.prototype, "writableBuffer", { enumerable: !1, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(D0.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
    return this._writableState.highWaterMark;
  } }), D0.prototype._write = function(P0, I0, f0) {
    f0(new d0("_write()"));
  }, D0.prototype._writev = null, D0.prototype.end = function(P0, I0, f0) {
    var m0 = this._writableState;
    return typeof P0 == "function" ? (f0 = P0, P0 = null, I0 = null) : typeof I0 == "function" && (f0 = I0, I0 = null), P0 != null && this.write(P0, I0), m0.corked && (m0.corked = 1, this.uncork()), m0.ending || function(A0, x0, _0) {
      x0.ending = !0, H0(A0, x0), _0 && (x0.finished ? ca.nextTick(_0) : A0.once("finish", _0)), x0.ended = !0, A0.writable = !1;
    }(this, m0, f0), this;
  }, Object.defineProperty(D0.prototype, "writableLength", { enumerable: !1, get: function() {
    return this._writableState.length;
  } }), Object.defineProperty(D0.prototype, "destroyed", { enumerable: !1, get: function() {
    return this._writableState !== void 0 && this._writableState.destroyed;
  }, set: function(P0) {
    this._writableState && (this._writableState.destroyed = P0);
  } }), D0.prototype.destroy = a0.destroy, D0.prototype._undestroy = a0.undestroy, D0.prototype._destroy = function(P0, I0) {
    I0(P0);
  }, cd;
}
function md() {
  if (ud)
    return dd;
  ud = 1;
  var t0 = Object.keys || function(l0) {
    var u0 = [];
    for (var d0 in l0)
      u0.push(d0);
    return u0;
  };
  dd = s0;
  var e0 = Od(), n0 = gd();
  fd(s0, e0);
  for (var r0 = t0(n0.prototype), i0 = 0; i0 < r0.length; i0++) {
    var o0 = r0[i0];
    s0.prototype[o0] || (s0.prototype[o0] = n0.prototype[o0]);
  }
  function s0(l0) {
    if (!(this instanceof s0))
      return new s0(l0);
    e0.call(this, l0), n0.call(this, l0), this.allowHalfOpen = !0, l0 && (l0.readable === !1 && (this.readable = !1), l0.writable === !1 && (this.writable = !1), l0.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", a0)));
  }
  function a0() {
    this._writableState.ended || ca.nextTick(c0, this);
  }
  function c0(l0) {
    l0.end();
  }
  return Object.defineProperty(s0.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
    return this._writableState.highWaterMark;
  } }), Object.defineProperty(s0.prototype, "writableBuffer", { enumerable: !1, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(s0.prototype, "writableLength", { enumerable: !1, get: function() {
    return this._writableState.length;
  } }), Object.defineProperty(s0.prototype, "destroyed", { enumerable: !1, get: function() {
    return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
  }, set: function(l0) {
    this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = l0, this._writableState.destroyed = l0);
  } }), dd;
}
var yd = _.isEncoding || function(t0) {
  switch (t0 && t0.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function vd(t0) {
  switch (this.encoding = (t0 || "utf8").toLowerCase().replace(/[-_]/, ""), function(e0) {
    if (e0 && !yd(e0))
      throw new Error("Unknown encoding: " + e0);
  }(t0), this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2, this.detectIncompleteChar = wd;
      break;
    case "base64":
      this.surrogateSize = 3, this.detectIncompleteChar = Ed;
      break;
    default:
      return void (this.write = bd);
  }
  this.charBuffer = new _(6), this.charReceived = 0, this.charLength = 0;
}
function bd(t0) {
  return t0.toString(this.encoding);
}
function wd(t0) {
  this.charReceived = t0.length % 2, this.charLength = this.charReceived ? 2 : 0;
}
function Ed(t0) {
  this.charReceived = t0.length % 3, this.charLength = this.charReceived ? 3 : 0;
}
vd.prototype.write = function(t0) {
  for (var e0 = ""; this.charLength; ) {
    var n0 = t0.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : t0.length;
    if (t0.copy(this.charBuffer, this.charReceived, 0, n0), this.charReceived += n0, this.charReceived < this.charLength)
      return "";
    if (t0 = t0.slice(n0, t0.length), !((i0 = (e0 = this.charBuffer.slice(0, this.charLength).toString(this.encoding)).charCodeAt(e0.length - 1)) >= 55296 && i0 <= 56319)) {
      if (this.charReceived = this.charLength = 0, t0.length === 0)
        return e0;
      break;
    }
    this.charLength += this.surrogateSize, e0 = "";
  }
  this.detectIncompleteChar(t0);
  var r0 = t0.length;
  this.charLength && (t0.copy(this.charBuffer, 0, t0.length - this.charReceived, r0), r0 -= this.charReceived);
  var i0;
  if (r0 = (e0 += t0.toString(this.encoding, 0, r0)).length - 1, (i0 = e0.charCodeAt(r0)) >= 55296 && i0 <= 56319) {
    var o0 = this.surrogateSize;
    return this.charLength += o0, this.charReceived += o0, this.charBuffer.copy(this.charBuffer, o0, 0, o0), t0.copy(this.charBuffer, 0, 0, o0), e0.substring(0, r0);
  }
  return e0;
}, vd.prototype.detectIncompleteChar = function(t0) {
  for (var e0 = t0.length >= 3 ? 3 : t0.length; e0 > 0; e0--) {
    var n0 = t0[t0.length - e0];
    if (e0 == 1 && n0 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (e0 <= 2 && n0 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (e0 <= 3 && n0 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = e0;
}, vd.prototype.end = function(t0) {
  var e0 = "";
  if (t0 && t0.length && (e0 = this.write(t0)), this.charReceived) {
    var n0 = this.charReceived, r0 = this.charBuffer, i0 = this.encoding;
    e0 += r0.slice(0, n0).toString(i0);
  }
  return e0;
};
var Sd = ue$1(Object.freeze({ __proto__: null, StringDecoder: vd })), _d = Ql.codes.ERR_STREAM_PREMATURE_CLOSE;
function Cd() {
}
var kd, xd, Md, Ad, Id, Rd, Pd = function t0(e0, n0, r0) {
  if (typeof n0 == "function")
    return t0(e0, null, n0);
  n0 || (n0 = {}), r0 = function(w0) {
    var y0 = !1;
    return function() {
      if (!y0) {
        y0 = !0;
        for (var E0 = arguments.length, b0 = new Array(E0), O0 = 0; O0 < E0; O0++)
          b0[O0] = arguments[O0];
        w0.apply(this, b0);
      }
    };
  }(r0 || Cd);
  var i0 = n0.readable || n0.readable !== !1 && e0.readable, o0 = n0.writable || n0.writable !== !1 && e0.writable, s0 = function() {
    e0.writable || c0();
  }, a0 = e0._writableState && e0._writableState.finished, c0 = function() {
    o0 = !1, a0 = !0, i0 || r0.call(e0);
  }, l0 = e0._readableState && e0._readableState.endEmitted, u0 = function() {
    i0 = !1, l0 = !0, o0 || r0.call(e0);
  }, d0 = function(w0) {
    r0.call(e0, w0);
  }, h0 = function() {
    var w0;
    return i0 && !l0 ? (e0._readableState && e0._readableState.ended || (w0 = new _d()), r0.call(e0, w0)) : o0 && !a0 ? (e0._writableState && e0._writableState.ended || (w0 = new _d()), r0.call(e0, w0)) : void 0;
  }, g0 = function() {
    e0.req.on("finish", c0);
  };
  return function(w0) {
    return w0.setHeader && typeof w0.abort == "function";
  }(e0) ? (e0.on("complete", c0), e0.on("abort", h0), e0.req ? g0() : e0.on("request", g0)) : o0 && !e0._writableState && (e0.on("end", s0), e0.on("close", s0)), e0.on("end", u0), e0.on("finish", c0), n0.error !== !1 && e0.on("error", d0), e0.on("close", h0), function() {
    e0.removeListener("complete", c0), e0.removeListener("abort", h0), e0.removeListener("request", g0), e0.req && e0.req.removeListener("finish", c0), e0.removeListener("end", s0), e0.removeListener("close", s0), e0.removeListener("finish", c0), e0.removeListener("end", u0), e0.removeListener("error", d0), e0.removeListener("close", h0);
  };
};
function Td() {
  if (xd)
    return kd;
  var t0;
  function e0(y0, E0, b0) {
    return (E0 = function(O0) {
      var S0 = function(k0, D0) {
        if (typeof k0 != "object" || k0 === null)
          return k0;
        var z0 = k0[Symbol.toPrimitive];
        if (z0 !== void 0) {
          var G0 = z0.call(k0, D0 || "default");
          if (typeof G0 != "object")
            return G0;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (D0 === "string" ? String : Number)(k0);
      }(O0, "string");
      return typeof S0 == "symbol" ? S0 : String(S0);
    }(E0)) in y0 ? Object.defineProperty(y0, E0, { value: b0, enumerable: !0, configurable: !0, writable: !0 }) : y0[E0] = b0, y0;
  }
  xd = 1;
  var n0 = Pd, r0 = Symbol("lastResolve"), i0 = Symbol("lastReject"), o0 = Symbol("error"), s0 = Symbol("ended"), a0 = Symbol("lastPromise"), c0 = Symbol("handlePromise"), l0 = Symbol("stream");
  function u0(y0, E0) {
    return { value: y0, done: E0 };
  }
  function d0(y0) {
    var E0 = y0[r0];
    if (E0 !== null) {
      var b0 = y0[l0].read();
      b0 !== null && (y0[a0] = null, y0[r0] = null, y0[i0] = null, E0(u0(b0, !1)));
    }
  }
  function h0(y0) {
    ca.nextTick(d0, y0);
  }
  var g0 = Object.getPrototypeOf(function() {
  }), w0 = Object.setPrototypeOf((e0(t0 = { get stream() {
    return this[l0];
  }, next: function() {
    var y0 = this, E0 = this[o0];
    if (E0 !== null)
      return Promise.reject(E0);
    if (this[s0])
      return Promise.resolve(u0(void 0, !0));
    if (this[l0].destroyed)
      return new Promise(function(k0, D0) {
        ca.nextTick(function() {
          y0[o0] ? D0(y0[o0]) : k0(u0(void 0, !0));
        });
      });
    var b0, O0 = this[a0];
    if (O0)
      b0 = new Promise(function(k0, D0) {
        return function(z0, G0) {
          k0.then(function() {
            D0[s0] ? z0(u0(void 0, !0)) : D0[c0](z0, G0);
          }, G0);
        };
      }(O0, this));
    else {
      var S0 = this[l0].read();
      if (S0 !== null)
        return Promise.resolve(u0(S0, !1));
      b0 = new Promise(this[c0]);
    }
    return this[a0] = b0, b0;
  } }, Symbol.asyncIterator, function() {
    return this;
  }), e0(t0, "return", function() {
    var y0 = this;
    return new Promise(function(E0, b0) {
      y0[l0].destroy(null, function(O0) {
        O0 ? b0(O0) : E0(u0(void 0, !0));
      });
    });
  }), t0), g0);
  return kd = function(y0) {
    var E0, b0 = Object.create(w0, (e0(E0 = {}, l0, { value: y0, writable: !0 }), e0(E0, r0, { value: null, writable: !0 }), e0(E0, i0, { value: null, writable: !0 }), e0(E0, o0, { value: null, writable: !0 }), e0(E0, s0, { value: y0._readableState.endEmitted, writable: !0 }), e0(E0, c0, { value: function(O0, S0) {
      var k0 = b0[l0].read();
      k0 ? (b0[a0] = null, b0[r0] = null, b0[i0] = null, O0(u0(k0, !1))) : (b0[r0] = O0, b0[i0] = S0);
    }, writable: !0 }), E0));
    return b0[a0] = null, n0(y0, function(O0) {
      if (O0 && O0.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var S0 = b0[i0];
        return S0 !== null && (b0[a0] = null, b0[r0] = null, b0[i0] = null, S0(O0)), void (b0[o0] = O0);
      }
      var k0 = b0[r0];
      k0 !== null && (b0[a0] = null, b0[r0] = null, b0[i0] = null, k0(u0(void 0, !0))), b0[s0] = !0;
    }), y0.on("readable", h0.bind(null, b0)), b0;
  }, kd;
}
function Od() {
  if (Rd)
    return Id;
  var t0;
  Rd = 1, Id = D0, D0.ReadableState = k0, sc.EventEmitter;
  var e0 = function(p0, v0) {
    return p0.listeners(v0).length;
  }, n0 = il(), r0 = sl.Buffer, i0 = (le$1 !== void 0 ? le$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  }, o0, s0 = Zl;
  o0 = s0 && s0.debuglog ? s0.debuglog("stream") : function() {
  };
  var a0, c0, l0, u0 = Jl(), d0 = Xl(), h0 = od().getHighWaterMark, g0 = Ql.codes, w0 = g0.ERR_INVALID_ARG_TYPE, y0 = g0.ERR_STREAM_PUSH_AFTER_EOF, E0 = g0.ERR_METHOD_NOT_IMPLEMENTED, b0 = g0.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  fd(D0, n0);
  var O0 = d0.errorOrDestroy, S0 = ["error", "close", "destroy", "pause", "resume"];
  function k0(p0, v0, T0) {
    t0 = t0 || md(), p0 = p0 || {}, typeof T0 != "boolean" && (T0 = v0 instanceof t0), this.objectMode = !!p0.objectMode, T0 && (this.objectMode = this.objectMode || !!p0.readableObjectMode), this.highWaterMark = h0(this, p0, "readableHighWaterMark", T0), this.buffer = new u0(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = p0.emitClose !== !1, this.autoDestroy = !!p0.autoDestroy, this.destroyed = !1, this.defaultEncoding = p0.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, p0.encoding && (a0 || (a0 = Sd.StringDecoder), this.decoder = new a0(p0.encoding), this.encoding = p0.encoding);
  }
  function D0(p0) {
    if (t0 = t0 || md(), !(this instanceof D0))
      return new D0(p0);
    var v0 = this instanceof t0;
    this._readableState = new k0(p0, this, v0), this.readable = !0, p0 && (typeof p0.read == "function" && (this._read = p0.read), typeof p0.destroy == "function" && (this._destroy = p0.destroy)), n0.call(this);
  }
  function z0(p0, v0, T0, L0, B0) {
    o0("readableAddChunk", v0);
    var W0, V0 = p0._readableState;
    if (v0 === null)
      V0.reading = !1, function(Q0, X0) {
        if (o0("onEofChunk"), !X0.ended) {
          if (X0.decoder) {
            var J0 = X0.decoder.end();
            J0 && J0.length && (X0.buffer.push(J0), X0.length += X0.objectMode ? 1 : J0.length);
          }
          X0.ended = !0, X0.sync ? F0(Q0) : (X0.needReadable = !1, X0.emittedReadable || (X0.emittedReadable = !0, H0(Q0)));
        }
      }(p0, V0);
    else if (B0 || (W0 = function(Q0, X0) {
      var J0;
      yg = X0, r0.isBuffer(yg) || yg instanceof i0 || typeof X0 == "string" || X0 === void 0 || Q0.objectMode || (J0 = new w0("chunk", ["string", "Buffer", "Uint8Array"], X0));
      var yg;
      return J0;
    }(V0, v0)), W0)
      O0(p0, W0);
    else if (V0.objectMode || v0 && v0.length > 0)
      if (typeof v0 == "string" || V0.objectMode || Object.getPrototypeOf(v0) === r0.prototype || (v0 = function(Q0) {
        return r0.from(Q0);
      }(v0)), L0)
        V0.endEmitted ? O0(p0, new b0()) : G0(p0, V0, v0, !0);
      else if (V0.ended)
        O0(p0, new y0());
      else {
        if (V0.destroyed)
          return !1;
        V0.reading = !1, V0.decoder && !T0 ? (v0 = V0.decoder.write(v0), V0.objectMode || v0.length !== 0 ? G0(p0, V0, v0, !1) : P0(p0, V0)) : G0(p0, V0, v0, !1);
      }
    else
      L0 || (V0.reading = !1, P0(p0, V0));
    return !V0.ended && (V0.length < V0.highWaterMark || V0.length === 0);
  }
  function G0(p0, v0, T0, L0) {
    v0.flowing && v0.length === 0 && !v0.sync ? (v0.awaitDrain = 0, p0.emit("data", T0)) : (v0.length += v0.objectMode ? 1 : T0.length, L0 ? v0.buffer.unshift(T0) : v0.buffer.push(T0), v0.needReadable && F0(p0)), P0(p0, v0);
  }
  Object.defineProperty(D0.prototype, "destroyed", { enumerable: !1, get: function() {
    return this._readableState !== void 0 && this._readableState.destroyed;
  }, set: function(p0) {
    this._readableState && (this._readableState.destroyed = p0);
  } }), D0.prototype.destroy = d0.destroy, D0.prototype._undestroy = d0.undestroy, D0.prototype._destroy = function(p0, v0) {
    v0(p0);
  }, D0.prototype.push = function(p0, v0) {
    var T0, L0 = this._readableState;
    return L0.objectMode ? T0 = !0 : typeof p0 == "string" && ((v0 = v0 || L0.defaultEncoding) !== L0.encoding && (p0 = r0.from(p0, v0), v0 = ""), T0 = !0), z0(this, p0, v0, !1, T0);
  }, D0.prototype.unshift = function(p0) {
    return z0(this, p0, null, !0, !1);
  }, D0.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, D0.prototype.setEncoding = function(p0) {
    a0 || (a0 = Sd.StringDecoder);
    var v0 = new a0(p0);
    this._readableState.decoder = v0, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var T0 = this._readableState.buffer.head, L0 = ""; T0 !== null; )
      L0 += v0.write(T0.data), T0 = T0.next;
    return this._readableState.buffer.clear(), L0 !== "" && this._readableState.buffer.push(L0), this._readableState.length = L0.length, this;
  };
  var K0 = 1073741824;
  function U0(p0, v0) {
    return p0 <= 0 || v0.length === 0 && v0.ended ? 0 : v0.objectMode ? 1 : p0 != p0 ? v0.flowing && v0.length ? v0.buffer.head.data.length : v0.length : (p0 > v0.highWaterMark && (v0.highWaterMark = function(T0) {
      return T0 >= K0 ? T0 = K0 : (T0--, T0 |= T0 >>> 1, T0 |= T0 >>> 2, T0 |= T0 >>> 4, T0 |= T0 >>> 8, T0 |= T0 >>> 16, T0++), T0;
    }(p0)), p0 <= v0.length ? p0 : v0.ended ? v0.length : (v0.needReadable = !0, 0));
  }
  function F0(p0) {
    var v0 = p0._readableState;
    o0("emitReadable", v0.needReadable, v0.emittedReadable), v0.needReadable = !1, v0.emittedReadable || (o0("emitReadable", v0.flowing), v0.emittedReadable = !0, ca.nextTick(H0, p0));
  }
  function H0(p0) {
    var v0 = p0._readableState;
    o0("emitReadable_", v0.destroyed, v0.length, v0.ended), v0.destroyed || !v0.length && !v0.ended || (p0.emit("readable"), v0.emittedReadable = !1), v0.needReadable = !v0.flowing && !v0.ended && v0.length <= v0.highWaterMark, x0(p0);
  }
  function P0(p0, v0) {
    v0.readingMore || (v0.readingMore = !0, ca.nextTick(I0, p0, v0));
  }
  function I0(p0, v0) {
    for (; !v0.reading && !v0.ended && (v0.length < v0.highWaterMark || v0.flowing && v0.length === 0); ) {
      var T0 = v0.length;
      if (o0("maybeReadMore read 0"), p0.read(0), T0 === v0.length)
        break;
    }
    v0.readingMore = !1;
  }
  function f0(p0) {
    var v0 = p0._readableState;
    v0.readableListening = p0.listenerCount("readable") > 0, v0.resumeScheduled && !v0.paused ? v0.flowing = !0 : p0.listenerCount("data") > 0 && p0.resume();
  }
  function m0(p0) {
    o0("readable nexttick read 0"), p0.read(0);
  }
  function A0(p0, v0) {
    o0("resume", v0.reading), v0.reading || p0.read(0), v0.resumeScheduled = !1, p0.emit("resume"), x0(p0), v0.flowing && !v0.reading && p0.read(0);
  }
  function x0(p0) {
    var v0 = p0._readableState;
    for (o0("flow", v0.flowing); v0.flowing && p0.read() !== null; )
      ;
  }
  function _0(p0, v0) {
    return v0.length === 0 ? null : (v0.objectMode ? T0 = v0.buffer.shift() : !p0 || p0 >= v0.length ? (T0 = v0.decoder ? v0.buffer.join("") : v0.buffer.length === 1 ? v0.buffer.first() : v0.buffer.concat(v0.length), v0.buffer.clear()) : T0 = v0.buffer.consume(p0, v0.decoder), T0);
    var T0;
  }
  function $0(p0) {
    var v0 = p0._readableState;
    o0("endReadable", v0.endEmitted), v0.endEmitted || (v0.ended = !0, ca.nextTick(C0, v0, p0));
  }
  function C0(p0, v0) {
    if (o0("endReadableNT", p0.endEmitted, p0.length), !p0.endEmitted && p0.length === 0 && (p0.endEmitted = !0, v0.readable = !1, v0.emit("end"), p0.autoDestroy)) {
      var T0 = v0._writableState;
      (!T0 || T0.autoDestroy && T0.finished) && v0.destroy();
    }
  }
  function M0(p0, v0) {
    for (var T0 = 0, L0 = p0.length; T0 < L0; T0++)
      if (p0[T0] === v0)
        return T0;
    return -1;
  }
  return D0.prototype.read = function(p0) {
    o0("read", p0), p0 = parseInt(p0, 10);
    var v0 = this._readableState, T0 = p0;
    if (p0 !== 0 && (v0.emittedReadable = !1), p0 === 0 && v0.needReadable && ((v0.highWaterMark !== 0 ? v0.length >= v0.highWaterMark : v0.length > 0) || v0.ended))
      return o0("read: emitReadable", v0.length, v0.ended), v0.length === 0 && v0.ended ? $0(this) : F0(this), null;
    if ((p0 = U0(p0, v0)) === 0 && v0.ended)
      return v0.length === 0 && $0(this), null;
    var L0, B0 = v0.needReadable;
    return o0("need readable", B0), (v0.length === 0 || v0.length - p0 < v0.highWaterMark) && o0("length less than watermark", B0 = !0), v0.ended || v0.reading ? o0("reading or ended", B0 = !1) : B0 && (o0("do read"), v0.reading = !0, v0.sync = !0, v0.length === 0 && (v0.needReadable = !0), this._read(v0.highWaterMark), v0.sync = !1, v0.reading || (p0 = U0(T0, v0))), (L0 = p0 > 0 ? _0(p0, v0) : null) === null ? (v0.needReadable = v0.length <= v0.highWaterMark, p0 = 0) : (v0.length -= p0, v0.awaitDrain = 0), v0.length === 0 && (v0.ended || (v0.needReadable = !0), T0 !== p0 && v0.ended && $0(this)), L0 !== null && this.emit("data", L0), L0;
  }, D0.prototype._read = function(p0) {
    O0(this, new E0("_read()"));
  }, D0.prototype.pipe = function(p0, v0) {
    var T0 = this, L0 = this._readableState;
    switch (L0.pipesCount) {
      case 0:
        L0.pipes = p0;
        break;
      case 1:
        L0.pipes = [L0.pipes, p0];
        break;
      default:
        L0.pipes.push(p0);
    }
    L0.pipesCount += 1, o0("pipe count=%d opts=%j", L0.pipesCount, v0);
    var B0 = (!v0 || v0.end !== !1) && p0 !== ca.stdout && p0 !== ca.stderr ? V0 : $g;
    function W0(Eg, bg) {
      o0("onunpipe"), Eg === T0 && bg && bg.hasUnpiped === !1 && (bg.hasUnpiped = !0, o0("cleanup"), p0.removeListener("close", _g), p0.removeListener("finish", wg), p0.removeListener("drain", Q0), p0.removeListener("error", yg), p0.removeListener("unpipe", W0), T0.removeListener("end", V0), T0.removeListener("end", $g), T0.removeListener("data", J0), X0 = !0, !L0.awaitDrain || p0._writableState && !p0._writableState.needDrain || Q0());
    }
    function V0() {
      o0("onend"), p0.end();
    }
    L0.endEmitted ? ca.nextTick(B0) : T0.once("end", B0), p0.on("unpipe", W0);
    var Q0 = function(Eg) {
      return function() {
        var bg = Eg._readableState;
        o0("pipeOnDrain", bg.awaitDrain), bg.awaitDrain && bg.awaitDrain--, bg.awaitDrain === 0 && e0(Eg, "data") && (bg.flowing = !0, x0(Eg));
      };
    }(T0);
    p0.on("drain", Q0);
    var X0 = !1;
    function J0(Eg) {
      o0("ondata");
      var bg = p0.write(Eg);
      o0("dest.write", bg), bg === !1 && ((L0.pipesCount === 1 && L0.pipes === p0 || L0.pipesCount > 1 && M0(L0.pipes, p0) !== -1) && !X0 && (o0("false write response, pause", L0.awaitDrain), L0.awaitDrain++), T0.pause());
    }
    function yg(Eg) {
      o0("onerror", Eg), $g(), p0.removeListener("error", yg), e0(p0, "error") === 0 && O0(p0, Eg);
    }
    function _g() {
      p0.removeListener("finish", wg), $g();
    }
    function wg() {
      o0("onfinish"), p0.removeListener("close", _g), $g();
    }
    function $g() {
      o0("unpipe"), T0.unpipe(p0);
    }
    return T0.on("data", J0), function(Eg, bg, vg) {
      if (typeof Eg.prependListener == "function")
        return Eg.prependListener(bg, vg);
      Eg._events && Eg._events[bg] ? Array.isArray(Eg._events[bg]) ? Eg._events[bg].unshift(vg) : Eg._events[bg] = [vg, Eg._events[bg]] : Eg.on(bg, vg);
    }(p0, "error", yg), p0.once("close", _g), p0.once("finish", wg), p0.emit("pipe", T0), L0.flowing || (o0("pipe resume"), T0.resume()), p0;
  }, D0.prototype.unpipe = function(p0) {
    var v0 = this._readableState, T0 = { hasUnpiped: !1 };
    if (v0.pipesCount === 0)
      return this;
    if (v0.pipesCount === 1)
      return p0 && p0 !== v0.pipes || (p0 || (p0 = v0.pipes), v0.pipes = null, v0.pipesCount = 0, v0.flowing = !1, p0 && p0.emit("unpipe", this, T0)), this;
    if (!p0) {
      var L0 = v0.pipes, B0 = v0.pipesCount;
      v0.pipes = null, v0.pipesCount = 0, v0.flowing = !1;
      for (var W0 = 0; W0 < B0; W0++)
        L0[W0].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var V0 = M0(v0.pipes, p0);
    return V0 === -1 || (v0.pipes.splice(V0, 1), v0.pipesCount -= 1, v0.pipesCount === 1 && (v0.pipes = v0.pipes[0]), p0.emit("unpipe", this, T0)), this;
  }, D0.prototype.on = function(p0, v0) {
    var T0 = n0.prototype.on.call(this, p0, v0), L0 = this._readableState;
    return p0 === "data" ? (L0.readableListening = this.listenerCount("readable") > 0, L0.flowing !== !1 && this.resume()) : p0 === "readable" && (L0.endEmitted || L0.readableListening || (L0.readableListening = L0.needReadable = !0, L0.flowing = !1, L0.emittedReadable = !1, o0("on readable", L0.length, L0.reading), L0.length ? F0(this) : L0.reading || ca.nextTick(m0, this))), T0;
  }, D0.prototype.addListener = D0.prototype.on, D0.prototype.removeListener = function(p0, v0) {
    var T0 = n0.prototype.removeListener.call(this, p0, v0);
    return p0 === "readable" && ca.nextTick(f0, this), T0;
  }, D0.prototype.removeAllListeners = function(p0) {
    var v0 = n0.prototype.removeAllListeners.apply(this, arguments);
    return p0 !== "readable" && p0 !== void 0 || ca.nextTick(f0, this), v0;
  }, D0.prototype.resume = function() {
    var p0 = this._readableState;
    return p0.flowing || (o0("resume"), p0.flowing = !p0.readableListening, function(v0, T0) {
      T0.resumeScheduled || (T0.resumeScheduled = !0, ca.nextTick(A0, v0, T0));
    }(this, p0)), p0.paused = !1, this;
  }, D0.prototype.pause = function() {
    return o0("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (o0("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  }, D0.prototype.wrap = function(p0) {
    var v0 = this, T0 = this._readableState, L0 = !1;
    for (var B0 in p0.on("end", function() {
      if (o0("wrapped end"), T0.decoder && !T0.ended) {
        var V0 = T0.decoder.end();
        V0 && V0.length && v0.push(V0);
      }
      v0.push(null);
    }), p0.on("data", function(V0) {
      o0("wrapped data"), T0.decoder && (V0 = T0.decoder.write(V0)), T0.objectMode && V0 == null || (T0.objectMode || V0 && V0.length) && (v0.push(V0) || (L0 = !0, p0.pause()));
    }), p0)
      this[B0] === void 0 && typeof p0[B0] == "function" && (this[B0] = function(V0) {
        return function() {
          return p0[V0].apply(p0, arguments);
        };
      }(B0));
    for (var W0 = 0; W0 < S0.length; W0++)
      p0.on(S0[W0], this.emit.bind(this, S0[W0]));
    return this._read = function(V0) {
      o0("wrapped _read", V0), L0 && (L0 = !1, p0.resume());
    }, this;
  }, typeof Symbol == "function" && (D0.prototype[Symbol.asyncIterator] = function() {
    return c0 === void 0 && (c0 = Td()), c0(this);
  }), Object.defineProperty(D0.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
    return this._readableState.highWaterMark;
  } }), Object.defineProperty(D0.prototype, "readableBuffer", { enumerable: !1, get: function() {
    return this._readableState && this._readableState.buffer;
  } }), Object.defineProperty(D0.prototype, "readableFlowing", { enumerable: !1, get: function() {
    return this._readableState.flowing;
  }, set: function(p0) {
    this._readableState && (this._readableState.flowing = p0);
  } }), D0._fromList = _0, Object.defineProperty(D0.prototype, "readableLength", { enumerable: !1, get: function() {
    return this._readableState.length;
  } }), typeof Symbol == "function" && (D0.from = function(p0, v0) {
    return l0 === void 0 && (l0 = Ad ? Md : (Ad = 1, Md = function() {
      throw new Error("Readable.from is not available in the browser");
    })), l0(D0, p0, v0);
  }), Id;
}
var Ld = Hd, Nd = Ql.codes, $d = Nd.ERR_METHOD_NOT_IMPLEMENTED, Dd = Nd.ERR_MULTIPLE_CALLBACK, Bd = Nd.ERR_TRANSFORM_ALREADY_TRANSFORMING, Kd = Nd.ERR_TRANSFORM_WITH_LENGTH_0, jd = md();
function Ud(t0, e0) {
  var n0 = this._transformState;
  n0.transforming = !1;
  var r0 = n0.writecb;
  if (r0 === null)
    return this.emit("error", new Dd());
  n0.writechunk = null, n0.writecb = null, e0 != null && this.push(e0), r0(t0);
  var i0 = this._readableState;
  i0.reading = !1, (i0.needReadable || i0.length < i0.highWaterMark) && this._read(i0.highWaterMark);
}
function Hd(t0) {
  if (!(this instanceof Hd))
    return new Hd(t0);
  jd.call(this, t0), this._transformState = { afterTransform: Ud.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, t0 && (typeof t0.transform == "function" && (this._transform = t0.transform), typeof t0.flush == "function" && (this._flush = t0.flush)), this.on("prefinish", Fd);
}
function Fd() {
  var t0 = this;
  typeof this._flush != "function" || this._readableState.destroyed ? zd(this, null, null) : this._flush(function(e0, n0) {
    zd(t0, e0, n0);
  });
}
function zd(t0, e0, n0) {
  if (e0)
    return t0.emit("error", e0);
  if (n0 != null && t0.push(n0), t0._writableState.length)
    throw new Kd();
  if (t0._transformState.transforming)
    throw new Bd();
  return t0.push(null);
}
fd(Hd, jd), Hd.prototype.push = function(t0, e0) {
  return this._transformState.needTransform = !1, jd.prototype.push.call(this, t0, e0);
}, Hd.prototype._transform = function(t0, e0, n0) {
  n0(new $d("_transform()"));
}, Hd.prototype._write = function(t0, e0, n0) {
  var r0 = this._transformState;
  if (r0.writecb = n0, r0.writechunk = t0, r0.writeencoding = e0, !r0.transforming) {
    var i0 = this._readableState;
    (r0.needTransform || i0.needReadable || i0.length < i0.highWaterMark) && this._read(i0.highWaterMark);
  }
}, Hd.prototype._read = function(t0) {
  var e0 = this._transformState;
  e0.writechunk === null || e0.transforming ? e0.needTransform = !0 : (e0.transforming = !0, this._transform(e0.writechunk, e0.writeencoding, e0.afterTransform));
}, Hd.prototype._destroy = function(t0, e0) {
  jd.prototype._destroy.call(this, t0, function(n0) {
    e0(n0);
  });
};
var qd, Wd = Gd, Vd = Ld;
function Gd(t0) {
  if (!(this instanceof Gd))
    return new Gd(t0);
  Vd.call(this, t0);
}
fd(Gd, Vd), Gd.prototype._transform = function(t0, e0, n0) {
  n0(null, t0);
};
var Yd = Ql.codes, Zd = Yd.ERR_MISSING_ARGS, Jd = Yd.ERR_STREAM_DESTROYED;
function Xd(t0) {
  if (t0)
    throw t0;
}
function Qd(t0) {
  t0();
}
function eu(t0, e0) {
  return t0.pipe(e0);
}
var tu = function() {
  for (var t0 = arguments.length, e0 = new Array(t0), n0 = 0; n0 < t0; n0++)
    e0[n0] = arguments[n0];
  var r0, i0 = function(s0) {
    return s0.length ? typeof s0[s0.length - 1] != "function" ? Xd : s0.pop() : Xd;
  }(e0);
  if (Array.isArray(e0[0]) && (e0 = e0[0]), e0.length < 2)
    throw new Zd("streams");
  var o0 = e0.map(function(s0, a0) {
    var c0 = a0 < e0.length - 1;
    return function(l0, u0, d0, h0) {
      h0 = function(y0) {
        var E0 = !1;
        return function() {
          E0 || (E0 = !0, y0.apply(void 0, arguments));
        };
      }(h0);
      var g0 = !1;
      l0.on("close", function() {
        g0 = !0;
      }), qd === void 0 && (qd = Pd), qd(l0, { readable: u0, writable: d0 }, function(y0) {
        if (y0)
          return h0(y0);
        g0 = !0, h0();
      });
      var w0 = !1;
      return function(y0) {
        if (!g0 && !w0)
          return w0 = !0, function(E0) {
            return E0.setHeader && typeof E0.abort == "function";
          }(l0) ? l0.abort() : typeof l0.destroy == "function" ? l0.destroy() : void h0(y0 || new Jd("pipe"));
      };
    }(s0, c0, a0 > 0, function(l0) {
      r0 || (r0 = l0), l0 && o0.forEach(Qd), c0 || (o0.forEach(Qd), i0(r0));
    });
  });
  return e0.reduce(eu);
};
(function(t0, e0) {
  (e0 = rl.exports = Od()).Stream = e0, e0.Readable = e0, e0.Writable = gd(), e0.Duplex = md(), e0.Transform = Ld, e0.PassThrough = Wd, e0.finished = Pd, e0.pipeline = tu;
})(0, rl.exports);
var nu = rl.exports;
function ru(t0 = {}) {
  const e0 = {}, n0 = new nu.Duplex({ objectMode: !0, read: () => {
  }, write: function(o0, s0, a0) {
    let c0 = null;
    try {
      o0.id ? function(l0) {
        const { id: u0 } = l0;
        if (u0 === null)
          return;
        const d0 = e0[u0];
        if (!d0)
          return void console.warn(`StreamMiddleware - Unknown response id "${u0}"`);
        delete e0[u0], Object.assign(d0.res, l0), setTimeout(d0.end);
      }(o0) : function(l0) {
        t0?.retryOnMessage && l0.method === t0.retryOnMessage && Object.values(e0).forEach(({ req: u0, retryCount: d0 = 0 }) => {
          if (!u0.id)
            return;
          if (d0 >= 3)
            throw new Error(`StreamMiddleware - Retry limit exceeded for request id "${u0.id}"`);
          const h0 = e0[u0.id];
          h0 && (h0.retryCount = d0 + 1), i0(u0);
        }), r0.emit("notification", l0);
      }(o0);
    } catch (l0) {
      c0 = l0;
    }
    a0(c0);
  } }), r0 = new Ic();
  return { events: r0, middleware: (o0, s0, a0, c0) => {
    e0[o0.id] = { req: o0, res: s0, next: a0, end: c0 }, i0(o0);
  }, stream: n0 };
  function i0(o0) {
    n0.push(o0);
  }
}
var iu = {}, ou = { exports: {} }, su = function t0(e0, n0) {
  if (e0 && n0)
    return t0(e0)(n0);
  if (typeof e0 != "function")
    throw new TypeError("need wrapper function");
  return Object.keys(e0).forEach(function(i0) {
    r0[i0] = e0[i0];
  }), r0;
  function r0() {
    for (var i0 = new Array(arguments.length), o0 = 0; o0 < i0.length; o0++)
      i0[o0] = arguments[o0];
    var s0 = e0.apply(this, i0), a0 = i0[i0.length - 1];
    return typeof s0 == "function" && s0 !== a0 && Object.keys(a0).forEach(function(c0) {
      s0[c0] = a0[c0];
    }), s0;
  }
}, au = su;
function cu(t0) {
  var e0 = function() {
    return e0.called ? e0.value : (e0.called = !0, e0.value = t0.apply(this, arguments));
  };
  return e0.called = !1, e0;
}
function lu(t0) {
  var e0 = function() {
    if (e0.called)
      throw new Error(e0.onceError);
    return e0.called = !0, e0.value = t0.apply(this, arguments);
  }, n0 = t0.name || "Function wrapped with `once`";
  return e0.onceError = n0 + " shouldn't be called more than once", e0.called = !1, e0;
}
ou.exports = au(cu), ou.exports.strict = au(lu), cu.proto = cu(function() {
  Object.defineProperty(Function.prototype, "once", { value: function() {
    return cu(this);
  }, configurable: !0 }), Object.defineProperty(Function.prototype, "onceStrict", { value: function() {
    return lu(this);
  }, configurable: !0 });
});
var du = ou.exports, uu = {};
Object.defineProperty(uu, "__esModule", { value: !0 }), uu.Substream = void 0;
const hu = nu;
class fu extends hu.Duplex {
  constructor({ parent: e0, name: n0 }) {
    super({ objectMode: !0 }), this._parent = e0, this._name = n0;
  }
  _read() {
  }
  _write(e0, n0, r0) {
    this._parent.push({ name: this._name, data: e0 }), r0();
  }
}
uu.Substream = fu;
var pu = le$1 && le$1.__importDefault || function(t0) {
  return t0 && t0.__esModule ? t0 : { default: t0 };
};
Object.defineProperty(iu, "__esModule", { value: !0 }), iu.ObjectMultiplex = void 0;
const gu = nu, mu = pu(du), yu = uu, vu = Symbol("IGNORE_SUBSTREAM");
let bu = class extends gu.Duplex {
  constructor(t0 = {}) {
    super(Object.assign(Object.assign({}, t0), { objectMode: !0 })), this._substreams = {};
  }
  createStream(t0) {
    if (this.destroyed)
      throw new Error(`ObjectMultiplex - parent stream for name "${t0}" already destroyed`);
    if (this._readableState.ended || this._writableState.ended)
      throw new Error(`ObjectMultiplex - parent stream for name "${t0}" already ended`);
    if (!t0)
      throw new Error("ObjectMultiplex - name must not be empty");
    if (this._substreams[t0])
      throw new Error(`ObjectMultiplex - Substream for name "${t0}" already exists`);
    const e0 = new yu.Substream({ parent: this, name: t0 });
    return this._substreams[t0] = e0, function(n0, r0) {
      const i0 = (0, mu.default)(r0);
      (0, gu.finished)(n0, { readable: !1 }, i0), (0, gu.finished)(n0, { writable: !1 }, i0);
    }(this, (n0) => e0.destroy(n0 || void 0)), e0;
  }
  ignoreStream(t0) {
    if (!t0)
      throw new Error("ObjectMultiplex - name must not be empty");
    if (this._substreams[t0])
      throw new Error(`ObjectMultiplex - Substream for name "${t0}" already exists`);
    this._substreams[t0] = vu;
  }
  _read() {
  }
  _write(t0, e0, n0) {
    const { name: r0, data: i0 } = t0;
    if (!r0)
      return console.warn(`ObjectMultiplex - malformed chunk without name "${t0}"`), n0();
    const o0 = this._substreams[r0];
    return o0 ? (o0 !== vu && o0.push(i0), n0()) : (console.warn(`ObjectMultiplex - orphaned data for stream "${r0}"`), n0());
  }
};
iu.ObjectMultiplex = bu;
var wu = de$1(iu.ObjectMultiplex);
const Eu = (t0) => t0 !== null && typeof t0 == "object" && typeof t0.pipe == "function";
Eu.writable = (t0) => Eu(t0) && t0.writable !== !1 && typeof t0._write == "function" && typeof t0._writableState == "object", Eu.readable = (t0) => Eu(t0) && t0.readable !== !1 && typeof t0._read == "function" && typeof t0._readableState == "object", Eu.duplex = (t0) => Eu.writable(t0) && Eu.readable(t0), Eu.transform = (t0) => Eu.duplex(t0) && typeof t0._transform == "function";
var Su, _u = Eu, Cu = class extends nl {
  constructor(t0, { jsonRpcStreamName: e0, logger: n0 = console, maxEventListeners: r0 = 100, rpcMiddleware: i0 = [] }) {
    if (super({ logger: n0, maxEventListeners: r0, rpcMiddleware: i0 }), !_u.duplex(t0))
      throw new Error(ts.errors.invalidDuplexStream());
    this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);
    const o0 = new wu();
    nu.pipeline(t0, o0, t0, this._handleStreamDisconnect.bind(this, "MetaMask")), this._jsonRpcConnection = ru({ retryOnMessage: "METAMASK_EXTENSION_CONNECT_CAN_RETRY" }), nu.pipeline(this._jsonRpcConnection.stream, o0.createStream(e0), this._jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, "MetaMask RpcProvider")), this._rpcEngine.push(this._jsonRpcConnection.middleware), this._jsonRpcConnection.events.on("notification", (s0) => {
      const { method: a0, params: c0 } = s0;
      a0 === "metamask_accountsChanged" ? this._handleAccountsChanged(c0) : a0 === "metamask_unlockStateChanged" ? this._handleUnlockStateChanged(c0) : a0 === "metamask_chainChanged" ? this._handleChainChanged(c0) : Oc.includes(a0) ? this.emit("message", { type: a0, data: c0 }) : a0 === "METAMASK_STREAM_FAILURE" && t0.destroy(new Error(ts.errors.permanentlyDisconnected()));
    });
  }
  async _initializeStateAsync() {
    let t0;
    try {
      t0 = await this.request({ method: "metamask_getProviderState" });
    } catch (e0) {
      this._log.error("MetaMask: Failed to get initial state. Please report this bug.", e0);
    }
    this._initializeState(t0);
  }
  _handleStreamDisconnect(t0, e0) {
    let n0 = `MetaMask: Lost connection to "${t0}".`;
    e0?.stack && (n0 += `
${e0.stack}`), this._log.warn(n0), this.listenerCount("error") > 0 && this.emit("error", n0), this._handleDisconnect(!1, e0 ? e0.message : void 0);
  }
  _handleChainChanged({ chainId: t0, networkVersion: e0 } = {}) {
    Dc(t0) && ((n0) => !!n0 && typeof n0 == "string")(e0) ? e0 === "loading" ? this._handleDisconnect(!0) : super._handleChainChanged({ chainId: t0 }) : this._log.error(ts.errors.invalidNetworkParams(), { chainId: t0, networkVersion: e0 });
  }
}, ku = class extends Cu {
  constructor(t0, { jsonRpcStreamName: e0 = "metamask-provider", logger: n0 = console, maxEventListeners: r0 = 100, shouldSendMetadata: i0 } = {}) {
    if (super(t0, { jsonRpcStreamName: e0, logger: n0, maxEventListeners: r0, rpcMiddleware: Lc(n0) }), this._sentWarnings = { chainId: !1, networkVersion: !1, selectedAddress: !1, enable: !1, experimentalMethods: !1, send: !1, events: { close: !1, data: !1, networkChanged: !1, notification: !1 } }, qc(this, Su, void 0), this._initializeStateAsync(), Wc(this, Su, null), this.isMetaMask = !0, this._sendSync = this._sendSync.bind(this), this.enable = this.enable.bind(this), this.send = this.send.bind(this), this.sendAsync = this.sendAsync.bind(this), this._warnOfDeprecation = this._warnOfDeprecation.bind(this), this._metamask = this._getExperimentalApi(), this._jsonRpcConnection.events.on("notification", (o0) => {
      const { method: s0 } = o0;
      Oc.includes(s0) && (this.emit("data", o0), this.emit("notification", o0.params.result));
    }), i0)
      if (document.readyState === "complete")
        Kc(this._rpcEngine, this._log);
      else {
        const o0 = () => {
          Kc(this._rpcEngine, this._log), window.removeEventListener("DOMContentLoaded", o0);
        };
        window.addEventListener("DOMContentLoaded", o0);
      }
  }
  get chainId() {
    return this._sentWarnings.chainId || (this._log.warn(ts.warnings.chainIdDeprecation), this._sentWarnings.chainId = !0), super.chainId;
  }
  get networkVersion() {
    return this._sentWarnings.networkVersion || (this._log.warn(ts.warnings.networkVersionDeprecation), this._sentWarnings.networkVersion = !0), zc(this, Su);
  }
  get selectedAddress() {
    return this._sentWarnings.selectedAddress || (this._log.warn(ts.warnings.selectedAddressDeprecation), this._sentWarnings.selectedAddress = !0), super.selectedAddress;
  }
  sendAsync(t0, e0) {
    this._rpcRequest(t0, e0);
  }
  addListener(t0, e0) {
    return this._warnOfDeprecation(t0), super.addListener(t0, e0);
  }
  on(t0, e0) {
    return this._warnOfDeprecation(t0), super.on(t0, e0);
  }
  once(t0, e0) {
    return this._warnOfDeprecation(t0), super.once(t0, e0);
  }
  prependListener(t0, e0) {
    return this._warnOfDeprecation(t0), super.prependListener(t0, e0);
  }
  prependOnceListener(t0, e0) {
    return this._warnOfDeprecation(t0), super.prependOnceListener(t0, e0);
  }
  _handleDisconnect(t0, e0) {
    super._handleDisconnect(t0, e0), zc(this, Su) && !t0 && Wc(this, Su, null);
  }
  _warnOfDeprecation(t0) {
    this._sentWarnings?.events[t0] === !1 && (this._log.warn(ts.warnings.events[t0]), this._sentWarnings.events[t0] = !0);
  }
  async enable() {
    return this._sentWarnings.enable || (this._log.warn(ts.warnings.enableDeprecation), this._sentWarnings.enable = !0), new Promise((t0, e0) => {
      try {
        this._rpcRequest({ method: "eth_requestAccounts", params: [] }, $c(t0, e0));
      } catch (n0) {
        e0(n0);
      }
    });
  }
  send(t0, e0) {
    return this._sentWarnings.send || (this._log.warn(ts.warnings.sendDeprecation), this._sentWarnings.send = !0), typeof t0 != "string" || e0 && !Array.isArray(e0) ? t0 && typeof t0 == "object" && typeof e0 == "function" ? this._rpcRequest(t0, e0) : this._sendSync(t0) : new Promise((n0, r0) => {
      try {
        this._rpcRequest({ method: t0, params: e0 }, $c(n0, r0, !1));
      } catch (i0) {
        r0(i0);
      }
    });
  }
  _sendSync(t0) {
    let e0;
    switch (t0.method) {
      case "eth_accounts":
        e0 = this.selectedAddress ? [this.selectedAddress] : [];
        break;
      case "eth_coinbase":
        e0 = this.selectedAddress ?? null;
        break;
      case "eth_uninstallFilter":
        this._rpcRequest(t0, Bc), e0 = !0;
        break;
      case "net_version":
        e0 = zc(this, Su) ?? null;
        break;
      default:
        throw new Error(ts.errors.unsupportedSync(t0.method));
    }
    return { id: t0.id, jsonrpc: t0.jsonrpc, result: e0 };
  }
  _getExperimentalApi() {
    return new Proxy({ isUnlocked: async () => (this._state.initialized || await new Promise((t0) => {
      this.on("_initialized", () => t0());
    }), this._state.isUnlocked), requestBatch: async (t0) => {
      if (!Array.isArray(t0))
        throw Za({ message: "Batch requests must be made with an array of request objects.", data: t0 });
      return new Promise((e0, n0) => {
        this._rpcRequest(t0, $c(e0, n0));
      });
    } }, { get: (t0, e0, ...n0) => (this._sentWarnings.experimentalMethods || (this._log.warn(ts.warnings.experimentalMethods), this._sentWarnings.experimentalMethods = !0), Reflect.get(t0, e0, ...n0)) });
  }
  _handleChainChanged({ chainId: t0, networkVersion: e0 } = {}) {
    super._handleChainChanged({ chainId: t0, networkVersion: e0 }), this._state.isConnected && e0 !== zc(this, Su) && (Wc(this, Su, e0), this._state.initialized && this.emit("networkChanged", zc(this, Su)));
  }
};
Su = /* @__PURE__ */ new WeakMap();
const xu = t("MM_SDK");
xu.color = "#FFAC1C";
var Mu = {}, Au = {};
Object.defineProperty(Au, "__esModule", { value: !0 }), Au.EthereumProviderError = Au.EthereumRpcError = void 0;
const Iu = La;
class Ru extends Error {
  constructor(e0, n0, r0) {
    if (!Number.isInteger(e0))
      throw new Error('"code" must be an integer.');
    if (!n0 || typeof n0 != "string")
      throw new Error('"message" must be a nonempty string.');
    super(n0), this.code = e0, r0 !== void 0 && (this.data = r0);
  }
  serialize() {
    const e0 = { code: this.code, message: this.message };
    return this.data !== void 0 && (e0.data = this.data), this.stack && (e0.stack = this.stack), e0;
  }
  toString() {
    return Iu.default(this.serialize(), Pu, 2);
  }
}
Au.EthereumRpcError = Ru;
function Pu(t0, e0) {
  if (e0 !== "[Circular]")
    return e0;
}
Au.EthereumProviderError = class extends Ru {
  constructor(t0, e0, n0) {
    if (!function(r0) {
      return Number.isInteger(r0) && r0 >= 1e3 && r0 <= 4999;
    }(t0))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(t0, e0, n0);
  }
};
var Tu = {}, Ou = {};
Object.defineProperty(Ou, "__esModule", { value: !0 }), Ou.errorValues = Ou.errorCodes = void 0, Ou.errorCodes = { rpc: { invalidInput: -32e3, resourceNotFound: -32001, resourceUnavailable: -32002, transactionRejected: -32003, methodNotSupported: -32004, limitExceeded: -32005, parse: -32700, invalidRequest: -32600, methodNotFound: -32601, invalidParams: -32602, internal: -32603 }, provider: { userRejectedRequest: 4001, unauthorized: 4100, unsupportedMethod: 4200, disconnected: 4900, chainDisconnected: 4901 } }, Ou.errorValues = { "-32700": { standard: "JSON RPC 2.0", message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text." }, "-32600": { standard: "JSON RPC 2.0", message: "The JSON sent is not a valid Request object." }, "-32601": { standard: "JSON RPC 2.0", message: "The method does not exist / is not available." }, "-32602": { standard: "JSON RPC 2.0", message: "Invalid method parameter(s)." }, "-32603": { standard: "JSON RPC 2.0", message: "Internal JSON-RPC error." }, "-32000": { standard: "EIP-1474", message: "Invalid input." }, "-32001": { standard: "EIP-1474", message: "Resource not found." }, "-32002": { standard: "EIP-1474", message: "Resource unavailable." }, "-32003": { standard: "EIP-1474", message: "Transaction rejected." }, "-32004": { standard: "EIP-1474", message: "Method not supported." }, "-32005": { standard: "EIP-1474", message: "Request limit exceeded." }, 4001: { standard: "EIP-1193", message: "User rejected the request." }, 4100: { standard: "EIP-1193", message: "The requested account and/or method has not been authorized by the user." }, 4200: { standard: "EIP-1193", message: "The requested method is not supported by this Ethereum provider." }, 4900: { standard: "EIP-1193", message: "The provider is disconnected from all chains." }, 4901: { standard: "EIP-1193", message: "The provider is disconnected from the specified chain." } }, function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.serializeError = t0.isValidCode = t0.getMessageFromCode = t0.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const e0 = Ou, n0 = Au, r0 = e0.errorCodes.rpc.internal, i0 = "Unspecified error message. This is a bug, please report it.", o0 = { code: r0, message: s0(r0) };
  function s0(d0, h0 = i0) {
    if (Number.isInteger(d0)) {
      const g0 = d0.toString();
      if (u0(e0.errorValues, g0))
        return e0.errorValues[g0].message;
      if (c0(d0))
        return t0.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return h0;
  }
  function a0(d0) {
    if (!Number.isInteger(d0))
      return !1;
    const h0 = d0.toString();
    return !!e0.errorValues[h0] || !!c0(d0);
  }
  function c0(d0) {
    return d0 >= -32099 && d0 <= -32e3;
  }
  function l0(d0) {
    return d0 && typeof d0 == "object" && !Array.isArray(d0) ? Object.assign({}, d0) : d0;
  }
  function u0(d0, h0) {
    return Object.prototype.hasOwnProperty.call(d0, h0);
  }
  t0.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.", t0.getMessageFromCode = s0, t0.isValidCode = a0, t0.serializeError = function(d0, { fallbackError: h0 = o0, shouldIncludeStack: g0 = !1 } = {}) {
    var w0, y0;
    if (!h0 || !Number.isInteger(h0.code) || typeof h0.message != "string")
      throw new Error("Must provide fallback error with integer number code and string message.");
    if (d0 instanceof n0.EthereumRpcError)
      return d0.serialize();
    const E0 = {};
    if (d0 && typeof d0 == "object" && !Array.isArray(d0) && u0(d0, "code") && a0(d0.code)) {
      const O0 = d0;
      E0.code = O0.code, O0.message && typeof O0.message == "string" ? (E0.message = O0.message, u0(O0, "data") && (E0.data = O0.data)) : (E0.message = s0(E0.code), E0.data = { originalError: l0(d0) });
    } else {
      E0.code = h0.code;
      const O0 = (w0 = d0) === null || w0 === void 0 ? void 0 : w0.message;
      E0.message = O0 && typeof O0 == "string" ? O0 : h0.message, E0.data = { originalError: l0(d0) };
    }
    const b0 = (y0 = d0) === null || y0 === void 0 ? void 0 : y0.stack;
    return g0 && d0 && b0 && typeof b0 == "string" && (E0.stack = b0), E0;
  };
}(Tu);
var Lu = {};
Object.defineProperty(Lu, "__esModule", { value: !0 }), Lu.ethErrors = void 0;
const Nu = Au, $u = Tu, Du = Ou;
function Bu(t0, e0) {
  const [n0, r0] = ju(e0);
  return new Nu.EthereumRpcError(t0, n0 || $u.getMessageFromCode(t0), r0);
}
function Ku(t0, e0) {
  const [n0, r0] = ju(e0);
  return new Nu.EthereumProviderError(t0, n0 || $u.getMessageFromCode(t0), r0);
}
function ju(t0) {
  if (t0) {
    if (typeof t0 == "string")
      return [t0];
    if (typeof t0 == "object" && !Array.isArray(t0)) {
      const { message: e0, data: n0 } = t0;
      if (e0 && typeof e0 != "string")
        throw new Error("Must specify string message.");
      return [e0 || void 0, n0];
    }
  }
  return [];
}
Lu.ethErrors = { rpc: { parse: (t0) => Bu(Du.errorCodes.rpc.parse, t0), invalidRequest: (t0) => Bu(Du.errorCodes.rpc.invalidRequest, t0), invalidParams: (t0) => Bu(Du.errorCodes.rpc.invalidParams, t0), methodNotFound: (t0) => Bu(Du.errorCodes.rpc.methodNotFound, t0), internal: (t0) => Bu(Du.errorCodes.rpc.internal, t0), server: (t0) => {
  if (!t0 || typeof t0 != "object" || Array.isArray(t0))
    throw new Error("Ethereum RPC Server errors must provide single object argument.");
  const { code: e0 } = t0;
  if (!Number.isInteger(e0) || e0 > -32005 || e0 < -32099)
    throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
  return Bu(e0, t0);
}, invalidInput: (t0) => Bu(Du.errorCodes.rpc.invalidInput, t0), resourceNotFound: (t0) => Bu(Du.errorCodes.rpc.resourceNotFound, t0), resourceUnavailable: (t0) => Bu(Du.errorCodes.rpc.resourceUnavailable, t0), transactionRejected: (t0) => Bu(Du.errorCodes.rpc.transactionRejected, t0), methodNotSupported: (t0) => Bu(Du.errorCodes.rpc.methodNotSupported, t0), limitExceeded: (t0) => Bu(Du.errorCodes.rpc.limitExceeded, t0) }, provider: { userRejectedRequest: (t0) => Ku(Du.errorCodes.provider.userRejectedRequest, t0), unauthorized: (t0) => Ku(Du.errorCodes.provider.unauthorized, t0), unsupportedMethod: (t0) => Ku(Du.errorCodes.provider.unsupportedMethod, t0), disconnected: (t0) => Ku(Du.errorCodes.provider.disconnected, t0), chainDisconnected: (t0) => Ku(Du.errorCodes.provider.chainDisconnected, t0), custom: (t0) => {
  if (!t0 || typeof t0 != "object" || Array.isArray(t0))
    throw new Error("Ethereum Provider custom errors must provide single object argument.");
  const { code: e0, message: n0, data: r0 } = t0;
  if (!n0 || typeof n0 != "string")
    throw new Error('"message" must be a nonempty string');
  return new Nu.EthereumProviderError(e0, n0, r0);
} } }, function(t0) {
  Object.defineProperty(t0, "__esModule", { value: !0 }), t0.getMessageFromCode = t0.serializeError = t0.EthereumProviderError = t0.EthereumRpcError = t0.ethErrors = t0.errorCodes = void 0;
  const e0 = Au;
  Object.defineProperty(t0, "EthereumRpcError", { enumerable: !0, get: function() {
    return e0.EthereumRpcError;
  } }), Object.defineProperty(t0, "EthereumProviderError", { enumerable: !0, get: function() {
    return e0.EthereumProviderError;
  } });
  const n0 = Tu;
  Object.defineProperty(t0, "serializeError", { enumerable: !0, get: function() {
    return n0.serializeError;
  } }), Object.defineProperty(t0, "getMessageFromCode", { enumerable: !0, get: function() {
    return n0.getMessageFromCode;
  } });
  const r0 = Lu;
  Object.defineProperty(t0, "ethErrors", { enumerable: !0, get: function() {
    return r0.ethErrors;
  } });
  const i0 = Ou;
  Object.defineProperty(t0, "errorCodes", { enumerable: !0, get: function() {
    return i0.errorCodes;
  } });
}(Mu);
var Uu = { exports: {} };
Uu.exports = function(t0) {
  var e0 = {};
  function n0(r0) {
    if (e0[r0])
      return e0[r0].exports;
    var i0 = e0[r0] = { i: r0, l: !1, exports: {} };
    return t0[r0].call(i0.exports, i0, i0.exports, n0), i0.l = !0, i0.exports;
  }
  return n0.m = t0, n0.c = e0, n0.d = function(r0, i0, o0) {
    n0.o(r0, i0) || Object.defineProperty(r0, i0, { enumerable: !0, get: o0 });
  }, n0.r = function(r0) {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(r0, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(r0, "__esModule", { value: !0 });
  }, n0.t = function(r0, i0) {
    if (1 & i0 && (r0 = n0(r0)), 8 & i0 || 4 & i0 && typeof r0 == "object" && r0 && r0.__esModule)
      return r0;
    var o0 = /* @__PURE__ */ Object.create(null);
    if (n0.r(o0), Object.defineProperty(o0, "default", { enumerable: !0, value: r0 }), 2 & i0 && typeof r0 != "string")
      for (var s0 in r0)
        n0.d(o0, s0, function(a0) {
          return r0[a0];
        }.bind(null, s0));
    return o0;
  }, n0.n = function(r0) {
    var i0 = r0 && r0.__esModule ? function() {
      return r0.default;
    } : function() {
      return r0;
    };
    return n0.d(i0, "a", i0), i0;
  }, n0.o = function(r0, i0) {
    return Object.prototype.hasOwnProperty.call(r0, i0);
  }, n0.p = "", n0(n0.s = 90);
}({ 17: function(t0, e0, n0) {
  e0.__esModule = !0, e0.default = void 0;
  var r0 = n0(18), i0 = function() {
    function o0() {
    }
    return o0.getFirstMatch = function(s0, a0) {
      var c0 = a0.match(s0);
      return c0 && c0.length > 0 && c0[1] || "";
    }, o0.getSecondMatch = function(s0, a0) {
      var c0 = a0.match(s0);
      return c0 && c0.length > 1 && c0[2] || "";
    }, o0.matchAndReturnConst = function(s0, a0, c0) {
      if (s0.test(a0))
        return c0;
    }, o0.getWindowsVersionName = function(s0) {
      switch (s0) {
        case "NT":
          return "NT";
        case "XP":
        case "NT 5.1":
          return "XP";
        case "NT 5.0":
          return "2000";
        case "NT 5.2":
          return "2003";
        case "NT 6.0":
          return "Vista";
        case "NT 6.1":
          return "7";
        case "NT 6.2":
          return "8";
        case "NT 6.3":
          return "8.1";
        case "NT 10.0":
          return "10";
        default:
          return;
      }
    }, o0.getMacOSVersionName = function(s0) {
      var a0 = s0.split(".").splice(0, 2).map(function(c0) {
        return parseInt(c0, 10) || 0;
      });
      if (a0.push(0), a0[0] === 10)
        switch (a0[1]) {
          case 5:
            return "Leopard";
          case 6:
            return "Snow Leopard";
          case 7:
            return "Lion";
          case 8:
            return "Mountain Lion";
          case 9:
            return "Mavericks";
          case 10:
            return "Yosemite";
          case 11:
            return "El Capitan";
          case 12:
            return "Sierra";
          case 13:
            return "High Sierra";
          case 14:
            return "Mojave";
          case 15:
            return "Catalina";
          default:
            return;
        }
    }, o0.getAndroidVersionName = function(s0) {
      var a0 = s0.split(".").splice(0, 2).map(function(c0) {
        return parseInt(c0, 10) || 0;
      });
      if (a0.push(0), !(a0[0] === 1 && a0[1] < 5))
        return a0[0] === 1 && a0[1] < 6 ? "Cupcake" : a0[0] === 1 && a0[1] >= 6 ? "Donut" : a0[0] === 2 && a0[1] < 2 ? "Eclair" : a0[0] === 2 && a0[1] === 2 ? "Froyo" : a0[0] === 2 && a0[1] > 2 ? "Gingerbread" : a0[0] === 3 ? "Honeycomb" : a0[0] === 4 && a0[1] < 1 ? "Ice Cream Sandwich" : a0[0] === 4 && a0[1] < 4 ? "Jelly Bean" : a0[0] === 4 && a0[1] >= 4 ? "KitKat" : a0[0] === 5 ? "Lollipop" : a0[0] === 6 ? "Marshmallow" : a0[0] === 7 ? "Nougat" : a0[0] === 8 ? "Oreo" : a0[0] === 9 ? "Pie" : void 0;
    }, o0.getVersionPrecision = function(s0) {
      return s0.split(".").length;
    }, o0.compareVersions = function(s0, a0, c0) {
      c0 === void 0 && (c0 = !1);
      var l0 = o0.getVersionPrecision(s0), u0 = o0.getVersionPrecision(a0), d0 = Math.max(l0, u0), h0 = 0, g0 = o0.map([s0, a0], function(w0) {
        var y0 = d0 - o0.getVersionPrecision(w0), E0 = w0 + new Array(y0 + 1).join(".0");
        return o0.map(E0.split("."), function(b0) {
          return new Array(20 - b0.length).join("0") + b0;
        }).reverse();
      });
      for (c0 && (h0 = d0 - Math.min(l0, u0)), d0 -= 1; d0 >= h0; ) {
        if (g0[0][d0] > g0[1][d0])
          return 1;
        if (g0[0][d0] === g0[1][d0]) {
          if (d0 === h0)
            return 0;
          d0 -= 1;
        } else if (g0[0][d0] < g0[1][d0])
          return -1;
      }
    }, o0.map = function(s0, a0) {
      var c0, l0 = [];
      if (Array.prototype.map)
        return Array.prototype.map.call(s0, a0);
      for (c0 = 0; c0 < s0.length; c0 += 1)
        l0.push(a0(s0[c0]));
      return l0;
    }, o0.find = function(s0, a0) {
      var c0, l0;
      if (Array.prototype.find)
        return Array.prototype.find.call(s0, a0);
      for (c0 = 0, l0 = s0.length; c0 < l0; c0 += 1) {
        var u0 = s0[c0];
        if (a0(u0, c0))
          return u0;
      }
    }, o0.assign = function(s0) {
      for (var a0, c0, l0 = s0, u0 = arguments.length, d0 = new Array(u0 > 1 ? u0 - 1 : 0), h0 = 1; h0 < u0; h0++)
        d0[h0 - 1] = arguments[h0];
      if (Object.assign)
        return Object.assign.apply(Object, [s0].concat(d0));
      var g0 = function() {
        var w0 = d0[a0];
        typeof w0 == "object" && w0 !== null && Object.keys(w0).forEach(function(y0) {
          l0[y0] = w0[y0];
        });
      };
      for (a0 = 0, c0 = d0.length; a0 < c0; a0 += 1)
        g0();
      return s0;
    }, o0.getBrowserAlias = function(s0) {
      return r0.BROWSER_ALIASES_MAP[s0];
    }, o0.getBrowserTypeByAlias = function(s0) {
      return r0.BROWSER_MAP[s0] || "";
    }, o0;
  }();
  e0.default = i0, t0.exports = e0.default;
}, 18: function(t0, e0, n0) {
  e0.__esModule = !0, e0.ENGINE_MAP = e0.OS_MAP = e0.PLATFORMS_MAP = e0.BROWSER_MAP = e0.BROWSER_ALIASES_MAP = void 0, e0.BROWSER_ALIASES_MAP = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" }, e0.BROWSER_MAP = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" }, e0.PLATFORMS_MAP = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" }, e0.OS_MAP = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" }, e0.ENGINE_MAP = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
}, 90: function(t0, e0, n0) {
  e0.__esModule = !0, e0.default = void 0;
  var r0, i0 = (r0 = n0(91)) && r0.__esModule ? r0 : { default: r0 }, o0 = n0(18);
  function s0(c0, l0) {
    for (var u0 = 0; u0 < l0.length; u0++) {
      var d0 = l0[u0];
      d0.enumerable = d0.enumerable || !1, d0.configurable = !0, "value" in d0 && (d0.writable = !0), Object.defineProperty(c0, d0.key, d0);
    }
  }
  var a0 = function() {
    function c0() {
    }
    var l0, u0, d0;
    return c0.getParser = function(h0, g0) {
      if (g0 === void 0 && (g0 = !1), typeof h0 != "string")
        throw new Error("UserAgent should be a string");
      return new i0.default(h0, g0);
    }, c0.parse = function(h0) {
      return new i0.default(h0).getResult();
    }, l0 = c0, d0 = [{ key: "BROWSER_MAP", get: function() {
      return o0.BROWSER_MAP;
    } }, { key: "ENGINE_MAP", get: function() {
      return o0.ENGINE_MAP;
    } }, { key: "OS_MAP", get: function() {
      return o0.OS_MAP;
    } }, { key: "PLATFORMS_MAP", get: function() {
      return o0.PLATFORMS_MAP;
    } }], (u0 = null) && s0(l0.prototype, u0), d0 && s0(l0, d0), c0;
  }();
  e0.default = a0, t0.exports = e0.default;
}, 91: function(t0, e0, n0) {
  e0.__esModule = !0, e0.default = void 0;
  var r0 = c0(n0(92)), i0 = c0(n0(93)), o0 = c0(n0(94)), s0 = c0(n0(95)), a0 = c0(n0(17));
  function c0(u0) {
    return u0 && u0.__esModule ? u0 : { default: u0 };
  }
  var l0 = function() {
    function u0(h0, g0) {
      if (g0 === void 0 && (g0 = !1), h0 == null || h0 === "")
        throw new Error("UserAgent parameter can't be empty");
      this._ua = h0, this.parsedResult = {}, g0 !== !0 && this.parse();
    }
    var d0 = u0.prototype;
    return d0.getUA = function() {
      return this._ua;
    }, d0.test = function(h0) {
      return h0.test(this._ua);
    }, d0.parseBrowser = function() {
      var h0 = this;
      this.parsedResult.browser = {};
      var g0 = a0.default.find(r0.default, function(w0) {
        if (typeof w0.test == "function")
          return w0.test(h0);
        if (w0.test instanceof Array)
          return w0.test.some(function(y0) {
            return h0.test(y0);
          });
        throw new Error("Browser's test function is not valid");
      });
      return g0 && (this.parsedResult.browser = g0.describe(this.getUA())), this.parsedResult.browser;
    }, d0.getBrowser = function() {
      return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
    }, d0.getBrowserName = function(h0) {
      return h0 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
    }, d0.getBrowserVersion = function() {
      return this.getBrowser().version;
    }, d0.getOS = function() {
      return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
    }, d0.parseOS = function() {
      var h0 = this;
      this.parsedResult.os = {};
      var g0 = a0.default.find(i0.default, function(w0) {
        if (typeof w0.test == "function")
          return w0.test(h0);
        if (w0.test instanceof Array)
          return w0.test.some(function(y0) {
            return h0.test(y0);
          });
        throw new Error("Browser's test function is not valid");
      });
      return g0 && (this.parsedResult.os = g0.describe(this.getUA())), this.parsedResult.os;
    }, d0.getOSName = function(h0) {
      var g0 = this.getOS().name;
      return h0 ? String(g0).toLowerCase() || "" : g0 || "";
    }, d0.getOSVersion = function() {
      return this.getOS().version;
    }, d0.getPlatform = function() {
      return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
    }, d0.getPlatformType = function(h0) {
      h0 === void 0 && (h0 = !1);
      var g0 = this.getPlatform().type;
      return h0 ? String(g0).toLowerCase() || "" : g0 || "";
    }, d0.parsePlatform = function() {
      var h0 = this;
      this.parsedResult.platform = {};
      var g0 = a0.default.find(o0.default, function(w0) {
        if (typeof w0.test == "function")
          return w0.test(h0);
        if (w0.test instanceof Array)
          return w0.test.some(function(y0) {
            return h0.test(y0);
          });
        throw new Error("Browser's test function is not valid");
      });
      return g0 && (this.parsedResult.platform = g0.describe(this.getUA())), this.parsedResult.platform;
    }, d0.getEngine = function() {
      return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
    }, d0.getEngineName = function(h0) {
      return h0 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
    }, d0.parseEngine = function() {
      var h0 = this;
      this.parsedResult.engine = {};
      var g0 = a0.default.find(s0.default, function(w0) {
        if (typeof w0.test == "function")
          return w0.test(h0);
        if (w0.test instanceof Array)
          return w0.test.some(function(y0) {
            return h0.test(y0);
          });
        throw new Error("Browser's test function is not valid");
      });
      return g0 && (this.parsedResult.engine = g0.describe(this.getUA())), this.parsedResult.engine;
    }, d0.parse = function() {
      return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
    }, d0.getResult = function() {
      return a0.default.assign({}, this.parsedResult);
    }, d0.satisfies = function(h0) {
      var g0 = this, w0 = {}, y0 = 0, E0 = {}, b0 = 0;
      if (Object.keys(h0).forEach(function(U0) {
        var F0 = h0[U0];
        typeof F0 == "string" ? (E0[U0] = F0, b0 += 1) : typeof F0 == "object" && (w0[U0] = F0, y0 += 1);
      }), y0 > 0) {
        var O0 = Object.keys(w0), S0 = a0.default.find(O0, function(U0) {
          return g0.isOS(U0);
        });
        if (S0) {
          var k0 = this.satisfies(w0[S0]);
          if (k0 !== void 0)
            return k0;
        }
        var D0 = a0.default.find(O0, function(U0) {
          return g0.isPlatform(U0);
        });
        if (D0) {
          var z0 = this.satisfies(w0[D0]);
          if (z0 !== void 0)
            return z0;
        }
      }
      if (b0 > 0) {
        var G0 = Object.keys(E0), K0 = a0.default.find(G0, function(U0) {
          return g0.isBrowser(U0, !0);
        });
        if (K0 !== void 0)
          return this.compareVersion(E0[K0]);
      }
    }, d0.isBrowser = function(h0, g0) {
      g0 === void 0 && (g0 = !1);
      var w0 = this.getBrowserName().toLowerCase(), y0 = h0.toLowerCase(), E0 = a0.default.getBrowserTypeByAlias(y0);
      return g0 && E0 && (y0 = E0.toLowerCase()), y0 === w0;
    }, d0.compareVersion = function(h0) {
      var g0 = [0], w0 = h0, y0 = !1, E0 = this.getBrowserVersion();
      if (typeof E0 == "string")
        return h0[0] === ">" || h0[0] === "<" ? (w0 = h0.substr(1), h0[1] === "=" ? (y0 = !0, w0 = h0.substr(2)) : g0 = [], h0[0] === ">" ? g0.push(1) : g0.push(-1)) : h0[0] === "=" ? w0 = h0.substr(1) : h0[0] === "~" && (y0 = !0, w0 = h0.substr(1)), g0.indexOf(a0.default.compareVersions(E0, w0, y0)) > -1;
    }, d0.isOS = function(h0) {
      return this.getOSName(!0) === String(h0).toLowerCase();
    }, d0.isPlatform = function(h0) {
      return this.getPlatformType(!0) === String(h0).toLowerCase();
    }, d0.isEngine = function(h0) {
      return this.getEngineName(!0) === String(h0).toLowerCase();
    }, d0.is = function(h0, g0) {
      return g0 === void 0 && (g0 = !1), this.isBrowser(h0, g0) || this.isOS(h0) || this.isPlatform(h0);
    }, d0.some = function(h0) {
      var g0 = this;
      return h0 === void 0 && (h0 = []), h0.some(function(w0) {
        return g0.is(w0);
      });
    }, u0;
  }();
  e0.default = l0, t0.exports = e0.default;
}, 92: function(t0, e0, n0) {
  e0.__esModule = !0, e0.default = void 0;
  var r0, i0 = (r0 = n0(17)) && r0.__esModule ? r0 : { default: r0 }, o0 = /version\/(\d+(\.?_?\d+)+)/i, s0 = [{ test: [/googlebot/i], describe: function(a0) {
    var c0 = { name: "Googlebot" }, l0 = i0.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, a0) || i0.default.getFirstMatch(o0, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/opera/i], describe: function(a0) {
    var c0 = { name: "Opera" }, l0 = i0.default.getFirstMatch(o0, a0) || i0.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/opr\/|opios/i], describe: function(a0) {
    var c0 = { name: "Opera" }, l0 = i0.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, a0) || i0.default.getFirstMatch(o0, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/SamsungBrowser/i], describe: function(a0) {
    var c0 = { name: "Samsung Internet for Android" }, l0 = i0.default.getFirstMatch(o0, a0) || i0.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/Whale/i], describe: function(a0) {
    var c0 = { name: "NAVER Whale Browser" }, l0 = i0.default.getFirstMatch(o0, a0) || i0.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/MZBrowser/i], describe: function(a0) {
    var c0 = { name: "MZ Browser" }, l0 = i0.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, a0) || i0.default.getFirstMatch(o0, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/focus/i], describe: function(a0) {
    var c0 = { name: "Focus" }, l0 = i0.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, a0) || i0.default.getFirstMatch(o0, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/swing/i], describe: function(a0) {
    var c0 = { name: "Swing" }, l0 = i0.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, a0) || i0.default.getFirstMatch(o0, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/coast/i], describe: function(a0) {
    var c0 = { name: "Opera Coast" }, l0 = i0.default.getFirstMatch(o0, a0) || i0.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe: function(a0) {
    var c0 = { name: "Opera Touch" }, l0 = i0.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, a0) || i0.default.getFirstMatch(o0, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/yabrowser/i], describe: function(a0) {
    var c0 = { name: "Yandex Browser" }, l0 = i0.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, a0) || i0.default.getFirstMatch(o0, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/ucbrowser/i], describe: function(a0) {
    var c0 = { name: "UC Browser" }, l0 = i0.default.getFirstMatch(o0, a0) || i0.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/Maxthon|mxios/i], describe: function(a0) {
    var c0 = { name: "Maxthon" }, l0 = i0.default.getFirstMatch(o0, a0) || i0.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/epiphany/i], describe: function(a0) {
    var c0 = { name: "Epiphany" }, l0 = i0.default.getFirstMatch(o0, a0) || i0.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/puffin/i], describe: function(a0) {
    var c0 = { name: "Puffin" }, l0 = i0.default.getFirstMatch(o0, a0) || i0.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/sleipnir/i], describe: function(a0) {
    var c0 = { name: "Sleipnir" }, l0 = i0.default.getFirstMatch(o0, a0) || i0.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/k-meleon/i], describe: function(a0) {
    var c0 = { name: "K-Meleon" }, l0 = i0.default.getFirstMatch(o0, a0) || i0.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/micromessenger/i], describe: function(a0) {
    var c0 = { name: "WeChat" }, l0 = i0.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, a0) || i0.default.getFirstMatch(o0, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/qqbrowser/i], describe: function(a0) {
    var c0 = { name: /qqbrowserlite/i.test(a0) ? "QQ Browser Lite" : "QQ Browser" }, l0 = i0.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, a0) || i0.default.getFirstMatch(o0, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/msie|trident/i], describe: function(a0) {
    var c0 = { name: "Internet Explorer" }, l0 = i0.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/\sedg\//i], describe: function(a0) {
    var c0 = { name: "Microsoft Edge" }, l0 = i0.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/edg([ea]|ios)/i], describe: function(a0) {
    var c0 = { name: "Microsoft Edge" }, l0 = i0.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/vivaldi/i], describe: function(a0) {
    var c0 = { name: "Vivaldi" }, l0 = i0.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/seamonkey/i], describe: function(a0) {
    var c0 = { name: "SeaMonkey" }, l0 = i0.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/sailfish/i], describe: function(a0) {
    var c0 = { name: "Sailfish" }, l0 = i0.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/silk/i], describe: function(a0) {
    var c0 = { name: "Amazon Silk" }, l0 = i0.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/phantom/i], describe: function(a0) {
    var c0 = { name: "PhantomJS" }, l0 = i0.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/slimerjs/i], describe: function(a0) {
    var c0 = { name: "SlimerJS" }, l0 = i0.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(a0) {
    var c0 = { name: "BlackBerry" }, l0 = i0.default.getFirstMatch(o0, a0) || i0.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/(web|hpw)[o0]s/i], describe: function(a0) {
    var c0 = { name: "WebOS Browser" }, l0 = i0.default.getFirstMatch(o0, a0) || i0.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/bada/i], describe: function(a0) {
    var c0 = { name: "Bada" }, l0 = i0.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/tizen/i], describe: function(a0) {
    var c0 = { name: "Tizen" }, l0 = i0.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, a0) || i0.default.getFirstMatch(o0, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/qupzilla/i], describe: function(a0) {
    var c0 = { name: "QupZilla" }, l0 = i0.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, a0) || i0.default.getFirstMatch(o0, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/firefox|iceweasel|fxios/i], describe: function(a0) {
    var c0 = { name: "Firefox" }, l0 = i0.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/electron/i], describe: function(a0) {
    var c0 = { name: "Electron" }, l0 = i0.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/MiuiBrowser/i], describe: function(a0) {
    var c0 = { name: "Miui" }, l0 = i0.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/chromium/i], describe: function(a0) {
    var c0 = { name: "Chromium" }, l0 = i0.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, a0) || i0.default.getFirstMatch(o0, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/chrome|crios|crmo/i], describe: function(a0) {
    var c0 = { name: "Chrome" }, l0 = i0.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/GSA/i], describe: function(a0) {
    var c0 = { name: "Google Search" }, l0 = i0.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: function(a0) {
    var c0 = !a0.test(/like android/i), l0 = a0.test(/android/i);
    return c0 && l0;
  }, describe: function(a0) {
    var c0 = { name: "Android Browser" }, l0 = i0.default.getFirstMatch(o0, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/playstation 4/i], describe: function(a0) {
    var c0 = { name: "PlayStation 4" }, l0 = i0.default.getFirstMatch(o0, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/safari|applewebkit/i], describe: function(a0) {
    var c0 = { name: "Safari" }, l0 = i0.default.getFirstMatch(o0, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/.*/i], describe: function(a0) {
    var c0 = a0.search("\\(") !== -1 ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
    return { name: i0.default.getFirstMatch(c0, a0), version: i0.default.getSecondMatch(c0, a0) };
  } }];
  e0.default = s0, t0.exports = e0.default;
}, 93: function(t0, e0, n0) {
  e0.__esModule = !0, e0.default = void 0;
  var r0, i0 = (r0 = n0(17)) && r0.__esModule ? r0 : { default: r0 }, o0 = n0(18), s0 = [{ test: [/Roku\/DVP/], describe: function(a0) {
    var c0 = i0.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, a0);
    return { name: o0.OS_MAP.Roku, version: c0 };
  } }, { test: [/windows phone/i], describe: function(a0) {
    var c0 = i0.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, a0);
    return { name: o0.OS_MAP.WindowsPhone, version: c0 };
  } }, { test: [/windows /i], describe: function(a0) {
    var c0 = i0.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, a0), l0 = i0.default.getWindowsVersionName(c0);
    return { name: o0.OS_MAP.Windows, version: c0, versionName: l0 };
  } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function(a0) {
    var c0 = { name: o0.OS_MAP.iOS }, l0 = i0.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/macintosh/i], describe: function(a0) {
    var c0 = i0.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, a0).replace(/[_\s]/g, "."), l0 = i0.default.getMacOSVersionName(c0), u0 = { name: o0.OS_MAP.MacOS, version: c0 };
    return l0 && (u0.versionName = l0), u0;
  } }, { test: [/(ipod|iphone|ipad)/i], describe: function(a0) {
    var c0 = i0.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, a0).replace(/[_\s]/g, ".");
    return { name: o0.OS_MAP.iOS, version: c0 };
  } }, { test: function(a0) {
    var c0 = !a0.test(/like android/i), l0 = a0.test(/android/i);
    return c0 && l0;
  }, describe: function(a0) {
    var c0 = i0.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, a0), l0 = i0.default.getAndroidVersionName(c0), u0 = { name: o0.OS_MAP.Android, version: c0 };
    return l0 && (u0.versionName = l0), u0;
  } }, { test: [/(web|hpw)[o0]s/i], describe: function(a0) {
    var c0 = i0.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, a0), l0 = { name: o0.OS_MAP.WebOS };
    return c0 && c0.length && (l0.version = c0), l0;
  } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(a0) {
    var c0 = i0.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, a0) || i0.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, a0) || i0.default.getFirstMatch(/\bbb(\d+)/i, a0);
    return { name: o0.OS_MAP.BlackBerry, version: c0 };
  } }, { test: [/bada/i], describe: function(a0) {
    var c0 = i0.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, a0);
    return { name: o0.OS_MAP.Bada, version: c0 };
  } }, { test: [/tizen/i], describe: function(a0) {
    var c0 = i0.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, a0);
    return { name: o0.OS_MAP.Tizen, version: c0 };
  } }, { test: [/linux/i], describe: function() {
    return { name: o0.OS_MAP.Linux };
  } }, { test: [/CrOS/], describe: function() {
    return { name: o0.OS_MAP.ChromeOS };
  } }, { test: [/PlayStation 4/], describe: function(a0) {
    var c0 = i0.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, a0);
    return { name: o0.OS_MAP.PlayStation4, version: c0 };
  } }];
  e0.default = s0, t0.exports = e0.default;
}, 94: function(t0, e0, n0) {
  e0.__esModule = !0, e0.default = void 0;
  var r0, i0 = (r0 = n0(17)) && r0.__esModule ? r0 : { default: r0 }, o0 = n0(18), s0 = [{ test: [/googlebot/i], describe: function() {
    return { type: "bot", vendor: "Google" };
  } }, { test: [/huawei/i], describe: function(a0) {
    var c0 = i0.default.getFirstMatch(/(can-l01)/i, a0) && "Nova", l0 = { type: o0.PLATFORMS_MAP.mobile, vendor: "Huawei" };
    return c0 && (l0.model = c0), l0;
  } }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: function() {
    return { type: o0.PLATFORMS_MAP.tablet, vendor: "Nexus" };
  } }, { test: [/ipad/i], describe: function() {
    return { type: o0.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
  } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function() {
    return { type: o0.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
  } }, { test: [/kftt build/i], describe: function() {
    return { type: o0.PLATFORMS_MAP.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" };
  } }, { test: [/silk/i], describe: function() {
    return { type: o0.PLATFORMS_MAP.tablet, vendor: "Amazon" };
  } }, { test: [/tablet(?! pc)/i], describe: function() {
    return { type: o0.PLATFORMS_MAP.tablet };
  } }, { test: function(a0) {
    var c0 = a0.test(/ipod|iphone/i), l0 = a0.test(/like (ipod|iphone)/i);
    return c0 && !l0;
  }, describe: function(a0) {
    var c0 = i0.default.getFirstMatch(/(ipod|iphone)/i, a0);
    return { type: o0.PLATFORMS_MAP.mobile, vendor: "Apple", model: c0 };
  } }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: function() {
    return { type: o0.PLATFORMS_MAP.mobile, vendor: "Nexus" };
  } }, { test: [/[^-]mobi/i], describe: function() {
    return { type: o0.PLATFORMS_MAP.mobile };
  } }, { test: function(a0) {
    return a0.getBrowserName(!0) === "blackberry";
  }, describe: function() {
    return { type: o0.PLATFORMS_MAP.mobile, vendor: "BlackBerry" };
  } }, { test: function(a0) {
    return a0.getBrowserName(!0) === "bada";
  }, describe: function() {
    return { type: o0.PLATFORMS_MAP.mobile };
  } }, { test: function(a0) {
    return a0.getBrowserName() === "windows phone";
  }, describe: function() {
    return { type: o0.PLATFORMS_MAP.mobile, vendor: "Microsoft" };
  } }, { test: function(a0) {
    var c0 = Number(String(a0.getOSVersion()).split(".")[0]);
    return a0.getOSName(!0) === "android" && c0 >= 3;
  }, describe: function() {
    return { type: o0.PLATFORMS_MAP.tablet };
  } }, { test: function(a0) {
    return a0.getOSName(!0) === "android";
  }, describe: function() {
    return { type: o0.PLATFORMS_MAP.mobile };
  } }, { test: function(a0) {
    return a0.getOSName(!0) === "macos";
  }, describe: function() {
    return { type: o0.PLATFORMS_MAP.desktop, vendor: "Apple" };
  } }, { test: function(a0) {
    return a0.getOSName(!0) === "windows";
  }, describe: function() {
    return { type: o0.PLATFORMS_MAP.desktop };
  } }, { test: function(a0) {
    return a0.getOSName(!0) === "linux";
  }, describe: function() {
    return { type: o0.PLATFORMS_MAP.desktop };
  } }, { test: function(a0) {
    return a0.getOSName(!0) === "playstation 4";
  }, describe: function() {
    return { type: o0.PLATFORMS_MAP.tv };
  } }, { test: function(a0) {
    return a0.getOSName(!0) === "roku";
  }, describe: function() {
    return { type: o0.PLATFORMS_MAP.tv };
  } }];
  e0.default = s0, t0.exports = e0.default;
}, 95: function(t0, e0, n0) {
  e0.__esModule = !0, e0.default = void 0;
  var r0, i0 = (r0 = n0(17)) && r0.__esModule ? r0 : { default: r0 }, o0 = n0(18), s0 = [{ test: function(a0) {
    return a0.getBrowserName(!0) === "microsoft edge";
  }, describe: function(a0) {
    if (/\sedg\//i.test(a0))
      return { name: o0.ENGINE_MAP.Blink };
    var c0 = i0.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, a0);
    return { name: o0.ENGINE_MAP.EdgeHTML, version: c0 };
  } }, { test: [/trident/i], describe: function(a0) {
    var c0 = { name: o0.ENGINE_MAP.Trident }, l0 = i0.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: function(a0) {
    return a0.test(/presto/i);
  }, describe: function(a0) {
    var c0 = { name: o0.ENGINE_MAP.Presto }, l0 = i0.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: function(a0) {
    var c0 = a0.test(/gecko/i), l0 = a0.test(/like gecko/i);
    return c0 && !l0;
  }, describe: function(a0) {
    var c0 = { name: o0.ENGINE_MAP.Gecko }, l0 = i0.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }, { test: [/(apple)?webkit\/537\.36/i], describe: function() {
    return { name: o0.ENGINE_MAP.Blink };
  } }, { test: [/(apple)?webkit/i], describe: function(a0) {
    var c0 = { name: o0.ENGINE_MAP.WebKit }, l0 = i0.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, a0);
    return l0 && (c0.version = l0), c0;
  } }];
  e0.default = s0, t0.exports = e0.default;
} });
var Hu = de$1(Uu.exports);
const Fu = { Initialized: "initialized", DisplayURI: "display_uri", ProviderUpdate: "provider_update", ConnectWithResponse: "connectWithResponse", ConnectionStatus: "connection_status", ServiceStatus: "service_status" };
class zu {
  constructor({ shouldSetOnWindow: e0, connectionStream: n0, shouldSendMetadata: r0 = !1, shouldShimWeb3: i0, sdkInstance: o0 }) {
    const s0 = new Vu({ connectionStream: n0, shouldSendMetadata: r0, shouldSetOnWindow: e0, shouldShimWeb3: i0, autoRequestAccounts: !1 }), a0 = new Proxy(s0, { deleteProperty: () => !0 });
    if (this.provider = a0, this.sdkInstance = o0, e0 && typeof window < "u")
      try {
        c0 = s0, window.ethereum = c0, window.dispatchEvent(new Event("ethereum#initialized"));
      } catch (l0) {
        xu("[Ethereum] Unable to set global provider - window.ethereum may be read-only", l0);
      }
    var c0;
    if (i0 && typeof window < "u")
      try {
        (function(l0, u0 = console) {
          let d0 = !1, h0 = !1;
          if (!window.web3) {
            const g0 = "__isMetaMaskShim__";
            let w0 = { currentProvider: l0 };
            Object.defineProperty(w0, g0, { value: !0, enumerable: !0, configurable: !1, writable: !1 }), w0 = new Proxy(w0, { get: (y0, E0, ...b0) => (E0 !== "currentProvider" || d0 ? E0 === "currentProvider" || E0 === g0 || h0 || (h0 = !0, u0.error("MetaMask no longer injects web3. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3"), l0.request({ method: "metamask_logWeb3ShimUsage" }).catch((O0) => {
              u0.debug("MetaMask: Failed to log web3 shim usage.", O0);
            })) : (d0 = !0, u0.warn("You are accessing the MetaMask window.web3.currentProvider shim. This property is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3")), Reflect.get(y0, E0, ...b0)), set: (...y0) => (u0.warn("You are accessing the MetaMask window.web3 shim. This object is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3"), Reflect.set(...y0)) }), Object.defineProperty(window, "web3", { value: w0, enumerable: !1, configurable: !0, writable: !0 });
          }
        })(this.provider);
      } catch (l0) {
        xu("[Ethereum] Unable to shim web3 - window.web3 may be read-only", l0);
      }
    this.provider.on("display_uri", (l0) => {
      this.sdkInstance.emit(Fu.DisplayURI, l0);
    }), this.provider.on("_initialized", () => {
      const l0 = { chainId: this.provider.getChainId(), isConnected: this.provider.isConnected(), isMetaMask: this.provider.isMetaMask, selectedAddress: this.provider.getSelectedAddress(), networkVersion: this.provider.getNetworkVersion() };
      this.sdkInstance.emit(Fu.Initialized, l0), xu("[Ethereum: constructor()] provider initialized", l0);
    });
  }
  static init(e0) {
    var n0;
    return xu("[Ethereum: init()] Initializing Ethereum service"), this.instance = new zu(e0), (n0 = this.instance) === null || n0 === void 0 ? void 0 : n0.provider;
  }
  static destroy() {
  }
  static getInstance() {
    var e0;
    if (!(!((e0 = this.instance) === null || e0 === void 0) && e0.provider))
      throw new Error("Ethereum instance not intiialized - call Ethereum.factory first.");
    return this.instance;
  }
  static getProvider() {
    var e0;
    if (!(!((e0 = this.instance) === null || e0 === void 0) && e0.provider))
      throw new Error("Ethereum instance not intiialized - call Ethereum.factory first.");
    return this.instance.provider;
  }
}
class qu {
  constructor({ useDeepLink: e0, preferredOpenLink: n0, debug: r0 = !1 }) {
    this.state = { platformType: void 0, useDeeplink: !1, preferredOpenLink: void 0, debug: !1 }, this.state.platformType = this.getPlatformType(), this.state.useDeeplink = e0, this.state.preferredOpenLink = n0, this.state.debug = r0;
  }
  openDeeplink(e0, n0, r0) {
    return function(i0, o0, s0, a0) {
      const { state: c0 } = i0;
      xu(`[PlatfformManager: openDeeplink()] universalLink --> ${o0}`), xu(`[PlatfformManager: openDeeplink()] deepLink --> ${s0}`);
      try {
        if (c0.preferredOpenLink)
          return void c0.preferredOpenLink(c0.useDeeplink ? s0 : o0, a0);
        if (xu(`[PlatfformManager: openDeeplink()] open link now useDeepLink=${c0.useDeeplink} link=${c0.useDeeplink ? s0 : o0}`), c0.useDeeplink)
          typeof window < "u" && (window.location.href = s0);
        else if (typeof document < "u") {
          const l0 = document.createElement("a");
          l0.href = o0, l0.target = "_self", l0.rel = "noreferrer noopener", l0.click();
        }
      } catch (l0) {
        console.log("[PlatfformManager: openDeeplink()] can't open link", l0);
      }
    }(this, e0, n0, r0);
  }
  isReactNative() {
    var e0;
    return this.isNotBrowser() && typeof window < "u" && window?.navigator && ((e0 = window.navigator) === null || e0 === void 0 ? void 0 : e0.product) === "ReactNative";
  }
  isMetaMaskInstalled() {
    return function() {
      const e0 = zu.getProvider() || window?.ethereum;
      return xu(`[PlatfformManager: isMetaMaskInstalled()] isMetaMask=${e0?.isMetaMask} isConnected=${e0?.isConnected()}`), e0?.isMetaMask && e0?.isConnected();
    }();
  }
  isDesktopWeb() {
    return this.isBrowser() && !this.isMobileWeb();
  }
  isMobile() {
    var e0, n0;
    const r0 = Hu.parse(window.navigator.userAgent);
    return ((e0 = r0?.platform) === null || e0 === void 0 ? void 0 : e0.type) === "mobile" || ((n0 = r0?.platform) === null || n0 === void 0 ? void 0 : n0.type) === "tablet";
  }
  isSecure() {
    return this.isReactNative() || this.isMobileWeb();
  }
  isMetaMaskMobileWebView() {
    return typeof window < "u" && !!window.ReactNativeWebView && !!navigator.userAgent.endsWith("MetaMaskMobile");
  }
  isMobileWeb() {
    return this.state.platformType === Bo.MobileWeb;
  }
  static isNotBrowser() {
    var e0;
    return typeof window > "u" || !window?.navigator || c !== void 0 && ((e0 = c?.navigator) === null || e0 === void 0 ? void 0 : e0.product) === "ReactNative" || navigator?.product === "ReactNative";
  }
  isNotBrowser() {
    return qu.isNotBrowser();
  }
  static isBrowser() {
    return !this.isNotBrowser();
  }
  isBrowser() {
    return qu.isBrowser();
  }
  isNodeJS() {
    return this.isNotBrowser() && !this.isReactNative();
  }
  isUseDeepLink() {
    return this.state.useDeeplink;
  }
  getPlatformType() {
    return function(e0) {
      const { state: n0 } = e0;
      return n0.platformType ? n0.platformType : e0.isReactNative() ? Bo.ReactNative : e0.isNotBrowser() ? Bo.NonBrowser : e0.isMetaMaskMobileWebView() ? Bo.MetaMaskMobileWebview : e0.isMobile() ? Bo.MobileWeb : Bo.DesktopWeb;
    }(this);
  }
}
const Wu = (t0) => a(void 0, void 0, void 0, function* () {
  if (qu.isBrowser()) {
    const { StorageManagerWeb: n0 } = yield Promise.resolve().then(function() {
      return nf;
    });
    return new n0(t0);
  }
  const e0 = { persistChannelConfig: () => a(void 0, void 0, void 0, function* () {
  }), getPersistedChannelConfig: () => a(void 0, void 0, void 0, function* () {
  }), persistAccounts: () => a(void 0, void 0, void 0, function* () {
  }), getCachedAccounts: () => a(void 0, void 0, void 0, function* () {
    return [];
  }), persistChainId: () => a(void 0, void 0, void 0, function* () {
  }), getCachedChainId: () => a(void 0, void 0, void 0, function* () {
  }), terminate: () => a(void 0, void 0, void 0, function* () {
  }) };
  return Promise.resolve(e0);
});
class Vu extends ku {
  constructor({ connectionStream: e0, shouldSendMetadata: n0, autoRequestAccounts: r0 = !1 }) {
    super(e0, { logger: console, maxEventListeners: 100, shouldSendMetadata: n0 }), this.state = { accounts: null, autoRequestAccounts: !1, providerStateRequested: !1, chainId: "", networkVersion: "" }, xu(`[SDKProvider: constructor()] autoRequestAccounts=${r0}`), this.state.autoRequestAccounts = r0;
  }
  forceInitializeState() {
    return a(this, void 0, void 0, function* () {
      return xu(`[SDKProvider: forceInitializeState()] autoRequestAccounts=${this.state.autoRequestAccounts}`), this._initializeStateAsync();
    });
  }
  _setConnected() {
    xu("[SDKProvider: _setConnected()] Setting connected state"), this._state.isConnected = !0;
  }
  getState() {
    return this._state;
  }
  getSDKProviderState() {
    return this.state;
  }
  getSelectedAddress() {
    var e0;
    const { accounts: n0 } = this._state;
    return n0 && n0.length !== 0 ? ((e0 = n0[0]) === null || e0 === void 0 ? void 0 : e0.toLowerCase()) || "" : (xu("[SDKProvider: getSelectedAddress] No accounts found"), null);
  }
  getChainId() {
    return this.state.chainId;
  }
  getNetworkVersion() {
    return this.state.networkVersion;
  }
  setSDKProviderState(e0) {
    this.state = Object.assign(Object.assign({}, this.state), e0);
  }
  handleAccountsChanged(e0, n0) {
    return this._handleAccountsChanged(e0, n0);
  }
  handleDisconnect({ terminate: e0 = !1 }) {
    (function({ terminate: n0 = !1, instance: r0 }) {
      const { state: i0 } = r0;
      xu(`[SDKProvider: handleDisconnect()] cleaning up provider state terminate=${n0}`, r0), n0 && (r0._state.accounts = null, r0._state.isUnlocked = !1, r0._state.isPermanentlyDisconnected = !0, r0._state.initialized = !1), r0._handleAccountsChanged([]), r0._state.isConnected = !1, r0.emit("disconnect", Mu.ethErrors.provider.disconnected()), i0.providerStateRequested = !1;
    })({ terminate: e0, instance: this });
  }
  _initializeStateAsync() {
    return a(this, void 0, void 0, function* () {
      return function(e0) {
        var n0, r0;
        return a(this, void 0, void 0, function* () {
          e0.state === void 0 && (e0.state = { accounts: null, autoRequestAccounts: !1, providerStateRequested: !1, chainId: "" });
          const { state: i0 } = e0;
          let o0;
          if (i0.providerStateRequested)
            xu("[SDKProvider: initializeStateAsync()] initialization already in progress");
          else {
            let s0;
            i0.providerStateRequested = !0;
            let a0 = null, c0 = !1, l0 = !1;
            const u0 = yield Wu({ enabled: !0 });
            if (u0) {
              const d0 = yield u0.getPersistedChannelConfig({});
              c0 = (n0 = d0?.relayPersistence) !== null && n0 !== void 0 && n0, s0 = yield u0.getCachedChainId();
              const h0 = yield u0.getCachedAccounts();
              h0.length > 0 && (a0 = h0[0]);
            }
            if (xu(`[SDKProvider: initializeStateAsync()] relayPersistence=${c0}`, { relayPersistence: c0, cachedChainId: s0, cachedSelectedAddress: a0 }), c0)
              if (s0 && a0)
                o0 = { accounts: [a0], chainId: s0, isUnlocked: !1 }, l0 = !0;
              else
                try {
                  o0 = yield e0.request({ method: "metamask_getProviderState" });
                } catch (d0) {
                  return e0._log.error("MetaMask: Failed to get initial state. Please report this bug.", d0), void (i0.providerStateRequested = !1);
                }
            if (((r0 = o0?.accounts) === null || r0 === void 0 ? void 0 : r0.length) === 0)
              if (e0.getSelectedAddress())
                o0.accounts = [e0.getSelectedAddress()];
              else {
                xu("[SDKProvider: initializeStateAsync()] Fetch accounts remotely.");
                const d0 = yield e0.request({ method: "eth_requestAccounts", params: [] });
                o0.accounts = d0;
              }
            e0._initializeState(o0), i0.providerStateRequested = !1, l0 && (e0._state.isConnected = !0, e0.emit("connect", { chainId: o0?.chainId }));
          }
        });
      }(this);
    });
  }
  _initializeState(e0) {
    return xu("[SDKProvider: _initializeState()]", e0), function(n0, r0, i0) {
      return xu("[SDKProvider: initializeState()] set state._initialized to false"), n0._state.initialized = !1, r0(i0);
    }(this, super._initializeState.bind(this), e0);
  }
  _handleChainChanged({ chainId: e0, networkVersion: n0 } = {}) {
    this.state.chainId = e0, this.state.networkVersion = n0, function({ instance: r0, chainId: i0, networkVersion: o0, superHandleChainChanged: s0 }) {
      xu(`[SDKProvider: handleChainChanged()] chainId=${i0} networkVersion=${o0}`);
      let a0 = o0;
      o0 || (xu("[SDKProvider: handleChainChanged()] forced network version to prevent provider error"), a0 = "1"), r0._state.isConnected = !0, r0.emit("connect", { chainId: i0 }), s0({ chainId: i0, networkVersion: a0 });
    }({ instance: this, chainId: e0, networkVersion: n0, superHandleChainChanged: super._handleChainChanged.bind(this) });
  }
}
var Gu, Yu = { name: "@metamask/sdk", version: "0.32.1", description: "", homepage: "https://github.com/MetaMask/metamask-sdk#readme", bugs: { url: "https://github.com/MetaMask/metamask-sdk/issues" }, repository: { type: "git", url: "https://github.com/MetaMask/metamask-sdk", directory: "packages/sdk" }, main: "dist/node/cjs/metamask-sdk.js", module: "dist/browser/es/metamask-sdk.js", browser: "dist/browser/es/metamask-sdk.js", unpkg: "dist/browser/umd/metamask-sdk.js", "react-native": "dist/react-native/es/metamask-sdk.js", types: "dist/types/src/index.d.ts", sideEffects: !1, files: ["/dist"], scripts: { "build:types": "tsc --project tsconfig.build.json --emitDeclarationOnly --outDir dist/types", build: "yarn build:types && rollup -c --bundleConfigAsCjs", "build:clean": "yarn clean && yarn build", "build:post-tsc": "echo 'N/A'", "build:pre-tsc": "echo 'N/A'", typecheck: "tsc --noEmit", clean: "rimraf ./dist", size: "node bundle-size && size-limit", lint: "yarn lint:eslint && yarn lint:misc --check", "lint:changelog": "../../scripts/validate-changelog.sh @metamask/sdk", "lint:eslint": "eslint . --cache --ext js,ts", "lint:fix": "yarn lint:eslint --fix && yarn lint:misc --write", "lint:misc": "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore", prepack: "../../scripts/prepack.sh", "publish:preview": "yarn npm publish --tag preview", reset: "yarn clean && rimraf ./node_modules/", test: 'jest --testPathIgnorePatterns "/e2e/"', "test:coverage": 'jest --coverage --testPathIgnorePatterns "/e2e/"', "test:e2e": 'jest --testPathPattern "/e2e/"', "test:ci": 'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns "/e2e/"', "test:dev": 'jest -c ./jest.config.ts --detectOpenHandles  --testPathIgnorePatterns "/e2e/"', watch: "rollup -c -w", dev: 'concurrently "tsc --watch" "rollup -c -w --bundleConfigAsCjs"', "build:dev": "yarn build:types && NODE_ENV=dev rollup -c --bundleConfigAsCjs" }, dependencies: { "@babel/runtime": "^7.26.0", "@metamask/onboarding": "^1.0.1", "@metamask/providers": "16.1.0", "@metamask/sdk-communication-layer": "workspace:*", "@metamask/sdk-install-modal-web": "workspace:*", "@paulmillr/qr": "^0.2.1", bowser: "^2.9.0", "cross-fetch": "^4.0.0", debug: "^4.3.4", eciesjs: "^0.4.11", "eth-rpc-errors": "^4.0.3", eventemitter2: "^6.4.9", "obj-multiplex": "^1.0.0", pump: "^3.0.0", "readable-stream": "^3.6.2", "socket.io-client": "^4.5.1", tslib: "^2.6.0", util: "^0.12.4", uuid: "^8.3.2" }, devDependencies: { "@jest/globals": "^29.3.1", "@lavamoat/allow-scripts": "^2.3.1", "@metamask/auto-changelog": "3.1.0", "@metamask/eslint-config": "^6.0.0", "@metamask/eslint-config-nodejs": "^6.0.0", "@metamask/eslint-config-typescript": "^6.0.0", "@react-native-async-storage/async-storage": "^1.19.6", "@rollup/plugin-alias": "^5.1.1", "@rollup/plugin-commonjs": "^25.0.7", "@rollup/plugin-json": "^6.0.0", "@rollup/plugin-node-resolve": "^15.0.2", "@rollup/plugin-replace": "^6.0.1", "@rollup/plugin-terser": "^0.4.1", "@size-limit/preset-big-lib": "^11.0.2", "@types/dom-screen-wake-lock": "^1.0.2", "@types/node": "^20.1.3", "@types/pump": "^1.1.1", "@types/qrcode-terminal": "^0.12.0", "@types/uuid": "^10.0.0", "@typescript-eslint/eslint-plugin": "^4.26.0", "@typescript-eslint/parser": "^4.26.0", "browserify-zlib": "^0.2.0", buffer: "^6.0.3", concurrently: "^9.1.2", "crypto-browserify": "^3.12.0", eslint: "^7.30.0", "eslint-config-prettier": "^8.3.0", "eslint-plugin-import": "^2.23.4", "eslint-plugin-jest": "^24.4.0", "eslint-plugin-jsdoc": "^36.1.0", "eslint-plugin-node": "^11.1.0", "eslint-plugin-prettier": "^3.4.0", "https-browserify": "^1.0.0", jest: "^29.3.1", "jest-environment-jsdom": "^29.3.1", prettier: "^2.3.0", process: "^0.11.10", rimraf: "^4.4.0", rollup: "^4.26.0", "rollup-plugin-analyzer": "^4.0.0", "rollup-plugin-jscc": "^2.0.0", "rollup-plugin-natives": "^0.7.5", "rollup-plugin-node-builtins": "^2.1.2", "rollup-plugin-polyfill-node": "^0.13.0", "rollup-plugin-sizes": "^1.0.6", "rollup-plugin-typescript2": "^0.31.2", "rollup-plugin-visualizer": "^5.12.0", "size-limit": "^11.0.2", "stream-browserify": "^3.0.0", "stream-http": "^3.2.0", "ts-jest": "^29.0.3", "ts-node": "^10.9.1", typescript: "^4.3.2", url: "^0.11.0", webpack: "^5.0.0" }, publishConfig: { access: "public", registry: "https://registry.npmjs.org/" }, lavamoat: { allowScripts: { "eciesjs>secp256k1": !1, "socket.io-client>engine.io-client>ws>bufferutil": !1, "socket.io-client>engine.io-client>ws>utf-8-validate": !1, "@metamask/sdk-communication-layer>bufferutil": !1, "@metamask/sdk-communication-layer>eciesjs>secp256k1": !1, "@metamask/sdk-communication-layer>utf-8-validate": !1 } } };
(function(t0) {
  t0.INPAGE = "metamask-inpage", t0.CONTENT_SCRIPT = "metamask-contentscript", t0.PROVIDER = "metamask-provider";
})(Gu || (Gu = {}));
const Zu = "direct", Ju = "https://metamask.app.link/connect", Xu = "metamask://connect", Qu = { NAME: "MetaMask", RDNS: ["io.metamask", "io.metamask.flask"] }, eh = /(?:^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}$)|(?:^0{8}-0{4}-0{4}-0{4}-0{12}$)/u, th = { METAMASK_GETPROVIDERSTATE: "metamask_getProviderState", METAMASK_CONNECTSIGN: "metamask_connectSign", METAMASK_CONNECTWITH: "metamask_connectWith", METAMASK_OPEN: "metamask_open", METAMASK_BATCH: "metamask_batch", PERSONAL_SIGN: "personal_sign", WALLET_REQUESTPERMISSIONS: "wallet_requestPermissions", WALLET_REVOKEPERMISSIONS: "wallet_revokePermissions", WALLET_GETPERMISSIONS: "wallet_getPermissions", WALLET_WATCHASSET: "wallet_watchAsset", WALLET_ADDETHEREUMCHAIN: "wallet_addEthereumChain", WALLET_SWITCHETHETHEREUMCHAIN: "wallet_switchEthereumChain", ETH_REQUESTACCOUNTS: "eth_requestAccounts", ETH_ACCOUNTS: "eth_accounts", ETH_CHAINID: "eth_chainId", ETH_SENDTRANSACTION: "eth_sendTransaction", ETH_SIGNTYPEDDATA: "eth_signTypedData", ETH_SIGNTYPEDDATA_V3: "eth_signTypedData_v3", ETH_SIGNTYPEDDATA_V4: "eth_signTypedData_v4", ETH_SIGNTRANSACTION: "eth_signTransaction", ETH_SIGN: "eth_sign", PERSONAL_EC_RECOVER: "personal_ecRecover" }, nh = { [th.ETH_REQUESTACCOUNTS]: !0, [th.ETH_SENDTRANSACTION]: !0, [th.ETH_SIGNTRANSACTION]: !0, [th.ETH_SIGN]: !0, [th.PERSONAL_SIGN]: !0, [th.ETH_ACCOUNTS]: !1, [th.ETH_CHAINID]: !1, [th.PERSONAL_SIGN]: !0, [th.ETH_SIGNTYPEDDATA]: !0, [th.ETH_SIGNTYPEDDATA_V3]: !0, [th.ETH_SIGNTYPEDDATA_V4]: !0, [th.WALLET_REQUESTPERMISSIONS]: !0, [th.WALLET_GETPERMISSIONS]: !0, [th.WALLET_WATCHASSET]: !0, [th.WALLET_ADDETHEREUMCHAIN]: !0, [th.WALLET_SWITCHETHETHEREUMCHAIN]: !0, [th.METAMASK_CONNECTSIGN]: !0, [th.METAMASK_CONNECTWITH]: !0, [th.PERSONAL_EC_RECOVER]: !0, [th.METAMASK_BATCH]: !0, [th.METAMASK_OPEN]: !0 }, rh = Object.keys(nh).filter((t0) => nh[t0] === !0).map((t0) => t0.toLowerCase()), ih = ["eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sign"].map((t0) => t0.toLowerCase()), oh = ".sdk-comm", sh = "providerType", ah = ".MMSDK_cached_address", ch = ".MMSDK_cached_chainId", lh = { CHAIN_CHANGED: "chainChanged", ACCOUNTS_CHANGED: "accountsChanged", DISCONNECT: "disconnect", CONNECT: "connect", CONNECTED: "connected" }, dh = 1e6;
var uh;
(function(t0) {
  t0.TERMINATE = "terminate", t0.EXTENSION = "extension", t0.INITIALIZED = "initialized";
})(uh || (uh = {}));
const hh = typeof window < "u" && window.localStorage;
function fh({ instance: t0, msg: e0 }) {
  return a(this, void 0, void 0, function* () {
    if (t0._initialized || (xu("[MetaMaskSDK: connectAndSign()] provider not ready -- wait for init()"), yield t0.init()), xu(`[MetaMaskSDK: connectAndSign()] activeProvider=${t0.activeProvider}`), !t0.activeProvider)
      throw new Error("SDK state invalid -- undefined provider");
    const n0 = /^0x([0-9A-Fa-f]{2})*$/u.test(e0) ? e0 : function(r0) {
      let i0;
      if (_ !== void 0)
        i0 = _.from(r0, "utf8").toString("hex");
      else if (typeof TextEncoder < "u") {
        const o0 = new TextEncoder().encode(r0);
        i0 = Array.from(o0).map((s0) => s0.toString(16).padStart(2, "0")).join("");
      } else {
        if (typeof c != "object" || !("Buffer" in c))
          throw new Error("Unable to convert string to hex: No available method.");
        i0 = c.Buffer.from(r0, "utf8").toString("hex");
      }
      return `0x${i0}`;
    }(e0);
    return t0.activeProvider.request({ method: th.METAMASK_CONNECTWITH, params: [{ method: th.PERSONAL_SIGN, params: [n0] }] });
  });
}
function ph(t0) {
  var e0, n0;
  return a(this, void 0, void 0, function* () {
    xu("[MetaMaskSDK: connectWithExtensionProvider()] ", t0), t0.sdkProvider = t0.activeProvider, t0.activeProvider = window.extension, window.ethereum = window.extension;
    try {
      const r0 = yield (e0 = window.extension) === null || e0 === void 0 ? void 0 : e0.request({ method: "eth_requestAccounts" });
      xu(`[MetaMaskSDK: connectWithExtensionProvider()] accounts=${r0}`);
    } catch (r0) {
      return void console.warn("[MetaMaskSDK: connectWithExtensionProvider()] can't request accounts error", r0);
    }
    localStorage.setItem(sh, "extension"), t0.extensionActive = !0, t0.emit(Fu.ProviderUpdate, uh.EXTENSION), t0.options.enableAnalytics && ((n0 = t0.analytics) === null || n0 === void 0 || n0.send({ event: _o.SDK_USE_EXTENSION }));
  });
}
function gh(t0) {
  let e0;
  if (_ !== void 0)
    e0 = _.from(t0, "utf8").toString("base64");
  else if (typeof btoa == "function")
    e0 = btoa(encodeURIComponent(t0).replace(/%([0-9A-F]{2})/gu, (n0, r0) => String.fromCharCode(parseInt(r0, 16))));
  else {
    if (typeof c != "object" || !("Buffer" in c))
      throw new Error("Unable to base64 encode: No available method.");
    e0 = c.Buffer.from(t0, "utf8").toString("base64");
  }
  return e0;
}
function mh(t0, e0, n0, r0) {
  var i0, o0, s0, a0, c0, l0, u0, d0, h0, g0, w0, y0, E0, b0, O0, S0, k0, D0, z0, G0;
  return a(this, void 0, void 0, function* () {
    const K0 = (i0 = t0.state.remote) === null || i0 === void 0 ? void 0 : i0.isReady(), U0 = (o0 = t0.state.remote) === null || o0 === void 0 ? void 0 : o0.isConnected(), F0 = (s0 = t0.state.remote) === null || s0 === void 0 ? void 0 : s0.isPaused(), H0 = zu.getProvider(), P0 = (a0 = t0.state.remote) === null || a0 === void 0 ? void 0 : a0.getChannelId(), I0 = (c0 = t0.state.remote) === null || c0 === void 0 ? void 0 : c0.isAuthorized(), { deeplinkProtocol: f0 } = t0.state, { method: m0, data: A0, triggeredInstaller: x0 } = ((M0) => {
      var p0, v0, T0, L0;
      let B0;
      _.isBuffer(M0) ? (B0 = M0.toJSON(), B0._isBuffer = !0) : B0 = M0;
      const W0 = (p0 = B0?.data) === null || p0 === void 0 ? void 0 : p0.method;
      let V0 = !1;
      return typeof ((v0 = B0?.data) === null || v0 === void 0 ? void 0 : v0.params) == "object" && ((L0 = (T0 = B0?.data) === null || T0 === void 0 ? void 0 : T0.params) === null || L0 === void 0 ? void 0 : L0.__triggeredInstaller) === !0 && (V0 = !0, B0.data.params = B0.data.params.wrappedParams), { method: W0, data: B0, triggeredInstaller: V0 };
    })(e0);
    if (xu(`[RCPMS: write()] method='${m0}' isRemoteReady=${K0} channelId=${P0} isSocketConnected=${U0} isRemotePaused=${F0} providerConnected=${H0.isConnected()}`, e0), !P0)
      return m0 !== th.METAMASK_GETPROVIDERSTATE && xu(`[RCPMS: write()] ${m0} --> channelId is undefined`), r0(new Error("disconnected"));
    xu(`[RCPMS: write()] remote.isPaused()=${(l0 = t0.state.remote) === null || l0 === void 0 ? void 0 : l0.isPaused()} authorized=${I0} ready=${K0} socketConnected=${U0}`, e0);
    const _0 = (u0 = t0.state.platformManager) === null || u0 === void 0 ? void 0 : u0.isSecure(), $0 = (h0 = (d0 = t0.state.platformManager) === null || d0 === void 0 ? void 0 : d0.isMobileWeb()) !== null && h0 !== void 0 && h0, C0 = (w0 = (g0 = t0.state.remote) === null || g0 === void 0 ? void 0 : g0.hasDeeplinkProtocol()) !== null && w0 !== void 0 && w0 && $0 && I0;
    try {
      if (!x0) {
        const v0 = JSON.stringify(A0?.data);
        if (v0.length > dh)
          return r0(new Error(`Message size ${v0.length} exceeds maximum allowed size of 1000000 bytes`));
        (y0 = t0.state.remote) === null || y0 === void 0 || y0.sendMessage(A0?.data).then(() => {
          xu(`[RCPMS: _write()] ${m0} sent successfully`);
        }).catch((T0) => {
          xu("[RCPMS: _write()] error sending message", T0);
        });
      }
      if (!_0)
        return xu(`[RCPMS: _write()] unsecure platform for method ${m0} -- return callback`), r0();
      if (x0)
        return xu("[RCPMS: _write()] prevent deeplink -- installation completed separately."), r0();
      const M0 = (O0 = (b0 = (E0 = t0.state.remote) === null || E0 === void 0 ? void 0 : E0.getKeyInfo()) === null || b0 === void 0 ? void 0 : b0.ecies.public) !== null && O0 !== void 0 ? O0 : "";
      let p0 = encodeURI(`channelId=${P0}&pubkey=${M0}&comm=socket&t=d&v=2`);
      if (C0) {
        const v0 = JSON.stringify(A0?.data), T0 = (S0 = t0.state.remote) === null || S0 === void 0 ? void 0 : S0.encrypt(v0);
        if (!T0)
          return xu("[RCPMS: _write()] error encrypting message"), r0(new Error("RemoteCommunicationPostMessageStream - disconnected"));
        p0 += `&scheme=${f0}&rpc=${gh(T0)}`;
      }
      if (!(!((k0 = t0.state.platformManager) === null || k0 === void 0) && k0.isMetaMaskInstalled()))
        return xu("[RCPMS: _write()] prevent deeplink until installation is completed."), r0();
      nh[m0] ? (xu(`[RCPMS: _write()] redirect link for '${m0}' socketConnected=${U0} connect?${p0}`), (D0 = t0.state.platformManager) === null || D0 === void 0 || D0.openDeeplink(`${Ju}?${p0}`, `${Xu}?${p0}`, "_self")) : !((z0 = t0.state.remote) === null || z0 === void 0) && z0.isPaused() ? (xu(`[RCPMS: _write()] MM is PAUSED! deeplink with connect! targetMethod=${m0}`), (G0 = t0.state.platformManager) === null || G0 === void 0 || G0.openDeeplink(`${Ju}?redirect=true&${p0}`, `${Xu}?redirect=true&${p0}`, "_self")) : xu(`[RCPMS: _write()] method ${m0} doesn't need redirect.`);
    } catch (M0) {
      return xu("[RCPMS: _write()] error sending message", M0), r0(new Error("RemoteCommunicationPostMessageStream - disconnected"));
    }
    return r0();
  });
}
class yh extends nu.Duplex {
  constructor({ name: e0, remote: n0, deeplinkProtocol: r0, platformManager: i0 }) {
    super({ objectMode: !0 }), this.state = { _name: null, remote: null, deeplinkProtocol: !1, platformManager: null }, this.state._name = e0, this.state.remote = n0, this.state.deeplinkProtocol = r0, this.state.platformManager = i0, this._onMessage = this._onMessage.bind(this), this.state.remote.on(bo.MESSAGE, this._onMessage);
  }
  _write(e0, n0, r0) {
    return a(this, void 0, void 0, function* () {
      return mh(this, e0, 0, r0);
    });
  }
  _read() {
  }
  _onMessage(e0) {
    return function(n0, r0) {
      try {
        if (xu("[RCPMS: onMessage()] message", r0), !r0 || typeof r0 != "object" || typeof r0?.data != "object")
          return;
        if (!r0?.name)
          return void xu("[RCPMS: onMessage()] ignore message without name", r0);
        if (r0?.name !== Gu.PROVIDER)
          return void xu(`[RCPMS: onMessage()] ignore message with wrong name message=${r0}`);
        if (_.isBuffer(r0)) {
          const i0 = _.from(r0);
          n0.push(i0);
        } else
          n0.push(r0);
      } catch (i0) {
        xu(`[RCPMS: onMessage()] ignore message error err=${i0}`);
      }
    }(this, e0);
  }
  start() {
  }
}
let vh = 1;
const bh = (t0) => new Promise((e0) => {
  setTimeout(() => {
    e0(!0);
  }, t0);
}), wh = ({ checkInstallationOnAllCalls: t0 = !1, communicationLayerPreference: e0, injectProvider: n0, shouldShimWeb3: r0, platformManager: i0, installer: o0, sdk: s0, remoteConnection: a0, debug: c0 }) => a(void 0, void 0, void 0, function* () {
  var l0, u0;
  const d0 = (({ name: F0, remoteConnection: H0 }) => {
    if (!H0 || !H0?.getConnector())
      throw new Error("Missing remote connection parameter");
    return new yh({ name: F0, remote: H0?.getConnector(), deeplinkProtocol: H0?.state.deeplinkProtocol, platformManager: H0?.getPlatformManager() });
  })({ name: Gu.INPAGE, target: Gu.CONTENT_SCRIPT, platformManager: i0, communicationLayerPreference: e0, remoteConnection: a0 }), h0 = i0.getPlatformType(), g0 = s0.options.dappMetadata, w0 = `Sdk/Javascript SdkVersion/${Yu.version} Platform/${h0} dApp/${(l0 = g0.url) !== null && l0 !== void 0 ? l0 : g0.name} dAppTitle/${g0.name}`;
  let y0 = null, E0 = null;
  const b0 = (u0 = s0.options.storage) === null || u0 === void 0 ? void 0 : u0.storageManager;
  if (b0) {
    try {
      const F0 = yield b0.getCachedAccounts();
      F0.length > 0 && (y0 = F0[0]);
    } catch (F0) {
      console.error(`[initializeMobileProvider] failed to get cached addresses: ${F0}`);
    }
    try {
      const F0 = yield b0.getCachedChainId();
      F0 && (E0 = F0);
    } catch (F0) {
      console.error(`[initializeMobileProvider] failed to parse cached chainId: ${F0}`);
    }
  }
  xu(`[initializeMobileProvider] cachedAccountAddress: ${y0}, cachedChainId: ${E0}`);
  const O0 = !(!n0 || h0 === Bo.NonBrowser || h0 === Bo.ReactNative), S0 = zu.init({ shouldSetOnWindow: O0, connectionStream: d0, shouldShimWeb3: r0, sdkInstance: s0 });
  let k0 = !1;
  const D0 = (F0) => {
    k0 = F0;
  }, z0 = () => k0, G0 = (F0, H0, P0, I0) => a(void 0, void 0, void 0, function* () {
    var f0, m0, A0, x0, _0, $0, C0, M0, p0;
    const v0 = zu.getProvider();
    if (k0) {
      v0.emit("display_uri", a0?.state.qrcodeLink || ""), a0?.showActiveModal();
      let yg = z0();
      for (; yg; ) {
        const _g = z0(), wg = a0?.isAuthorized();
        yg = _g && !wg, xu(`[initializeMobileProvider: sendRequest()] waiting for initialization to complete - initializing: ${_g} authorized: ${wg}`), yield bh(1e3);
      }
      return xu("[initializeMobileProvider: sendRequest()] initial method completed -- prevent installation and call provider"), P0(...H0);
    }
    const T0 = i0.isMetaMaskInstalled(), L0 = a0?.isConnected();
    let B0 = null, W0 = null, V0 = null;
    if (B0 = (f0 = v0.getSelectedAddress()) !== null && f0 !== void 0 ? f0 : y0, V0 = v0.getChainId() || E0, B0 && b0 && B0 !== y0 && b0.persistAccounts([B0]).catch((yg) => {
      console.error(`[initializeMobileProvider] failed to persist account: ${yg}`);
    }), V0 && (E0 = V0, b0 && b0.persistChainId(V0).catch((yg) => {
      console.error(`[initializeMobileProvider] failed to persist chainId: ${yg}`);
    })), xu("[initializeMobileProvider: sendRequest()]", { selectedAddress: B0, chainId: V0 }), I0 && xu(`[initializeMobileProvider: sendRequest()] method=${F0} ongoing=${k0} selectedAddress=${B0} isInstalled=${T0} checkInstallationOnAllCalls=${t0} socketConnected=${L0}`), B0 && F0.toLowerCase() === th.ETH_ACCOUNTS.toLowerCase())
      return [B0];
    if (V0 && F0.toLowerCase() === th.ETH_CHAINID.toLowerCase())
      return V0;
    const Q0 = [th.ETH_REQUESTACCOUNTS, th.WALLET_REQUESTPERMISSIONS, th.METAMASK_CONNECTSIGN, th.METAMASK_CONNECTWITH], X0 = !nh[F0], J0 = (m0 = s0.options.readonlyRPCMap) === null || m0 === void 0 ? void 0 : m0[V0];
    if (J0 && X0)
      try {
        const yg = (A0 = H0?.[0]) === null || A0 === void 0 ? void 0 : A0.params, _g = yield (({ rpcEndpoint: wg, method: $g, sdkInfo: Eg, params: bg }) => a(void 0, void 0, void 0, function* () {
          const vg = JSON.stringify({ jsonrpc: "2.0", method: $g, params: bg, id: (vh += 1, vh) }), Ag = { Accept: "application/json", "Content-Type": "application/json" };
          let Ig;
          wg.includes("infura") && (Ag["Metamask-Sdk-Info"] = Eg);
          try {
            Ig = yield e(wg, { method: "POST", headers: Ag, body: vg });
          } catch (Mg) {
            throw Mg instanceof Error ? new Error(`Failed to fetch from RPC: ${Mg.message}`) : new Error(`Failed to fetch from RPC: ${Mg}`);
          }
          if (!Ig.ok)
            throw new Error(`Server responded with a status of ${Ig.status}`);
          return (yield Ig.json()).result;
        }))({ rpcEndpoint: J0, sdkInfo: w0, method: F0, params: yg || [] });
        return I0 && xu(`initializeProvider::ReadOnlyRPCResponse ${_g}`), _g;
      } catch (yg) {
        console.warn(`[initializeMobileProvider: sendRequest()] method=${F0} readOnlyRPCRequest failed:`, yg);
      }
    if ((!T0 || T0 && !L0) && F0 !== th.METAMASK_GETPROVIDERSTATE) {
      const yg = ((x0 = H0?.[0]) === null || x0 === void 0 ? void 0 : x0.params) || [];
      if (Q0.indexOf(F0) !== -1 || t0) {
        D0(!0);
        const _g = F0 === th.METAMASK_CONNECTWITH, wg = `${Date.now()}`;
        try {
          yield o0.start({ wait: !1, connectWith: _g ? { method: F0, id: wg, params: yg } : void 0 }), yield new Promise(($g, Eg) => {
            a0?.isAuthorized() && (xu("[initializeMobileProvider: sendRequest()] already authorized"), $g(!0)), a0?.getConnector().once(bo.AUTHORIZED, () => {
              $g(!0);
            }), s0.once(bo.PROVIDER_UPDATE, (bg) => {
              xu(`[initializeMobileProvider: sendRequest()] PROVIDER_UPDATE --- remote provider request interupted type=${bg}`), bg === uh.EXTENSION ? Eg(bo.PROVIDER_UPDATE) : Eg(new Error("Connection Terminated"));
            });
          });
        } catch ($g) {
          if (uh.EXTENSION === $g) {
            if (xu(`[initializeMobileProvider: sendRequest()] extension provider detect: re-create ${F0} on the active provider`), F0.toLowerCase() === th.METAMASK_CONNECTSIGN.toLowerCase()) {
              const Eg = yield (_0 = s0.getProvider()) === null || _0 === void 0 ? void 0 : _0.request({ method: th.ETH_REQUESTACCOUNTS, params: [] });
              if (!Eg.length)
                throw new Error("SDK state invalid -- undefined accounts");
              const bg = yield ($0 = s0.getProvider()) === null || $0 === void 0 ? void 0 : $0.request({ method: th.PERSONAL_SIGN, params: [yg[0], Eg[0]] });
              return s0.emit(Fu.ConnectWithResponse, bg), bg;
            }
            if (F0.toLowerCase() === th.METAMASK_CONNECTWITH.toLowerCase()) {
              const [Eg] = yg, bg = yield (({ method: vg, sdk: Ag, params: Ig }) => a(void 0, void 0, void 0, function* () {
                var Mg, Sg, Ng, Rg;
                if (!Ag.isExtensionActive())
                  throw new Error("SDK state invalid -- extension is not active");
                xu("[MetaMaskProvider: extensionConnectWithOverwrite()] Overwriting request method", vg, Ig);
                const kg = yield (Mg = Ag.getProvider()) === null || Mg === void 0 ? void 0 : Mg.request({ method: th.ETH_REQUESTACCOUNTS, params: [] });
                if (!kg.length)
                  throw new Error("SDK state invalid -- undefined accounts");
                if (vg?.toLowerCase() === th.PERSONAL_SIGN.toLowerCase()) {
                  const Dg = { method: vg, params: [Ig[0], kg[0]] };
                  return yield (Sg = Ag.getProvider()) === null || Sg === void 0 ? void 0 : Sg.request(Dg);
                }
                if (vg?.toLowerCase() === th.ETH_SENDTRANSACTION.toLowerCase()) {
                  const Dg = { method: vg, params: [Object.assign(Object.assign({}, Ig[0]), { from: kg[0] })] };
                  return yield (Ng = Ag.getProvider()) === null || Ng === void 0 ? void 0 : Ng.request(Dg);
                }
                return ih.includes(vg.toLowerCase()) ? (console.warn(`MetaMaskSDK connectWith method=${vg} -- not handled by the extension -- call separately`), kg) : yield (Rg = Ag.getProvider()) === null || Rg === void 0 ? void 0 : Rg.request({ method: vg, params: Ig });
              }))({ method: Eg.method, sdk: s0, params: Eg.params });
              return s0.emit(Fu.ConnectWithResponse, bg), bg;
            }
            return xu(`[initializeMobileProvider: sendRequest()] sending '${F0}' on active provider`, yg), yield (C0 = s0.getProvider()) === null || C0 === void 0 ? void 0 : C0.request({ method: F0, params: yg });
          }
          throw $g === bo.REJECTED ? (a0?.closeModal(), (M0 = s0.getProvider()) === null || M0 === void 0 || M0.handleDisconnect({ terminate: !1 }), Object.assign(new Error("User rejected connection"), { code: 4001 })) : (xu(`[initializeMobileProvider: sendRequest()] failed to start installer: ${$g}`), $g);
        } finally {
          D0(!1);
        }
        if (F0 === th.ETH_REQUESTACCOUNTS)
          return W0 = yield new Promise(($g) => {
            const Eg = setInterval(() => {
              const { accounts: bg } = v0.getState();
              bg && (clearInterval(Eg), $g(bg));
            }, 100);
          }), xu(`[initializeMobileProvider: sendRequest()] selectedAddress: ${B0} --- SKIP rpc call`), W0;
        if (F0 === th.METAMASK_CONNECTWITH)
          try {
            let $g = 0;
            const Eg = 5, bg = ({ resolve: Mg, reject: Sg }) => {
              $g += 1;
              const Ng = a0?.getConnector().getRPCMethodTracker(), Rg = Ng?.[wg];
              return xu(`TRACKER: update method ${wg}`, Rg), Rg?.result ? (xu("[initializeMobileProvider: sendRequest()] found result", Rg.result), s0.emit(Fu.ConnectWithResponse, Rg.result), void Mg(Rg.result)) : Rg?.error ? (xu("[initializeMobileProvider: sendRequest()] found error", Rg.error), void Sg(Rg.error)) : $g >= Eg ? (xu("[initializeMobileProvider: sendRequest()] max message count reached without result"), void Sg(new Error("Max message count reached without result"))) : void xu("[initializeMobileProvider: sendRequest()] not found yet, need to wait for next update");
            };
            let vg, Ag;
            const Ig = yield new Promise((Mg, Sg) => {
              const Ng = a0?.getConnector().getRPCMethodTracker();
              xu(`TRACKER: method ${wg}`, Ng), Ng?.[wg].result ? (xu("[initializeMobileProvider: sendRequest()] found result", Ng?.[wg].result), Mg(Ng?.[wg].result)) : Ng?.[wg].error && (xu("[initializeMobileProvider: sendRequest()] found error", Ng?.[wg].error), Sg(Ng?.[wg].error)), Ag = () => bg({ resolve: Mg, reject: Sg }), vg = a0?.getConnector().on(bo.RPC_UPDATE, Ag);
            });
            return Ag && vg?.off(bo.RPC_UPDATE, Ag), xu("TRACKER: result", Ig), Ig;
          } catch ($g) {
            throw xu("[initializeMobileProvider: sendRequest()] error:", $g), $g;
          }
        return H0[0] && typeof H0[0] == "object" && (H0[0].params = { __triggeredInstaller: !0, wrappedParams: H0[0].params }), P0(...H0);
      }
      if (i0.isSecure() && nh[F0])
        return P0(...H0);
      if (s0.isExtensionActive())
        return xu(`[initializeMobileProvider: sendRequest()] EXTENSION active - redirect request '${F0}' to it`, H0, yg), yield (p0 = s0.getProvider()) === null || p0 === void 0 ? void 0 : p0.request({ method: F0, params: yg });
      throw xu(`[initializeMobileProvider: sendRequest()] method=${F0} --- skip --- not connected/installed`), new Error("MetaMask is not connected/installed, please call eth_requestAccounts to connect first.");
    }
    try {
      const yg = yield P0(...H0);
      if (xu(`[initializeMobileProvider: sendRequest()] method=${F0} rpcResponse`, yg), F0 === th.WALLET_REQUESTPERMISSIONS) {
        const _g = yg.reduce((wg, $g) => {
          var Eg;
          if ($g.parentCapability === "eth_accounts") {
            const bg = (Eg = $g.caveats.find((vg) => vg.type === "restrictReturnedAccounts")) === null || Eg === void 0 ? void 0 : Eg.value;
            bg && wg.push(...bg);
          }
          return wg;
        }, []);
        xu("[initializeMobileProvider: sendRequest()] accountsToPersist:", _g), _g.length > 0 && (v0.handleAccountsChanged(_g, !1), b0?.persistAccounts(_g));
      }
      return yg;
    } catch (yg) {
      throw console.error("[initializeMobileProvider: sendRequest()] error:", yg), yg;
    }
  }), { request: K0 } = S0;
  S0.request = (...F0) => a(void 0, void 0, void 0, function* () {
    return G0(F0?.[0].method, F0, K0, c0);
  });
  const { send: U0 } = S0;
  return S0.send = (...F0) => a(void 0, void 0, void 0, function* () {
    return G0(F0?.[0], F0, U0, c0);
  }), xu("[initializeMobileProvider: sendRequest()] metamaskStream.start()"), d0.start(), S0;
});
function Eh(t0) {
  var e0, n0, r0, i0;
  return a(this, void 0, void 0, function* () {
    const { options: o0 } = t0, s0 = { communicationLayerPreference: (e0 = o0.communicationLayerPreference) !== null && e0 !== void 0 ? e0 : Do.SOCKET, platformManager: t0.platformManager, sdk: t0, checkInstallationOnAllCalls: o0.checkInstallationOnAllCalls, injectProvider: (n0 = o0.injectProvider) === null || n0 === void 0 || n0, shouldShimWeb3: (r0 = o0.shouldShimWeb3) === null || r0 === void 0 || r0, extensionOnly: (i0 = o0.extensionOnly) === null || i0 === void 0 || i0, installer: t0.installer, remoteConnection: t0.remoteConnection, debug: t0.debug }, a0 = yield wh(s0);
    t0.activeProvider = a0, function(c0) {
      var l0, u0, d0, h0;
      (u0 = (l0 = c0.remoteConnection) === null || l0 === void 0 ? void 0 : l0.getConnector()) === null || u0 === void 0 || u0.on(Fu.ConnectionStatus, (g0) => {
        c0.emit(Fu.ConnectionStatus, g0);
      }), (h0 = (d0 = c0.remoteConnection) === null || d0 === void 0 ? void 0 : d0.getConnector()) === null || h0 === void 0 || h0.on(Fu.ServiceStatus, (g0) => {
        c0.emit(Fu.ServiceStatus, g0);
      });
    }(t0);
  });
}
const Sh = "sdk";
class _h {
  constructor({ serverUrl: e0, enabled: n0, originatorInfo: r0 }) {
    this.serverURL = ho, this.serverURL = e0, this.originatorInfo = r0, this.enabled = n0 == null || n0;
  }
  send({ event: e0, params: n0 }) {
    if (!this.enabled)
      return;
    const r0 = Object.assign(Object.assign({ id: Sh, event: e0, sdkVersion: Yu.version }, this.originatorInfo), { params: n0 });
    xu(`[Analytics: send()] event: ${e0}`, r0), co(r0, this.serverURL).catch((i0) => {
      xu(`[Analytics: send()] error: ${i0}`);
    });
  }
}
const Ch = () => {
  if (typeof document > "u")
    return;
  let t0;
  const e0 = document.getElementsByTagName("link");
  for (let n0 = 0; n0 < e0.length; n0++)
    e0[n0].getAttribute("rel") !== "icon" && e0[n0].getAttribute("rel") !== "shortcut icon" || (t0 = e0[n0].getAttribute("href"));
  return t0;
}, kh = 163400;
function xh(t0) {
  var e0, n0, r0;
  const { dappMetadata: i0 } = t0, o0 = function({ url: u0, name: d0 }) {
    var h0;
    const g0 = u0 + d0, w0 = gh(g0);
    if (!localStorage)
      return "";
    let y0 = (h0 = localStorage.getItem(w0)) !== null && h0 !== void 0 ? h0 : "";
    if (!y0) {
      y0 = v4();
      try {
        localStorage.setItem(w0, y0);
      } catch {
        return "";
      }
    }
    return y0;
  }({ url: (e0 = i0?.url) !== null && e0 !== void 0 ? e0 : "no_url", name: (n0 = i0?.name) !== null && n0 !== void 0 ? n0 : "no_name" }), s0 = (r0 = t0.platformManager) === null || r0 === void 0 ? void 0 : r0.getPlatformType(), a0 = s0 === Bo.DesktopWeb, c0 = s0 === Bo.MetaMaskMobileWebview;
  let l0 = "N/A";
  return a0 ? l0 = "extension" : c0 && (l0 = "mobile"), { id: o0, from: l0 };
}
const Mh = ({ provider: t0, sdkInstance: e0 }) => {
  if ("state" in t0)
    throw new Error("INVALID EXTENSION PROVIDER");
  return new Proxy(t0, { get: (n0, r0) => r0 === "request" ? function(i0) {
    var o0, s0;
    return a(this, void 0, void 0, function* () {
      xu("[wrapExtensionProvider()] Overwriting request method", i0);
      const { method: a0, params: c0 } = i0, l0 = rh.includes(a0.toLowerCase()), { id: u0, from: d0 } = xh(e0);
      if (l0 && ((o0 = e0.analytics) === null || o0 === void 0 || o0.send({ event: _o.SDK_RPC_REQUEST, params: { method: a0, from: d0, id: u0 } })), a0 === th.METAMASK_BATCH && Array.isArray(c0))
        return (({ target: g0, args: w0, trackEvent: y0, sdkInstance: E0 }) => a(void 0, void 0, void 0, function* () {
          var b0, O0;
          if (w0.method !== "metamask_batch")
            throw new Error("Invalid usage");
          const S0 = [], k0 = (b0 = w0?.params) !== null && b0 !== void 0 ? b0 : [];
          for (const G0 of k0) {
            const K0 = yield g0?.request({ method: G0.method, params: G0.params });
            S0.push(K0);
          }
          const { id: D0, from: z0 } = xh(E0);
          return y0 && ((O0 = E0.analytics) === null || O0 === void 0 || O0.send({ event: _o.SDK_RPC_REQUEST_DONE, params: { method: w0.method, from: z0, id: D0 } })), S0;
        }))({ target: n0, args: i0, trackEvent: l0, sdkInstance: e0 });
      if (a0.toLowerCase() === th.METAMASK_CONNECTSIGN.toLowerCase() && Array.isArray(c0))
        return (({ target: g0, params: w0 }) => a(void 0, void 0, void 0, function* () {
          const y0 = yield g0.request({ method: th.ETH_REQUESTACCOUNTS, params: [] });
          if (!y0.length)
            throw new Error("SDK state invalid -- undefined accounts");
          return yield g0.request({ method: th.PERSONAL_SIGN, params: [w0[0], y0[0]] });
        }))({ target: n0, params: c0 });
      if (a0.toLowerCase() === th.METAMASK_CONNECTWITH.toLowerCase() && Array.isArray(c0))
        return (({ target: g0, params: w0 }) => a(void 0, void 0, void 0, function* () {
          const [y0] = w0, E0 = y0.method, b0 = y0.params, O0 = yield g0.request({ method: th.ETH_REQUESTACCOUNTS, params: [] });
          if (!O0.length)
            throw new Error("SDK state invalid -- undefined accounts");
          return E0?.toLowerCase() === th.PERSONAL_SIGN.toLowerCase() ? yield g0.request({ method: E0, params: [b0[0], O0[0]] }) : E0?.toLowerCase() === th.ETH_SENDTRANSACTION.toLowerCase() ? yield g0.request({ method: E0, params: [Object.assign(Object.assign({}, b0[0]), { from: O0[0] })] }) : ih.includes(E0.toLowerCase()) ? (console.warn(`MetaMaskSDK connectWith method=${E0} -- not handled by the extension -- call separately`), O0) : yield g0.request({ method: E0, params: b0 });
        }))({ target: n0, params: c0 });
      let h0;
      try {
        return h0 = yield n0.request(i0), h0;
      } finally {
        l0 && ((s0 = e0.analytics) === null || s0 === void 0 || s0.send({ event: _o.SDK_RPC_REQUEST_DONE, params: { method: a0, from: d0, id: u0 } }));
      }
    });
  } : r0 === "getChainId" ? function() {
    return t0.chainId;
  } : r0 === "getNetworkVersion" ? function() {
    return t0.networkVersion;
  } : r0 === "getSelectedAddress" ? function() {
    return t0.selectedAddress;
  } : r0 === "isConnected" ? function() {
    return t0._state.isConnected;
  } : n0[r0] });
};
var Ah;
function Ih({ mustBeMetaMask: t0, sdkInstance: e0 }) {
  return a(this, void 0, void 0, function* () {
    if (typeof window > "u")
      throw new Error("window not available");
    try {
      const n0 = yield new Promise((r0, i0) => {
        const o0 = setTimeout(() => {
          i0(new Error("eip6963RequestProvider timed out"));
        }, 500);
        window.addEventListener(Ah.Announce, (s0) => {
          const a0 = s0, { detail: { info: c0, provider: l0 } = {} } = a0, { name: u0, rdns: d0, uuid: h0 } = c0 ?? {};
          eh.test(h0) && u0.startsWith(Qu.NAME) && Qu.RDNS.includes(d0) && (clearTimeout(o0), r0(l0));
        }), window.dispatchEvent(new Event(Ah.Request));
      });
      return Mh({ provider: n0, sdkInstance: e0 });
    } catch {
      if (!t0 && window.ethereum)
        return Mh({ provider: window.ethereum, sdkInstance: e0 });
      throw new Error("Provider not found");
    }
  });
}
(function(t0) {
  t0.Announce = "eip6963:announceProvider", t0.Request = "eip6963:requestProvider";
})(Ah || (Ah = {}));
const Rh = (t0) => a(void 0, void 0, void 0, function* () {
  const { options: e0 } = t0, { infuraAPIKey: n0 } = e0;
  if (!n0)
    return;
  const r0 = { "0x1": `https://mainnet.infura.io/v3/${n0}`, "0x5": `https://goerli.infura.io/v3/${n0}`, "0xaa36a7": `https://sepolia.infura.io/v3/${n0}`, "0xe708": `https://linea-mainnet.infura.io/v3/${n0}`, "0xe704": `https://linea-goerli.infura.io/v3/${n0}`, "0x89": `https://polygon-mainnet.infura.io/v3/${n0}`, "0x13881": `https://polygon-mumbai.infura.io/v3/${n0}`, "0x45": `https://optimism-mainnet.infura.io/v3/${n0}`, "0x1a4": `https://optimism-goerli.infura.io/v3/${n0}`, "0xa4b1": `https://arbitrum-mainnet.infura.io/v3/${n0}`, "0x66eed": `https://arbitrum-goerli.infura.io/v3/${n0}`, "0x2a15c308d": `https://palm-mainnet.infura.io/v3/${n0}`, "0x2a15c3083": `https://palm-testnet.infura.io/v3/${n0}`, "0xa86a": `https://avalanche-mainnet.infura.io/v3/${n0}`, "0xa869": `https://avalanche-fuji.infura.io/v3/${n0}`, "0x4e454152": `https://aurora-mainnet.infura.io/v3/${n0}`, "0x4e454153": `https://aurora-testnet.infura.io/v3/${n0}`, "0x534e5f4d41494e": `https://starknet-mainnet.infura.io/v3/${n0}`, "0x534e5f474f45524c49": `https://starknet-goerli.infura.io/v3/${n0}`, "0x534e5f474f45524c4932": `https://starknet-goerli2.infura.io/v3/${n0}`, "0xa4ec": `https://celo-mainnet.infura.io/v3/${n0}`, "0xaef3": `https://celo-alfajores.infura.io/v3/${n0}` };
  t0.options.readonlyRPCMap ? t0.options.readonlyRPCMap = Object.assign(Object.assign({}, t0.options.readonlyRPCMap), r0) : t0.options.readonlyRPCMap = r0;
}), Ph = (t0) => a(void 0, void 0, void 0, function* () {
  const { options: e0 } = t0, { readonlyRPCMap: n0 } = e0;
  if (n0)
    try {
      xu("[MetaMaskSDK: setupReadOnlyRPCProviders()] Setting up Readonly RPC Providers", n0), t0.setReadOnlyRPCCalls(!0);
    } catch {
      throw new Error("Invalid Infura Settings");
    }
});
function Th(t0, e0, n0, r0) {
  return new (n0 || (n0 = Promise))(function(i0, o0) {
    function s0(l0) {
      try {
        c0(r0.next(l0));
      } catch (u0) {
        o0(u0);
      }
    }
    function a0(l0) {
      try {
        c0(r0.throw(l0));
      } catch (u0) {
        o0(u0);
      }
    }
    function c0(l0) {
      var u0;
      l0.done ? i0(l0.value) : (u0 = l0.value, u0 instanceof n0 ? u0 : new n0(function(d0) {
        d0(u0);
      })).then(s0, a0);
    }
    c0((r0 = r0.apply(t0, [])).next());
  });
}
function Oh(t0, e0) {
  var n0, r0, i0, o0, s0 = { label: 0, sent: function() {
    if (1 & i0[0])
      throw i0[1];
    return i0[1];
  }, trys: [], ops: [] };
  return o0 = { next: a0(0), throw: a0(1), return: a0(2) }, typeof Symbol == "function" && (o0[Symbol.iterator] = function() {
    return this;
  }), o0;
  function a0(c0) {
    return function(l0) {
      return function(u0) {
        if (n0)
          throw new TypeError("Generator is already executing.");
        for (; s0; )
          try {
            if (n0 = 1, r0 && (i0 = 2 & u0[0] ? r0.return : u0[0] ? r0.throw || ((i0 = r0.return) && i0.call(r0), 0) : r0.next) && !(i0 = i0.call(r0, u0[1])).done)
              return i0;
            switch (r0 = 0, i0 && (u0 = [2 & u0[0], i0.value]), u0[0]) {
              case 0:
              case 1:
                i0 = u0;
                break;
              case 4:
                return s0.label++, { value: u0[1], done: !1 };
              case 5:
                s0.label++, r0 = u0[1], u0 = [0];
                continue;
              case 7:
                u0 = s0.ops.pop(), s0.trys.pop();
                continue;
              default:
                if (i0 = s0.trys, !((i0 = i0.length > 0 && i0[i0.length - 1]) || u0[0] !== 6 && u0[0] !== 2)) {
                  s0 = 0;
                  continue;
                }
                if (u0[0] === 3 && (!i0 || u0[1] > i0[0] && u0[1] < i0[3])) {
                  s0.label = u0[1];
                  break;
                }
                if (u0[0] === 6 && s0.label < i0[1]) {
                  s0.label = i0[1], i0 = u0;
                  break;
                }
                if (i0 && s0.label < i0[2]) {
                  s0.label = i0[2], s0.ops.push(u0);
                  break;
                }
                i0[2] && s0.ops.pop(), s0.trys.pop();
                continue;
            }
            u0 = e0.call(t0, s0);
          } catch (d0) {
            u0 = [6, d0], r0 = 0;
          } finally {
            n0 = i0 = 0;
          }
        if (5 & u0[0])
          throw u0[1];
        return { value: u0[0] ? u0[1] : void 0, done: !0 };
      }([c0, l0]);
    };
  }
}
var Lh = "INSTALLED", Nh = "NOT_INSTALLED", $h = "REGISTERED", Dh = "REGISTERING", Bh = "RELOADING", Kh = { CHROME: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn", FIREFOX: "https://addons.mozilla.org/firefox/addon/ether-metamask/", DEFAULT: "https://metamask.io" }, jh = "REGISTRATION_IN_PROGRESS", Uh = "FORWARDER_ID", Hh = function() {
  function t0(e0) {
    var n0 = e0 === void 0 ? {} : e0, r0 = n0.forwarderOrigin, i0 = r0 === void 0 ? "https://fwd.metamask.io" : r0, o0 = n0.forwarderMode, s0 = o0 === void 0 ? t0.FORWARDER_MODE.INJECT : o0;
    this.forwarderOrigin = i0, this.forwarderMode = s0, this.state = t0.isMetaMaskInstalled() ? Lh : Nh;
    var a0 = t0._detectBrowser();
    this.downloadUrl = a0 ? Kh[a0] : Kh.DEFAULT, this._onMessage = this._onMessage.bind(this), this._onMessageFromForwarder = this._onMessageFromForwarder.bind(this), this._openForwarder = this._openForwarder.bind(this), this._openDownloadPage = this._openDownloadPage.bind(this), this.startOnboarding = this.startOnboarding.bind(this), this.stopOnboarding = this.stopOnboarding.bind(this), window.addEventListener("message", this._onMessage), s0 === t0.FORWARDER_MODE.INJECT && sessionStorage.getItem(jh) === "true" && t0._injectForwarder(this.forwarderOrigin);
  }
  return t0.prototype._onMessage = function(e0) {
    if (e0.origin === this.forwarderOrigin)
      return e0.data.type === "metamask:reload" ? this._onMessageFromForwarder(e0) : void console.debug("Unknown message from '" + e0.origin + "' with data " + JSON.stringify(e0.data));
  }, t0.prototype._onMessageUnknownStateError = function(e0) {
    throw new Error("Unknown state: '" + e0 + "'");
  }, t0.prototype._onMessageFromForwarder = function(e0) {
    return Th(this, 0, void 0, function() {
      return Oh(this, function(n0) {
        switch (n0.label) {
          case 0:
            switch (this.state) {
              case Bh:
                return [3, 1];
              case Nh:
                return [3, 2];
              case Lh:
                return [3, 3];
              case Dh:
                return [3, 5];
              case $h:
                return [3, 6];
            }
            return [3, 7];
          case 1:
            return console.debug("Ignoring message while reloading"), [3, 8];
          case 2:
            return console.debug("Reloading now to register with MetaMask"), this.state = Bh, location.reload(), [3, 8];
          case 3:
            return console.debug("Registering with MetaMask"), this.state = Dh, [4, t0._register()];
          case 4:
            return n0.sent(), this.state = $h, e0.source.postMessage({ type: "metamask:registrationCompleted" }, e0.origin), this.stopOnboarding(), [3, 8];
          case 5:
            return console.debug("Already registering - ignoring reload message"), [3, 8];
          case 6:
            return console.debug("Already registered - ignoring reload message"), [3, 8];
          case 7:
            this._onMessageUnknownStateError(this.state), n0.label = 8;
          case 8:
            return [2];
        }
      });
    });
  }, t0.prototype.startOnboarding = function() {
    sessionStorage.setItem(jh, "true"), this._openDownloadPage(), this._openForwarder();
  }, t0.prototype.stopOnboarding = function() {
    sessionStorage.getItem(jh) === "true" && (this.forwarderMode === t0.FORWARDER_MODE.INJECT && (console.debug("Removing forwarder"), t0._removeForwarder()), sessionStorage.setItem(jh, "false"));
  }, t0.prototype._openForwarder = function() {
    this.forwarderMode === t0.FORWARDER_MODE.OPEN_TAB ? window.open(this.forwarderOrigin, "_blank") : t0._injectForwarder(this.forwarderOrigin);
  }, t0.prototype._openDownloadPage = function() {
    window.open(this.downloadUrl, "_blank");
  }, t0.isMetaMaskInstalled = function() {
    return !!(window.ethereum && window.ethereum.isMetaMask);
  }, t0._register = function() {
    return window.ethereum.request({ method: "wallet_registerOnboarding" });
  }, t0._injectForwarder = function(e0) {
    var n0 = document.body, r0 = document.createElement("iframe");
    r0.setAttribute("height", "0"), r0.setAttribute("width", "0"), r0.setAttribute("style", "display: none;"), r0.setAttribute("src", e0), r0.setAttribute("id", Uh), n0.insertBefore(r0, n0.children[0]);
  }, t0._removeForwarder = function() {
    var e0;
    (e0 = document.getElementById(Uh)) === null || e0 === void 0 || e0.remove();
  }, t0._detectBrowser = function() {
    var e0 = Hu.parse(window.navigator.userAgent);
    return e0.browser.name === "Firefox" ? "FIREFOX" : ["Chrome", "Chromium"].includes(e0.browser.name || "") ? "CHROME" : null;
  }, t0.FORWARDER_MODE = { INJECT: "INJECT", OPEN_TAB: "OPEN_TAB" }, t0;
}();
function Fh(t0, { wait: e0 = !1 }) {
  return a(this, void 0, void 0, function* () {
    return xu(`[MetamaskInstaller: startInstaller()] wait=${e0}`), e0 && (yield bh(1e3)), yield t0.checkInstallation();
  });
}
class zh {
  constructor({ remote: e0, preferDesktop: n0, platformManager: r0, debug: i0 = !1 }) {
    this.state = { isInstalling: !1, hasInstalled: !1, resendRequest: null, preferDesktop: !1, platformManager: null, remote: null, debug: !1, connectWith: void 0 }, this.state.remote = e0, this.state.preferDesktop = n0, this.state.platformManager = r0, this.state.debug = i0;
  }
  startDesktopOnboarding() {
    return function() {
      return a(this, void 0, void 0, function* () {
        xu("[MetamaskInstaller: startDesktopOnboarding() starting desktop onboarding"), window.ethereum && (window.ethereum = void 0), new Hh().startOnboarding();
      });
    }();
  }
  redirectToProperInstall() {
    return a(this, void 0, void 0, function* () {
      return function(e0) {
        var n0, r0;
        return a(this, void 0, void 0, function* () {
          const { state: i0 } = e0, o0 = (n0 = i0.platformManager) === null || n0 === void 0 ? void 0 : n0.getPlatformType();
          if (xu(`[MetamaskInstaller: redirectToProperInstall()] platform=${o0}`), o0 === Bo.MetaMaskMobileWebview)
            return !1;
          i0.isInstalling = !0;
          try {
            yield (r0 = i0.remote) === null || r0 === void 0 ? void 0 : r0.startConnection({ connectWith: i0.connectWith }), i0.isInstalling = !1, i0.hasInstalled = !0;
          } catch (s0) {
            throw i0.isInstalling = !1, s0;
          }
          return !0;
        });
      }(this);
    });
  }
  checkInstallation() {
    return a(this, void 0, void 0, function* () {
      return function(e0) {
        var n0;
        return a(this, void 0, void 0, function* () {
          const { state: r0 } = e0, i0 = (n0 = r0.platformManager) === null || n0 === void 0 ? void 0 : n0.isMetaMaskInstalled();
          return xu(`[MetamaskInstaller: checkInstallation()] isInstalled=${i0}`), !!i0 || (yield e0.redirectToProperInstall());
        });
      }(this);
    });
  }
  start({ wait: e0 = !1, connectWith: n0 }) {
    return a(this, void 0, void 0, function* () {
      this.state.connectWith = n0, xu(`[MetaMaskInstaller: start()] wait=${e0}`, n0), yield Fh(this, { wait: e0 });
    });
  }
}
class qh {
  constructor({ debug: e0, sdkVersion: n0 }) {
    this.containers = { install: void 0, pending: void 0, select: void 0 }, this.defined = { install: !1, pending: !1, select: !1 }, this.debug = e0 != null && e0, this.sdkVersion = n0;
  }
  loadComponent(e0) {
    return a(this, void 0, void 0, function* () {
      if (!this.defined[e0]) {
        this.defined[e0] = !0;
        try {
          const n0 = yield Promise.resolve().then(function() {
            return Rp;
          });
          console.log("loader", n0), n0.defineCustomElements();
        } catch (n0) {
          console.error(`Failed to load ${e0} modal:`, n0);
        }
      }
    });
  }
  renderInstallModal(e0) {
    var n0;
    return a(this, void 0, void 0, function* () {
      this.debug && console.debug("ModalLoader: renderInstallModal", e0), this.containers.install = e0.parentElement, yield this.loadComponent("install");
      const r0 = document.createElement("mm-install-modal");
      r0.link = e0.link, r0.preferDesktop = e0.preferDesktop, r0.sdkVersion = (n0 = e0.sdkVersion) !== null && n0 !== void 0 ? n0 : this.sdkVersion, r0.addEventListener("close", ({ detail: { shouldTerminate: i0 } }) => e0.onClose(i0)), r0.addEventListener("startDesktopOnboarding", e0.metaMaskInstaller.startDesktopOnboarding), r0.addEventListener("trackAnalytics", (i0) => {
        var o0;
        return (o0 = e0.onAnalyticsEvent) === null || o0 === void 0 ? void 0 : o0.call(e0, i0.detail);
      }), e0.parentElement.appendChild(r0);
    });
  }
  renderSelectModal(e0) {
    var n0;
    return a(this, void 0, void 0, function* () {
      this.containers.select = e0.parentElement, yield this.loadComponent("select");
      const r0 = document.createElement("mm-select-modal");
      r0.link = e0.link, r0.sdkVersion = (n0 = e0.sdkVersion) !== null && n0 !== void 0 ? n0 : this.sdkVersion, r0.preferDesktop = e0.preferDesktop, r0.addEventListener("close", ({ detail: { shouldTerminate: i0 } }) => e0.onClose(i0)), r0.addEventListener("connectWithExtension", e0.connectWithExtension), e0.parentElement.appendChild(r0), setTimeout(() => this.updateQRCode(e0.link), 100);
    });
  }
  renderPendingModal(e0) {
    var n0;
    return a(this, void 0, void 0, function* () {
      this.containers.pending = e0.parentElement, yield this.loadComponent("pending");
      const r0 = document.createElement("mm-pending-modal");
      r0.sdkVersion = (n0 = e0.sdkVersion) !== null && n0 !== void 0 ? n0 : this.sdkVersion, r0.displayOTP = e0.displayOTP, r0.addEventListener("close", e0.onClose), r0.addEventListener("updateOTPValue", ({ detail: { otpValue: i0 } }) => e0.updateOTPValue(i0)), e0.onDisconnect && r0.addEventListener("disconnect", e0.onDisconnect), e0.parentElement.appendChild(r0);
    });
  }
  updateOTPValue(e0) {
    const n0 = () => {
      var r0;
      const i0 = (r0 = this.containers.pending) === null || r0 === void 0 ? void 0 : r0.querySelector("mm-pending-modal");
      return !!i0 && (i0.otpCode = e0, !0);
    };
    setTimeout(() => {
      n0();
    }, 800);
  }
  updateQRCode(e0) {
    var n0, r0;
    const i0 = (n0 = this.containers.install) === null || n0 === void 0 ? void 0 : n0.querySelector("mm-install-modal");
    if (i0)
      i0.link = e0;
    else {
      const o0 = (r0 = this.containers.select) === null || r0 === void 0 ? void 0 : r0.querySelector("mm-select-modal");
      o0 && (o0.link = e0);
    }
  }
  unmount() {
    Object.entries(this.containers).forEach(([e0, n0]) => {
      var r0;
      (r0 = n0?.parentNode) === null || r0 === void 0 || r0.removeChild(n0), this.containers[e0] = void 0;
    });
  }
}
const Wh = ({ link: t0, debug: e0, installer: n0, terminate: r0, connectWithExtension: i0, preferDesktop: o0, onAnalyticsEvent: s0 }) => {
  let a0 = null, c0 = null;
  xu("[UI: InstallModal-web: sdkWebInstallModal()] ################## Installing Modal #################"), xu(`[UI: InstallModal-web: sdkWebInstallModal()] link=${t0}`), xu(`[UI: InstallModal-web: sdkWebInstallModal()] npx uri-scheme open "${t0}" --ios`), xu(`[UI: InstallModal-web: sdkWebInstallModal()] npx uri-scheme open "${t0}" --android`), xu(`[UI: InstallModal-web: sdkWebInstallModal()] adb shell am start -a android.intent.action.VIEW -d "${t0}"`);
  const l0 = (u0) => {
    var d0;
    xu("[UI: InstallModal-web: sdkWebInstallModal()] installModal-web unmounting install modal -- shouldTerminate:", u0, c0), c0?.parentNode && ((d0 = c0.parentNode) === null || d0 === void 0 || d0.removeChild(c0)), c0 = null, a0 = null, u0 === !0 && r0?.();
  };
  return { mount: (u0) => {
    if (xu("[UI: InstallModal-web: sdkWebInstallModal()] installModal-web mounting install modal", c0), c0)
      return c0.style.display = "block", void (a0 == null || a0.updateQRCode(u0));
    a0 = new qh({ debug: e0, sdkVersion: Yu.version }), c0 = document.createElement("div"), document.body.appendChild(c0), window.extension ? a0.renderSelectModal({ parentElement: c0, connectWithExtension: () => {
      l0(), i0?.();
    }, onClose: l0, link: t0, preferDesktop: o0 != null && o0 }).catch((d0) => {
      console.error(d0);
    }) : a0.renderInstallModal({ parentElement: c0, preferDesktop: o0 != null && o0, link: t0, metaMaskInstaller: n0, onClose: l0, onAnalyticsEvent: s0 }).catch((d0) => {
      console.error("[UI: InstallModal-web: sdkWebInstallModal()]", d0);
    });
  }, unmount: l0 };
}, Vh = ({ onDisconnect: t0, debug: e0 }) => {
  let n0 = null, r0 = null;
  const i0 = () => {
    xu("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web unmount", n0), n0?.parentNode && n0.parentNode.removeChild(n0), n0 = null, r0 = null;
  }, o0 = (a0) => {
    xu("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web updateOTPValue", a0), r0 && r0.updateOTPValue(a0);
  }, s0 = ({ displayOTP: a0 } = { displayOTP: !0 }) => {
    xu("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web mount", n0), n0 ? n0.style.display = "block" : (r0 = new qh({ debug: e0, sdkVersion: Yu.version }), n0 = document.createElement("div"), document.body.appendChild(n0), r0.renderPendingModal({ parentElement: n0, onClose: i0, onDisconnect: t0, updateOTPValue: o0, displayOTP: a0 }).catch((c0) => {
      console.error("[UI: pendingModal-web: sdkWebPendingModal()]", c0);
    }));
  };
  return s0(), { mount: s0, unmount: i0, updateOTPValue: o0 };
};
function Gh(t0, e0) {
  var n0, r0, i0, o0;
  t0.connector || (xu("[RemoteConnection: initializeConnector()] initialize connector"), t0.connector = new Xo({ platformType: e0.platformManager.getPlatformType(), communicationLayerPreference: e0.communicationLayerPreference, transports: e0.transports, dappMetadata: Object.assign(Object.assign({}, e0.dappMetadata), { source: e0._source }), analytics: e0.enableAnalytics, communicationServerUrl: e0.communicationServerUrl, sdkVersion: Yu.version, context: "dapp", ecies: e0.ecies, storage: e0.storage, logging: e0.logging }), e0.timer && (xu("[RemoteConnection: initializeConnector()] reset background timer", e0.timer), (r0 = (n0 = e0.timer) === null || n0 === void 0 ? void 0 : n0.stopBackgroundTimer) === null || r0 === void 0 || r0.call(n0), (o0 = (i0 = e0.timer) === null || i0 === void 0 ? void 0 : i0.runBackgroundTimer) === null || o0 === void 0 || o0.call(i0, () => !1, 1e4)));
}
function Yh(t0) {
  t0.listeners.forEach(({ event: e0, handler: n0 }) => {
    var r0;
    (r0 = t0.connector) === null || r0 === void 0 || r0.off(e0, n0);
  }), t0.listeners = [];
}
function Zh(t0, e0, n0) {
  return a(this, void 0, void 0, function* () {
    return new Promise((r0, i0) => {
      if (!t0.connector)
        return void i0(new Error("No connector available"));
      xu("[RemoteConnection: connectWithModalInstaller()]", { state: t0, options: e0, linkParams: n0 });
      const o0 = `${t0.useDeeplink ? Xu : Ju}?${n0}`;
      (function(s0, a0, c0) {
        var l0, u0, d0, h0;
        s0.installModal = (u0 = (l0 = a0.modals).install) === null || u0 === void 0 ? void 0 : u0.call(l0, { link: c0, preferDesktop: s0.preferDesktop, installer: a0.getMetaMaskInstaller(), terminate: () => {
          xu("[RemoteConnection: showInstallModal() => terminate()] terminate connection"), a0.sdk.terminate().catch((g0) => {
            console.warn("[MMSDK] failed to terminate connection", g0);
          });
        }, debug: s0.developerMode, connectWithExtension: () => {
          var g0;
          return (g0 = a0.connectWithExtensionProvider) === null || g0 === void 0 || g0.call(a0), !1;
        }, onAnalyticsEvent: ({ event: g0, params: w0 }) => {
          var y0, E0, b0;
          const O0 = Object.assign(Object.assign({}, w0), { sdkVersion: a0.sdk.getVersion(), dappId: (y0 = a0.dappMetadata) === null || y0 === void 0 ? void 0 : y0.name, source: a0._source, url: (E0 = a0.dappMetadata) === null || E0 === void 0 ? void 0 : E0.url });
          (b0 = s0.analytics) === null || b0 === void 0 || b0.send({ event: g0, params: O0 });
        } }), (h0 = (d0 = s0.installModal) === null || d0 === void 0 ? void 0 : d0.mount) === null || h0 === void 0 || h0.call(d0, c0);
      })(t0, e0, o0), e0.sdk.once(bo.PROVIDER_UPDATE, (s0) => a(this, void 0, void 0, function* () {
        xu("[RemoteConnection: connectWithModalInstaller()] once provider_update -- resolving startConnection promise"), s0 !== uh.TERMINATE ? i0(s0) : i0({ code: 4001, message: "User rejected the request." });
      })), t0.connector.once(bo.AUTHORIZED, () => {
        r0();
      }), t0.connector.once(bo.REJECTED, () => {
        i0(bo.REJECTED);
      }), t0.connector.once(bo.CLIENTS_READY, () => a(this, void 0, void 0, function* () {
        xu("[RemoteConnection: connectWithModalInstaller()] once clients_ready -- resolving startConnection promise"), r0();
      }));
    });
  });
}
function Jh(t0, e0) {
  function n0(r0, i0) {
    var o0;
    (o0 = t0.connector) === null || o0 === void 0 || o0.on(r0, i0), t0.listeners.push({ event: r0, handler: i0 });
  }
  t0.connector && (Yh(t0), n0(bo.WALLET_INIT, ({ accounts: r0, chainId: i0 }) => a(this, void 0, void 0, function* () {
    xu(`[RemoteConnection: setupListeners() => EventType.WALLET_INIT] 'wallet_init' accounts=${r0} chainId=${i0}`);
    const o0 = zu.getProvider();
    o0._setConnected();
    const s0 = { accounts: r0, chainId: i0, isUnlocked: !1 };
    o0._initializeState(s0), o0.emit("chainChanged", i0), o0.emit("accountsChanged", r0);
  })), n0(bo.AUTHORIZED, () => a(this, void 0, void 0, function* () {
    var r0, i0, o0, s0;
    try {
      xu("[RemoteConnection: setupListeners() => EventType.AUTHORIZED] 'authorized' closing modals", t0.pendingModal, t0.installModal);
      const a0 = zu.getProvider();
      a0._setConnected(), (i0 = (r0 = t0.pendingModal) === null || r0 === void 0 ? void 0 : r0.unmount) === null || i0 === void 0 || i0.call(r0), (s0 = (o0 = t0.installModal) === null || o0 === void 0 ? void 0 : o0.unmount) === null || s0 === void 0 || s0.call(o0, !1), t0.otpAnswer = void 0, t0.authorized = !0, xu("[RemoteConnection: setupListeners() => EventType.AUTHORIZED] 'authorized' provider.state", a0.getState()), yield a0.forceInitializeState();
    } catch {
    }
  })), n0(bo.TERMINATE, () => {
    var r0, i0, o0, s0, a0;
    (i0 = (r0 = t0.pendingModal) === null || r0 === void 0 ? void 0 : r0.unmount) === null || i0 === void 0 || i0.call(r0), (s0 = (o0 = t0.installModal) === null || o0 === void 0 ? void 0 : o0.unmount) === null || s0 === void 0 || s0.call(o0, !0), t0.pendingModal = void 0, t0.installModal = void 0, t0.otpAnswer = void 0, (a0 = t0.connector) === null || a0 === void 0 || a0.disconnect({ terminate: !0 }), t0.authorized = !1, zu.getProvider().handleDisconnect({ terminate: !0 }), Yh(t0), xu("[RemoteConnection: setupListeners()] All listeners cleaned up");
  }));
}
function Xh(t0, e0, { initialCheck: n0, connectWith: r0 } = {}) {
  var i0, o0, s0, a0, c0, l0, u0, d0, h0, g0, w0, y0, E0, b0, O0, S0, k0, D0, z0;
  return a(this, void 0, void 0, function* () {
    try {
      if (Gh(t0, e0), !t0.connector)
        throw new Error("no connector defined");
      Jh(t0);
      const G0 = zu.getProvider();
      t0.authorized = !1, G0.emit("connecting");
      const K0 = yield (i0 = t0.connector) === null || i0 === void 0 ? void 0 : i0.originatorSessionConnect();
      xu(`[RemoteConnection: startConnection()] after originatorSessionConnect initialCheck=${n0}`, K0);
      let U0 = (o0 = K0?.channelId) !== null && o0 !== void 0 ? o0 : "", F0 = (a0 = (s0 = t0.connector.getKeyInfo()) === null || s0 === void 0 ? void 0 : s0.ecies.public) !== null && a0 !== void 0 ? a0 : "", H0 = (l0 = (c0 = t0.connector.getKeyInfo()) === null || c0 === void 0 ? void 0 : c0.ecies.private) !== null && l0 !== void 0 ? l0 : "";
      if (n0 && !K0)
        return Promise.resolve();
      if (!K0 && !n0) {
        const L0 = yield t0.connector.generateChannelIdConnect();
        U0 = (u0 = L0.channelId) !== null && u0 !== void 0 ? u0 : "", F0 = (d0 = L0.pubKey) !== null && d0 !== void 0 ? d0 : "", H0 = (h0 = L0.privKey) !== null && h0 !== void 0 ? h0 : "";
        const B0 = Date.now();
        (g0 = t0.connector.state.storageManager) === null || g0 === void 0 || g0.persistChannelConfig({ channelId: U0, localKey: H0, lastActive: B0, validUntil: B0 + po });
      }
      if (n0 && K0?.channelId)
        return !((w0 = t0.connector) === null || w0 === void 0) && w0.isConnected() || (xu(`[RemoteConnection: startConnection()] reconnecting to channel initialCheck=${n0}`, K0), yield (y0 = t0.connector) === null || y0 === void 0 ? void 0 : y0.connectToChannel({ channelId: U0 })), Promise.resolve();
      K0 && !(!((E0 = t0.connector) === null || E0 === void 0) && E0.isConnected()) && (xu("[RemoteConnection: startConnection()] reconnecting to channel", K0), yield (b0 = t0.connector) === null || b0 === void 0 ? void 0 : b0.connectToChannel({ channelId: U0 }));
      const P0 = !((O0 = t0.platformManager) === null || O0 === void 0) && O0.isSecure() ? "" : "&t=q", I0 = Yu.version, { iconUrl: f0, name: m0, url: A0, scheme: x0 } = e0.dappMetadata || {}, _0 = (S0 = t0.platformManager) === null || S0 === void 0 ? void 0 : S0.getPlatformType();
      let $0 = "N/A";
      typeof window < "u" && window.location && window.location.hostname ? $0 = window.location.hostname : m0 !== void 0 ? $0 = m0 : A0 !== void 0 && ($0 = A0);
      const C0 = { url: A0 ?? "", title: m0 ?? "", icon: f0, scheme: x0 ?? "", apiVersion: I0, dappId: $0 || A0 || "N/A", platform: _0 ?? "", source: (k0 = e0._source) !== null && k0 !== void 0 ? k0 : "" }, M0 = gh(JSON.stringify(C0));
      let p0 = `channelId=${U0}&v=2&comm=${(D0 = t0.communicationLayerPreference) !== null && D0 !== void 0 ? D0 : ""}&pubkey=${F0}${P0}&originatorInfo=${M0}`;
      if (r0) {
        p0 += `&rpc=${gh(JSON.stringify(r0))}`;
        const L0 = t0.connector.getRPCMethodTracker();
        L0 && (L0[`${r0.id}`] = Object.assign(Object.assign({}, r0), { id: `${r0.id}`, timestamp: Date.now() }));
      }
      const v0 = encodeURI(p0), T0 = `${t0.useDeeplink ? Xu : Ju}?${p0}`;
      return t0.qrcodeLink = T0, t0.developerMode && xu(`[RemoteConnection: startConnection()] qrcodeLink=${v0}`), G0.emit("display_uri", T0), !((z0 = t0.platformManager) === null || z0 === void 0) && z0.isSecure() ? (yield function(L0, B0) {
        var W0, V0;
        return a(this, void 0, void 0, function* () {
          const Q0 = `${Ju}?${B0}`, X0 = `${Xu}?${B0}`;
          (V0 = (W0 = L0.platformManager) === null || W0 === void 0 ? void 0 : W0.openDeeplink) === null || V0 === void 0 || V0.call(W0, Q0, X0, "_self");
        });
      }(t0, v0), new Promise((L0, B0) => {
        var W0, V0, Q0;
        !((W0 = t0.connector) === null || W0 === void 0) && W0.isAuthorized() ? L0() : ((V0 = t0.connector) === null || V0 === void 0 || V0.once(bo.AUTHORIZED, () => {
          L0();
        }), (Q0 = t0.connector) === null || Q0 === void 0 || Q0.once(bo.REJECTED, () => {
          B0(bo.REJECTED);
        }));
      })) : Zh(t0, e0, v0);
    } catch (G0) {
      throw console.error("[startConnection] error", G0), G0;
    }
  });
}
class Qh {
  constructor(e0) {
    var n0, r0, i0;
    this.state = { connector: void 0, qrcodeLink: void 0, analytics: void 0, developerMode: !1, authorized: !1, reconnection: !1, preferDesktop: !1, deeplinkProtocol: !1, listeners: [], communicationLayerPreference: void 0, platformManager: void 0, pendingModal: void 0, installModal: void 0, otpAnswer: void 0 }, this.options = e0;
    const o0 = ((n0 = e0.logging) === null || n0 === void 0 ? void 0 : n0.developerMode) === !0 || ((r0 = e0.logging) === null || r0 === void 0 ? void 0 : r0.sdk) === !0;
    this.state.developerMode = o0, this.state.analytics = e0.analytics, this.state.preferDesktop = (i0 = e0.preferDesktop) !== null && i0 !== void 0 && i0, this.state.useDeeplink = e0.sdk.options.useDeeplink, this.state.communicationLayerPreference = e0.communicationLayerPreference, this.state.platformManager = e0.platformManager, e0.modals.install || (e0.modals.install = Wh), e0.modals.otp || (e0.modals.otp = Vh);
  }
  startConnection(e0) {
    return a(this, void 0, void 0, function* () {
      return Xh(this.state, this.options, e0);
    });
  }
  initRemoteCommunication({ sdkInstance: e0 }) {
    var n0, r0, i0;
    return a(this, void 0, void 0, function* () {
      const o0 = yield (r0 = (n0 = e0.options.storage) === null || n0 === void 0 ? void 0 : n0.storageManager) === null || r0 === void 0 ? void 0 : r0.getPersistedChannelConfig();
      if (!this.options.ecies) {
        const s0 = { privateKey: o0?.localKey };
        this.options.ecies = s0;
      }
      Gh(this.state, this.options), yield (i0 = this.getConnector()) === null || i0 === void 0 ? void 0 : i0.initFromDappStorage(), Jh(this.state, this.options);
    });
  }
  showActiveModal() {
    return function(e0) {
      var n0, r0, i0, o0;
      e0.authorized ? xu("[RemoteConnection: showActiveModal()] already authorized") : e0.pendingModal ? (r0 = (n0 = e0.pendingModal).mount) === null || r0 === void 0 || r0.call(n0) : e0.installModal && ((o0 = (i0 = e0.installModal).mount) === null || o0 === void 0 || o0.call(i0, e0.qrcodeLink || ""));
    }(this.state);
  }
  closeModal() {
    var e0, n0, r0, i0;
    (n0 = (e0 = this.state.pendingModal) === null || e0 === void 0 ? void 0 : e0.unmount) === null || n0 === void 0 || n0.call(e0), (i0 = (r0 = this.state.installModal) === null || r0 === void 0 ? void 0 : r0.unmount) === null || i0 === void 0 || i0.call(r0, !1);
  }
  getUniversalLink() {
    if (!this.state.qrcodeLink)
      throw new Error("connection not started. run startConnection() first.");
    return this.state.qrcodeLink;
  }
  getChannelConfig() {
    var e0;
    return (e0 = this.state.connector) === null || e0 === void 0 ? void 0 : e0.getChannelConfig();
  }
  getKeyInfo() {
    var e0;
    return (e0 = this.state.connector) === null || e0 === void 0 ? void 0 : e0.getKeyInfo();
  }
  getConnector() {
    if (!this.state.connector)
      throw new Error("invalid remote connector");
    return this.state.connector;
  }
  getPlatformManager() {
    if (!this.state.platformManager)
      throw new Error("PlatformManager not available");
    return this.state.platformManager;
  }
  isConnected() {
    var e0;
    return ((e0 = this.state.connector) === null || e0 === void 0 ? void 0 : e0.isReady()) || !1;
  }
  isAuthorized() {
    var e0;
    return ((e0 = this.state.connector) === null || e0 === void 0 ? void 0 : e0.isAuthorized()) || !1;
  }
  isPaused() {
    var e0;
    return (e0 = this.state.connector) === null || e0 === void 0 ? void 0 : e0.isPaused();
  }
  disconnect(e0) {
    var n0, r0, i0;
    xu("[RemoteConnection: disconnect()]", e0), e0?.terminate && (zu.getProvider().handleDisconnect({ terminate: !0 }), (r0 = (n0 = this.state.pendingModal) === null || n0 === void 0 ? void 0 : n0.unmount) === null || r0 === void 0 || r0.call(n0), this.state.otpAnswer = void 0), (i0 = this.state.connector) === null || i0 === void 0 || i0.disconnect(e0), function(o0) {
      xu("[RemoteConnection: cleanupConnector()] cleaning up connector"), o0.connector && (Yh(o0), o0.connector.disconnect({ terminate: !0 }).catch((s0) => {
        xu("[RemoteConnection: cleanupConnector()] error disconnecting connector", s0);
      }));
    }(this.state);
  }
}
function ef(t0) {
  var e0, n0, r0, i0, o0, s0, a0, c0, l0, u0, d0;
  return a(this, void 0, void 0, function* () {
    const { options: h0 } = t0;
    if (h0.logging = (e0 = h0.logging) !== null && e0 !== void 0 ? e0 : {}, h0.communicationLayerPreference = (n0 = h0.communicationLayerPreference) !== null && n0 !== void 0 ? n0 : Do.SOCKET, h0.enableDebug !== void 0 && (t.enable("MM_SDK"), console.warn("enableDebug is removed. Please use enableAnalytics instead.")), h0.enableAnalytics = (r0 = h0.enableAnalytics) === null || r0 === void 0 || r0, h0.injectProvider = (i0 = h0.injectProvider) === null || i0 === void 0 || i0, h0.shouldShimWeb3 = (o0 = h0.shouldShimWeb3) === null || o0 === void 0 || o0, h0.extensionOnly = (s0 = h0.extensionOnly) === null || s0 === void 0 || s0, h0.useDeeplink = (a0 = h0.useDeeplink) === null || a0 === void 0 || a0, h0.storage = (c0 = h0.storage) !== null && c0 !== void 0 ? c0 : { enabled: !0 }, h0.headless) {
      t("[MetaMaskSDK: performSDKInitialization()] headless mode enabled");
      const O0 = () => {
      }, S0 = { install: () => ({ mount: O0, unmount: O0 }) }, k0 = { installer: O0 };
      h0.modals = S0, h0.ui = k0;
    }
    const g0 = ((l0 = h0.logging) === null || l0 === void 0 ? void 0 : l0.developerMode) === !0;
    t0.debug = ((u0 = h0.logging) === null || u0 === void 0 ? void 0 : u0.sdk) || g0, xu("[MetaMaskSDK: performSDKInitialization()] options", t0.options);
    const w0 = Object.assign({}, h0.logging);
    g0 && (w0.sdk = !0, w0.eciesLayer = !0, w0.keyExchangeLayer = !0, w0.remoteLayer = !0, w0.serviceLayer = !0, w0.plaintext = !0), yield function(O0) {
      var S0;
      return a(this, void 0, void 0, function* () {
        const { options: k0 } = O0;
        O0.platformManager = new qu({ useDeepLink: (S0 = k0.useDeeplink) !== null && S0 !== void 0 && S0, preferredOpenLink: k0.openDeeplink, debug: O0.debug });
      });
    }(t0), yield function(O0) {
      var S0, k0, D0, z0, G0, K0, U0, F0, H0;
      return a(this, void 0, void 0, function* () {
        const { options: P0 } = O0, I0 = (S0 = O0.platformManager) === null || S0 === void 0 ? void 0 : S0.getPlatformType();
        O0.analytics = new _h({ serverUrl: (k0 = P0.communicationServerUrl) !== null && k0 !== void 0 ? k0 : ho, enabled: P0.enableAnalytics, originatorInfo: { url: (D0 = P0.dappMetadata.url) !== null && D0 !== void 0 ? D0 : "", title: (z0 = P0.dappMetadata.name) !== null && z0 !== void 0 ? z0 : "", dappId: typeof window > "u" || window.location === void 0 ? (F0 = (K0 = (G0 = P0.dappMetadata) === null || G0 === void 0 ? void 0 : G0.name) !== null && K0 !== void 0 ? K0 : (U0 = P0.dappMetadata) === null || U0 === void 0 ? void 0 : U0.url) !== null && F0 !== void 0 ? F0 : "N/A" : window.location.hostname, platform: I0 ?? "", source: (H0 = P0._source) !== null && H0 !== void 0 ? H0 : "" } });
      });
    }(t0), yield function(O0) {
      var S0;
      return a(this, void 0, void 0, function* () {
        const { options: k0 } = O0;
        ((S0 = k0.storage) === null || S0 === void 0 ? void 0 : S0.enabled) !== !0 || k0.storage.storageManager || (k0.storage.storageManager = yield Wu(k0.storage));
      });
    }(t0), yield function(O0) {
      return a(this, void 0, void 0, function* () {
        const { options: S0 } = O0, k0 = /^(http|https):\/\/[^\s]*$/;
        if (S0.dappMetadata) {
          S0.dappMetadata.iconUrl && !k0.test(S0.dappMetadata.iconUrl) && (console.warn("Invalid dappMetadata.iconUrl: URL must start with http:// or https://"), S0.dappMetadata.iconUrl = void 0), S0.dappMetadata.base64Icon && S0.dappMetadata.base64Icon.length > kh && (console.warn("Invalid dappMetadata.base64Icon: Base64-encoded icon string length must be less than 163400 characters"), S0.dappMetadata.base64Icon = void 0), S0.dappMetadata.url && !k0.test(S0.dappMetadata.url) && console.warn("Invalid dappMetadata.url: URL must start with http:// or https://");
          const D0 = Ch();
          if (D0 && !S0.dappMetadata.iconUrl && !S0.dappMetadata.base64Icon) {
            const z0 = `${window.location.protocol}//${window.location.host}${D0}`;
            S0.dappMetadata.iconUrl = z0;
          }
        }
        O0.dappMetadata = S0.dappMetadata;
      });
    }(t0), yield Rh(t0), yield Ph(t0);
    const { metamaskBrowserExtension: y0, preferExtension: E0, shouldReturn: b0 } = yield function(O0) {
      var S0, k0, D0, z0;
      return a(this, void 0, void 0, function* () {
        const { options: G0 } = O0;
        let K0, U0 = !1, F0 = !1;
        if (typeof window < "u" && window.ethereum && !(!((S0 = O0.platformManager) === null || S0 === void 0) && S0.isMetaMaskMobileWebView())) {
          U0 = localStorage.getItem(sh) === "extension";
          try {
            K0 = yield Ih({ mustBeMetaMask: !0, sdkInstance: O0 }), window.extension = K0, K0.on(lh.CHAIN_CHANGED, (H0) => {
              xu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE chainChanged chainId=${H0}`), O0.sdkProvider && O0.getMobileProvider().emit(lh.CHAIN_CHANGED, H0);
            }), K0.on(lh.ACCOUNTS_CHANGED, (H0) => a(this, void 0, void 0, function* () {
              var P0;
              xu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE accountsChanged accounts=${H0}`);
              const I0 = !!O0.sdkProvider, f0 = !!O0.extensionActive;
              if (I0 && O0.getMobileProvider().emit(lh.ACCOUNTS_CHANGED, H0), f0 && H0?.length === 0 && (yield (P0 = O0.getProvider()) === null || P0 === void 0 ? void 0 : P0.request({ method: th.WALLET_GETPERMISSIONS, params: [] })).length === 0)
                try {
                  yield O0.terminate();
                } catch (m0) {
                  xu("[MetaMaskSDK: setupExtensionPreferences()] error terminating on permissions revoked", m0);
                }
            })), K0.on(lh.DISCONNECT, (H0) => {
              xu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE disconnect error=${H0}`), O0.sdkProvider && O0.getMobileProvider().emit(lh.DISCONNECT, H0);
            }), K0.on(lh.CONNECT, (H0) => {
              xu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE connect args=${H0}`), O0.sdkProvider && O0.getMobileProvider().emit(lh.CONNECT, H0);
            }), K0.on(lh.CONNECTED, (H0) => {
              xu("[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE connected", H0), O0.sdkProvider && O0.getMobileProvider().emit(lh.CONNECTED, H0);
            });
          } catch {
            window.extension = void 0;
          }
        } else
          !((k0 = O0.platformManager) === null || k0 === void 0) && k0.isMetaMaskMobileWebView() && ((D0 = O0.analytics) === null || D0 === void 0 || D0.send({ event: _o.SDK_USE_INAPP_BROWSER }), O0.activeProvider = Mh({ provider: window.ethereum, sdkInstance: O0 }), O0._initialized = !0, F0 = !0);
        return K0 && G0.extensionOnly && (xu("[MetaMaskSDK: setupExtensionPreferences()] EXTENSION ONLY --- prevent sdk initialization"), (z0 = O0.analytics) === null || z0 === void 0 || z0.send({ event: _o.SDK_USE_EXTENSION }), O0.activeProvider = K0, O0.extensionActive = !0, O0.extension = K0, O0._initialized = !0, F0 = !0), { preferExtension: U0, shouldReturn: F0, metamaskBrowserExtension: K0 };
      });
    }(t0);
    if (b0)
      xu("[MetaMaskSDK: performSDKInitialization()] shouldReturn=true --- prevent sdk initialization");
    else {
      yield function(O0, S0) {
        var k0, D0, z0, G0, K0;
        return a(this, void 0, void 0, function* () {
          const { options: U0 } = O0, F0 = Object.assign({}, U0.logging);
          O0.remoteConnection = new Qh({ preferDesktop: (k0 = U0.preferDesktop) !== null && k0 !== void 0 && k0, communicationLayerPreference: (D0 = U0.communicationLayerPreference) !== null && D0 !== void 0 ? D0 : Do.SOCKET, analytics: O0.analytics, dappMetadata: U0.dappMetadata, _source: U0._source, enableAnalytics: (z0 = U0.enableAnalytics) === null || z0 === void 0 || z0, timer: U0.timer, sdk: O0, platformManager: O0.platformManager, transports: U0.transports, communicationServerUrl: U0.communicationServerUrl, storage: (G0 = U0.storage) !== null && G0 !== void 0 ? G0 : { enabled: !0 }, getMetaMaskInstaller: () => {
            if (!O0.installer)
              throw new Error("Invalid SDK status -- installer not initialized");
            return O0.installer;
          }, logging: F0, connectWithExtensionProvider: S0 === void 0 ? void 0 : () => ph(O0), modals: Object.assign(Object.assign({}, U0.modals), { onPendingModalDisconnect: O0.terminate.bind(O0) }) }), yield O0.remoteConnection.initRemoteCommunication({ sdkInstance: O0 }), O0.installer = new zh({ remote: O0.remoteConnection, preferDesktop: (K0 = U0.preferDesktop) !== null && K0 !== void 0 && K0, platformManager: O0.platformManager, debug: O0.debug });
        });
      }(t0, y0), yield Eh(t0), yield function(O0, S0) {
        var k0, D0;
        return a(this, void 0, void 0, function* () {
          const { options: z0 } = O0;
          S0 ? (xu("[MetaMaskSDK: handleAutoAndExtensionConnections()] preferExtension is detected -- connect with it."), (k0 = O0.analytics) === null || k0 === void 0 || k0.send({ event: _o.SDK_EXTENSION_UTILIZED }), ph(O0).catch((G0) => {
            console.warn("Can't connect with MetaMask extension...", G0), localStorage.removeItem(sh);
          })) : z0.checkInstallationImmediately && (!((D0 = O0.platformManager) === null || D0 === void 0) && D0.isDesktopWeb() ? (xu("[MetaMaskSDK: handleAutoAndExtensionConnections()] checkInstallationImmediately"), O0.connect().catch((G0) => {
            xu(`[MetaMaskSDK: handleAutoAndExtensionConnections()] checkInstallationImmediately --- IGNORED --- error on autoconnect _err=${G0}`);
          })) : console.warn("[handleAutoAndExtensionConnections()] checkInstallationImmediately --- IGNORED --- only for web desktop")), O0._initialized = !0;
        });
      }(t0, E0);
      try {
        yield (d0 = t0.remoteConnection) === null || d0 === void 0 ? void 0 : d0.startConnection({ initialCheck: !0 });
      } catch (O0) {
        console.error("[MetaMaskSDK: setupRemoteConnectionAndInstaller()] Error while checking installation", O0);
      }
      t0.emit(Fu.ProviderUpdate, uh.INITIALIZED);
    }
  });
}
class tf extends n {
  constructor(e0 = { storage: { enabled: !0 }, injectProvider: !0, forceInjectProvider: !1, enableAnalytics: !0, shouldShimWeb3: !0, useDeeplink: !0, extensionOnly: !0, headless: !1, dappMetadata: { name: "", url: "", iconUrl: "" }, _source: Zu, i18nOptions: { enabled: !1 } }) {
    var n0, r0, i0;
    super(), this.extensionActive = !1, this._initialized = !1, this.sdkInitPromise = void 0, this.debug = !1, this.readonlyRPCCalls = !1, this.availableLanguages = ["en"], t.disable();
    const o0 = ((n0 = e0.logging) === null || n0 === void 0 ? void 0 : n0.developerMode) === !0;
    if ((!((r0 = e0.logging) === null || r0 === void 0) && r0.sdk || o0) && t.enable("MM_SDK"), xu("[MetaMaskSDK: constructor()]: begin."), this.setMaxListeners(50), !(!((i0 = e0.dappMetadata) === null || i0 === void 0) && i0.url)) {
      if (typeof window > "u" || typeof document > "u")
        throw new Error("You must provide dAppMetadata url");
      e0.dappMetadata = Object.assign(Object.assign({}, e0.dappMetadata), { url: `${window.location.protocol}//${window.location.host}` });
    }
    this.options = e0, this.options._source || (e0._source = Zu), this.init().then(() => {
      xu("[MetaMaskSDK: constructor()]: initialized successfully."), typeof window < "u" && (window.mmsdk = this);
    }).catch((s0) => {
      console.error("[MetaMaskSDK: constructor()] error during initialization", s0);
    });
  }
  init() {
    return a(this, void 0, void 0, function* () {
      return function(e0) {
        var n0;
        return a(this, void 0, void 0, function* () {
          if (typeof window < "u" && (!((n0 = window.mmsdk) === null || n0 === void 0) && n0.isInitialized()))
            return xu("[MetaMaskSDK: initializeMetaMaskSDK()] already initialized"), Promise.resolve(window.mmsdk);
          if (e0._initialized)
            return xu("[MetaMaskSDK: initializeMetaMaskSDK()] already initialized"), e0.sdkInitPromise;
          if (e0.sdkInitPromise)
            return xu("[MetaMaskSDK: initializeMetaMaskSDK()] already initializing"), e0.sdkInitPromise;
          try {
            e0.sdkInitPromise = ef(e0), yield e0.sdkInitPromise;
          } catch (r0) {
            throw console.error(r0), r0;
          }
          return e0.sdkInitPromise;
        });
      }(this);
    });
  }
  isExtensionActive() {
    return this.extensionActive;
  }
  checkExtensionAvailability() {
    var e0;
    return typeof window < "u" && !!(!((e0 = window.ethereum) === null || e0 === void 0) && e0.isMetaMask);
  }
  connect() {
    return a(this, void 0, void 0, function* () {
      return function(e0) {
        return a(this, void 0, void 0, function* () {
          if (e0._initialized || (xu("[MetaMaskSDK: connect()] provider not ready -- wait for init()"), yield e0.init()), xu(`[MetaMaskSDK: connect()] isExtensionActive=${e0.isExtensionActive()} activeProvider`, e0.activeProvider), !e0.activeProvider)
            throw new Error("SDK state invalid -- undefined provider");
          const n0 = e0.activeProvider.getSelectedAddress();
          return n0 ? [n0] : e0.activeProvider.request({ method: th.ETH_REQUESTACCOUNTS, params: [] });
        });
      }(this);
    });
  }
  connectAndSign({ msg: e0 }) {
    return a(this, void 0, void 0, function* () {
      return fh({ instance: this, msg: e0 });
    });
  }
  connectWith(e0) {
    return a(this, void 0, void 0, function* () {
      return function({ instance: n0, rpc: r0 }) {
        return a(this, void 0, void 0, function* () {
          if (n0._initialized || (xu("[MetaMaskSDK: connectWith()] provider not ready -- wait for init()"), yield n0.init()), xu(`[MetaMaskSDK: connectWith()] method: ${r0.method} rpc=${r0}`), !n0.activeProvider)
            throw new Error("SDK state invalid -- undefined provider");
          return n0.activeProvider.request({ method: th.METAMASK_CONNECTWITH, params: [r0] });
        });
      }({ instance: this, rpc: e0 });
    });
  }
  resume() {
    return function(e0) {
      var n0, r0, i0;
      return a(this, void 0, void 0, function* () {
        if (!(!((r0 = (n0 = e0.remoteConnection) === null || n0 === void 0 ? void 0 : n0.getConnector()) === null || r0 === void 0) && r0.isReady()))
          return xu("[MetaMaskSDK: resume()] channel is not ready -- starting connection"), void ((i0 = e0.remoteConnection) === null || i0 === void 0 || i0.startConnection());
        xu("[MetaMaskSDK: resume()] channel is ready");
      });
    }(this);
  }
  disconnect() {
    return console.warn("MetaMaskSDK.disconnect() is deprecated, use terminate()"), this.terminate();
  }
  isAuthorized() {
    var e0;
    (e0 = this.remoteConnection) === null || e0 === void 0 || e0.isAuthorized();
  }
  terminate() {
    return function(e0) {
      var n0, r0, i0;
      return a(this, void 0, void 0, function* () {
        if (!(!((n0 = e0.platformManager) === null || n0 === void 0) && n0.isMetaMaskMobileWebView())) {
          if (hh && (window.localStorage.removeItem(sh), window.localStorage.removeItem(ch), window.localStorage.removeItem(ah)), e0.extensionActive) {
            try {
              yield (r0 = e0.activeProvider) === null || r0 === void 0 ? void 0 : r0.request({ method: th.WALLET_REVOKEPERMISSIONS, params: [{ eth_accounts: {} }] });
            } catch (o0) {
              xu("[MetaMaskSDK: terminate()] error revoking permissions", o0);
            }
            return e0.options.extensionOnly ? (e0.emit(Fu.ProviderUpdate, uh.TERMINATE), void xu("[MetaMaskSDK: terminate()] extensionOnly --- prevent switching providers")) : (e0.activeProvider = e0.sdkProvider, window.ethereum = e0.activeProvider, e0.extensionActive = !1, void e0.emit(Fu.ProviderUpdate, uh.TERMINATE));
          }
          e0.emit(Fu.ProviderUpdate, uh.TERMINATE), xu(`[MetaMaskSDK: terminate()] remoteConnection=${e0.remoteConnection}`), (i0 = e0.remoteConnection) === null || i0 === void 0 || i0.disconnect({ terminate: !0, sendMessage: !0 });
        }
      });
    }(this);
  }
  isInitialized() {
    return this._initialized;
  }
  setReadOnlyRPCCalls(e0) {
    this.readonlyRPCCalls = e0;
  }
  hasReadOnlyRPCCalls() {
    return this.readonlyRPCCalls;
  }
  getProvider() {
    if (this.activeProvider)
      return this.activeProvider;
    console.warn("MetaMaskSDK: No active provider found");
  }
  getMobileProvider() {
    if (!this.sdkProvider)
      throw new Error("SDK state invalid -- undefined mobile provider");
    return this.sdkProvider;
  }
  getUniversalLink() {
    var e0;
    const n0 = (e0 = this.remoteConnection) === null || e0 === void 0 ? void 0 : e0.getUniversalLink();
    if (!n0)
      throw new Error("No Universal Link available, please call eth_requestAccounts first.");
    return n0;
  }
  getChannelId() {
    var e0, n0;
    return (n0 = (e0 = this.remoteConnection) === null || e0 === void 0 ? void 0 : e0.getChannelConfig()) === null || n0 === void 0 ? void 0 : n0.channelId;
  }
  getRPCHistory() {
    var e0, n0;
    return (n0 = (e0 = this.remoteConnection) === null || e0 === void 0 ? void 0 : e0.getConnector()) === null || n0 === void 0 ? void 0 : n0.getRPCMethodTracker();
  }
  getVersion() {
    return Yu.version;
  }
  getWalletStatus() {
    var e0, n0;
    return (n0 = (e0 = this.remoteConnection) === null || e0 === void 0 ? void 0 : e0.getConnector()) === null || n0 === void 0 ? void 0 : n0.getConnectionStatus();
  }
  _getChannelConfig() {
    var e0;
    return (e0 = this.remoteConnection) === null || e0 === void 0 ? void 0 : e0.getChannelConfig();
  }
  _ping() {
    var e0, n0;
    (n0 = (e0 = this.remoteConnection) === null || e0 === void 0 ? void 0 : e0.getConnector()) === null || n0 === void 0 || n0.ping();
  }
  _keyCheck() {
    var e0, n0;
    (n0 = (e0 = this.remoteConnection) === null || e0 === void 0 ? void 0 : e0.getConnector()) === null || n0 === void 0 || n0.keyCheck();
  }
  _getServiceStatus() {
    var e0, n0;
    return (n0 = (e0 = this.remoteConnection) === null || e0 === void 0 ? void 0 : e0.getConnector()) === null || n0 === void 0 ? void 0 : n0.getServiceStatus();
  }
  _getRemoteConnection() {
    return this.remoteConnection;
  }
  _getDappMetadata() {
    return this.dappMetadata;
  }
  _getKeyInfo() {
    var e0;
    return (e0 = this.remoteConnection) === null || e0 === void 0 ? void 0 : e0.getKeyInfo();
  }
  _resetKeys() {
    var e0, n0;
    (n0 = (e0 = this.remoteConnection) === null || e0 === void 0 ? void 0 : e0.getConnector()) === null || n0 === void 0 || n0.resetKeys();
  }
  _getConnection() {
    return this.remoteConnection;
  }
  emit(e0, n0) {
    return super.emit(e0, n0);
  }
  on(e0, n0) {
    return super.on(e0, n0);
  }
}
var nf = Object.freeze({ __proto__: null, StorageManagerWeb: class {
  constructor({ enabled: t0 } = { enabled: !1 }) {
    this.enabled = !1, this.enabled = t0;
  }
  persistChannelConfig(t0) {
    return a(this, void 0, void 0, function* () {
      const e0 = JSON.stringify(t0);
      xu(`[StorageManagerWeb: persistChannelConfig()] enabled=${this.enabled}`, t0), localStorage.setItem(oh, e0);
    });
  }
  getPersistedChannelConfig() {
    return a(this, void 0, void 0, function* () {
      let t0;
      try {
        if (xu(`[StorageManagerWeb: getPersistedChannelConfig()] enabled=${this.enabled}`), t0 = localStorage.getItem(oh), xu("[StorageManagerWeb: getPersistedChannelConfig()]", t0), !t0)
          return;
        const e0 = JSON.parse(t0);
        return xu("[StorageManagerWeb: getPersistedChannelConfig()] channelConfig", e0), e0;
      } catch (e0) {
        return void console.error("[StorageManagerWeb: getPersistedChannelConfig()] Can't find existing channel config", e0);
      }
    });
  }
  persistAccounts(t0) {
    return a(this, void 0, void 0, function* () {
      xu(`[StorageManagerWeb: persistAccounts()] enabled=${this.enabled}`, t0);
      const e0 = JSON.stringify(t0);
      localStorage.setItem(ah, e0);
    });
  }
  getCachedAccounts() {
    return a(this, void 0, void 0, function* () {
      try {
        const t0 = localStorage.getItem(ah);
        return t0 ? JSON.parse(t0) : [];
      } catch (t0) {
        throw console.error("[StorageManagerWeb: getCachedAccounts()] Error reading cached accounts", t0), t0;
      }
    });
  }
  persistChainId(t0) {
    return a(this, void 0, void 0, function* () {
      xu(`[StorageManagerWeb: persistChainId()] enabled=${this.enabled}`, t0), localStorage.setItem(ch, t0);
    });
  }
  getCachedChainId() {
    return a(this, void 0, void 0, function* () {
      try {
        const t0 = localStorage.getItem(ch);
        return t0 ?? void 0;
      } catch (t0) {
        throw console.error("[StorageManagerWeb: getCachedChainId()] Error reading cached chainId", t0), t0;
      }
    });
  }
  terminate() {
    return a(this, void 0, void 0, function* () {
      xu(`[StorageManagerWeb: terminate()] enabled=${this.enabled}`), localStorage.removeItem(oh);
    });
  }
} });
const rf = "hydrated", of = !1, sf = !1, af = !0;
var cf = Object.defineProperty, lf = /* @__PURE__ */ new WeakMap(), df = (t0) => lf.get(t0), uf = (t0, e0) => lf.set(e0.$lazyInstance$ = t0, e0), hf = (t0, e0) => e0 in t0, ff = (t0, e0) => (0, console.error)(t0, e0), pf = /* @__PURE__ */ new Map(), gf = /* @__PURE__ */ new Map(), mf = "slot-fb{display:contents}slot-fb[hidden]{display:none}", yf = typeof window < "u" ? window : {}, vf = yf.document || { head: {} }, bf = { $flags$: 0, $resourcesUrl$: "", jmp: (t0) => t0(), raf: (t0) => requestAnimationFrame(t0), ael: (t0, e0, n0, r0) => t0.addEventListener(e0, n0, r0), rel: (t0, e0, n0, r0) => t0.removeEventListener(e0, n0, r0), ce: (t0, e0) => new CustomEvent(t0, e0) }, wf = (() => {
  try {
    return new CSSStyleSheet(), typeof new CSSStyleSheet().replaceSync == "function";
  } catch {
  }
  return !1;
})(), Ef = !1, Sf = [], _f = [], Cf = (t0, e0) => (n0) => {
  t0.push(n0), Ef || (Ef = !0, 4 & bf.$flags$ ? Mf(xf) : bf.raf(xf));
}, kf = (t0) => {
  for (let e0 = 0; e0 < t0.length; e0++)
    try {
      t0[e0](performance.now());
    } catch (n0) {
      ff(n0);
    }
  t0.length = 0;
}, xf = () => {
  kf(Sf), kf(_f), (Ef = Sf.length > 0) && bf.raf(xf);
}, Mf = (t0) => ((e0) => Promise.resolve(e0))().then(t0), Af = Cf(_f), If = {}, Rf = (t0) => (t0 = typeof t0) == "object" || t0 === "function";
function Pf(t0) {
  var e0, n0, r0;
  return (r0 = (n0 = (e0 = t0.head) == null ? void 0 : e0.querySelector('meta[name="csp-nonce"]')) == null ? void 0 : n0.getAttribute("content")) != null ? r0 : void 0;
}
((t0, e0) => {
  for (var n0 in e0)
    cf(t0, n0, { get: e0[n0], enumerable: !0 });
})({}, { err: () => Of, map: () => Lf, ok: () => Tf, unwrap: () => Df, unwrapErr: () => Bf });
var Tf = (t0) => ({ isOk: !0, isErr: !1, value: t0 }), Of = (t0) => ({ isOk: !1, isErr: !0, value: t0 });
function Lf(t0, e0) {
  if (t0.isOk) {
    const n0 = e0(t0.value);
    return n0 instanceof Promise ? n0.then((r0) => Tf(r0)) : Tf(n0);
  }
  if (t0.isErr) {
    const n0 = t0.value;
    return Of(n0);
  }
  throw "should never get here";
}
var Nf, $f, Df = (t0) => {
  if (t0.isOk)
    return t0.value;
  throw t0.value;
}, Bf = (t0) => {
  if (t0.isErr)
    return t0.value;
  throw t0.value;
}, Kf = (t0, e0, ...n0) => {
  let r0 = null, i0 = !1, o0 = !1;
  const s0 = [], a0 = (l0) => {
    for (let u0 = 0; u0 < l0.length; u0++)
      r0 = l0[u0], Array.isArray(r0) ? a0(r0) : r0 != null && typeof r0 != "boolean" && ((i0 = typeof t0 != "function" && !Rf(r0)) && (r0 = String(r0)), i0 && o0 ? s0[s0.length - 1].$text$ += r0 : s0.push(i0 ? jf(null, r0) : r0), o0 = i0);
  };
  if (a0(n0), e0) {
    const l0 = e0.className || e0.class;
    l0 && (e0.class = typeof l0 != "object" ? l0 : Object.keys(l0).filter((u0) => l0[u0]).join(" "));
  }
  if (typeof t0 == "function")
    return t0(e0 === null ? {} : e0, s0, Hf);
  const c0 = jf(t0, null);
  return c0.$attrs$ = e0, s0.length > 0 && (c0.$children$ = s0), c0;
}, jf = (t0, e0) => ({ $flags$: 0, $tag$: t0, $text$: e0, $elm$: null, $children$: null, $attrs$: null }), Uf = {}, Hf = { forEach: (t0, e0) => t0.map(Ff).forEach(e0), map: (t0, e0) => t0.map(Ff).map(e0).map(zf) }, Ff = (t0) => ({ vattrs: t0.$attrs$, vchildren: t0.$children$, vkey: t0.$key$, vname: t0.$name$, vtag: t0.$tag$, vtext: t0.$text$ }), zf = (t0) => {
  if (typeof t0.vtag == "function") {
    const n0 = { ...t0.vattrs };
    return t0.vkey && (n0.key = t0.vkey), t0.vname && (n0.name = t0.vname), Kf(t0.vtag, n0, ...t0.vchildren || []);
  }
  const e0 = jf(t0.vtag, t0.vtext);
  return e0.$attrs$ = t0.vattrs, e0.$children$ = t0.vchildren, e0.$key$ = t0.vkey, e0.$name$ = t0.vname, e0;
}, qf = (t0) => df(t0).$hostElement$, Wf = (t0, e0, n0) => {
  const r0 = qf(t0);
  return { emit: (i0) => Vf(r0, e0, { bubbles: !!(4 & n0), composed: !!(2 & n0), cancelable: !!(1 & n0), detail: i0 }) };
}, Vf = (t0, e0, n0) => {
  const r0 = bf.ce(e0, n0);
  return t0.dispatchEvent(r0), r0;
}, Gf = /* @__PURE__ */ new WeakMap(), Yf = (t0) => {
  const e0 = t0.$cmpMeta$, n0 = t0.$hostElement$, r0 = e0.$flags$;
  e0.$tagName$;
  const i0 = ((o0, s0, a0) => {
    var c0;
    const l0 = Zf(s0), u0 = gf.get(l0);
    if (o0 = o0.nodeType === 11 ? o0 : vf, u0)
      if (typeof u0 == "string") {
        o0 = o0.head || o0;
        let d0, h0 = Gf.get(o0);
        if (h0 || Gf.set(o0, h0 = /* @__PURE__ */ new Set()), !h0.has(l0)) {
          {
            d0 = vf.createElement("style"), d0.innerHTML = u0;
            const g0 = (c0 = bf.$nonce$) != null ? c0 : Pf(vf);
            if (g0 != null && d0.setAttribute("nonce", g0), !(1 & s0.$flags$))
              if (o0.nodeName === "HEAD") {
                const w0 = o0.querySelectorAll("link[rel=preconnect]"), y0 = w0.length > 0 ? w0[w0.length - 1].nextSibling : o0.querySelector("style");
                o0.insertBefore(d0, y0);
              } else if ("host" in o0)
                if (wf) {
                  const w0 = new CSSStyleSheet();
                  w0.replaceSync(u0), o0.adoptedStyleSheets = [w0, ...o0.adoptedStyleSheets];
                } else {
                  const w0 = o0.querySelector("style");
                  w0 ? w0.innerHTML = u0 + w0.innerHTML : o0.prepend(d0);
                }
              else
                o0.append(d0);
            1 & s0.$flags$ && o0.nodeName !== "HEAD" && o0.insertBefore(d0, null);
          }
          4 & s0.$flags$ && (d0.innerHTML += mf), h0 && h0.add(l0);
        }
      } else
        o0.adoptedStyleSheets.includes(u0) || (o0.adoptedStyleSheets = [...o0.adoptedStyleSheets, u0]);
    return l0;
  })(n0.shadowRoot ? n0.shadowRoot : n0.getRootNode(), e0);
  10 & r0 && 2 & r0 && (n0["s-sc"] = i0, n0.classList.add(i0 + "-h"));
}, Zf = (t0, e0) => "sc-" + t0.$tagName$, Jf = (t0, e0, n0, r0, i0, o0) => {
  if (n0 !== r0) {
    let s0 = hf(t0, e0), a0 = e0.toLowerCase();
    if (e0 === "class") {
      const c0 = t0.classList, l0 = Qf(n0), u0 = Qf(r0);
      c0.remove(...l0.filter((d0) => d0 && !u0.includes(d0))), c0.add(...u0.filter((d0) => d0 && !l0.includes(d0)));
    } else if (e0 === "style") {
      for (const c0 in n0)
        r0 && r0[c0] != null || (c0.includes("-") ? t0.style.removeProperty(c0) : t0.style[c0] = "");
      for (const c0 in r0)
        n0 && r0[c0] === n0[c0] || (c0.includes("-") ? t0.style.setProperty(c0, r0[c0]) : t0.style[c0] = r0[c0]);
    } else if (s0 || e0[0] !== "o" || e0[1] !== "n") {
      const c0 = Rf(r0);
      if ((s0 || c0 && r0 !== null) && !i0)
        try {
          if (t0.tagName.includes("-"))
            t0[e0] = r0;
          else {
            const l0 = r0 ?? "";
            e0 === "list" ? s0 = !1 : n0 != null && t0[e0] == l0 || (typeof t0.__lookupSetter__(e0) == "function" ? t0[e0] = l0 : t0.setAttribute(e0, l0));
          }
        } catch {
        }
      r0 == null || r0 === !1 ? r0 === !1 && t0.getAttribute(e0) !== "" || t0.removeAttribute(e0) : (!s0 || 4 & o0 || i0) && !c0 && (r0 = r0 === !0 ? "" : r0, t0.setAttribute(e0, r0));
    } else if (e0 = e0[2] === "-" ? e0.slice(3) : hf(yf, a0) ? a0.slice(2) : a0[2] + e0.slice(3), n0 || r0) {
      const c0 = e0.endsWith(ep);
      e0 = e0.replace(tp, ""), n0 && bf.rel(t0, e0, n0, c0), r0 && bf.ael(t0, e0, r0, c0);
    }
  }
}, Xf = /\s/, Qf = (t0) => t0 ? t0.split(Xf) : [], ep = "Capture", tp = new RegExp(ep + "$"), np = (t0, e0, n0) => {
  const r0 = e0.$elm$.nodeType === 11 && e0.$elm$.host ? e0.$elm$.host : e0.$elm$, i0 = t0 && t0.$attrs$ || If, o0 = e0.$attrs$ || If;
  for (const s0 of rp(Object.keys(i0)))
    s0 in o0 || Jf(r0, s0, i0[s0], void 0, n0, e0.$flags$);
  for (const s0 of rp(Object.keys(o0)))
    Jf(r0, s0, i0[s0], o0[s0], n0, e0.$flags$);
};
function rp(t0) {
  return t0.includes("ref") ? [...t0.filter((e0) => e0 !== "ref"), "ref"] : t0;
}
var ip = !1, op = !1, sp = (t0, e0, n0, r0) => {
  const i0 = e0.$children$[n0];
  let o0, s0, a0 = 0;
  if (i0.$text$ !== null)
    o0 = i0.$elm$ = vf.createTextNode(i0.$text$);
  else {
    if (op || (op = i0.$tag$ === "svg"), o0 = i0.$elm$ = vf.createElementNS(op ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", !ip && sf && 2 & i0.$flags$ ? "slot-fb" : i0.$tag$), op && i0.$tag$ === "foreignObject" && (op = !1), np(null, i0, op), o0.getRootNode().querySelector("body") && of && ((c0) => c0 != null)(Nf) && o0["s-si"] !== Nf && o0.classList.add(o0["s-si"] = Nf), i0.$children$)
      for (a0 = 0; a0 < i0.$children$.length; ++a0)
        s0 = sp(t0, i0, a0), s0 && o0.appendChild(s0);
    i0.$tag$ === "svg" ? op = !1 : o0.tagName === "foreignObject" && (op = !0);
  }
  return o0["s-hn"] = $f, o0;
}, ap = (t0, e0, n0, r0, i0, o0) => {
  let s0, a0 = t0;
  for (a0.shadowRoot && a0.tagName === $f && (a0 = a0.shadowRoot); i0 <= o0; ++i0)
    r0[i0] && (s0 = sp(null, n0, i0), s0 && (r0[i0].$elm$ = s0, up(a0, s0, e0)));
}, cp = (t0, e0, n0) => {
  for (let r0 = e0; r0 <= n0; ++r0) {
    const i0 = t0[r0];
    if (i0) {
      const o0 = i0.$elm$;
      o0 && o0.remove();
    }
  }
}, lp = (t0, e0, n0 = !1) => t0.$tag$ === e0.$tag$, dp = (t0, e0, n0 = !1) => {
  const r0 = e0.$elm$ = t0.$elm$, i0 = t0.$children$, o0 = e0.$children$, s0 = e0.$tag$, a0 = e0.$text$;
  a0 === null ? (np(t0, e0, op = s0 === "svg" || s0 !== "foreignObject" && op), i0 !== null && o0 !== null ? ((c0, l0, u0, d0, h0 = !1) => {
    let g0, w0 = 0, y0 = 0, E0 = l0.length - 1, b0 = l0[0], O0 = l0[E0], S0 = d0.length - 1, k0 = d0[0], D0 = d0[S0];
    for (; w0 <= E0 && y0 <= S0; )
      b0 == null ? b0 = l0[++w0] : O0 == null ? O0 = l0[--E0] : k0 == null ? k0 = d0[++y0] : D0 == null ? D0 = d0[--S0] : lp(b0, k0, h0) ? (dp(b0, k0, h0), b0 = l0[++w0], k0 = d0[++y0]) : lp(O0, D0, h0) ? (dp(O0, D0, h0), O0 = l0[--E0], D0 = d0[--S0]) : lp(b0, D0, h0) ? (dp(b0, D0, h0), up(c0, b0.$elm$, O0.$elm$.nextSibling), b0 = l0[++w0], D0 = d0[--S0]) : lp(O0, k0, h0) ? (dp(O0, k0, h0), up(c0, O0.$elm$, b0.$elm$), O0 = l0[--E0], k0 = d0[++y0]) : (g0 = sp(l0 && l0[y0], u0, y0), k0 = d0[++y0], g0 && up(b0.$elm$.parentNode, g0, b0.$elm$));
    w0 > E0 ? ap(c0, d0[S0 + 1] == null ? null : d0[S0 + 1].$elm$, u0, d0, y0, S0) : y0 > S0 && cp(l0, w0, E0);
  })(r0, i0, e0, o0, n0) : o0 !== null ? (t0.$text$ !== null && (r0.textContent = ""), ap(r0, null, e0, o0, 0, o0.length - 1)) : !n0 && af && i0 !== null && cp(i0, 0, i0.length - 1), op && s0 === "svg" && (op = !1)) : t0.$text$ !== a0 && (r0.data = a0);
}, up = (t0, e0, n0) => t0?.insertBefore(e0, n0), hp = (t0, e0, n0 = !1) => {
  const r0 = t0.$hostElement$, i0 = t0.$cmpMeta$, o0 = t0.$vnode$ || jf(null, null), s0 = (a0 = e0) && a0.$tag$ === Uf ? e0 : Kf(null, null, e0);
  var a0;
  if ($f = r0.tagName, n0 && s0.$attrs$)
    for (const c0 of Object.keys(s0.$attrs$))
      r0.hasAttribute(c0) && !["key", "ref", "style", "class"].includes(c0) && (s0.$attrs$[c0] = r0[c0]);
  s0.$tag$ = null, s0.$flags$ |= 4, t0.$vnode$ = s0, s0.$elm$ = o0.$elm$ = r0.shadowRoot || r0, Nf = r0["s-sc"], ip = (1 & i0.$flags$) != 0, dp(o0, s0, n0);
}, fp = (t0, e0) => {
  e0 && !t0.$onRenderResolve$ && e0["s-p"] && e0["s-p"].push(new Promise((n0) => t0.$onRenderResolve$ = n0));
}, pp = (t0, e0) => (t0.$flags$ |= 16, 4 & t0.$flags$ ? void (t0.$flags$ |= 512) : (fp(t0, t0.$ancestorComponent$), Af(() => gp(t0, e0)))), gp = (t0, e0) => {
  const n0 = t0.$hostElement$;
  t0.$cmpMeta$.$tagName$;
  const r0 = t0.$lazyInstance$;
  if (!r0)
    throw new Error(`Can't render component <${n0.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);
  return mp(void 0, () => vp(t0, r0, e0));
}, mp = (t0, e0) => yp(t0) ? t0.then(e0).catch((n0) => {
  console.error(n0), e0();
}) : e0(), yp = (t0) => t0 instanceof Promise || t0 && t0.then && typeof t0.then == "function", vp = async (t0, e0, n0) => {
  var r0;
  const i0 = t0.$hostElement$;
  t0.$cmpMeta$.$tagName$;
  const o0 = i0["s-rc"];
  n0 && Yf(t0), t0.$cmpMeta$.$tagName$, bp(t0, e0, i0, n0), o0 && (o0.map((s0) => s0()), i0["s-rc"] = void 0);
  {
    const s0 = (r0 = i0["s-p"]) != null ? r0 : [], a0 = () => wp(t0);
    s0.length === 0 ? a0() : (Promise.all(s0).then(a0), t0.$flags$ |= 4, s0.length = 0);
  }
}, bp = (t0, e0, n0, r0) => {
  try {
    e0 = e0.render(), t0.$flags$ &= -17, t0.$flags$ |= 2, hp(t0, e0, r0);
  } catch (i0) {
    ff(i0, t0.$hostElement$);
  }
  return null;
}, wp = (t0) => {
  t0.$cmpMeta$.$tagName$;
  const e0 = t0.$hostElement$, n0 = () => {
  }, r0 = t0.$lazyInstance$, i0 = t0.$ancestorComponent$;
  64 & t0.$flags$ ? n0() : (t0.$flags$ |= 64, _p(e0), Sp(r0, "componentDidLoad"), t0.$onReadyResolve$(e0), i0 || Ep()), t0.$onRenderResolve$ && (t0.$onRenderResolve$(), t0.$onRenderResolve$ = void 0), 512 & t0.$flags$ && Mf(() => pp(t0, !1)), t0.$flags$ &= -517;
}, Ep = (t0) => {
  _p(vf.documentElement), Mf(() => Vf(yf, "appload", { detail: { namespace: "sdk-install-modal-web" } }));
}, Sp = (t0, e0, n0) => {
  if (t0 && t0[e0])
    try {
      return t0[e0](n0);
    } catch (r0) {
      ff(r0);
    }
}, _p = (t0) => {
  var e0;
  return t0.classList.add((e0 = rf) != null ? e0 : "hydrated");
}, Cp = (t0, e0, n0, r0) => {
  const i0 = df(t0);
  if (!i0)
    throw new Error(`Couldn't find host element for "${r0.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).`);
  const o0 = i0.$hostElement$, s0 = i0.$instanceValues$.get(e0), a0 = i0.$flags$, c0 = i0.$lazyInstance$;
  var l0, u0;
  l0 = n0, u0 = r0.$members$[e0][0], n0 = l0 == null || Rf(l0) ? l0 : 4 & u0 ? l0 !== "false" && (l0 === "" || !!l0) : 1 & u0 ? String(l0) : l0;
  const d0 = Number.isNaN(s0) && Number.isNaN(n0);
  if ((!(8 & a0) || s0 === void 0) && n0 !== s0 && !d0 && (i0.$instanceValues$.set(e0, n0), c0)) {
    if (r0.$watchers$ && 128 & a0) {
      const h0 = r0.$watchers$[e0];
      h0 && h0.map((g0) => {
        try {
          c0[g0](n0, s0, e0);
        } catch (w0) {
          ff(w0, o0);
        }
      });
    }
    (18 & a0) == 2 && pp(i0, !1);
  }
}, kp = (t0, e0, n0) => {
  var r0, i0;
  const o0 = t0.prototype;
  if (e0.$members$ || e0.$watchers$ || t0.watchers) {
    t0.watchers && !e0.$watchers$ && (e0.$watchers$ = t0.watchers);
    const s0 = Object.entries((r0 = e0.$members$) != null ? r0 : {});
    if (s0.map(([a0, [c0]]) => {
      (31 & c0 || 2 & n0 && 32 & c0) && Object.defineProperty(o0, a0, { get() {
        return l0 = a0, df(this).$instanceValues$.get(l0);
        var l0;
      }, set(l0) {
        Cp(this, a0, l0, e0);
      }, configurable: !0, enumerable: !0 });
    }), 1 & n0) {
      const a0 = /* @__PURE__ */ new Map();
      o0.attributeChangedCallback = function(c0, l0, u0) {
        bf.jmp(() => {
          var d0;
          const h0 = a0.get(c0);
          if (this.hasOwnProperty(h0))
            u0 = this[h0], delete this[h0];
          else {
            if (o0.hasOwnProperty(h0) && typeof this[h0] == "number" && this[h0] == u0)
              return;
            if (h0 == null) {
              const g0 = df(this), w0 = g0?.$flags$;
              if (w0 && !(8 & w0) && 128 & w0 && u0 !== l0) {
                const y0 = g0.$lazyInstance$, E0 = (d0 = e0.$watchers$) == null ? void 0 : d0[c0];
                E0?.forEach((b0) => {
                  y0[b0] != null && y0[b0].call(y0, u0, l0, c0);
                });
              }
              return;
            }
          }
          this[h0] = (u0 !== null || typeof this[h0] != "boolean") && u0;
        });
      }, t0.observedAttributes = Array.from(/* @__PURE__ */ new Set([...Object.keys((i0 = e0.$watchers$) != null ? i0 : {}), ...s0.filter(([c0, l0]) => 15 & l0[0]).map(([c0, l0]) => {
        const u0 = l0[1] || c0;
        return a0.set(u0, c0), u0;
      })]));
    }
  }
  return t0;
}, xp = async (t0, e0, n0, r0) => {
  let i0;
  if (!(32 & e0.$flags$)) {
    if (e0.$flags$ |= 32, n0.$lazyBundleId$) {
      const a0 = ((c0, l0, u0) => {
        const d0 = c0.$tagName$.replace(/-/g, "_"), h0 = c0.$lazyBundleId$;
        if (!h0)
          return;
        const g0 = pf.get(h0);
        if (g0)
          return g0[d0];
        {
          const w0 = (y0) => (pf.set(h0, y0), y0[d0]);
          if (h0 === "mm-install-modal_3")
            return Promise.resolve().then(function() {
              return gg;
            }).then(w0, ff);
        }
        return import(
          /* webpackIgnore: true */
          /* @vite-ignore */
          /* webpackInclude: /\.entry\.js$/ */
          /* webpackExclude: /\.system\.entry\.js$/ */
          /* webpackMode: "lazy" */
          `./${h0}.entry.js`
        ).then((w0) => (pf.set(h0, w0), w0[d0]), ff);
      })(n0);
      if (a0 && "then" in a0 ? i0 = await a0 : i0 = a0, !i0)
        throw new Error(`Constructor for "${n0.$tagName$}#${e0.$modeName$}" was not found`);
      i0.isProxied || (n0.$watchers$ = i0.watchers, kp(i0, n0, 2), i0.isProxied = !0), n0.$tagName$, e0.$flags$ |= 8;
      try {
        new i0(e0);
      } catch (c0) {
        ff(c0);
      }
      e0.$flags$ &= -9, e0.$flags$ |= 128, Mp(e0.$lazyInstance$);
    } else {
      i0 = t0.constructor;
      const a0 = t0.localName;
      customElements.whenDefined(a0).then(() => e0.$flags$ |= 128);
    }
    if (i0 && i0.style) {
      let a0;
      typeof i0.style == "string" && (a0 = i0.style);
      const c0 = Zf(n0);
      gf.has(c0) || (n0.$tagName$, ((l0, u0, d0) => {
        let h0 = gf.get(l0);
        wf && d0 ? (h0 = h0 || new CSSStyleSheet(), typeof h0 == "string" ? h0 = u0 : h0.replaceSync(u0)) : h0 = u0, gf.set(l0, h0);
      })(c0, a0, !!(1 & n0.$flags$)));
    }
  }
  const o0 = e0.$ancestorComponent$, s0 = () => pp(e0, !0);
  o0 && o0["s-rc"] ? o0["s-rc"].push(s0) : s0();
}, Mp = (t0) => {
  Sp(t0, "connectedCallback");
}, Ap = (t0) => {
  Sp(t0, "disconnectedCallback");
}, Ip = (t0, e0 = {}) => {
  var n0;
  const r0 = [], i0 = e0.exclude || [], o0 = yf.customElements, s0 = vf.head, a0 = s0.querySelector("meta[charset]"), c0 = vf.createElement("style"), l0 = [];
  let u0, d0 = !0;
  Object.assign(bf, e0), bf.$resourcesUrl$ = new URL(e0.resourcesUrl || "./", vf.baseURI).href;
  let h0 = !1;
  if (t0.map((g0) => {
    g0[1].map((w0) => {
      var y0;
      const E0 = { $flags$: w0[0], $tagName$: w0[1], $members$: w0[2], $listeners$: w0[3] };
      4 & E0.$flags$ && (h0 = !0), E0.$members$ = w0[2], E0.$watchers$ = (y0 = w0[4]) != null ? y0 : {};
      const b0 = E0.$tagName$, O0 = class extends HTMLElement {
        constructor(S0) {
          if (super(S0), this.hasRegisteredEventListeners = !1, ((k0, D0) => {
            const z0 = { $flags$: 0, $hostElement$: k0, $cmpMeta$: D0, $instanceValues$: /* @__PURE__ */ new Map() };
            z0.$onReadyPromise$ = new Promise((G0) => z0.$onReadyResolve$ = G0), k0["s-p"] = [], k0["s-rc"] = [], lf.set(k0, z0);
          })(S0 = this, E0), 1 & E0.$flags$)
            if (S0.shadowRoot) {
              if (S0.shadowRoot.mode !== "open")
                throw new Error(`Unable to re-use existing shadow root for ${E0.$tagName$}! Mode is set to ${S0.shadowRoot.mode} but Stencil only supports open shadow roots.`);
            } else
              S0.attachShadow({ mode: "open" });
        }
        connectedCallback() {
          df(this), this.hasRegisteredEventListeners || (this.hasRegisteredEventListeners = !0), u0 && (clearTimeout(u0), u0 = null), d0 ? l0.push(this) : bf.jmp(() => ((S0) => {
            if (!(1 & bf.$flags$)) {
              const k0 = df(S0), D0 = k0.$cmpMeta$;
              if (D0.$tagName$, 1 & k0.$flags$)
                k0?.$lazyInstance$ ? Mp(k0.$lazyInstance$) : k0?.$onReadyPromise$ && k0.$onReadyPromise$.then(() => Mp(k0.$lazyInstance$));
              else {
                k0.$flags$ |= 1;
                {
                  let z0 = S0;
                  for (; z0 = z0.parentNode || z0.host; )
                    if (z0["s-p"]) {
                      fp(k0, k0.$ancestorComponent$ = z0);
                      break;
                    }
                }
                D0.$members$ && Object.entries(D0.$members$).map(([z0, [G0]]) => {
                  if (31 & G0 && S0.hasOwnProperty(z0)) {
                    const K0 = S0[z0];
                    delete S0[z0], S0[z0] = K0;
                  }
                }), xp(S0, k0, D0);
              }
            }
          })(this));
        }
        disconnectedCallback() {
          bf.jmp(() => (async (S0) => {
            if (!(1 & bf.$flags$)) {
              const k0 = df(S0);
              k0?.$lazyInstance$ ? Ap(k0.$lazyInstance$) : k0?.$onReadyPromise$ && k0.$onReadyPromise$.then(() => Ap(k0.$lazyInstance$));
            }
          })(this));
        }
        componentOnReady() {
          return df(this).$onReadyPromise$;
        }
      };
      E0.$lazyBundleId$ = g0[0], i0.includes(b0) || o0.get(b0) || (r0.push(b0), o0.define(b0, kp(O0, E0, 1)));
    });
  }), r0.length > 0 && (h0 && (c0.textContent += mf), c0.textContent += r0.sort() + "{visibility:hidden}.hydrated{visibility:inherit}", c0.innerHTML.length)) {
    c0.setAttribute("data-styles", "");
    const g0 = (n0 = bf.$nonce$) != null ? n0 : Pf(vf);
    g0 != null && c0.setAttribute("nonce", g0), s0.insertBefore(c0, a0 ? a0.nextSibling : s0.firstChild);
  }
  d0 = !1, l0.length ? l0.map((g0) => g0.connectedCallback()) : bf.jmp(() => u0 = setTimeout(Ep, 30));
};
(function() {
  if (typeof window < "u" && window.Reflect !== void 0 && window.customElements !== void 0) {
    var t0 = HTMLElement;
    window.HTMLElement = function() {
      return Reflect.construct(t0, [], this.constructor);
    }, HTMLElement.prototype = t0.prototype, HTMLElement.prototype.constructor = HTMLElement, Object.setPrototypeOf(HTMLElement, t0);
  }
})();
var Rp = Object.freeze({ __proto__: null, defineCustomElements: async (t0, e0) => {
  if (typeof window < "u")
    return await void 0, Ip([["mm-install-modal_3", [[1, "mm-install-modal", { link: [1], sdkVersion: [1, "sdk-version"], preferDesktop: [4, "prefer-desktop"], tab: [32], isDefaultTab: [32], translationsLoaded: [32] }, null, { preferDesktop: ["updatePreferDesktop"] }], [1, "mm-pending-modal", { displayOTP: [4, "display-o-t-p"], sdkVersion: [1, "sdk-version"], otpCode: [1, "otp-code"], translationsLoaded: [32] }], [1, "mm-select-modal", { link: [1], sdkVersion: [1, "sdk-version"], preferDesktop: [4, "prefer-desktop"], tab: [32], isDefaultTab: [32], translationsLoaded: [32] }, null, { preferDesktop: ["updatePreferDesktop"] }]]]], e0);
}, setNonce: (t0) => bf.$nonce$ = t0 });
const Pp = { fontFamily: "Roboto, sans-serif" }, Tp = ({ className: t0 }, e0) => Kf("div", { style: Pp, class: t0 }, e0), Op = ({ Icon: t0, text: e0 }) => Kf("div", { class: "flexContainer", style: { padding: "6", flexDirection: "row" } }, Kf("div", { class: "flexItem1" }, Kf(t0, null)), Kf("div", { class: "flexItem11" }, Kf("span", { style: { lineHeight: "2", color: "black" } }, e0))), Lp = () => Kf("svg", { width: "20", height: "18", viewBox: "0 0 20 18", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, Kf("path", { d: "M20.0002 7.9702V10.0302C20.0002 10.5802 19.5602 11.0302 19.0002 11.0502H17.0402C15.9602 11.0502 14.9702 10.2602 14.8802 9.1802C14.8202 8.5502 15.0602 7.9602 15.4802 7.5502C15.8502 7.1702 16.3602 6.9502 16.9202 6.9502H19.0002C19.5602 6.9702 20.0002 7.4202 20.0002 7.9702Z", fill: "#037DD6" }), Kf("path", { d: "M18.47 12.55H17.04C15.14 12.55 13.54 11.12 13.38 9.3C13.29 8.26 13.67 7.22 14.43 6.48C15.07 5.82 15.96 5.45 16.92 5.45H18.47C18.76 5.45 19 5.21 18.97 4.92C18.75 2.49 17.14 0.83 14.75 0.55C14.51 0.51 14.26 0.5 14 0.5H5C4.72 0.5 4.45 0.52 4.19 0.56C1.64 0.88 0 2.78 0 5.5V12.5C0 15.26 2.24 17.5 5 17.5H14C16.8 17.5 18.73 15.75 18.97 13.08C19 12.79 18.76 12.55 18.47 12.55ZM11 6.75H5C4.59 6.75 4.25 6.41 4.25 6C4.25 5.59 4.59 5.25 5 5.25H11C11.41 5.25 11.75 5.59 11.75 6C11.75 6.41 11.41 6.75 11 6.75Z", fill: "#037DD6" })), Np = () => Kf("svg", { width: "20", height: "18", viewBox: "0 0 20 18", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, Kf("path", { d: "M14.44 0.0999756C12.63 0.0999756 11.01 0.979976 10 2.32998C8.99 0.979976 7.37 0.0999756 5.56 0.0999756C2.49 0.0999756 0 2.59998 0 5.68998C0 6.87998 0.19 7.97998 0.52 8.99998C2.1 14 6.97 16.99 9.38 17.81C9.72 17.93 10.28 17.93 10.62 17.81C13.03 16.99 17.9 14 19.48 8.99998C19.81 7.97998 20 6.87998 20 5.68998C20 2.59998 17.51 0.0999756 14.44 0.0999756Z", fill: "#037DD6" })), $p = () => Kf("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, Kf("path", { d: "M16.28 7.53V6.28C16.28 3.58 15.63 0 10 0C4.37 0 3.72 3.58 3.72 6.28V7.53C0.92 7.88 0 9.3 0 12.79V14.65C0 18.75 1.25 20 5.35 20H14.65C18.75 20 20 18.75 20 14.65V12.79C20 9.3 19.08 7.88 16.28 7.53ZM10 16.74C8.33 16.74 6.98 15.38 6.98 13.72C6.98 12.05 8.34 10.7 10 10.7C11.66 10.7 13.02 12.06 13.02 13.72C13.02 15.39 11.67 16.74 10 16.74ZM5.35 7.44C5.27 7.44 5.2 7.44 5.12 7.44V6.28C5.12 3.35 5.95 1.4 10 1.4C14.05 1.4 14.88 3.35 14.88 6.28V7.45C14.8 7.45 14.73 7.45 14.65 7.45H5.35V7.44Z", fill: "#037DD6" })), Dp = () => Kf("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, Kf("path", { d: "M16.4405 8.8999C20.0405 9.2099 21.5105 11.0599 21.5105 15.1099V15.2399C21.5105 19.7099 19.7205 21.4999 15.2505 21.4999H8.74047C4.27047 21.4999 2.48047 19.7099 2.48047 15.2399V15.1099C2.48047 11.0899 3.93047 9.2399 7.47047 8.9099", stroke: "white", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }), Kf("path", { d: "M12 2V14.88", stroke: "white", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }), Kf("path", { d: "M15.3504 12.6499L12.0004 15.9999L8.65039 12.6499", stroke: "white", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }));
function Bp({ version: t0 }) {
  return Kf("div", { style: { textAlign: "center", color: "#BBC0C5", fontSize: "12" } }, "SDK Version ", t0 ? `v${t0}` : "unknown");
}
const Kp = () => Kf("svg", { width: "14", height: "14", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, Kf("rect", { width: "16", height: "16", fill: "white" }), Kf("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M2.40554 2.40554C2.94627 1.86482 3.82296 1.86482 4.36369 2.40554L8 6.04186L11.6363 2.40554C12.177 1.86482 13.0537 1.86482 13.5945 2.40554C14.1352 2.94627 14.1352 3.82296 13.5945 4.36369L9.95814 8L13.5945 11.6363C14.1352 12.177 14.1352 13.0537 13.5945 13.5945C13.0537 14.1352 12.177 14.1352 11.6363 13.5945L8 9.95814L4.36369 13.5945C3.82296 14.1352 2.94627 14.1352 2.40554 13.5945C1.86482 13.0537 1.86482 12.177 2.40554 11.6363L6.04186 8L2.40554 4.36369C1.86482 3.82296 1.86482 2.94627 2.40554 2.40554Z", fill: "#BBC0C5" })), jp = () => Kf("svg", { width: "120", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 127 63" }, Kf("path", { fill: "currentColor", d: "M71.554 48.607v13.81h-7.072v-9.568l-8.059.945c-1.77.205-2.548.79-2.548 1.864 0 1.575 1.478 2.239 4.648 2.239 1.932 0 4.073-.29 5.963-.79l-3.66 5.225c-1.479.332-2.92.496-4.44.496-6.414 0-10.074-2.57-10.074-7.132 0-4.023 2.877-6.136 9.416-6.884l8.638-1.012c-.467-2.532-2.362-3.633-6.13-3.633-3.537 0-7.443.912-10.937 2.613l1.111-6.18c3.248-1.369 6.95-2.074 10.69-2.074 8.226 0 12.461 3.444 12.461 10.075l-.008.005ZM7.938 31.315.208 62.416h7.73l3.836-15.628 6.65 8.039h8.06l6.65-8.039 3.836 15.628h7.73l-7.73-31.105-14.518 17.388L7.934 31.311l.004.004ZM36.97.21 22.452 17.598 7.938.21.208 31.315h7.73l3.836-15.628 6.65 8.039h8.06l6.65-8.039 3.836 15.628h7.73L36.97.21Zm53.17 48.107-6.25-.912c-1.562-.247-2.178-.747-2.178-1.617 0-1.41 1.52-2.032 4.647-2.032 3.62 0 6.868.747 10.283 2.364l-.862-6.094c-2.757-.995-5.922-1.491-9.212-1.491-7.688 0-11.886 2.696-11.886 7.547 0 3.776 2.303 5.889 7.196 6.636l6.335.954c1.603.248 2.261.87 2.261 1.865 0 1.41-1.478 2.074-4.481 2.074-3.948 0-8.225-.953-11.72-2.654l.7 6.094c3.003 1.122 6.91 1.785 10.57 1.785 7.896 0 12.007-2.78 12.007-7.715 0-3.94-2.303-6.057-7.4-6.8l-.01-.004ZM100.3 34.09v28.325h7.071V34.091H100.3Zm15.334 15.595 9.833-10.744h-8.8l-9.296 11.114 9.912 12.356h8.925l-10.574-12.73v.004Zm-16.321-25.09c0 4.56 3.66 7.13 10.074 7.13 1.52 0 2.961-.167 4.44-.495l3.66-5.225c-1.89.496-4.031.79-5.963.79-3.166 0-4.648-.664-4.648-2.239 0-1.079.783-1.659 2.549-1.864l8.058-.945v9.567h7.072v-13.81c0-6.635-4.236-10.075-12.461-10.075-3.744 0-7.442.705-10.691 2.075l-1.112 6.178c3.495-1.701 7.401-2.613 10.937-2.613 3.769 0 5.664 1.1 6.13 3.633l-8.637 1.013c-6.539.747-9.417 2.86-9.417 6.883l.009-.004Zm-19.779-1.492c0 5.725 3.29 8.627 9.787 8.627 2.59 0 4.732-.416 6.785-1.37l.903-6.261c-1.974 1.2-3.99 1.822-6.005 1.822-3.044 0-4.402-1.243-4.402-4.023v-8.295h10.732V7.84H86.601V2.948l-13.448 7.174v3.482h6.372V23.1l.008.004Zm-6.95-2.612v1.411H53.47c.862 2.873 3.423 4.187 7.97 4.187 3.62 0 6.993-.747 9.992-2.196l-.862 6.056c-2.757 1.16-6.251 1.785-9.829 1.785-9.5 0-14.68-4.23-14.68-12.066 0-7.838 5.264-12.235 13.406-12.235s13.119 4.771 13.119 13.062l-.005-.004ZM53.378 17.09h12.086c-.637-2.751-2.732-4.188-6.08-4.188-3.349 0-5.335 1.399-6.006 4.188Z" }));
function Up(t0, e0) {
  return t0.toString(2).padStart(e0, "0");
}
function Hp(t0, e0) {
  const n0 = t0 % e0;
  return n0 >= 0 ? n0 : e0 + n0;
}
function Fp$1(t0, e0) {
  return new Array(t0).fill(e0);
}
function zp(...t0) {
  let e0 = 0;
  for (const r0 of t0)
    e0 = Math.max(e0, r0.length);
  const n0 = [];
  for (let r0 = 0; r0 < e0; r0++)
    for (const i0 of t0)
      r0 >= i0.length || n0.push(i0[r0]);
  return new Uint8Array(n0);
}
function qp(t0, e0, n0) {
  if (n0 < 0 || n0 + e0.length > t0.length)
    return !1;
  for (let r0 = 0; r0 < e0.length; r0++)
    if (e0[r0] !== t0[n0 + r0])
      return !1;
  return !0;
}
function Wp(t0) {
  return { has: (e0) => t0.includes(e0), decode: (e0) => {
    if (!Array.isArray(e0) || e0.length && typeof e0[0] != "string")
      throw new Error("alphabet.decode input should be array of strings");
    return e0.map((n0) => {
      if (typeof n0 != "string")
        throw new Error(`alphabet.decode: not string element=${n0}`);
      const r0 = t0.indexOf(n0);
      if (r0 === -1)
        throw new Error(`Unknown letter: "${n0}". Allowed: ${t0}`);
      return r0;
    });
  }, encode: (e0) => {
    if (!Array.isArray(e0) || e0.length && typeof e0[0] != "number")
      throw new Error("alphabet.encode input should be an array of numbers");
    return e0.map((n0) => {
      if (function(r0) {
        if (!Number.isSafeInteger(r0))
          throw new Error(`Wrong integer: ${r0}`);
      }(n0), n0 < 0 || n0 >= t0.length)
        throw new Error(`Digit index outside alphabet: ${n0} (alphabet: ${t0.length})`);
      return t0[n0];
    });
  } };
}
class Vp {
  static size(e0, n0) {
    if (typeof e0 == "number" && (e0 = { height: e0, width: e0 }), !Number.isSafeInteger(e0.height) && e0.height !== 1 / 0)
      throw new Error(`Bitmap: wrong height=${e0.height} (${typeof e0.height})`);
    if (!Number.isSafeInteger(e0.width) && e0.width !== 1 / 0)
      throw new Error(`Bitmap: wrong width=${e0.width} (${typeof e0.width})`);
    return n0 !== void 0 && (e0 = { width: Math.min(e0.width, n0.width), height: Math.min(e0.height, n0.height) }), e0;
  }
  static fromString(e0) {
    const n0 = (e0 = e0.replace(/^\n+/g, "").replace(/\n+$/g, "")).split(`
`), r0 = n0.length, i0 = new Array(r0);
    let o0;
    for (const s0 of n0) {
      const a0 = s0.split("").map((c0) => {
        if (c0 === "X")
          return !0;
        if (c0 === " ")
          return !1;
        if (c0 !== "?")
          throw new Error(`Bitmap.fromString: unknown symbol=${c0}`);
      });
      if (o0 && a0.length !== o0)
        throw new Error(`Bitmap.fromString different row sizes: width=${o0} cur=${a0.length}`);
      o0 = a0.length, i0.push(a0);
    }
    return o0 || (o0 = 0), new Vp({ height: r0, width: o0 }, i0);
  }
  constructor(e0, n0) {
    const { height: r0, width: i0 } = Vp.size(e0);
    this.data = n0 || Array.from({ length: r0 }, () => Fp$1(i0, void 0)), this.height = r0, this.width = i0;
  }
  point(e0) {
    return this.data[e0.y][e0.x];
  }
  isInside(e0) {
    return 0 <= e0.x && e0.x < this.width && 0 <= e0.y && e0.y < this.height;
  }
  size(e0) {
    if (!e0)
      return { height: this.height, width: this.width };
    const { x: n0, y: r0 } = this.xy(e0);
    return { height: this.height - r0, width: this.width - n0 };
  }
  xy(e0) {
    if (typeof e0 == "number" && (e0 = { x: e0, y: e0 }), !Number.isSafeInteger(e0.x))
      throw new Error(`Bitmap: wrong x=${e0.x}`);
    if (!Number.isSafeInteger(e0.y))
      throw new Error(`Bitmap: wrong y=${e0.y}`);
    return e0.x = Hp(e0.x, this.width), e0.y = Hp(e0.y, this.height), e0;
  }
  rect(e0, n0, r0) {
    const { x: i0, y: o0 } = this.xy(e0), { height: s0, width: a0 } = Vp.size(n0, this.size({ x: i0, y: o0 }));
    for (let c0 = 0; c0 < s0; c0++)
      for (let l0 = 0; l0 < a0; l0++)
        this.data[o0 + c0][i0 + l0] = typeof r0 == "function" ? r0({ x: l0, y: c0 }, this.data[o0 + c0][i0 + l0]) : r0;
    return this;
  }
  rectRead(e0, n0, r0) {
    return this.rect(e0, n0, (i0, o0) => (r0(i0, o0), o0));
  }
  hLine(e0, n0, r0) {
    return this.rect(e0, { width: n0, height: 1 }, r0);
  }
  vLine(e0, n0, r0) {
    return this.rect(e0, { width: 1, height: n0 }, r0);
  }
  border(e0 = 2, n0) {
    const r0 = this.height + 2 * e0, i0 = this.width + 2 * e0, o0 = Fp$1(e0, n0), s0 = Array.from({ length: e0 }, () => Fp$1(i0, n0));
    return new Vp({ height: r0, width: i0 }, [...s0, ...this.data.map((a0) => [...o0, ...a0, ...o0]), ...s0]);
  }
  embed(e0, n0) {
    return this.rect(e0, n0.size(), ({ x: r0, y: i0 }) => n0.data[i0][r0]);
  }
  rectSlice(e0, n0 = this.size()) {
    const r0 = new Vp(Vp.size(n0, this.size(this.xy(e0))));
    return this.rect(e0, n0, ({ x: i0, y: o0 }, s0) => r0.data[o0][i0] = s0), r0;
  }
  inverse() {
    const { height: e0, width: n0 } = this;
    return new Vp({ height: n0, width: e0 }).rect({ x: 0, y: 0 }, 1 / 0, ({ x: r0, y: i0 }) => this.data[r0][i0]);
  }
  scale(e0) {
    if (!Number.isSafeInteger(e0) || e0 > 1024)
      throw new Error(`Wrong scale factor: ${e0}`);
    const { height: n0, width: r0 } = this;
    return new Vp({ height: e0 * n0, width: e0 * r0 }).rect({ x: 0, y: 0 }, 1 / 0, ({ x: i0, y: o0 }) => this.data[Math.floor(o0 / e0)][Math.floor(i0 / e0)]);
  }
  clone() {
    return new Vp(this.size()).rect({ x: 0, y: 0 }, this.size(), ({ x: e0, y: n0 }) => this.data[n0][e0]);
  }
  assertDrawn() {
    this.rectRead(0, 1 / 0, (e0, n0) => {
      if (typeof n0 != "boolean")
        throw new Error("Invalid color type=" + typeof n0);
    });
  }
  toString() {
    return this.data.map((e0) => e0.map((n0) => n0 === void 0 ? "?" : n0 ? "X" : " ").join("")).join(`
`);
  }
  toASCII() {
    const { height: e0, width: n0, data: r0 } = this;
    let i0 = "";
    for (let o0 = 0; o0 < e0; o0 += 2) {
      for (let s0 = 0; s0 < n0; s0++) {
        const a0 = r0[o0][s0], c0 = o0 + 1 >= e0 || r0[o0 + 1][s0];
        a0 || c0 ? !a0 && c0 ? i0 += "" : a0 && !c0 ? i0 += "" : a0 && c0 && (i0 += " ") : i0 += "";
      }
      i0 += `
`;
    }
    return i0;
  }
  toTerm() {
    const e0 = "\x1B[0m", n0 = `\x1B[1;47m  ${e0}`, r0 = `\x1B[40m  ${e0}`;
    return this.data.map((i0) => i0.map((o0) => o0 ? r0 : n0).join("")).join(`
`);
  }
  toSVG() {
    let e0 = `<svg xmlns:svg="http://www.w3.org/2000/svg" viewBox="0 0 ${this.width} ${this.height}" version="1.1" xmlns="http://www.w3.org/2000/svg">`;
    return this.rectRead(0, 1 / 0, ({ x: n0, y: r0 }, i0) => {
      i0 && (e0 += `<rect x="${n0}" y="${r0}" width="1" height="1" />`);
    }), e0 += "</svg>", e0;
  }
  toGIF() {
    const e0 = (a0) => [255 & a0, a0 >>> 8 & 255], n0 = [...e0(this.width), ...e0(this.height)], r0 = [];
    this.rectRead(0, 1 / 0, (a0, c0) => r0.push(+(c0 === !0)));
    const i0 = 126, o0 = [71, 73, 70, 56, 55, 97, ...n0, 246, 0, 0, 255, 255, 255, ...Fp$1(381, 0), 44, 0, 0, 0, 0, ...n0, 0, 7], s0 = Math.floor(r0.length / i0);
    for (let a0 = 0; a0 < s0; a0++)
      o0.push(127, 128, ...r0.slice(i0 * a0, i0 * (a0 + 1)).map((c0) => +c0));
    return o0.push(r0.length % i0 + 1, 128, ...r0.slice(s0 * i0).map((a0) => +a0)), o0.push(1, 129, 0, 59), new Uint8Array(o0);
  }
  toImage(e0 = !1) {
    const { height: n0, width: r0 } = this.size(), i0 = new Uint8Array(n0 * r0 * (e0 ? 3 : 4));
    let o0 = 0;
    for (let s0 = 0; s0 < n0; s0++)
      for (let a0 = 0; a0 < r0; a0++) {
        const c0 = this.data[s0][a0] ? 0 : 255;
        i0[o0++] = c0, i0[o0++] = c0, i0[o0++] = c0, e0 || (i0[o0++] = 255);
      }
    return { height: n0, width: r0, data: i0 };
  }
}
const Gp = ["low", "medium", "quartile", "high"], Yp = ["numeric", "alphanumeric", "byte", "kanji", "eci"], Zp = [26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706], Jp = { low: [7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], medium: [10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28], quartile: [13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], high: [17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30] }, Xp = { low: [1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25], medium: [1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49], quartile: [1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68], high: [1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81] }, Qp = { size: { encode: (t0) => 21 + 4 * (t0 - 1), decode: (t0) => (t0 - 17) / 4 }, sizeType: (t0) => Math.floor((t0 + 7) / 17), alignmentPatterns(t0) {
  if (t0 === 1)
    return [];
  const e0 = Qp.size.encode(t0) - 6 - 1, n0 = e0 - 6, r0 = Math.ceil(n0 / 28);
  let i0 = Math.floor(n0 / r0);
  i0 % 2 ? i0 += 1 : n0 % r0 * 2 >= r0 && (i0 += 2);
  const o0 = [6];
  for (let s0 = 1; s0 < r0; s0++)
    o0.push(e0 - (r0 - s0) * i0);
  return o0.push(e0), o0;
}, ECCode: { low: 1, medium: 0, quartile: 3, high: 2 }, formatMask: 21522, formatBits(t0, e0) {
  const n0 = Qp.ECCode[t0] << 3 | e0;
  let r0 = n0;
  for (let i0 = 0; i0 < 10; i0++)
    r0 = r0 << 1 ^ 1335 * (r0 >> 9);
  return (n0 << 10 | r0) ^ Qp.formatMask;
}, versionBits(t0) {
  let e0 = t0;
  for (let n0 = 0; n0 < 12; n0++)
    e0 = e0 << 1 ^ 7973 * (e0 >> 11);
  return t0 << 12 | e0;
}, alphabet: { numeric: Wp("0123456789"), alphanumerc: Wp("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:") }, lengthBits: (t0, e0) => ({ numeric: [10, 12, 14], alphanumeric: [9, 11, 13], byte: [8, 16, 16], kanji: [8, 10, 12], eci: [0, 0, 0] })[e0][Qp.sizeType(t0)], modeBits: { numeric: "0001", alphanumeric: "0010", byte: "0100", kanji: "1000", eci: "0111" }, capacity(t0, e0) {
  const n0 = Zp[t0 - 1], r0 = Jp[e0][t0 - 1], i0 = Xp[e0][t0 - 1], o0 = Math.floor(n0 / i0) - r0, s0 = i0 - n0 % i0;
  return { words: r0, numBlocks: i0, shortBlocks: s0, blockLen: o0, capacity: 8 * (n0 - r0 * i0), total: (r0 + o0) * i0 + i0 - s0 };
} }, eg = [(t0, e0) => (t0 + e0) % 2 == 0, (t0, e0) => e0 % 2 == 0, (t0, e0) => t0 % 3 == 0, (t0, e0) => (t0 + e0) % 3 == 0, (t0, e0) => (Math.floor(e0 / 2) + Math.floor(t0 / 3)) % 2 == 0, (t0, e0) => t0 * e0 % 2 + t0 * e0 % 3 == 0, (t0, e0) => (t0 * e0 % 2 + t0 * e0 % 3) % 2 == 0, (t0, e0) => ((t0 + e0) % 2 + t0 * e0 % 3) % 2 == 0], tg = { tables: ((t0) => {
  const e0 = Fp$1(256, 0), n0 = Fp$1(256, 0);
  for (let r0 = 0, i0 = 1; r0 < 256; r0++)
    e0[r0] = i0, n0[i0] = r0, i0 <<= 1, 256 & i0 && (i0 ^= 285);
  return { exp: e0, log: n0 };
})(), exp: (t0) => tg.tables.exp[t0], log(t0) {
  if (t0 === 0)
    throw new Error(`GF.log: wrong arg=${t0}`);
  return tg.tables.log[t0] % 255;
}, mul: (t0, e0) => t0 === 0 || e0 === 0 ? 0 : tg.tables.exp[(tg.tables.log[t0] + tg.tables.log[e0]) % 255], add: (t0, e0) => t0 ^ e0, pow: (t0, e0) => tg.tables.exp[tg.tables.log[t0] * e0 % 255], inv(t0) {
  if (t0 === 0)
    throw new Error(`GF.inverse: wrong arg=${t0}`);
  return tg.tables.exp[255 - tg.tables.log[t0]];
}, polynomial(t0) {
  if (t0.length == 0)
    throw new Error("GF.polymomial: wrong length");
  if (t0[0] !== 0)
    return t0;
  let e0 = 0;
  for (; e0 < t0.length - 1 && t0[e0] == 0; e0++)
    ;
  return t0.slice(e0);
}, monomial(t0, e0) {
  if (t0 < 0)
    throw new Error(`GF.monomial: wrong degree=${t0}`);
  if (e0 == 0)
    return [0];
  let n0 = Fp$1(t0 + 1, 0);
  return n0[0] = e0, tg.polynomial(n0);
}, degree: (t0) => t0.length - 1, coefficient: (t0, e0) => t0[tg.degree(t0) - e0], mulPoly(t0, e0) {
  if (t0[0] === 0 || e0[0] === 0)
    return [0];
  const n0 = Fp$1(t0.length + e0.length - 1, 0);
  for (let r0 = 0; r0 < t0.length; r0++)
    for (let i0 = 0; i0 < e0.length; i0++)
      n0[r0 + i0] = tg.add(n0[r0 + i0], tg.mul(t0[r0], e0[i0]));
  return tg.polynomial(n0);
}, mulPolyScalar(t0, e0) {
  if (e0 == 0)
    return [0];
  if (e0 == 1)
    return t0;
  const n0 = Fp$1(t0.length, 0);
  for (let r0 = 0; r0 < t0.length; r0++)
    n0[r0] = tg.mul(t0[r0], e0);
  return tg.polynomial(n0);
}, mulPolyMonomial(t0, e0, n0) {
  if (e0 < 0)
    throw new Error("GF.mulPolyMonomial: wrong degree");
  if (n0 == 0)
    return [0];
  const r0 = Fp$1(t0.length + e0, 0);
  for (let i0 = 0; i0 < t0.length; i0++)
    r0[i0] = tg.mul(t0[i0], n0);
  return tg.polynomial(r0);
}, addPoly(t0, e0) {
  if (t0[0] === 0)
    return e0;
  if (e0[0] === 0)
    return t0;
  let n0 = t0, r0 = e0;
  n0.length > r0.length && ([n0, r0] = [r0, n0]);
  let i0 = Fp$1(r0.length, 0), o0 = r0.length - n0.length, s0 = r0.slice(0, o0);
  for (let a0 = 0; a0 < s0.length; a0++)
    i0[a0] = s0[a0];
  for (let a0 = o0; a0 < r0.length; a0++)
    i0[a0] = tg.add(n0[a0 - o0], r0[a0]);
  return tg.polynomial(i0);
}, remainderPoly(t0, e0) {
  const n0 = Array.from(t0);
  for (let r0 = 0; r0 < t0.length - e0.length + 1; r0++) {
    const i0 = n0[r0];
    if (i0 !== 0)
      for (let o0 = 1; o0 < e0.length; o0++)
        e0[o0] !== 0 && (n0[r0 + o0] = tg.add(n0[r0 + o0], tg.mul(e0[o0], i0)));
  }
  return n0.slice(t0.length - e0.length + 1, n0.length);
}, divisorPoly(t0) {
  let e0 = [1];
  for (let n0 = 0; n0 < t0; n0++)
    e0 = tg.mulPoly(e0, [1, tg.pow(2, n0)]);
  return e0;
}, evalPoly(t0, e0) {
  if (e0 == 0)
    return tg.coefficient(t0, 0);
  let n0 = t0[0];
  for (let r0 = 1; r0 < t0.length; r0++)
    n0 = tg.add(tg.mul(e0, n0), t0[r0]);
  return n0;
}, euclidian(t0, e0, n0) {
  tg.degree(t0) < tg.degree(e0) && ([t0, e0] = [e0, t0]);
  let r0 = t0, i0 = e0, o0 = [0], s0 = [1];
  for (; 2 * tg.degree(i0) >= n0; ) {
    let l0 = r0, u0 = o0;
    if (r0 = i0, o0 = s0, r0[0] === 0)
      throw new Error("rLast[0] === 0");
    i0 = l0;
    let d0 = [0];
    const h0 = tg.inv(r0[0]);
    for (; tg.degree(i0) >= tg.degree(r0) && i0[0] !== 0; ) {
      const g0 = tg.degree(i0) - tg.degree(r0), w0 = tg.mul(i0[0], h0);
      d0 = tg.addPoly(d0, tg.monomial(g0, w0)), i0 = tg.addPoly(i0, tg.mulPolyMonomial(r0, g0, w0));
    }
    if (d0 = tg.mulPoly(d0, o0), s0 = tg.addPoly(d0, u0), tg.degree(i0) >= tg.degree(r0))
      throw new Error(`Division failed r: ${i0}, rLast: ${r0}`);
  }
  const a0 = tg.coefficient(s0, 0);
  if (a0 == 0)
    throw new Error("sigmaTilde(0) was zero");
  const c0 = tg.inv(a0);
  return [tg.mulPolyScalar(s0, c0), tg.mulPolyScalar(i0, c0)];
} };
function ng(t0, e0) {
  const { words: n0, shortBlocks: r0, numBlocks: i0, blockLen: o0, total: s0 } = Qp.capacity(t0, e0), a0 = (c0 = n0, { encode(l0) {
    const u0 = tg.divisorPoly(c0), d0 = Array.from(l0);
    return d0.push(...u0.slice(0, -1).fill(0)), Uint8Array.from(tg.remainderPoly(d0, u0));
  }, decode(l0) {
    const u0 = l0.slice(), d0 = tg.polynomial(Array.from(l0));
    let h0 = Fp$1(c0, 0), g0 = !1;
    for (let S0 = 0; S0 < c0; S0++) {
      const k0 = tg.evalPoly(d0, tg.exp(S0));
      h0[h0.length - 1 - S0] = k0, k0 !== 0 && (g0 = !0);
    }
    if (!g0)
      return u0;
    h0 = tg.polynomial(h0);
    const w0 = tg.monomial(c0, 1), [y0, E0] = tg.euclidian(w0, h0, c0), b0 = Fp$1(tg.degree(y0), 0);
    let O0 = 0;
    for (let S0 = 1; S0 < 256 && O0 < b0.length; S0++)
      tg.evalPoly(y0, S0) === 0 && (b0[O0++] = tg.inv(S0));
    if (O0 !== b0.length)
      throw new Error("RS.decode: wrong errors number");
    for (let S0 = 0; S0 < b0.length; S0++) {
      const k0 = u0.length - 1 - tg.log(b0[S0]);
      if (k0 < 0)
        throw new Error("RS.decode: wrong error location");
      const D0 = tg.inv(b0[S0]);
      let z0 = 1;
      for (let G0 = 0; G0 < b0.length; G0++)
        S0 !== G0 && (z0 = tg.mul(z0, tg.add(1, tg.mul(b0[G0], D0))));
      u0[k0] = tg.add(u0[k0], tg.mul(tg.evalPoly(E0, D0), tg.inv(z0)));
    }
    return u0;
  } });
  var c0;
  return { encode(l0) {
    const u0 = [], d0 = [];
    for (let y0 = 0; y0 < i0; y0++) {
      const E0 = o0 + (y0 < r0 ? 0 : 1);
      u0.push(l0.subarray(0, E0)), d0.push(a0.encode(l0.subarray(0, E0))), l0 = l0.subarray(E0);
    }
    const h0 = zp(...u0), g0 = zp(...d0), w0 = new Uint8Array(h0.length + g0.length);
    return w0.set(h0), w0.set(g0, h0.length), w0;
  }, decode(l0) {
    if (l0.length !== s0)
      throw new Error(`interleave.decode: len(data)=${l0.length}, total=${s0}`);
    const u0 = [];
    for (let g0 = 0; g0 < i0; g0++) {
      const w0 = g0 < r0;
      u0.push(new Uint8Array(n0 + o0 + (w0 ? 0 : 1)));
    }
    let d0 = 0;
    for (let g0 = 0; g0 < o0; g0++)
      for (let w0 = 0; w0 < i0; w0++)
        u0[w0][g0] = l0[d0++];
    for (let g0 = r0; g0 < i0; g0++)
      u0[g0][o0] = l0[d0++];
    for (let g0 = o0; g0 < o0 + n0; g0++)
      for (let w0 = 0; w0 < i0; w0++) {
        const y0 = w0 < r0;
        u0[w0][g0 + (y0 ? 0 : 1)] = l0[d0++];
      }
    const h0 = [];
    for (const g0 of u0)
      h0.push(...Array.from(a0.decode(g0)).slice(0, -n0));
    return Uint8Array.from(h0);
  } };
}
function rg(t0, e0, n0, r0) {
  let i0 = "", o0 = n0.length;
  if (r0 === "numeric") {
    const d0 = Qp.alphabet.numeric.decode(n0.split("")), h0 = d0.length;
    for (let g0 = 0; g0 < h0 - 2; g0 += 3)
      i0 += Up(100 * d0[g0] + 10 * d0[g0 + 1] + d0[g0 + 2], 10);
    h0 % 3 == 1 ? i0 += Up(d0[h0 - 1], 4) : h0 % 3 == 2 && (i0 += Up(10 * d0[h0 - 2] + d0[h0 - 1], 7));
  } else if (r0 === "alphanumeric") {
    const d0 = Qp.alphabet.alphanumerc.decode(n0.split("")), h0 = d0.length;
    for (let g0 = 0; g0 < h0 - 1; g0 += 2)
      i0 += Up(45 * d0[g0] + d0[g0 + 1], 11);
    h0 % 2 == 1 && (i0 += Up(d0[h0 - 1], 6));
  } else {
    if (r0 !== "byte")
      throw new Error("encode: unsupported type");
    {
      const d0 = function(h0) {
        if (typeof h0 != "string")
          throw new Error("utf8ToBytes expected string, got " + typeof h0);
        return new Uint8Array(new TextEncoder().encode(h0));
      }(n0);
      o0 = d0.length, i0 = Array.from(d0).map((h0) => Up(h0, 8)).join("");
    }
  }
  const { capacity: s0 } = Qp.capacity(t0, e0), a0 = Up(o0, Qp.lengthBits(t0, r0));
  let c0 = Qp.modeBits[r0] + a0 + i0;
  if (c0.length > s0)
    throw new Error("Capacity overflow");
  c0 += "0".repeat(Math.min(4, Math.max(0, s0 - c0.length))), c0.length % 8 && (c0 += "0".repeat(8 - c0.length % 8));
  const l0 = "1110110000010001";
  for (let d0 = 0; c0.length !== s0; d0++)
    c0 += l0[d0 % 16];
  const u0 = Uint8Array.from(c0.match(/(.{8})/g).map((d0) => +`0b${d0}`));
  return ng(t0, e0).encode(u0);
}
function ig(t0, e0, n0, r0, i0 = !1) {
  const o0 = function(c0, l0, u0, d0 = !1) {
    const h0 = Qp.size.encode(c0);
    let g0 = new Vp(h0 + 2);
    const w0 = new Vp(3).rect(0, 3, !0).border(1, !1).border(1, !0).border(1, !1);
    g0 = g0.embed(0, w0).embed({ x: -w0.width, y: 0 }, w0).embed({ x: 0, y: -w0.height }, w0), g0 = g0.rectSlice(1, h0);
    const y0 = new Vp(1).rect(0, 1, !0).border(1, !1).border(1, !0), E0 = Qp.alignmentPatterns(c0);
    for (const b0 of E0)
      for (const O0 of E0)
        g0.data[b0][O0] === void 0 && g0.embed({ x: O0 - 2, y: b0 - 2 }, y0);
    g0 = g0.hLine({ x: 0, y: 6 }, 1 / 0, ({ x: b0 }, O0) => O0 === void 0 ? b0 % 2 == 0 : O0).vLine({ x: 6, y: 0 }, 1 / 0, ({ y: b0 }, O0) => O0 === void 0 ? b0 % 2 == 0 : O0);
    {
      const b0 = Qp.formatBits(l0, u0), O0 = (S0) => !d0 && (b0 >> S0 & 1) == 1;
      for (let S0 = 0; S0 < 6; S0++)
        g0.data[S0][8] = O0(S0);
      for (let S0 = 6; S0 < 8; S0++)
        g0.data[S0 + 1][8] = O0(S0);
      for (let S0 = 8; S0 < 15; S0++)
        g0.data[h0 - 15 + S0][8] = O0(S0);
      for (let S0 = 0; S0 < 8; S0++)
        g0.data[8][h0 - S0 - 1] = O0(S0);
      for (let S0 = 8; S0 < 9; S0++)
        g0.data[8][15 - S0 - 1 + 1] = O0(S0);
      for (let S0 = 9; S0 < 15; S0++)
        g0.data[8][15 - S0 - 1] = O0(S0);
      g0.data[h0 - 8][8] = !d0;
    }
    if (c0 >= 7) {
      const b0 = Qp.versionBits(c0);
      for (let O0 = 0; O0 < 18; O0 += 1) {
        const S0 = !d0 && (b0 >> O0 & 1) == 1, k0 = Math.floor(O0 / 3), D0 = O0 % 3 + h0 - 8 - 3;
        g0.data[k0][D0] = S0, g0.data[D0][k0] = S0;
      }
    }
    return g0;
  }(t0, e0, r0, i0);
  let s0 = 0;
  const a0 = 8 * n0.length;
  if (function(c0, l0, u0) {
    const d0 = c0.height, h0 = eg[l0];
    let g0 = -1, w0 = d0 - 1;
    for (let y0 = d0 - 1; y0 > 0; y0 -= 2) {
      for (y0 == 6 && (y0 = 5); ; w0 += g0) {
        for (let E0 = 0; E0 < 2; E0 += 1) {
          const b0 = y0 - E0;
          c0.data[w0][b0] === void 0 && u0(b0, w0, h0(b0, w0));
        }
        if (w0 + g0 < 0 || w0 + g0 >= d0)
          break;
      }
      g0 = -g0;
    }
  }(o0, r0, (c0, l0, u0) => {
    let d0 = !1;
    s0 < a0 && (d0 = (n0[s0 >>> 3] >> (7 - s0 & 7) & 1) != 0, s0++), o0.data[l0][c0] = d0 !== u0;
  }), s0 !== a0)
    throw new Error("QR: bytes left after draw");
  return o0;
}
function og(t0) {
  const e0 = t0.inverse(), n0 = (g0) => {
    let w0 = 0;
    for (let y0, E0 = 0, b0 = 1; E0 < g0.length; E0++)
      y0 === g0[E0] && (b0++, E0 !== g0.length - 1) || (b0 >= 5 && (w0 += b0 - 5 + 3), y0 = g0[E0], b0 = 1);
    return w0;
  };
  let r0 = 0;
  t0.data.forEach((g0) => r0 += n0(g0)), e0.data.forEach((g0) => r0 += n0(g0));
  let i0 = 0, o0 = t0.data;
  const s0 = t0.width - 1, a0 = t0.height - 1;
  for (let g0 = 0; g0 < s0; g0++)
    for (let w0 = 0; w0 < a0; w0++) {
      const y0 = g0 + 1, E0 = w0 + 1;
      o0[g0][w0] === o0[y0][w0] && o0[y0][w0] === o0[g0][E0] && o0[y0][w0] === o0[y0][E0] && (i0 += 3);
    }
  const c0 = (g0) => {
    const w0 = [!0, !1, !0, !0, !0, !1, !0], y0 = [!1, !1, !1, !1], E0 = [...w0, ...y0], b0 = [...y0, ...w0];
    let O0 = 0;
    for (let S0 = 0; S0 < g0.length; S0++)
      qp(g0, E0, S0) && (O0 += 40), qp(g0, b0, S0) && (O0 += 40);
    return O0;
  };
  let l0 = 0;
  for (const g0 of t0.data)
    l0 += c0(g0);
  for (const g0 of e0.data)
    l0 += c0(g0);
  let u0 = 0;
  t0.rectRead(0, 1 / 0, (g0, w0) => u0 += w0 ? 1 : 0);
  const d0 = u0 / (t0.height * t0.width) * 100, h0 = 10 * Math.floor(Math.abs(d0 - 50) / 5);
  return r0 + i0 + l0 + h0;
}
function sg(t0, e0 = "raw", n0 = {}) {
  const r0 = n0.ecc !== void 0 ? n0.ecc : "medium";
  (function(u0) {
    if (!Gp.includes(u0))
      throw new Error(`Invalid error correction mode=${u0}. Expected: ${Gp}`);
  })(r0);
  const i0 = n0.encoding !== void 0 ? n0.encoding : function(u0) {
    let d0 = "numeric";
    for (let h0 of u0)
      if (!Qp.alphabet.numeric.has(h0) && (d0 = "alphanumeric", !Qp.alphabet.alphanumerc.has(h0)))
        return "byte";
    return d0;
  }(t0);
  (function(u0) {
    if (!Yp.includes(u0))
      throw new Error(`Encoding: invalid mode=${u0}. Expected: ${Yp}`);
    if (u0 === "kanji" || u0 === "eci")
      throw new Error(`Encoding: ${u0} is not supported (yet?).`);
  })(i0), n0.mask !== void 0 && function(u0) {
    if (![0, 1, 2, 3, 4, 5, 6, 7].includes(u0) || !eg[u0])
      throw new Error(`Invalid mask=${u0}. Expected number [0..7]`);
  }(n0.mask);
  let o0, s0 = n0.version, a0 = new Error("Unknown error");
  if (s0 !== void 0)
    (function(u0) {
      if (!Number.isSafeInteger(u0) || u0 < 1 || u0 > 40)
        throw new Error(`Invalid version=${u0}. Expected number [1..40]`);
    })(s0), o0 = rg(s0, r0, t0, i0);
  else
    for (let u0 = 1; u0 <= 40; u0++)
      try {
        o0 = rg(u0, r0, t0, i0), s0 = u0;
        break;
      } catch (d0) {
        a0 = d0;
      }
  if (!s0 || !o0)
    throw a0;
  let c0 = function(u0, d0, h0, g0) {
    if (g0 === void 0) {
      const w0 = function() {
        let y0, E0 = 1 / 0;
        return { add(b0, O0) {
          b0 >= E0 || (y0 = O0, E0 = b0);
        }, get: () => y0, score: () => E0 };
      }();
      for (let y0 = 0; y0 < eg.length; y0++)
        w0.add(og(ig(u0, d0, h0, y0, !0)), y0);
      g0 = w0.get();
    }
    if (g0 === void 0)
      throw new Error("Cannot find mask");
    return ig(u0, d0, h0, g0);
  }(s0, r0, o0, n0.mask);
  c0.assertDrawn();
  const l0 = n0.border === void 0 ? 2 : n0.border;
  if (!Number.isSafeInteger(l0))
    throw new Error("Wrong border type=" + typeof l0);
  if (c0 = c0.border(l0, !1), n0.scale !== void 0 && (c0 = c0.scale(n0.scale)), e0 === "raw")
    return c0.data;
  if (e0 === "ascii")
    return c0.toASCII();
  if (e0 === "svg")
    return c0.toSVG();
  if (e0 === "gif")
    return c0.toGIF();
  if (e0 === "term")
    return c0.toTerm();
  throw new Error(`Unknown output: ${e0}`);
}
const ag = { DESKTOP: "Desktop", MOBILE: "Mobile", META_MASK_MOBILE_APP: "MetaMask mobile app", SCAN_TO_CONNECT: "Scan to connect and sign with", CONNECT_WITH_EXTENSION: "Connect With MetaMask Extension", INSTALL_MODAL: { TRUSTED_BY_USERS: "Trusted by over 30 million users to buy, store, send and swap crypto securely", LEADING_CRYPTO_WALLET: "The leading crypto wallet & gateway to blockchain apps built on Ethereum Mainnet, Polygon, Optimism, and many other networks", CONTROL_DIGITAL_INTERACTIONS: "Puts you in control of your digital interactions by making power of cryptography more accessible", INSTALL_META_MASK_EXTENSION: "Install MetaMask Extension" }, PENDING_MODAL: { OPEN_META_MASK_SELECT_CODE: "Please open the MetaMask wallet app and select the code on the screen OR disconnect", OPEN_META_MASK_CONTINUE: "Open the MetaMask app to continue with your session.", NUMBER_AFTER_OPEN_NOTICE: "If a number doesn't appear after opening MetaMask, please click disconnect and re-scan the QRCode.", DISCONNECT: "Disconnect" }, SELECT_MODAL: { CRYPTO_TAKE_CONTROL_TEXT: "Take control of your crypto and explore the blockchain with the wallet trusted by over 30 million people worldwide" }, META_MASK_MODAL: { ADDRESS_COPIED: "Address copied to clipboard!", DISCONNECT: "Disconnect", ACTIVE_NETWORK: "Active Network" } };
class cg {
  constructor(e0) {
    var n0;
    this.translations = ag, this.supportedLocales = ["es", "fr", "he", "it", "pt", "tr"], this.baseUrl = (n0 = e0?.baseUrl) !== null && n0 !== void 0 ? n0 : "https://raw.githubusercontent.com/MetaMask/metamask-sdk/refs/heads/gh-pages/locales";
  }
  getBrowserLanguage() {
    if ((navigator.languages || [navigator.language]).some((n0) => n0.toLowerCase().startsWith("en")))
      return "en";
    const e0 = navigator.language.toLowerCase().split("-")[0];
    return this.supportedLocales.includes(e0) ? e0 : "en";
  }
  async init(e0) {
    const n0 = this.getBrowserLanguage() || e0.fallbackLng;
    await this.loadTranslations(n0);
  }
  async loadTranslations(e0) {
    const n0 = e0.split("-")[0];
    if (n0 !== "en" && this.supportedLocales.includes(n0))
      try {
        const r0 = `${this.baseUrl}/${n0}.json`, i0 = await fetch(r0);
        if (!i0.ok)
          throw new Error(`HTTP error! status: ${i0.status}`);
        this.translations = await i0.json();
      } catch (r0) {
        console.warn(` Failed to load ${n0} translations, falling back to English:`, r0), this.translations = ag;
      }
    else
      this.translations = ag;
  }
  t(e0) {
    return this.getNestedTranslation(e0, this.translations) || e0;
  }
  getNestedTranslation(e0, n0) {
    const r0 = e0.split(".");
    let i0 = n0;
    for (const o0 of r0) {
      if (typeof i0 != "object")
        return "";
      i0 = i0[o0];
    }
    return typeof i0 == "string" ? i0 : "";
  }
}
var lg;
(function(t0) {
  t0.SDK_MODAL_VIEWED = "sdk_modal_viewed", t0.SDK_MODAL_BUTTON_CLICKED = "sdk_modal_button_clicked", t0.SDK_MODAL_TOGGLE_CHANGED = "sdk_modal_toggle_changed";
})(lg || (lg = {}));
const dg = class {
  constructor(t0) {
    uf(this, t0), this.close = Wf(this, "close", 7), this.startDesktopOnboarding = Wf(this, "startDesktopOnboarding", 7), this.trackAnalytics = Wf(this, "trackAnalytics", 7), this.link = void 0, this.sdkVersion = void 0, this.preferDesktop = void 0, this.tab = 1, this.isDefaultTab = !0, this.translationsLoaded = !1, this.onClose = this.onClose.bind(this), this.onStartDesktopOnboardingHandler = this.onStartDesktopOnboardingHandler.bind(this), this.setTab = this.setTab.bind(this), this.render = this.render.bind(this), this.setTab(this.preferDesktop ? 1 : 2), this.i18nInstance = new cg();
  }
  componentDidLoad() {
    this.trackAnalytics.emit({ event: lg.SDK_MODAL_VIEWED, params: { extensionInstalled: !1, tab: this.tab === 1 ? "desktop" : "mobile" } });
  }
  async connectedCallback() {
    await this.i18nInstance.init({ fallbackLng: "en" }), this.translationsLoaded = !0;
  }
  updatePreferDesktop(t0) {
    t0 ? this.setTab(1) : this.setTab(2);
  }
  onClose(t0 = !1) {
    this.close.emit({ shouldTerminate: t0 });
  }
  onStartDesktopOnboardingHandler() {
    this.trackAnalytics.emit({ event: lg.SDK_MODAL_BUTTON_CLICKED, params: { button_type: "install_extension", tab: "desktop" } }), this.startDesktopOnboarding.emit();
  }
  setTab(t0, e0 = !1) {
    e0 && this.trackAnalytics.emit({ event: lg.SDK_MODAL_TOGGLE_CHANGED, params: { toggle: this.tab === 1 ? "desktop_to_mobile" : "mobile_to_desktop" } }), this.tab = t0, this.isDefaultTab = !1;
  }
  render() {
    if (!this.translationsLoaded)
      return null;
    const t0 = (r0) => this.i18nInstance.t(r0), e0 = this.isDefaultTab ? this.preferDesktop ? 1 : 2 : this.tab, n0 = sg(this.link, "svg", { ecc: "medium", scale: 2 });
    return Kf(Tp, { className: "install-model" }, Kf("div", { class: "backdrop", onClick: () => this.onClose(!0) }), Kf("div", { class: "modal" }, Kf("div", { class: "closeButtonContainer" }, Kf("div", { class: "right" }, Kf("span", { class: "closeButton", onClick: () => this.onClose(!0) }, Kf(Kp, null)))), Kf("div", { class: "logoContainer" }, Kf(jp, null)), Kf("div", null, Kf("div", { class: "tabcontainer" }, Kf("div", { class: "flexContainer" }, Kf("div", { onClick: () => this.setTab(1, !0), class: "tab flexItem " + (e0 === 1 ? "tabactive" : "") }, t0("DESKTOP")), Kf("div", { onClick: () => this.setTab(2, !0), class: "tab flexItem " + (e0 === 2 ? "tabactive" : "") }, t0("MOBILE")))), Kf("div", { style: { display: e0 === 1 ? "none" : "block" } }, Kf("div", { class: "flexContainer" }, Kf("div", { class: "flexItem", style: { textAlign: "center", marginTop: "4" } }, n0 && Kf("div", { id: "sdk-mm-qrcode", class: "center", innerHTML: n0 }), Kf("div", { class: "connectMobileText" }, t0("SCAN_TO_CONNECT"), " ", Kf("br", null), Kf("span", { class: "blue" }, Kf("b", null, t0("META_MASK_MOBILE_APP"))))))), Kf("div", { style: { display: e0 === 2 ? "none" : "block" } }, Kf("div", { class: "item" }, Kf(Op, { Icon: Np, text: t0("INSTALL_MODAL.TRUSTED_BY_USERS") })), Kf("div", { class: "item" }, Kf(Op, { Icon: Lp, text: t0("INSTALL_MODAL.LEADING_CRYPTO_WALLET") })), Kf("div", { class: "item" }, Kf(Op, { Icon: $p, text: t0("INSTALL_MODAL.CONTROL_DIGITAL_INTERACTIONS") })), Kf("button", { class: "button", onClick: () => this.onStartDesktopOnboardingHandler() }, Kf(Dp, null), Kf("span", { class: "installExtensionText" }, t0("INSTALL_MODAL.INSTALL_META_MASK_EXTENSION"))))), Kf(Bp, { version: this.sdkVersion })));
  }
  get el() {
    return qf(this);
  }
  static get watchers() {
    return { preferDesktop: ["updatePreferDesktop"] };
  }
};
dg.style = `.flexContainer {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: row;
}

.flexItem {
    flex: 1;
    justify-content: center;
    align-items: center;
}

.flexItem11 {
    flex: 11;
    justify-content: center;
    align-items: center;
}

.flexItem1 {
    flex: 1;
    justify-content: center;
    align-items: center;
}

.tab {
    padding: 8px;
    cursor: pointer;
    background-color: #F2F4F6;
    font-size: 12px;
    text-align: center;
    color: #24292E;
}

.tabcontainer {
    padding: 4px;
    background-color: #F2F4F6;
    border-radius: 8px;
    margin-bottom: 30px;
    margin-top: 30px;
}

.tabactive {
    background-color: white;
    -webkit-transition: background-color 300ms linear;
    -ms-transition: background-color 300ms linear;
    transition: background-color 300ms linear;
    border-radius: 8px;
}

.item {
    font-size: 12px;
    margin-bottom: 16px;
    border-radius: 8px;
    padding: 10px;
    border: 2px #F2F4F6 solid;
    color: #24292E;
}

.extensionLabel {
    font-style: normal;
    font-weight: bold;
    font-size: 14px;
    text-align: cetner;
    color: #24272A;
}

.notice {
    font-size: 12px;
    margin-left: 10px;
    margin-right: 10px;
    color: grey;
}

.button {
    margin-top: 41.5px;
    margin-bottom: 20px;
    width: 100%;
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    padding: 12px 20px;
    background: #037DD6;
    border-radius: 32px;
    color: white;
    border: 0;
    font-size: 14px;
    cursor: pointer;
}

.backdrop {
    visibility: visible;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    z-index: 99998;
    background: rgba(0, 0, 0, 0.87);
    opacity: 0.3;
}

.modal {
    visibility: visible;
    position: fixed;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 99999;
    background: white;
    padding: 20px;
    border-radius: 8px;
    top: 50%;
    max-width: 100%;
    width: 460px;
    min-width: 300px;
    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;
    -webkit-font-smoothing: antialiased;
}

.closeButton {
    color: #BBC0C5;
    cursor: pointer;
}

.logoContainer {
    margin-left: 24px;
    margin-right: 24px;
    margin-top: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.connectMobileText {
    font-size: 14px;
    color: black;
    margin-top: 28px;
    margin-bottom: 28px;
    line-height: 2;
}

.blue {
    color: #037DD6;
    font-weight: 700;
}

.installExtensionText {
    margin-left: 10px;
}

.center {
    display: flex;
    justify-content: center;
    align-items: center;
}

.right {
    display: flex;
    align-items: center;
    justify-content: right;
}

#sdk-mm-qrcode {
    svg {
        width: 50%;
    }
}`;
const ug = class {
  constructor(t0) {
    uf(this, t0), this.close = Wf(this, "close", 7), this.disconnect = Wf(this, "disconnect", 7), this.updateOTPValue = Wf(this, "updateOTPValue", 7), this.displayOTP = void 0, this.sdkVersion = void 0, this.otpCode = void 0, this.translationsLoaded = !1, this.i18nInstance = new cg();
  }
  async connectedCallback() {
    await this.i18nInstance.init({ fallbackLng: "en" }), this.translationsLoaded = !0;
  }
  onClose() {
    this.close.emit();
  }
  onDisconnect() {
    this.disconnect.emit();
  }
  onUpdateOTPValueHandler(t0) {
    this.updateOTPValue.emit({ otpValue: t0 });
  }
  disconnectedCallback() {
    this.onClose();
  }
  render() {
    var t0;
    if (!this.translationsLoaded)
      return null;
    const e0 = (t0 = this.displayOTP) === null || t0 === void 0 || t0, n0 = this.sdkVersion, r0 = (i0) => this.i18nInstance.t(i0);
    return Kf(Tp, { className: "pending-modal" }, Kf("div", { class: "backdrop", onClick: () => this.onClose() }), Kf("div", { class: "modal" }, Kf("div", { class: "closeButtonContainer" }, Kf("div", { class: "right" }, Kf("span", { class: "closeButton", onClick: () => this.onClose() }, Kf(Kp, null)))), Kf("div", { class: "logoContainer" }, Kf(jp, null)), Kf("div", null, Kf("div", { class: "flexContainer", style: { flexDirection: "column", color: "black" } }, Kf("div", { class: "flexItem", style: { textAlign: "center", marginTop: "30px", marginBottom: "30px", fontSize: "16px" } }, r0(e0 ? "PENDING_MODAL.OPEN_META_MASK_SELECT_CODE" : "PENDING_MODAL.OPEN_META_MASK_CONTINUE")), Kf("div", { id: "sdk-mm-otp-value", style: { padding: "10px", fontSize: "32px", display: this.otpCode ? "block" : "none" } }, this.otpCode), e0 && Kf("div", { class: "notice" }, "* ", r0("PENDING_MODAL.NUMBER_AFTER_OPEN_NOTICE"))), Kf("div", { style: { marginTop: "20px" } }, Kf("button", { class: "button blue", style: { marginTop: "5px", color: "#0376C9", borderColor: "#0376C9", borderWidth: "1px", borderStyle: "solid", backgroundColor: "white" }, onClick: () => this.onDisconnect() }, r0("PENDING_MODAL.DISCONNECT")))), Kf(Bp, { version: n0 })));
  }
  get el() {
    return qf(this);
  }
};
ug.style = `.flexContainer {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: row;
}

.flexItem {
    flex: 1;
    justify-content: center;
    align-items: center;
}

.flexItem11 {
    flex: 11;
    justify-content: center;
    align-items: center;
}

.flexItem1 {
    flex: 1;
    justify-content: center;
    align-items: center;
}

.tab {
    padding: 8px;
    cursor: pointer;
    background-color: #F2F4F6;
    font-size: 12px;
    text-align: center;
    color: #24292E;
}

.tabcontainer {
    padding: 4px;
    background-color: #F2F4F6;
    border-radius: 8px;
    margin-bottom: 30px;
    margin-top: 30px;
}

.tabactive {
    background-color: white;
    -webkit-transition: background-color 300ms linear;
    -ms-transition: background-color 300ms linear;
    transition: background-color 300ms linear;
    border-radius: 8px;
}

.item {
    font-size: 12px;
    margin-bottom: 16px;
    border-radius: 8px;
    padding: 10px;
    border: 2px #F2F4F6 solid;
    color: #24292E;
}

.extensionLabel {
    font-style: normal;
    font-weight: bold;
    font-size: 14px;
    text-align: cetner;
    color: #24272A;
}

.notice {
    font-size: 12px;
    margin-left: 10px;
    margin-right: 10px;
    color: grey;
}

.button {
    margin-top: 41.5px;
    margin-bottom: 20px;
    width: 100%;
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    padding: 12px 20px;
    background: #037DD6;
    border-radius: 32px;
    color: white;
    border: 0;
    font-size: 14px;
    cursor: pointer;
}

.backdrop {
    visibility: visible;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    z-index: 99998;
    background: rgba(0, 0, 0, 0.87);
    opacity: 0.3;
}

.modal {
    visibility: visible;
    position: fixed;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 99999;
    background: white;
    padding: 20px;
    border-radius: 8px;
    top: 50%;
    max-width: 100%;
    width: 460px;
    min-width: 300px;
    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;
    -webkit-font-smoothing: antialiased;
}

.closeButton {
    color: #BBC0C5;
    cursor: pointer;
}

.logoContainer {
    margin-left: 24px;
    margin-right: 24px;
    margin-top: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.connectMobileText {
    font-size: 14px;
    color: black;
    margin-top: 28px;
    margin-bottom: 28px;
    line-height: 2;
}

.blue {
    color: #037DD6;
    font-weight: 700;
}

.installExtensionText {
    margin-left: 10px;
}

.center {
    display: flex;
    justify-content: center;
    align-items: center;
}

.right {
    display: flex;
    align-items: center;
    justify-content: right;
}

#sdk-mm-qrcode {
    svg {
        width: 50%;
    }
}`;
const hg = () => Kf("svg", { width: "21", height: "15", viewBox: "0 0 21 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, Kf("path", { d: "M14.1364 14.9851C13.5909 14.9851 13.2273 14.5851 13.2273 13.9851C13.2273 13.3851 13.5909 12.9851 14.1364 12.9851C16.6818 12.9851 18.6818 10.7851 18.6818 7.98508C18.6818 5.18508 16.6818 2.98508 14.1364 2.98508C11.5909 2.98508 9.59091 5.18508 9.59091 7.98508C9.59091 8.58508 9.22727 8.98508 8.68182 8.98508C8.13636 8.98508 7.77273 8.58508 7.77273 7.98508C7.77273 4.08508 10.5909 0.985077 14.1364 0.985077C17.6818 0.985077 20.5 4.08508 20.5 7.98508C20.5 11.8851 17.6818 14.9851 14.1364 14.9851ZM6.68182 14.7851C3.22727 14.7851 0.5 11.6851 0.5 7.98508C0.5 4.28508 3.22727 1.18508 6.68182 1.18508C7.22727 1.18508 7.59091 1.58508 7.59091 2.18508C7.59091 2.78508 7.22727 3.18508 6.68182 3.18508C4.22727 3.18508 2.31818 5.38508 2.31818 7.98508C2.31818 10.5851 4.22727 12.7851 6.68182 12.7851C9.13636 12.7851 11.0455 10.6851 11.0455 7.98508C11.0455 7.38508 11.4091 6.98508 11.9545 6.98508C12.5 6.98508 12.8636 7.38508 12.8636 7.98508C12.7727 11.6851 10.0455 14.7851 6.68182 14.7851Z", fill: "white" })), fg = () => Kf("svg", { width: "400", height: "300", viewBox: "0 0 400 300", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, Kf("rect", { width: "400", height: "300", fill: "white" }), Kf("path", { d: "M300.116 242.46L250.485 227.681L213.057 250.055L186.944 250.045L149.493 227.681L99.8843 242.46L84.7939 191.518L99.8843 134.979L84.7939 87.1777L99.8843 27.9336L177.402 74.2466H222.598L300.116 27.9336L315.206 87.1777L300.116 134.979L315.206 191.518L300.116 242.46Z", fill: "#FF5C16" }), Kf("path", { d: "M99.8955 27.9336L177.414 74.2792L174.331 106.085L99.8955 27.9336Z", fill: "#FF5C16" }), Kf("path", { d: "M149.505 191.539L183.612 217.521L149.505 227.681V191.539Z", fill: "#FF5C16" }), Kf("path", { d: "M180.886 148.585L174.33 106.107L132.369 134.991L132.348 134.98V135.001L132.477 164.732L149.493 148.585H149.504H180.886Z", fill: "#FF5C16" }), Kf("path", { d: "M300.116 27.9336L222.598 74.2792L225.67 106.085L300.116 27.9336Z", fill: "#FF5C16" }), Kf("path", { d: "M250.508 191.539L216.4 217.521L250.508 227.681V191.539Z", fill: "#FF5C16" }), Kf("path", { d: "M267.652 135.001H267.663H267.652V134.98L267.641 134.991L225.68 106.107L219.125 148.585H250.507L267.533 164.732L267.652 135.001Z", fill: "#FF5C16" }), Kf("path", { d: "M149.493 227.681L99.8843 242.46L84.7939 191.54H149.493V227.681Z", fill: "#E34807" }), Kf("path", { d: "M180.875 148.574L190.351 209.98L177.219 175.838L132.456 164.732L149.483 148.574H180.864H180.875Z", fill: "#E34807" }), Kf("path", { d: "M250.507 227.681L300.116 242.46L315.206 191.54H250.507V227.681Z", fill: "#E34807" }), Kf("path", { d: "M219.126 148.574L209.649 209.98L222.782 175.838L267.545 164.732L250.507 148.574H219.126Z", fill: "#E34807" }), Kf("path", { d: "M84.7939 191.517L99.8843 134.979H132.337L132.456 164.721L177.219 175.826L190.351 209.969L183.601 217.488L149.493 191.506H84.7939V191.517Z", fill: "#FF8D5D" }), Kf("path", { d: "M315.206 191.517L300.116 134.979H267.664L267.545 164.721L222.782 175.826L209.649 209.969L216.4 217.488L250.507 191.506H315.206V191.517Z", fill: "#FF8D5D" }), Kf("path", { d: "M222.598 74.2466H200H177.402L174.33 106.053L190.351 209.936H209.649L225.681 106.053L222.598 74.2466Z", fill: "#FF8D5D" }), Kf("path", { d: "M99.8843 27.9336L84.7939 87.1777L99.8843 134.979H132.337L174.319 106.085L99.8843 27.9336Z", fill: "#661800" }), Kf("path", { d: "M171.496 160.906H156.795L148.79 168.752L177.229 175.804L171.496 160.896V160.906Z", fill: "#661800" }), Kf("path", { d: "M300.116 27.9336L315.206 87.1777L300.116 134.979H267.663L225.681 106.085L300.116 27.9336Z", fill: "#661800" }), Kf("path", { d: "M228.525 160.906H243.248L251.253 168.763L222.781 175.826L228.525 160.896V160.906Z", fill: "#661800" }), Kf("path", { d: "M213.046 229.789L216.399 217.51L209.649 209.991H190.34L183.59 217.51L186.943 229.789", fill: "#661800" }), Kf("path", { d: "M213.047 229.789V250.066H186.944V229.789H213.047Z", fill: "#C0C4CD" }), Kf("path", { d: "M149.504 227.66L186.965 250.056V229.779L183.611 217.5L149.504 227.66Z", fill: "#E7EBF6" }), Kf("path", { d: "M250.506 227.66L213.045 250.056V229.779L216.398 217.5L250.506 227.66Z", fill: "#E7EBF6" })), pg = class {
  constructor(t0) {
    uf(this, t0), this.close = Wf(this, "close", 7), this.connectWithExtension = Wf(this, "connectWithExtension", 7), this.link = void 0, this.sdkVersion = void 0, this.preferDesktop = void 0, this.tab = 1, this.isDefaultTab = !0, this.translationsLoaded = !1, this.i18nInstance = new cg(), this.setTab(this.preferDesktop ? 1 : 2);
  }
  async connectedCallback() {
    await this.i18nInstance.init({ fallbackLng: "en" }), this.translationsLoaded = !0;
  }
  onClose(t0 = !1) {
    this.close.emit({ shouldTerminate: t0 });
  }
  connectWithExtensionHandler() {
    this.connectWithExtension.emit();
  }
  setTab(t0) {
    this.tab = t0, this.isDefaultTab = !1;
  }
  disconnectedCallback() {
    this.onClose();
  }
  updatePreferDesktop(t0) {
    t0 ? this.setTab(1) : this.setTab(2);
  }
  render() {
    if (!this.translationsLoaded)
      return null;
    const t0 = (i0) => this.i18nInstance.t(i0), e0 = this.sdkVersion, n0 = this.isDefaultTab ? this.preferDesktop ? 1 : 2 : this.tab, r0 = sg(this.link, "svg", { ecc: "medium", scale: 2 });
    return Kf(Tp, { className: "select-modal" }, Kf("div", { class: "backdrop", onClick: () => this.onClose(!0) }), Kf("div", { class: "modal" }, Kf("div", { class: "closeButtonContainer" }, Kf("div", { class: "right" }, Kf("span", { class: "closeButton", onClick: () => this.onClose(!0) }, Kf(Kp, null)))), Kf("div", { class: "logoContainer" }, Kf(jp, null)), Kf("div", null, Kf("div", { class: "tabcontainer" }, Kf("div", { class: "flexContainer" }, Kf("div", { onClick: () => this.setTab(1), class: "tab flexItem " + (n0 === 1 ? "tabactive" : "") }, t0("DESKTOP")), Kf("div", { onClick: () => this.setTab(2), class: "tab flexItem " + (n0 === 2 ? "tabactive" : "") }, t0("MOBILE")))), Kf("div", { style: { display: n0 === 1 ? "none" : "block" } }, Kf("div", { class: "flexContainer" }, Kf("div", { class: "flexItem", style: { textAlign: "center", marginTop: "4" } }, Kf("div", { class: "center", id: "sdk-mm-qrcode", innerHTML: r0 }), Kf("div", { class: "connectMobileText" }, t0("SCAN_TO_CONNECT"), Kf("br", null), Kf("span", { class: "blue" }, Kf("b", null, t0("META_MASK_MOBILE_APP"))))))), Kf("div", { style: { display: n0 === 2 ? "none" : "block" } }, Kf("div", { style: { display: "flex", justifyContent: "center", height: "300", marginTop: "-20" } }, Kf(fg, null)), Kf("div", { class: "extensionLabel" }, t0("SELECT_MODAL.CRYPTO_TAKE_CONTROL_TEXT")), Kf("button", { class: "button", onClick: () => this.connectWithExtensionHandler() }, Kf(hg, null), Kf("span", { class: "installExtensionText" }, t0("CONNECT_WITH_EXTENSION"))))), Kf(Bp, { version: e0 })));
  }
  get el() {
    return qf(this);
  }
  static get watchers() {
    return { preferDesktop: ["updatePreferDesktop"] };
  }
};
pg.style = `.flexContainer {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: row;
}

.flexItem {
    flex: 1;
    justify-content: center;
    align-items: center;
}

.flexItem11 {
    flex: 11;
    justify-content: center;
    align-items: center;
}

.flexItem1 {
    flex: 1;
    justify-content: center;
    align-items: center;
}

.tab {
    padding: 8px;
    cursor: pointer;
    background-color: #F2F4F6;
    font-size: 12px;
    text-align: center;
    color: #24292E;
}

.tabcontainer {
    padding: 4px;
    background-color: #F2F4F6;
    border-radius: 8px;
    margin-bottom: 30px;
    margin-top: 30px;
}

.tabactive {
    background-color: white;
    -webkit-transition: background-color 300ms linear;
    -ms-transition: background-color 300ms linear;
    transition: background-color 300ms linear;
    border-radius: 8px;
}

.item {
    font-size: 12px;
    margin-bottom: 16px;
    border-radius: 8px;
    padding: 10px;
    border: 2px #F2F4F6 solid;
    color: #24292E;
}

.extensionLabel {
    font-style: normal;
    font-weight: bold;
    font-size: 14px;
    text-align: cetner;
    color: #24272A;
}

.notice {
    font-size: 12px;
    margin-left: 10px;
    margin-right: 10px;
    color: grey;
}

.button {
    margin-top: 41.5px;
    margin-bottom: 20px;
    width: 100%;
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    padding: 12px 20px;
    background: #037DD6;
    border-radius: 32px;
    color: white;
    border: 0;
    font-size: 14px;
    cursor: pointer;
}

.backdrop {
    visibility: visible;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    z-index: 99998;
    background: rgba(0, 0, 0, 0.87);
    opacity: 0.3;
}

.modal {
    visibility: visible;
    position: fixed;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 99999;
    background: white;
    padding: 20px;
    border-radius: 8px;
    top: 50%;
    max-width: 100%;
    width: 460px;
    min-width: 300px;
    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;
    -webkit-font-smoothing: antialiased;
}

.closeButton {
    color: #BBC0C5;
    cursor: pointer;
}

.logoContainer {
    margin-left: 24px;
    margin-right: 24px;
    margin-top: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.connectMobileText {
    font-size: 14px;
    color: black;
    margin-top: 28px;
    margin-bottom: 28px;
    line-height: 2;
}

.blue {
    color: #037DD6;
    font-weight: 700;
}

.installExtensionText {
    margin-left: 10px;
}

.center {
    display: flex;
    justify-content: center;
    align-items: center;
}

.right {
    display: flex;
    align-items: center;
    justify-content: right;
}

#sdk-mm-qrcode {
    svg {
        width: 50%;
    }
}`;
var gg = Object.freeze({ __proto__: null, mm_install_modal: dg, mm_pending_modal: ug, mm_select_modal: pg }), buffer = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i)
  lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(t0) {
  var e0 = t0.length;
  if (e0 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n0 = t0.indexOf("=");
  n0 === -1 && (n0 = e0);
  var r0 = n0 === e0 ? 0 : 4 - n0 % 4;
  return [n0, r0];
}
function byteLength(t0) {
  var e0 = getLens(t0), n0 = e0[0], r0 = e0[1];
  return (n0 + r0) * 3 / 4 - r0;
}
function _byteLength(t0, e0, n0) {
  return (e0 + n0) * 3 / 4 - n0;
}
function toByteArray(t0) {
  var e0, n0 = getLens(t0), r0 = n0[0], i0 = n0[1], o0 = new Arr(_byteLength(t0, r0, i0)), s0 = 0, a0 = i0 > 0 ? r0 - 4 : r0, c0;
  for (c0 = 0; c0 < a0; c0 += 4)
    e0 = revLookup[t0.charCodeAt(c0)] << 18 | revLookup[t0.charCodeAt(c0 + 1)] << 12 | revLookup[t0.charCodeAt(c0 + 2)] << 6 | revLookup[t0.charCodeAt(c0 + 3)], o0[s0++] = e0 >> 16 & 255, o0[s0++] = e0 >> 8 & 255, o0[s0++] = e0 & 255;
  return i0 === 2 && (e0 = revLookup[t0.charCodeAt(c0)] << 2 | revLookup[t0.charCodeAt(c0 + 1)] >> 4, o0[s0++] = e0 & 255), i0 === 1 && (e0 = revLookup[t0.charCodeAt(c0)] << 10 | revLookup[t0.charCodeAt(c0 + 1)] << 4 | revLookup[t0.charCodeAt(c0 + 2)] >> 2, o0[s0++] = e0 >> 8 & 255, o0[s0++] = e0 & 255), o0;
}
function tripletToBase64(t0) {
  return lookup[t0 >> 18 & 63] + lookup[t0 >> 12 & 63] + lookup[t0 >> 6 & 63] + lookup[t0 & 63];
}
function encodeChunk(t0, e0, n0) {
  for (var r0, i0 = [], o0 = e0; o0 < n0; o0 += 3)
    r0 = (t0[o0] << 16 & 16711680) + (t0[o0 + 1] << 8 & 65280) + (t0[o0 + 2] & 255), i0.push(tripletToBase64(r0));
  return i0.join("");
}
function fromByteArray(t0) {
  for (var e0, n0 = t0.length, r0 = n0 % 3, i0 = [], o0 = 16383, s0 = 0, a0 = n0 - r0; s0 < a0; s0 += o0)
    i0.push(encodeChunk(t0, s0, s0 + o0 > a0 ? a0 : s0 + o0));
  return r0 === 1 ? (e0 = t0[n0 - 1], i0.push(
    lookup[e0 >> 2] + lookup[e0 << 4 & 63] + "=="
  )) : r0 === 2 && (e0 = (t0[n0 - 2] << 8) + t0[n0 - 1], i0.push(
    lookup[e0 >> 10] + lookup[e0 >> 4 & 63] + lookup[e0 << 2 & 63] + "="
  )), i0.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(t0, e0, n0, r0, i0) {
  var o0, s0, a0 = i0 * 8 - r0 - 1, c0 = (1 << a0) - 1, l0 = c0 >> 1, u0 = -7, d0 = n0 ? i0 - 1 : 0, h0 = n0 ? -1 : 1, g0 = t0[e0 + d0];
  for (d0 += h0, o0 = g0 & (1 << -u0) - 1, g0 >>= -u0, u0 += a0; u0 > 0; o0 = o0 * 256 + t0[e0 + d0], d0 += h0, u0 -= 8)
    ;
  for (s0 = o0 & (1 << -u0) - 1, o0 >>= -u0, u0 += r0; u0 > 0; s0 = s0 * 256 + t0[e0 + d0], d0 += h0, u0 -= 8)
    ;
  if (o0 === 0)
    o0 = 1 - l0;
  else {
    if (o0 === c0)
      return s0 ? NaN : (g0 ? -1 : 1) * (1 / 0);
    s0 = s0 + Math.pow(2, r0), o0 = o0 - l0;
  }
  return (g0 ? -1 : 1) * s0 * Math.pow(2, o0 - r0);
};
ieee754.write = function(t0, e0, n0, r0, i0, o0) {
  var s0, a0, c0, l0 = o0 * 8 - i0 - 1, u0 = (1 << l0) - 1, d0 = u0 >> 1, h0 = i0 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, g0 = r0 ? 0 : o0 - 1, w0 = r0 ? 1 : -1, y0 = e0 < 0 || e0 === 0 && 1 / e0 < 0 ? 1 : 0;
  for (e0 = Math.abs(e0), isNaN(e0) || e0 === 1 / 0 ? (a0 = isNaN(e0) ? 1 : 0, s0 = u0) : (s0 = Math.floor(Math.log(e0) / Math.LN2), e0 * (c0 = Math.pow(2, -s0)) < 1 && (s0--, c0 *= 2), s0 + d0 >= 1 ? e0 += h0 / c0 : e0 += h0 * Math.pow(2, 1 - d0), e0 * c0 >= 2 && (s0++, c0 /= 2), s0 + d0 >= u0 ? (a0 = 0, s0 = u0) : s0 + d0 >= 1 ? (a0 = (e0 * c0 - 1) * Math.pow(2, i0), s0 = s0 + d0) : (a0 = e0 * Math.pow(2, d0 - 1) * Math.pow(2, i0), s0 = 0)); i0 >= 8; t0[n0 + g0] = a0 & 255, g0 += w0, a0 /= 256, i0 -= 8)
    ;
  for (s0 = s0 << i0 | a0, l0 += i0; l0 > 0; t0[n0 + g0] = s0 & 255, g0 += w0, s0 /= 256, l0 -= 8)
    ;
  t0[n0 + g0 - w0] |= y0 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t0) {
  const e0 = base64Js, n0 = ieee754, r0 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  t0.Buffer = a0, t0.SlowBuffer = O0, t0.INSPECT_MAX_BYTES = 50;
  const i0 = 2147483647;
  t0.kMaxLength = i0, a0.TYPED_ARRAY_SUPPORT = o0(), !a0.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function o0() {
    try {
      const j0 = new Uint8Array(1), N0 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(N0, Uint8Array.prototype), Object.setPrototypeOf(j0, N0), j0.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(a0.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (a0.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(a0.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (a0.isBuffer(this))
        return this.byteOffset;
    }
  });
  function s0(j0) {
    if (j0 > i0)
      throw new RangeError('The value "' + j0 + '" is invalid for option "size"');
    const N0 = new Uint8Array(j0);
    return Object.setPrototypeOf(N0, a0.prototype), N0;
  }
  function a0(j0, N0, R0) {
    if (typeof j0 == "number") {
      if (typeof N0 == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return d0(j0);
    }
    return c0(j0, N0, R0);
  }
  a0.poolSize = 8192;
  function c0(j0, N0, R0) {
    if (typeof j0 == "string")
      return h0(j0, N0);
    if (ArrayBuffer.isView(j0))
      return w0(j0);
    if (j0 == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof j0
      );
    if (Sg(j0, ArrayBuffer) || j0 && Sg(j0.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Sg(j0, SharedArrayBuffer) || j0 && Sg(j0.buffer, SharedArrayBuffer)))
      return y0(j0, N0, R0);
    if (typeof j0 == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Y0 = j0.valueOf && j0.valueOf();
    if (Y0 != null && Y0 !== j0)
      return a0.from(Y0, N0, R0);
    const Z0 = E0(j0);
    if (Z0)
      return Z0;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof j0[Symbol.toPrimitive] == "function")
      return a0.from(j0[Symbol.toPrimitive]("string"), N0, R0);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof j0
    );
  }
  a0.from = function(j0, N0, R0) {
    return c0(j0, N0, R0);
  }, Object.setPrototypeOf(a0.prototype, Uint8Array.prototype), Object.setPrototypeOf(a0, Uint8Array);
  function l0(j0) {
    if (typeof j0 != "number")
      throw new TypeError('"size" argument must be of type number');
    if (j0 < 0)
      throw new RangeError('The value "' + j0 + '" is invalid for option "size"');
  }
  function u0(j0, N0, R0) {
    return l0(j0), j0 <= 0 ? s0(j0) : N0 !== void 0 ? typeof R0 == "string" ? s0(j0).fill(N0, R0) : s0(j0).fill(N0) : s0(j0);
  }
  a0.alloc = function(j0, N0, R0) {
    return u0(j0, N0, R0);
  };
  function d0(j0) {
    return l0(j0), s0(j0 < 0 ? 0 : b0(j0) | 0);
  }
  a0.allocUnsafe = function(j0) {
    return d0(j0);
  }, a0.allocUnsafeSlow = function(j0) {
    return d0(j0);
  };
  function h0(j0, N0) {
    if ((typeof N0 != "string" || N0 === "") && (N0 = "utf8"), !a0.isEncoding(N0))
      throw new TypeError("Unknown encoding: " + N0);
    const R0 = S0(j0, N0) | 0;
    let Y0 = s0(R0);
    const Z0 = Y0.write(j0, N0);
    return Z0 !== R0 && (Y0 = Y0.slice(0, Z0)), Y0;
  }
  function g0(j0) {
    const N0 = j0.length < 0 ? 0 : b0(j0.length) | 0, R0 = s0(N0);
    for (let Y0 = 0; Y0 < N0; Y0 += 1)
      R0[Y0] = j0[Y0] & 255;
    return R0;
  }
  function w0(j0) {
    if (Sg(j0, Uint8Array)) {
      const N0 = new Uint8Array(j0);
      return y0(N0.buffer, N0.byteOffset, N0.byteLength);
    }
    return g0(j0);
  }
  function y0(j0, N0, R0) {
    if (N0 < 0 || j0.byteLength < N0)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (j0.byteLength < N0 + (R0 || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Y0;
    return N0 === void 0 && R0 === void 0 ? Y0 = new Uint8Array(j0) : R0 === void 0 ? Y0 = new Uint8Array(j0, N0) : Y0 = new Uint8Array(j0, N0, R0), Object.setPrototypeOf(Y0, a0.prototype), Y0;
  }
  function E0(j0) {
    if (a0.isBuffer(j0)) {
      const N0 = b0(j0.length) | 0, R0 = s0(N0);
      return R0.length === 0 || j0.copy(R0, 0, 0, N0), R0;
    }
    if (j0.length !== void 0)
      return typeof j0.length != "number" || Ng(j0.length) ? s0(0) : g0(j0);
    if (j0.type === "Buffer" && Array.isArray(j0.data))
      return g0(j0.data);
  }
  function b0(j0) {
    if (j0 >= i0)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i0.toString(16) + " bytes");
    return j0 | 0;
  }
  function O0(j0) {
    return +j0 != j0 && (j0 = 0), a0.alloc(+j0);
  }
  a0.isBuffer = function(N0) {
    return N0 != null && N0._isBuffer === !0 && N0 !== a0.prototype;
  }, a0.compare = function(N0, R0) {
    if (Sg(N0, Uint8Array) && (N0 = a0.from(N0, N0.offset, N0.byteLength)), Sg(R0, Uint8Array) && (R0 = a0.from(R0, R0.offset, R0.byteLength)), !a0.isBuffer(N0) || !a0.isBuffer(R0))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (N0 === R0)
      return 0;
    let Y0 = N0.length, Z0 = R0.length;
    for (let q0 = 0, mg = Math.min(Y0, Z0); q0 < mg; ++q0)
      if (N0[q0] !== R0[q0]) {
        Y0 = N0[q0], Z0 = R0[q0];
        break;
      }
    return Y0 < Z0 ? -1 : Z0 < Y0 ? 1 : 0;
  }, a0.isEncoding = function(N0) {
    switch (String(N0).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, a0.concat = function(N0, R0) {
    if (!Array.isArray(N0))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (N0.length === 0)
      return a0.alloc(0);
    let Y0;
    if (R0 === void 0)
      for (R0 = 0, Y0 = 0; Y0 < N0.length; ++Y0)
        R0 += N0[Y0].length;
    const Z0 = a0.allocUnsafe(R0);
    let q0 = 0;
    for (Y0 = 0; Y0 < N0.length; ++Y0) {
      let mg = N0[Y0];
      if (Sg(mg, Uint8Array))
        q0 + mg.length > Z0.length ? (a0.isBuffer(mg) || (mg = a0.from(mg)), mg.copy(Z0, q0)) : Uint8Array.prototype.set.call(
          Z0,
          mg,
          q0
        );
      else if (a0.isBuffer(mg))
        mg.copy(Z0, q0);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      q0 += mg.length;
    }
    return Z0;
  };
  function S0(j0, N0) {
    if (a0.isBuffer(j0))
      return j0.length;
    if (ArrayBuffer.isView(j0) || Sg(j0, ArrayBuffer))
      return j0.byteLength;
    if (typeof j0 != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof j0
      );
    const R0 = j0.length, Y0 = arguments.length > 2 && arguments[2] === !0;
    if (!Y0 && R0 === 0)
      return 0;
    let Z0 = !1;
    for (; ; )
      switch (N0) {
        case "ascii":
        case "latin1":
        case "binary":
          return R0;
        case "utf8":
        case "utf-8":
          return bg(j0).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return R0 * 2;
        case "hex":
          return R0 >>> 1;
        case "base64":
          return Ig(j0).length;
        default:
          if (Z0)
            return Y0 ? -1 : bg(j0).length;
          N0 = ("" + N0).toLowerCase(), Z0 = !0;
      }
  }
  a0.byteLength = S0;
  function k0(j0, N0, R0) {
    let Y0 = !1;
    if ((N0 === void 0 || N0 < 0) && (N0 = 0), N0 > this.length || ((R0 === void 0 || R0 > this.length) && (R0 = this.length), R0 <= 0) || (R0 >>>= 0, N0 >>>= 0, R0 <= N0))
      return "";
    for (j0 || (j0 = "utf8"); ; )
      switch (j0) {
        case "hex":
          return $0(this, N0, R0);
        case "utf8":
        case "utf-8":
          return f0(this, N0, R0);
        case "ascii":
          return x0(this, N0, R0);
        case "latin1":
        case "binary":
          return _0(this, N0, R0);
        case "base64":
          return I0(this, N0, R0);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return C0(this, N0, R0);
        default:
          if (Y0)
            throw new TypeError("Unknown encoding: " + j0);
          j0 = (j0 + "").toLowerCase(), Y0 = !0;
      }
  }
  a0.prototype._isBuffer = !0;
  function D0(j0, N0, R0) {
    const Y0 = j0[N0];
    j0[N0] = j0[R0], j0[R0] = Y0;
  }
  a0.prototype.swap16 = function() {
    const N0 = this.length;
    if (N0 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let R0 = 0; R0 < N0; R0 += 2)
      D0(this, R0, R0 + 1);
    return this;
  }, a0.prototype.swap32 = function() {
    const N0 = this.length;
    if (N0 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let R0 = 0; R0 < N0; R0 += 4)
      D0(this, R0, R0 + 3), D0(this, R0 + 1, R0 + 2);
    return this;
  }, a0.prototype.swap64 = function() {
    const N0 = this.length;
    if (N0 % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let R0 = 0; R0 < N0; R0 += 8)
      D0(this, R0, R0 + 7), D0(this, R0 + 1, R0 + 6), D0(this, R0 + 2, R0 + 5), D0(this, R0 + 3, R0 + 4);
    return this;
  }, a0.prototype.toString = function() {
    const N0 = this.length;
    return N0 === 0 ? "" : arguments.length === 0 ? f0(this, 0, N0) : k0.apply(this, arguments);
  }, a0.prototype.toLocaleString = a0.prototype.toString, a0.prototype.equals = function(N0) {
    if (!a0.isBuffer(N0))
      throw new TypeError("Argument must be a Buffer");
    return this === N0 ? !0 : a0.compare(this, N0) === 0;
  }, a0.prototype.inspect = function() {
    let N0 = "";
    const R0 = t0.INSPECT_MAX_BYTES;
    return N0 = this.toString("hex", 0, R0).replace(/(.{2})/g, "$1 ").trim(), this.length > R0 && (N0 += " ... "), "<Buffer " + N0 + ">";
  }, r0 && (a0.prototype[r0] = a0.prototype.inspect), a0.prototype.compare = function(N0, R0, Y0, Z0, q0) {
    if (Sg(N0, Uint8Array) && (N0 = a0.from(N0, N0.offset, N0.byteLength)), !a0.isBuffer(N0))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof N0
      );
    if (R0 === void 0 && (R0 = 0), Y0 === void 0 && (Y0 = N0 ? N0.length : 0), Z0 === void 0 && (Z0 = 0), q0 === void 0 && (q0 = this.length), R0 < 0 || Y0 > N0.length || Z0 < 0 || q0 > this.length)
      throw new RangeError("out of range index");
    if (Z0 >= q0 && R0 >= Y0)
      return 0;
    if (Z0 >= q0)
      return -1;
    if (R0 >= Y0)
      return 1;
    if (R0 >>>= 0, Y0 >>>= 0, Z0 >>>= 0, q0 >>>= 0, this === N0)
      return 0;
    let mg = q0 - Z0, Lg = Y0 - R0;
    const Tg = Math.min(mg, Lg), Og = this.slice(Z0, q0), Pg = N0.slice(R0, Y0);
    for (let Cg = 0; Cg < Tg; ++Cg)
      if (Og[Cg] !== Pg[Cg]) {
        mg = Og[Cg], Lg = Pg[Cg];
        break;
      }
    return mg < Lg ? -1 : Lg < mg ? 1 : 0;
  };
  function z0(j0, N0, R0, Y0, Z0) {
    if (j0.length === 0)
      return -1;
    if (typeof R0 == "string" ? (Y0 = R0, R0 = 0) : R0 > 2147483647 ? R0 = 2147483647 : R0 < -2147483648 && (R0 = -2147483648), R0 = +R0, Ng(R0) && (R0 = Z0 ? 0 : j0.length - 1), R0 < 0 && (R0 = j0.length + R0), R0 >= j0.length) {
      if (Z0)
        return -1;
      R0 = j0.length - 1;
    } else if (R0 < 0)
      if (Z0)
        R0 = 0;
      else
        return -1;
    if (typeof N0 == "string" && (N0 = a0.from(N0, Y0)), a0.isBuffer(N0))
      return N0.length === 0 ? -1 : G0(j0, N0, R0, Y0, Z0);
    if (typeof N0 == "number")
      return N0 = N0 & 255, typeof Uint8Array.prototype.indexOf == "function" ? Z0 ? Uint8Array.prototype.indexOf.call(j0, N0, R0) : Uint8Array.prototype.lastIndexOf.call(j0, N0, R0) : G0(j0, [N0], R0, Y0, Z0);
    throw new TypeError("val must be string, number or Buffer");
  }
  function G0(j0, N0, R0, Y0, Z0) {
    let q0 = 1, mg = j0.length, Lg = N0.length;
    if (Y0 !== void 0 && (Y0 = String(Y0).toLowerCase(), Y0 === "ucs2" || Y0 === "ucs-2" || Y0 === "utf16le" || Y0 === "utf-16le")) {
      if (j0.length < 2 || N0.length < 2)
        return -1;
      q0 = 2, mg /= 2, Lg /= 2, R0 /= 2;
    }
    function Tg(Pg, Cg) {
      return q0 === 1 ? Pg[Cg] : Pg.readUInt16BE(Cg * q0);
    }
    let Og;
    if (Z0) {
      let Pg = -1;
      for (Og = R0; Og < mg; Og++)
        if (Tg(j0, Og) === Tg(N0, Pg === -1 ? 0 : Og - Pg)) {
          if (Pg === -1 && (Pg = Og), Og - Pg + 1 === Lg)
            return Pg * q0;
        } else
          Pg !== -1 && (Og -= Og - Pg), Pg = -1;
    } else
      for (R0 + Lg > mg && (R0 = mg - Lg), Og = R0; Og >= 0; Og--) {
        let Pg = !0;
        for (let Cg = 0; Cg < Lg; Cg++)
          if (Tg(j0, Og + Cg) !== Tg(N0, Cg)) {
            Pg = !1;
            break;
          }
        if (Pg)
          return Og;
      }
    return -1;
  }
  a0.prototype.includes = function(N0, R0, Y0) {
    return this.indexOf(N0, R0, Y0) !== -1;
  }, a0.prototype.indexOf = function(N0, R0, Y0) {
    return z0(this, N0, R0, Y0, !0);
  }, a0.prototype.lastIndexOf = function(N0, R0, Y0) {
    return z0(this, N0, R0, Y0, !1);
  };
  function K0(j0, N0, R0, Y0) {
    R0 = Number(R0) || 0;
    const Z0 = j0.length - R0;
    Y0 ? (Y0 = Number(Y0), Y0 > Z0 && (Y0 = Z0)) : Y0 = Z0;
    const q0 = N0.length;
    Y0 > q0 / 2 && (Y0 = q0 / 2);
    let mg;
    for (mg = 0; mg < Y0; ++mg) {
      const Lg = parseInt(N0.substr(mg * 2, 2), 16);
      if (Ng(Lg))
        return mg;
      j0[R0 + mg] = Lg;
    }
    return mg;
  }
  function U0(j0, N0, R0, Y0) {
    return Mg(bg(N0, j0.length - R0), j0, R0, Y0);
  }
  function F0(j0, N0, R0, Y0) {
    return Mg(vg(N0), j0, R0, Y0);
  }
  function H0(j0, N0, R0, Y0) {
    return Mg(Ig(N0), j0, R0, Y0);
  }
  function P0(j0, N0, R0, Y0) {
    return Mg(Ag(N0, j0.length - R0), j0, R0, Y0);
  }
  a0.prototype.write = function(N0, R0, Y0, Z0) {
    if (R0 === void 0)
      Z0 = "utf8", Y0 = this.length, R0 = 0;
    else if (Y0 === void 0 && typeof R0 == "string")
      Z0 = R0, Y0 = this.length, R0 = 0;
    else if (isFinite(R0))
      R0 = R0 >>> 0, isFinite(Y0) ? (Y0 = Y0 >>> 0, Z0 === void 0 && (Z0 = "utf8")) : (Z0 = Y0, Y0 = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const q0 = this.length - R0;
    if ((Y0 === void 0 || Y0 > q0) && (Y0 = q0), N0.length > 0 && (Y0 < 0 || R0 < 0) || R0 > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Z0 || (Z0 = "utf8");
    let mg = !1;
    for (; ; )
      switch (Z0) {
        case "hex":
          return K0(this, N0, R0, Y0);
        case "utf8":
        case "utf-8":
          return U0(this, N0, R0, Y0);
        case "ascii":
        case "latin1":
        case "binary":
          return F0(this, N0, R0, Y0);
        case "base64":
          return H0(this, N0, R0, Y0);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return P0(this, N0, R0, Y0);
        default:
          if (mg)
            throw new TypeError("Unknown encoding: " + Z0);
          Z0 = ("" + Z0).toLowerCase(), mg = !0;
      }
  }, a0.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function I0(j0, N0, R0) {
    return N0 === 0 && R0 === j0.length ? e0.fromByteArray(j0) : e0.fromByteArray(j0.slice(N0, R0));
  }
  function f0(j0, N0, R0) {
    R0 = Math.min(j0.length, R0);
    const Y0 = [];
    let Z0 = N0;
    for (; Z0 < R0; ) {
      const q0 = j0[Z0];
      let mg = null, Lg = q0 > 239 ? 4 : q0 > 223 ? 3 : q0 > 191 ? 2 : 1;
      if (Z0 + Lg <= R0) {
        let Tg, Og, Pg, Cg;
        switch (Lg) {
          case 1:
            q0 < 128 && (mg = q0);
            break;
          case 2:
            Tg = j0[Z0 + 1], (Tg & 192) === 128 && (Cg = (q0 & 31) << 6 | Tg & 63, Cg > 127 && (mg = Cg));
            break;
          case 3:
            Tg = j0[Z0 + 1], Og = j0[Z0 + 2], (Tg & 192) === 128 && (Og & 192) === 128 && (Cg = (q0 & 15) << 12 | (Tg & 63) << 6 | Og & 63, Cg > 2047 && (Cg < 55296 || Cg > 57343) && (mg = Cg));
            break;
          case 4:
            Tg = j0[Z0 + 1], Og = j0[Z0 + 2], Pg = j0[Z0 + 3], (Tg & 192) === 128 && (Og & 192) === 128 && (Pg & 192) === 128 && (Cg = (q0 & 15) << 18 | (Tg & 63) << 12 | (Og & 63) << 6 | Pg & 63, Cg > 65535 && Cg < 1114112 && (mg = Cg));
        }
      }
      mg === null ? (mg = 65533, Lg = 1) : mg > 65535 && (mg -= 65536, Y0.push(mg >>> 10 & 1023 | 55296), mg = 56320 | mg & 1023), Y0.push(mg), Z0 += Lg;
    }
    return A0(Y0);
  }
  const m0 = 4096;
  function A0(j0) {
    const N0 = j0.length;
    if (N0 <= m0)
      return String.fromCharCode.apply(String, j0);
    let R0 = "", Y0 = 0;
    for (; Y0 < N0; )
      R0 += String.fromCharCode.apply(
        String,
        j0.slice(Y0, Y0 += m0)
      );
    return R0;
  }
  function x0(j0, N0, R0) {
    let Y0 = "";
    R0 = Math.min(j0.length, R0);
    for (let Z0 = N0; Z0 < R0; ++Z0)
      Y0 += String.fromCharCode(j0[Z0] & 127);
    return Y0;
  }
  function _0(j0, N0, R0) {
    let Y0 = "";
    R0 = Math.min(j0.length, R0);
    for (let Z0 = N0; Z0 < R0; ++Z0)
      Y0 += String.fromCharCode(j0[Z0]);
    return Y0;
  }
  function $0(j0, N0, R0) {
    const Y0 = j0.length;
    (!N0 || N0 < 0) && (N0 = 0), (!R0 || R0 < 0 || R0 > Y0) && (R0 = Y0);
    let Z0 = "";
    for (let q0 = N0; q0 < R0; ++q0)
      Z0 += Rg[j0[q0]];
    return Z0;
  }
  function C0(j0, N0, R0) {
    const Y0 = j0.slice(N0, R0);
    let Z0 = "";
    for (let q0 = 0; q0 < Y0.length - 1; q0 += 2)
      Z0 += String.fromCharCode(Y0[q0] + Y0[q0 + 1] * 256);
    return Z0;
  }
  a0.prototype.slice = function(N0, R0) {
    const Y0 = this.length;
    N0 = ~~N0, R0 = R0 === void 0 ? Y0 : ~~R0, N0 < 0 ? (N0 += Y0, N0 < 0 && (N0 = 0)) : N0 > Y0 && (N0 = Y0), R0 < 0 ? (R0 += Y0, R0 < 0 && (R0 = 0)) : R0 > Y0 && (R0 = Y0), R0 < N0 && (R0 = N0);
    const Z0 = this.subarray(N0, R0);
    return Object.setPrototypeOf(Z0, a0.prototype), Z0;
  };
  function M0(j0, N0, R0) {
    if (j0 % 1 !== 0 || j0 < 0)
      throw new RangeError("offset is not uint");
    if (j0 + N0 > R0)
      throw new RangeError("Trying to access beyond buffer length");
  }
  a0.prototype.readUintLE = a0.prototype.readUIntLE = function(N0, R0, Y0) {
    N0 = N0 >>> 0, R0 = R0 >>> 0, Y0 || M0(N0, R0, this.length);
    let Z0 = this[N0], q0 = 1, mg = 0;
    for (; ++mg < R0 && (q0 *= 256); )
      Z0 += this[N0 + mg] * q0;
    return Z0;
  }, a0.prototype.readUintBE = a0.prototype.readUIntBE = function(N0, R0, Y0) {
    N0 = N0 >>> 0, R0 = R0 >>> 0, Y0 || M0(N0, R0, this.length);
    let Z0 = this[N0 + --R0], q0 = 1;
    for (; R0 > 0 && (q0 *= 256); )
      Z0 += this[N0 + --R0] * q0;
    return Z0;
  }, a0.prototype.readUint8 = a0.prototype.readUInt8 = function(N0, R0) {
    return N0 = N0 >>> 0, R0 || M0(N0, 1, this.length), this[N0];
  }, a0.prototype.readUint16LE = a0.prototype.readUInt16LE = function(N0, R0) {
    return N0 = N0 >>> 0, R0 || M0(N0, 2, this.length), this[N0] | this[N0 + 1] << 8;
  }, a0.prototype.readUint16BE = a0.prototype.readUInt16BE = function(N0, R0) {
    return N0 = N0 >>> 0, R0 || M0(N0, 2, this.length), this[N0] << 8 | this[N0 + 1];
  }, a0.prototype.readUint32LE = a0.prototype.readUInt32LE = function(N0, R0) {
    return N0 = N0 >>> 0, R0 || M0(N0, 4, this.length), (this[N0] | this[N0 + 1] << 8 | this[N0 + 2] << 16) + this[N0 + 3] * 16777216;
  }, a0.prototype.readUint32BE = a0.prototype.readUInt32BE = function(N0, R0) {
    return N0 = N0 >>> 0, R0 || M0(N0, 4, this.length), this[N0] * 16777216 + (this[N0 + 1] << 16 | this[N0 + 2] << 8 | this[N0 + 3]);
  }, a0.prototype.readBigUInt64LE = kg(function(N0) {
    N0 = N0 >>> 0, _g(N0, "offset");
    const R0 = this[N0], Y0 = this[N0 + 7];
    (R0 === void 0 || Y0 === void 0) && wg(N0, this.length - 8);
    const Z0 = R0 + this[++N0] * 2 ** 8 + this[++N0] * 2 ** 16 + this[++N0] * 2 ** 24, q0 = this[++N0] + this[++N0] * 2 ** 8 + this[++N0] * 2 ** 16 + Y0 * 2 ** 24;
    return BigInt(Z0) + (BigInt(q0) << BigInt(32));
  }), a0.prototype.readBigUInt64BE = kg(function(N0) {
    N0 = N0 >>> 0, _g(N0, "offset");
    const R0 = this[N0], Y0 = this[N0 + 7];
    (R0 === void 0 || Y0 === void 0) && wg(N0, this.length - 8);
    const Z0 = R0 * 2 ** 24 + this[++N0] * 2 ** 16 + this[++N0] * 2 ** 8 + this[++N0], q0 = this[++N0] * 2 ** 24 + this[++N0] * 2 ** 16 + this[++N0] * 2 ** 8 + Y0;
    return (BigInt(Z0) << BigInt(32)) + BigInt(q0);
  }), a0.prototype.readIntLE = function(N0, R0, Y0) {
    N0 = N0 >>> 0, R0 = R0 >>> 0, Y0 || M0(N0, R0, this.length);
    let Z0 = this[N0], q0 = 1, mg = 0;
    for (; ++mg < R0 && (q0 *= 256); )
      Z0 += this[N0 + mg] * q0;
    return q0 *= 128, Z0 >= q0 && (Z0 -= Math.pow(2, 8 * R0)), Z0;
  }, a0.prototype.readIntBE = function(N0, R0, Y0) {
    N0 = N0 >>> 0, R0 = R0 >>> 0, Y0 || M0(N0, R0, this.length);
    let Z0 = R0, q0 = 1, mg = this[N0 + --Z0];
    for (; Z0 > 0 && (q0 *= 256); )
      mg += this[N0 + --Z0] * q0;
    return q0 *= 128, mg >= q0 && (mg -= Math.pow(2, 8 * R0)), mg;
  }, a0.prototype.readInt8 = function(N0, R0) {
    return N0 = N0 >>> 0, R0 || M0(N0, 1, this.length), this[N0] & 128 ? (255 - this[N0] + 1) * -1 : this[N0];
  }, a0.prototype.readInt16LE = function(N0, R0) {
    N0 = N0 >>> 0, R0 || M0(N0, 2, this.length);
    const Y0 = this[N0] | this[N0 + 1] << 8;
    return Y0 & 32768 ? Y0 | 4294901760 : Y0;
  }, a0.prototype.readInt16BE = function(N0, R0) {
    N0 = N0 >>> 0, R0 || M0(N0, 2, this.length);
    const Y0 = this[N0 + 1] | this[N0] << 8;
    return Y0 & 32768 ? Y0 | 4294901760 : Y0;
  }, a0.prototype.readInt32LE = function(N0, R0) {
    return N0 = N0 >>> 0, R0 || M0(N0, 4, this.length), this[N0] | this[N0 + 1] << 8 | this[N0 + 2] << 16 | this[N0 + 3] << 24;
  }, a0.prototype.readInt32BE = function(N0, R0) {
    return N0 = N0 >>> 0, R0 || M0(N0, 4, this.length), this[N0] << 24 | this[N0 + 1] << 16 | this[N0 + 2] << 8 | this[N0 + 3];
  }, a0.prototype.readBigInt64LE = kg(function(N0) {
    N0 = N0 >>> 0, _g(N0, "offset");
    const R0 = this[N0], Y0 = this[N0 + 7];
    (R0 === void 0 || Y0 === void 0) && wg(N0, this.length - 8);
    const Z0 = this[N0 + 4] + this[N0 + 5] * 2 ** 8 + this[N0 + 6] * 2 ** 16 + (Y0 << 24);
    return (BigInt(Z0) << BigInt(32)) + BigInt(R0 + this[++N0] * 2 ** 8 + this[++N0] * 2 ** 16 + this[++N0] * 2 ** 24);
  }), a0.prototype.readBigInt64BE = kg(function(N0) {
    N0 = N0 >>> 0, _g(N0, "offset");
    const R0 = this[N0], Y0 = this[N0 + 7];
    (R0 === void 0 || Y0 === void 0) && wg(N0, this.length - 8);
    const Z0 = (R0 << 24) + // Overflow
    this[++N0] * 2 ** 16 + this[++N0] * 2 ** 8 + this[++N0];
    return (BigInt(Z0) << BigInt(32)) + BigInt(this[++N0] * 2 ** 24 + this[++N0] * 2 ** 16 + this[++N0] * 2 ** 8 + Y0);
  }), a0.prototype.readFloatLE = function(N0, R0) {
    return N0 = N0 >>> 0, R0 || M0(N0, 4, this.length), n0.read(this, N0, !0, 23, 4);
  }, a0.prototype.readFloatBE = function(N0, R0) {
    return N0 = N0 >>> 0, R0 || M0(N0, 4, this.length), n0.read(this, N0, !1, 23, 4);
  }, a0.prototype.readDoubleLE = function(N0, R0) {
    return N0 = N0 >>> 0, R0 || M0(N0, 8, this.length), n0.read(this, N0, !0, 52, 8);
  }, a0.prototype.readDoubleBE = function(N0, R0) {
    return N0 = N0 >>> 0, R0 || M0(N0, 8, this.length), n0.read(this, N0, !1, 52, 8);
  };
  function p0(j0, N0, R0, Y0, Z0, q0) {
    if (!a0.isBuffer(j0))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (N0 > Z0 || N0 < q0)
      throw new RangeError('"value" argument is out of bounds');
    if (R0 + Y0 > j0.length)
      throw new RangeError("Index out of range");
  }
  a0.prototype.writeUintLE = a0.prototype.writeUIntLE = function(N0, R0, Y0, Z0) {
    if (N0 = +N0, R0 = R0 >>> 0, Y0 = Y0 >>> 0, !Z0) {
      const Lg = Math.pow(2, 8 * Y0) - 1;
      p0(this, N0, R0, Y0, Lg, 0);
    }
    let q0 = 1, mg = 0;
    for (this[R0] = N0 & 255; ++mg < Y0 && (q0 *= 256); )
      this[R0 + mg] = N0 / q0 & 255;
    return R0 + Y0;
  }, a0.prototype.writeUintBE = a0.prototype.writeUIntBE = function(N0, R0, Y0, Z0) {
    if (N0 = +N0, R0 = R0 >>> 0, Y0 = Y0 >>> 0, !Z0) {
      const Lg = Math.pow(2, 8 * Y0) - 1;
      p0(this, N0, R0, Y0, Lg, 0);
    }
    let q0 = Y0 - 1, mg = 1;
    for (this[R0 + q0] = N0 & 255; --q0 >= 0 && (mg *= 256); )
      this[R0 + q0] = N0 / mg & 255;
    return R0 + Y0;
  }, a0.prototype.writeUint8 = a0.prototype.writeUInt8 = function(N0, R0, Y0) {
    return N0 = +N0, R0 = R0 >>> 0, Y0 || p0(this, N0, R0, 1, 255, 0), this[R0] = N0 & 255, R0 + 1;
  }, a0.prototype.writeUint16LE = a0.prototype.writeUInt16LE = function(N0, R0, Y0) {
    return N0 = +N0, R0 = R0 >>> 0, Y0 || p0(this, N0, R0, 2, 65535, 0), this[R0] = N0 & 255, this[R0 + 1] = N0 >>> 8, R0 + 2;
  }, a0.prototype.writeUint16BE = a0.prototype.writeUInt16BE = function(N0, R0, Y0) {
    return N0 = +N0, R0 = R0 >>> 0, Y0 || p0(this, N0, R0, 2, 65535, 0), this[R0] = N0 >>> 8, this[R0 + 1] = N0 & 255, R0 + 2;
  }, a0.prototype.writeUint32LE = a0.prototype.writeUInt32LE = function(N0, R0, Y0) {
    return N0 = +N0, R0 = R0 >>> 0, Y0 || p0(this, N0, R0, 4, 4294967295, 0), this[R0 + 3] = N0 >>> 24, this[R0 + 2] = N0 >>> 16, this[R0 + 1] = N0 >>> 8, this[R0] = N0 & 255, R0 + 4;
  }, a0.prototype.writeUint32BE = a0.prototype.writeUInt32BE = function(N0, R0, Y0) {
    return N0 = +N0, R0 = R0 >>> 0, Y0 || p0(this, N0, R0, 4, 4294967295, 0), this[R0] = N0 >>> 24, this[R0 + 1] = N0 >>> 16, this[R0 + 2] = N0 >>> 8, this[R0 + 3] = N0 & 255, R0 + 4;
  };
  function v0(j0, N0, R0, Y0, Z0) {
    yg(N0, Y0, Z0, j0, R0, 7);
    let q0 = Number(N0 & BigInt(4294967295));
    j0[R0++] = q0, q0 = q0 >> 8, j0[R0++] = q0, q0 = q0 >> 8, j0[R0++] = q0, q0 = q0 >> 8, j0[R0++] = q0;
    let mg = Number(N0 >> BigInt(32) & BigInt(4294967295));
    return j0[R0++] = mg, mg = mg >> 8, j0[R0++] = mg, mg = mg >> 8, j0[R0++] = mg, mg = mg >> 8, j0[R0++] = mg, R0;
  }
  function T0(j0, N0, R0, Y0, Z0) {
    yg(N0, Y0, Z0, j0, R0, 7);
    let q0 = Number(N0 & BigInt(4294967295));
    j0[R0 + 7] = q0, q0 = q0 >> 8, j0[R0 + 6] = q0, q0 = q0 >> 8, j0[R0 + 5] = q0, q0 = q0 >> 8, j0[R0 + 4] = q0;
    let mg = Number(N0 >> BigInt(32) & BigInt(4294967295));
    return j0[R0 + 3] = mg, mg = mg >> 8, j0[R0 + 2] = mg, mg = mg >> 8, j0[R0 + 1] = mg, mg = mg >> 8, j0[R0] = mg, R0 + 8;
  }
  a0.prototype.writeBigUInt64LE = kg(function(N0, R0 = 0) {
    return v0(this, N0, R0, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a0.prototype.writeBigUInt64BE = kg(function(N0, R0 = 0) {
    return T0(this, N0, R0, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a0.prototype.writeIntLE = function(N0, R0, Y0, Z0) {
    if (N0 = +N0, R0 = R0 >>> 0, !Z0) {
      const Tg = Math.pow(2, 8 * Y0 - 1);
      p0(this, N0, R0, Y0, Tg - 1, -Tg);
    }
    let q0 = 0, mg = 1, Lg = 0;
    for (this[R0] = N0 & 255; ++q0 < Y0 && (mg *= 256); )
      N0 < 0 && Lg === 0 && this[R0 + q0 - 1] !== 0 && (Lg = 1), this[R0 + q0] = (N0 / mg >> 0) - Lg & 255;
    return R0 + Y0;
  }, a0.prototype.writeIntBE = function(N0, R0, Y0, Z0) {
    if (N0 = +N0, R0 = R0 >>> 0, !Z0) {
      const Tg = Math.pow(2, 8 * Y0 - 1);
      p0(this, N0, R0, Y0, Tg - 1, -Tg);
    }
    let q0 = Y0 - 1, mg = 1, Lg = 0;
    for (this[R0 + q0] = N0 & 255; --q0 >= 0 && (mg *= 256); )
      N0 < 0 && Lg === 0 && this[R0 + q0 + 1] !== 0 && (Lg = 1), this[R0 + q0] = (N0 / mg >> 0) - Lg & 255;
    return R0 + Y0;
  }, a0.prototype.writeInt8 = function(N0, R0, Y0) {
    return N0 = +N0, R0 = R0 >>> 0, Y0 || p0(this, N0, R0, 1, 127, -128), N0 < 0 && (N0 = 255 + N0 + 1), this[R0] = N0 & 255, R0 + 1;
  }, a0.prototype.writeInt16LE = function(N0, R0, Y0) {
    return N0 = +N0, R0 = R0 >>> 0, Y0 || p0(this, N0, R0, 2, 32767, -32768), this[R0] = N0 & 255, this[R0 + 1] = N0 >>> 8, R0 + 2;
  }, a0.prototype.writeInt16BE = function(N0, R0, Y0) {
    return N0 = +N0, R0 = R0 >>> 0, Y0 || p0(this, N0, R0, 2, 32767, -32768), this[R0] = N0 >>> 8, this[R0 + 1] = N0 & 255, R0 + 2;
  }, a0.prototype.writeInt32LE = function(N0, R0, Y0) {
    return N0 = +N0, R0 = R0 >>> 0, Y0 || p0(this, N0, R0, 4, 2147483647, -2147483648), this[R0] = N0 & 255, this[R0 + 1] = N0 >>> 8, this[R0 + 2] = N0 >>> 16, this[R0 + 3] = N0 >>> 24, R0 + 4;
  }, a0.prototype.writeInt32BE = function(N0, R0, Y0) {
    return N0 = +N0, R0 = R0 >>> 0, Y0 || p0(this, N0, R0, 4, 2147483647, -2147483648), N0 < 0 && (N0 = 4294967295 + N0 + 1), this[R0] = N0 >>> 24, this[R0 + 1] = N0 >>> 16, this[R0 + 2] = N0 >>> 8, this[R0 + 3] = N0 & 255, R0 + 4;
  }, a0.prototype.writeBigInt64LE = kg(function(N0, R0 = 0) {
    return v0(this, N0, R0, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), a0.prototype.writeBigInt64BE = kg(function(N0, R0 = 0) {
    return T0(this, N0, R0, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function L0(j0, N0, R0, Y0, Z0, q0) {
    if (R0 + Y0 > j0.length)
      throw new RangeError("Index out of range");
    if (R0 < 0)
      throw new RangeError("Index out of range");
  }
  function B0(j0, N0, R0, Y0, Z0) {
    return N0 = +N0, R0 = R0 >>> 0, Z0 || L0(j0, N0, R0, 4), n0.write(j0, N0, R0, Y0, 23, 4), R0 + 4;
  }
  a0.prototype.writeFloatLE = function(N0, R0, Y0) {
    return B0(this, N0, R0, !0, Y0);
  }, a0.prototype.writeFloatBE = function(N0, R0, Y0) {
    return B0(this, N0, R0, !1, Y0);
  };
  function W0(j0, N0, R0, Y0, Z0) {
    return N0 = +N0, R0 = R0 >>> 0, Z0 || L0(j0, N0, R0, 8), n0.write(j0, N0, R0, Y0, 52, 8), R0 + 8;
  }
  a0.prototype.writeDoubleLE = function(N0, R0, Y0) {
    return W0(this, N0, R0, !0, Y0);
  }, a0.prototype.writeDoubleBE = function(N0, R0, Y0) {
    return W0(this, N0, R0, !1, Y0);
  }, a0.prototype.copy = function(N0, R0, Y0, Z0) {
    if (!a0.isBuffer(N0))
      throw new TypeError("argument should be a Buffer");
    if (Y0 || (Y0 = 0), !Z0 && Z0 !== 0 && (Z0 = this.length), R0 >= N0.length && (R0 = N0.length), R0 || (R0 = 0), Z0 > 0 && Z0 < Y0 && (Z0 = Y0), Z0 === Y0 || N0.length === 0 || this.length === 0)
      return 0;
    if (R0 < 0)
      throw new RangeError("targetStart out of bounds");
    if (Y0 < 0 || Y0 >= this.length)
      throw new RangeError("Index out of range");
    if (Z0 < 0)
      throw new RangeError("sourceEnd out of bounds");
    Z0 > this.length && (Z0 = this.length), N0.length - R0 < Z0 - Y0 && (Z0 = N0.length - R0 + Y0);
    const q0 = Z0 - Y0;
    return this === N0 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(R0, Y0, Z0) : Uint8Array.prototype.set.call(
      N0,
      this.subarray(Y0, Z0),
      R0
    ), q0;
  }, a0.prototype.fill = function(N0, R0, Y0, Z0) {
    if (typeof N0 == "string") {
      if (typeof R0 == "string" ? (Z0 = R0, R0 = 0, Y0 = this.length) : typeof Y0 == "string" && (Z0 = Y0, Y0 = this.length), Z0 !== void 0 && typeof Z0 != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Z0 == "string" && !a0.isEncoding(Z0))
        throw new TypeError("Unknown encoding: " + Z0);
      if (N0.length === 1) {
        const mg = N0.charCodeAt(0);
        (Z0 === "utf8" && mg < 128 || Z0 === "latin1") && (N0 = mg);
      }
    } else
      typeof N0 == "number" ? N0 = N0 & 255 : typeof N0 == "boolean" && (N0 = Number(N0));
    if (R0 < 0 || this.length < R0 || this.length < Y0)
      throw new RangeError("Out of range index");
    if (Y0 <= R0)
      return this;
    R0 = R0 >>> 0, Y0 = Y0 === void 0 ? this.length : Y0 >>> 0, N0 || (N0 = 0);
    let q0;
    if (typeof N0 == "number")
      for (q0 = R0; q0 < Y0; ++q0)
        this[q0] = N0;
    else {
      const mg = a0.isBuffer(N0) ? N0 : a0.from(N0, Z0), Lg = mg.length;
      if (Lg === 0)
        throw new TypeError('The value "' + N0 + '" is invalid for argument "value"');
      for (q0 = 0; q0 < Y0 - R0; ++q0)
        this[q0 + R0] = mg[q0 % Lg];
    }
    return this;
  };
  const V0 = {};
  function Q0(j0, N0, R0) {
    V0[j0] = class extends R0 {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: N0.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${j0}]`, this.stack, delete this.name;
      }
      get code() {
        return j0;
      }
      set code(Z0) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Z0,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${j0}]: ${this.message}`;
      }
    };
  }
  Q0(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(j0) {
      return j0 ? `${j0} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Q0(
    "ERR_INVALID_ARG_TYPE",
    function(j0, N0) {
      return `The "${j0}" argument must be of type number. Received type ${typeof N0}`;
    },
    TypeError
  ), Q0(
    "ERR_OUT_OF_RANGE",
    function(j0, N0, R0) {
      let Y0 = `The value of "${j0}" is out of range.`, Z0 = R0;
      return Number.isInteger(R0) && Math.abs(R0) > 2 ** 32 ? Z0 = X0(String(R0)) : typeof R0 == "bigint" && (Z0 = String(R0), (R0 > BigInt(2) ** BigInt(32) || R0 < -(BigInt(2) ** BigInt(32))) && (Z0 = X0(Z0)), Z0 += "n"), Y0 += ` It must be ${N0}. Received ${Z0}`, Y0;
    },
    RangeError
  );
  function X0(j0) {
    let N0 = "", R0 = j0.length;
    const Y0 = j0[0] === "-" ? 1 : 0;
    for (; R0 >= Y0 + 4; R0 -= 3)
      N0 = `_${j0.slice(R0 - 3, R0)}${N0}`;
    return `${j0.slice(0, R0)}${N0}`;
  }
  function J0(j0, N0, R0) {
    _g(N0, "offset"), (j0[N0] === void 0 || j0[N0 + R0] === void 0) && wg(N0, j0.length - (R0 + 1));
  }
  function yg(j0, N0, R0, Y0, Z0, q0) {
    if (j0 > R0 || j0 < N0) {
      const mg = typeof N0 == "bigint" ? "n" : "";
      let Lg;
      throw q0 > 3 ? N0 === 0 || N0 === BigInt(0) ? Lg = `>= 0${mg} and < 2${mg} ** ${(q0 + 1) * 8}${mg}` : Lg = `>= -(2${mg} ** ${(q0 + 1) * 8 - 1}${mg}) and < 2 ** ${(q0 + 1) * 8 - 1}${mg}` : Lg = `>= ${N0}${mg} and <= ${R0}${mg}`, new V0.ERR_OUT_OF_RANGE("value", Lg, j0);
    }
    J0(Y0, Z0, q0);
  }
  function _g(j0, N0) {
    if (typeof j0 != "number")
      throw new V0.ERR_INVALID_ARG_TYPE(N0, "number", j0);
  }
  function wg(j0, N0, R0) {
    throw Math.floor(j0) !== j0 ? (_g(j0, R0), new V0.ERR_OUT_OF_RANGE(R0 || "offset", "an integer", j0)) : N0 < 0 ? new V0.ERR_BUFFER_OUT_OF_BOUNDS() : new V0.ERR_OUT_OF_RANGE(
      R0 || "offset",
      `>= ${R0 ? 1 : 0} and <= ${N0}`,
      j0
    );
  }
  const $g = /[^+/0-9A-Za-z-_]/g;
  function Eg(j0) {
    if (j0 = j0.split("=")[0], j0 = j0.trim().replace($g, ""), j0.length < 2)
      return "";
    for (; j0.length % 4 !== 0; )
      j0 = j0 + "=";
    return j0;
  }
  function bg(j0, N0) {
    N0 = N0 || 1 / 0;
    let R0;
    const Y0 = j0.length;
    let Z0 = null;
    const q0 = [];
    for (let mg = 0; mg < Y0; ++mg) {
      if (R0 = j0.charCodeAt(mg), R0 > 55295 && R0 < 57344) {
        if (!Z0) {
          if (R0 > 56319) {
            (N0 -= 3) > -1 && q0.push(239, 191, 189);
            continue;
          } else if (mg + 1 === Y0) {
            (N0 -= 3) > -1 && q0.push(239, 191, 189);
            continue;
          }
          Z0 = R0;
          continue;
        }
        if (R0 < 56320) {
          (N0 -= 3) > -1 && q0.push(239, 191, 189), Z0 = R0;
          continue;
        }
        R0 = (Z0 - 55296 << 10 | R0 - 56320) + 65536;
      } else
        Z0 && (N0 -= 3) > -1 && q0.push(239, 191, 189);
      if (Z0 = null, R0 < 128) {
        if ((N0 -= 1) < 0)
          break;
        q0.push(R0);
      } else if (R0 < 2048) {
        if ((N0 -= 2) < 0)
          break;
        q0.push(
          R0 >> 6 | 192,
          R0 & 63 | 128
        );
      } else if (R0 < 65536) {
        if ((N0 -= 3) < 0)
          break;
        q0.push(
          R0 >> 12 | 224,
          R0 >> 6 & 63 | 128,
          R0 & 63 | 128
        );
      } else if (R0 < 1114112) {
        if ((N0 -= 4) < 0)
          break;
        q0.push(
          R0 >> 18 | 240,
          R0 >> 12 & 63 | 128,
          R0 >> 6 & 63 | 128,
          R0 & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return q0;
  }
  function vg(j0) {
    const N0 = [];
    for (let R0 = 0; R0 < j0.length; ++R0)
      N0.push(j0.charCodeAt(R0) & 255);
    return N0;
  }
  function Ag(j0, N0) {
    let R0, Y0, Z0;
    const q0 = [];
    for (let mg = 0; mg < j0.length && !((N0 -= 2) < 0); ++mg)
      R0 = j0.charCodeAt(mg), Y0 = R0 >> 8, Z0 = R0 % 256, q0.push(Z0), q0.push(Y0);
    return q0;
  }
  function Ig(j0) {
    return e0.toByteArray(Eg(j0));
  }
  function Mg(j0, N0, R0, Y0) {
    let Z0;
    for (Z0 = 0; Z0 < Y0 && !(Z0 + R0 >= N0.length || Z0 >= j0.length); ++Z0)
      N0[Z0 + R0] = j0[Z0];
    return Z0;
  }
  function Sg(j0, N0) {
    return j0 instanceof N0 || j0 != null && j0.constructor != null && j0.constructor.name != null && j0.constructor.name === N0.name;
  }
  function Ng(j0) {
    return j0 !== j0;
  }
  const Rg = function() {
    const j0 = "0123456789abcdef", N0 = new Array(256);
    for (let R0 = 0; R0 < 16; ++R0) {
      const Y0 = R0 * 16;
      for (let Z0 = 0; Z0 < 16; ++Z0)
        N0[Y0 + Z0] = j0[R0] + j0[Z0];
    }
    return N0;
  }();
  function kg(j0) {
    return typeof BigInt > "u" ? Dg : j0;
  }
  function Dg() {
    throw new Error("BigInt not supported");
  }
})(buffer);
const crypto$1 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function isBytes(t0) {
  return t0 instanceof Uint8Array || ArrayBuffer.isView(t0) && t0.constructor.name === "Uint8Array";
}
function anumber(t0) {
  if (!Number.isSafeInteger(t0) || t0 < 0)
    throw new Error("positive integer expected, got " + t0);
}
function abytes(t0, ...e0) {
  if (!isBytes(t0))
    throw new Error("Uint8Array expected");
  if (e0.length > 0 && !e0.includes(t0.length))
    throw new Error("Uint8Array expected of length " + e0 + ", got length=" + t0.length);
}
function ahash(t0) {
  if (typeof t0 != "function" || typeof t0.create != "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(t0.outputLen), anumber(t0.blockLen);
}
function aexists(t0, e0 = !0) {
  if (t0.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e0 && t0.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(t0, e0) {
  abytes(t0);
  const n0 = e0.outputLen;
  if (t0.length < n0)
    throw new Error("digestInto() expects output buffer of length at least " + n0);
}
function clean(...t0) {
  for (let e0 = 0; e0 < t0.length; e0++)
    t0[e0].fill(0);
}
function createView(t0) {
  return new DataView(t0.buffer, t0.byteOffset, t0.byteLength);
}
function rotr(t0, e0) {
  return t0 << 32 - e0 | t0 >>> e0;
}
const hasHexBuiltin = /* @__PURE__ */ (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function"
))(), hexes = /* @__PURE__ */ Array.from({ length: 256 }, (t0, e0) => e0.toString(16).padStart(2, "0"));
function bytesToHex(t0) {
  if (abytes(t0), hasHexBuiltin)
    return t0.toHex();
  let e0 = "";
  for (let n0 = 0; n0 < t0.length; n0++)
    e0 += hexes[t0[n0]];
  return e0;
}
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(t0) {
  if (t0 >= asciis._0 && t0 <= asciis._9)
    return t0 - asciis._0;
  if (t0 >= asciis.A && t0 <= asciis.F)
    return t0 - (asciis.A - 10);
  if (t0 >= asciis.a && t0 <= asciis.f)
    return t0 - (asciis.a - 10);
}
function hexToBytes(t0) {
  if (typeof t0 != "string")
    throw new Error("hex string expected, got " + typeof t0);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(t0);
  const e0 = t0.length, n0 = e0 / 2;
  if (e0 % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e0);
  const r0 = new Uint8Array(n0);
  for (let i0 = 0, o0 = 0; i0 < n0; i0++, o0 += 2) {
    const s0 = asciiToBase16(t0.charCodeAt(o0)), a0 = asciiToBase16(t0.charCodeAt(o0 + 1));
    if (s0 === void 0 || a0 === void 0) {
      const c0 = t0[o0] + t0[o0 + 1];
      throw new Error('hex string expected, got non-hex character "' + c0 + '" at index ' + o0);
    }
    r0[i0] = s0 * 16 + a0;
  }
  return r0;
}
function utf8ToBytes(t0) {
  if (typeof t0 != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t0));
}
function toBytes(t0) {
  return typeof t0 == "string" && (t0 = utf8ToBytes(t0)), abytes(t0), t0;
}
function concatBytes(...t0) {
  let e0 = 0;
  for (let r0 = 0; r0 < t0.length; r0++) {
    const i0 = t0[r0];
    abytes(i0), e0 += i0.length;
  }
  const n0 = new Uint8Array(e0);
  for (let r0 = 0, i0 = 0; r0 < t0.length; r0++) {
    const o0 = t0[r0];
    n0.set(o0, i0), i0 += o0.length;
  }
  return n0;
}
class Hash {
}
function createHasher(t0) {
  const e0 = (r0) => t0().update(toBytes(r0)).digest(), n0 = t0();
  return e0.outputLen = n0.outputLen, e0.blockLen = n0.blockLen, e0.create = () => t0(), e0;
}
function randomBytes(t0 = 32) {
  if (crypto$1 && typeof crypto$1.getRandomValues == "function")
    return crypto$1.getRandomValues(new Uint8Array(t0));
  if (crypto$1 && typeof crypto$1.randomBytes == "function")
    return Uint8Array.from(crypto$1.randomBytes(t0));
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64(t0, e0, n0, r0) {
  if (typeof t0.setBigUint64 == "function")
    return t0.setBigUint64(e0, n0, r0);
  const i0 = BigInt(32), o0 = BigInt(4294967295), s0 = Number(n0 >> i0 & o0), a0 = Number(n0 & o0), c0 = r0 ? 4 : 0, l0 = r0 ? 0 : 4;
  t0.setUint32(e0 + c0, s0, r0), t0.setUint32(e0 + l0, a0, r0);
}
function Chi(t0, e0, n0) {
  return t0 & e0 ^ ~t0 & n0;
}
function Maj(t0, e0, n0) {
  return t0 & e0 ^ t0 & n0 ^ e0 & n0;
}
class HashMD extends Hash {
  constructor(e0, n0, r0, i0) {
    super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = e0, this.outputLen = n0, this.padOffset = r0, this.isLE = i0, this.buffer = new Uint8Array(e0), this.view = createView(this.buffer);
  }
  update(e0) {
    aexists(this), e0 = toBytes(e0), abytes(e0);
    const { view: n0, buffer: r0, blockLen: i0 } = this, o0 = e0.length;
    for (let s0 = 0; s0 < o0; ) {
      const a0 = Math.min(i0 - this.pos, o0 - s0);
      if (a0 === i0) {
        const c0 = createView(e0);
        for (; i0 <= o0 - s0; s0 += i0)
          this.process(c0, s0);
        continue;
      }
      r0.set(e0.subarray(s0, s0 + a0), this.pos), this.pos += a0, s0 += a0, this.pos === i0 && (this.process(n0, 0), this.pos = 0);
    }
    return this.length += e0.length, this.roundClean(), this;
  }
  digestInto(e0) {
    aexists(this), aoutput(e0, this), this.finished = !0;
    const { buffer: n0, view: r0, blockLen: i0, isLE: o0 } = this;
    let { pos: s0 } = this;
    n0[s0++] = 128, clean(this.buffer.subarray(s0)), this.padOffset > i0 - s0 && (this.process(r0, 0), s0 = 0);
    for (let d0 = s0; d0 < i0; d0++)
      n0[d0] = 0;
    setBigUint64(r0, i0 - 8, BigInt(this.length * 8), o0), this.process(r0, 0);
    const a0 = createView(e0), c0 = this.outputLen;
    if (c0 % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l0 = c0 / 4, u0 = this.get();
    if (l0 > u0.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let d0 = 0; d0 < l0; d0++)
      a0.setUint32(4 * d0, u0[d0], o0);
  }
  digest() {
    const { buffer: e0, outputLen: n0 } = this;
    this.digestInto(e0);
    const r0 = e0.slice(0, n0);
    return this.destroy(), r0;
  }
  _cloneInto(e0) {
    e0 || (e0 = new this.constructor()), e0.set(...this.get());
    const { blockLen: n0, buffer: r0, length: i0, finished: o0, destroyed: s0, pos: a0 } = this;
    return e0.destroyed = s0, e0.finished = o0, e0.length = i0, e0.pos = a0, i0 % n0 && e0.buffer.set(r0), e0;
  }
  clone() {
    return this._cloneInto();
  }
}
const SHA256_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA512_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]), U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n = /* @__PURE__ */ BigInt(32);
function fromBig(t0, e0 = !1) {
  return e0 ? { h: Number(t0 & U32_MASK64), l: Number(t0 >> _32n & U32_MASK64) } : { h: Number(t0 >> _32n & U32_MASK64) | 0, l: Number(t0 & U32_MASK64) | 0 };
}
function split(t0, e0 = !1) {
  const n0 = t0.length;
  let r0 = new Uint32Array(n0), i0 = new Uint32Array(n0);
  for (let o0 = 0; o0 < n0; o0++) {
    const { h: s0, l: a0 } = fromBig(t0[o0], e0);
    [r0[o0], i0[o0]] = [s0, a0];
  }
  return [r0, i0];
}
const shrSH = (t0, e0, n0) => t0 >>> n0, shrSL = (t0, e0, n0) => t0 << 32 - n0 | e0 >>> n0, rotrSH = (t0, e0, n0) => t0 >>> n0 | e0 << 32 - n0, rotrSL = (t0, e0, n0) => t0 << 32 - n0 | e0 >>> n0, rotrBH = (t0, e0, n0) => t0 << 64 - n0 | e0 >>> n0 - 32, rotrBL = (t0, e0, n0) => t0 >>> n0 - 32 | e0 << 64 - n0;
function add(t0, e0, n0, r0) {
  const i0 = (e0 >>> 0) + (r0 >>> 0);
  return { h: t0 + n0 + (i0 / 2 ** 32 | 0) | 0, l: i0 | 0 };
}
const add3L = (t0, e0, n0) => (t0 >>> 0) + (e0 >>> 0) + (n0 >>> 0), add3H = (t0, e0, n0, r0) => e0 + n0 + r0 + (t0 / 2 ** 32 | 0) | 0, add4L = (t0, e0, n0, r0) => (t0 >>> 0) + (e0 >>> 0) + (n0 >>> 0) + (r0 >>> 0), add4H = (t0, e0, n0, r0, i0) => e0 + n0 + r0 + i0 + (t0 / 2 ** 32 | 0) | 0, add5L = (t0, e0, n0, r0, i0) => (t0 >>> 0) + (e0 >>> 0) + (n0 >>> 0) + (r0 >>> 0) + (i0 >>> 0), add5H = (t0, e0, n0, r0, i0, o0) => e0 + n0 + r0 + i0 + o0 + (t0 / 2 ** 32 | 0) | 0, SHA256_K = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends HashMD {
  constructor(e0 = 32) {
    super(64, e0, 8, !1), this.A = SHA256_IV[0] | 0, this.B = SHA256_IV[1] | 0, this.C = SHA256_IV[2] | 0, this.D = SHA256_IV[3] | 0, this.E = SHA256_IV[4] | 0, this.F = SHA256_IV[5] | 0, this.G = SHA256_IV[6] | 0, this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: e0, B: n0, C: r0, D: i0, E: o0, F: s0, G: a0, H: c0 } = this;
    return [e0, n0, r0, i0, o0, s0, a0, c0];
  }
  // prettier-ignore
  set(e0, n0, r0, i0, o0, s0, a0, c0) {
    this.A = e0 | 0, this.B = n0 | 0, this.C = r0 | 0, this.D = i0 | 0, this.E = o0 | 0, this.F = s0 | 0, this.G = a0 | 0, this.H = c0 | 0;
  }
  process(e0, n0) {
    for (let d0 = 0; d0 < 16; d0++, n0 += 4)
      SHA256_W[d0] = e0.getUint32(n0, !1);
    for (let d0 = 16; d0 < 64; d0++) {
      const h0 = SHA256_W[d0 - 15], g0 = SHA256_W[d0 - 2], w0 = rotr(h0, 7) ^ rotr(h0, 18) ^ h0 >>> 3, y0 = rotr(g0, 17) ^ rotr(g0, 19) ^ g0 >>> 10;
      SHA256_W[d0] = y0 + SHA256_W[d0 - 7] + w0 + SHA256_W[d0 - 16] | 0;
    }
    let { A: r0, B: i0, C: o0, D: s0, E: a0, F: c0, G: l0, H: u0 } = this;
    for (let d0 = 0; d0 < 64; d0++) {
      const h0 = rotr(a0, 6) ^ rotr(a0, 11) ^ rotr(a0, 25), g0 = u0 + h0 + Chi(a0, c0, l0) + SHA256_K[d0] + SHA256_W[d0] | 0, y0 = (rotr(r0, 2) ^ rotr(r0, 13) ^ rotr(r0, 22)) + Maj(r0, i0, o0) | 0;
      u0 = l0, l0 = c0, c0 = a0, a0 = s0 + g0 | 0, s0 = o0, o0 = i0, i0 = r0, r0 = g0 + y0 | 0;
    }
    r0 = r0 + this.A | 0, i0 = i0 + this.B | 0, o0 = o0 + this.C | 0, s0 = s0 + this.D | 0, a0 = a0 + this.E | 0, c0 = c0 + this.F | 0, l0 = l0 + this.G | 0, u0 = u0 + this.H | 0, this.set(r0, i0, o0, s0, a0, c0, l0, u0);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), clean(this.buffer);
  }
}
const K512 = /* @__PURE__ */ (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((t0) => BigInt(t0))))(), SHA512_Kh = /* @__PURE__ */ (() => K512[0])(), SHA512_Kl = /* @__PURE__ */ (() => K512[1])(), SHA512_W_H = /* @__PURE__ */ new Uint32Array(80), SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends HashMD {
  constructor(e0 = 64) {
    super(128, e0, 16, !1), this.Ah = SHA512_IV[0] | 0, this.Al = SHA512_IV[1] | 0, this.Bh = SHA512_IV[2] | 0, this.Bl = SHA512_IV[3] | 0, this.Ch = SHA512_IV[4] | 0, this.Cl = SHA512_IV[5] | 0, this.Dh = SHA512_IV[6] | 0, this.Dl = SHA512_IV[7] | 0, this.Eh = SHA512_IV[8] | 0, this.El = SHA512_IV[9] | 0, this.Fh = SHA512_IV[10] | 0, this.Fl = SHA512_IV[11] | 0, this.Gh = SHA512_IV[12] | 0, this.Gl = SHA512_IV[13] | 0, this.Hh = SHA512_IV[14] | 0, this.Hl = SHA512_IV[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah: e0, Al: n0, Bh: r0, Bl: i0, Ch: o0, Cl: s0, Dh: a0, Dl: c0, Eh: l0, El: u0, Fh: d0, Fl: h0, Gh: g0, Gl: w0, Hh: y0, Hl: E0 } = this;
    return [e0, n0, r0, i0, o0, s0, a0, c0, l0, u0, d0, h0, g0, w0, y0, E0];
  }
  // prettier-ignore
  set(e0, n0, r0, i0, o0, s0, a0, c0, l0, u0, d0, h0, g0, w0, y0, E0) {
    this.Ah = e0 | 0, this.Al = n0 | 0, this.Bh = r0 | 0, this.Bl = i0 | 0, this.Ch = o0 | 0, this.Cl = s0 | 0, this.Dh = a0 | 0, this.Dl = c0 | 0, this.Eh = l0 | 0, this.El = u0 | 0, this.Fh = d0 | 0, this.Fl = h0 | 0, this.Gh = g0 | 0, this.Gl = w0 | 0, this.Hh = y0 | 0, this.Hl = E0 | 0;
  }
  process(e0, n0) {
    for (let S0 = 0; S0 < 16; S0++, n0 += 4)
      SHA512_W_H[S0] = e0.getUint32(n0), SHA512_W_L[S0] = e0.getUint32(n0 += 4);
    for (let S0 = 16; S0 < 80; S0++) {
      const k0 = SHA512_W_H[S0 - 15] | 0, D0 = SHA512_W_L[S0 - 15] | 0, z0 = rotrSH(k0, D0, 1) ^ rotrSH(k0, D0, 8) ^ shrSH(k0, D0, 7), G0 = rotrSL(k0, D0, 1) ^ rotrSL(k0, D0, 8) ^ shrSL(k0, D0, 7), K0 = SHA512_W_H[S0 - 2] | 0, U0 = SHA512_W_L[S0 - 2] | 0, F0 = rotrSH(K0, U0, 19) ^ rotrBH(K0, U0, 61) ^ shrSH(K0, U0, 6), H0 = rotrSL(K0, U0, 19) ^ rotrBL(K0, U0, 61) ^ shrSL(K0, U0, 6), P0 = add4L(G0, H0, SHA512_W_L[S0 - 7], SHA512_W_L[S0 - 16]), I0 = add4H(P0, z0, F0, SHA512_W_H[S0 - 7], SHA512_W_H[S0 - 16]);
      SHA512_W_H[S0] = I0 | 0, SHA512_W_L[S0] = P0 | 0;
    }
    let { Ah: r0, Al: i0, Bh: o0, Bl: s0, Ch: a0, Cl: c0, Dh: l0, Dl: u0, Eh: d0, El: h0, Fh: g0, Fl: w0, Gh: y0, Gl: E0, Hh: b0, Hl: O0 } = this;
    for (let S0 = 0; S0 < 80; S0++) {
      const k0 = rotrSH(d0, h0, 14) ^ rotrSH(d0, h0, 18) ^ rotrBH(d0, h0, 41), D0 = rotrSL(d0, h0, 14) ^ rotrSL(d0, h0, 18) ^ rotrBL(d0, h0, 41), z0 = d0 & g0 ^ ~d0 & y0, G0 = h0 & w0 ^ ~h0 & E0, K0 = add5L(O0, D0, G0, SHA512_Kl[S0], SHA512_W_L[S0]), U0 = add5H(K0, b0, k0, z0, SHA512_Kh[S0], SHA512_W_H[S0]), F0 = K0 | 0, H0 = rotrSH(r0, i0, 28) ^ rotrBH(r0, i0, 34) ^ rotrBH(r0, i0, 39), P0 = rotrSL(r0, i0, 28) ^ rotrBL(r0, i0, 34) ^ rotrBL(r0, i0, 39), I0 = r0 & o0 ^ r0 & a0 ^ o0 & a0, f0 = i0 & s0 ^ i0 & c0 ^ s0 & c0;
      b0 = y0 | 0, O0 = E0 | 0, y0 = g0 | 0, E0 = w0 | 0, g0 = d0 | 0, w0 = h0 | 0, { h: d0, l: h0 } = add(l0 | 0, u0 | 0, U0 | 0, F0 | 0), l0 = a0 | 0, u0 = c0 | 0, a0 = o0 | 0, c0 = s0 | 0, o0 = r0 | 0, s0 = i0 | 0;
      const m0 = add3L(F0, P0, f0);
      r0 = add3H(m0, U0, H0, I0), i0 = m0 | 0;
    }
    ({ h: r0, l: i0 } = add(this.Ah | 0, this.Al | 0, r0 | 0, i0 | 0)), { h: o0, l: s0 } = add(this.Bh | 0, this.Bl | 0, o0 | 0, s0 | 0), { h: a0, l: c0 } = add(this.Ch | 0, this.Cl | 0, a0 | 0, c0 | 0), { h: l0, l: u0 } = add(this.Dh | 0, this.Dl | 0, l0 | 0, u0 | 0), { h: d0, l: h0 } = add(this.Eh | 0, this.El | 0, d0 | 0, h0 | 0), { h: g0, l: w0 } = add(this.Fh | 0, this.Fl | 0, g0 | 0, w0 | 0), { h: y0, l: E0 } = add(this.Gh | 0, this.Gl | 0, y0 | 0, E0 | 0), { h: b0, l: O0 } = add(this.Hh | 0, this.Hl | 0, b0 | 0, O0 | 0), this.set(r0, i0, o0, s0, a0, c0, l0, u0, d0, h0, g0, w0, y0, E0, b0, O0);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const sha256$1 = /* @__PURE__ */ createHasher(() => new SHA256()), sha512 = /* @__PURE__ */ createHasher(() => new SHA512());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$4 = /* @__PURE__ */ BigInt(0), _1n$6 = /* @__PURE__ */ BigInt(1);
function abool(t0, e0) {
  if (typeof e0 != "boolean")
    throw new Error(t0 + " boolean expected, got " + e0);
}
function numberToHexUnpadded(t0) {
  const e0 = t0.toString(16);
  return e0.length & 1 ? "0" + e0 : e0;
}
function hexToNumber(t0) {
  if (typeof t0 != "string")
    throw new Error("hex string expected, got " + typeof t0);
  return t0 === "" ? _0n$4 : BigInt("0x" + t0);
}
function bytesToNumberBE(t0) {
  return hexToNumber(bytesToHex(t0));
}
function bytesToNumberLE(t0) {
  return abytes(t0), hexToNumber(bytesToHex(Uint8Array.from(t0).reverse()));
}
function numberToBytesBE(t0, e0) {
  return hexToBytes(t0.toString(16).padStart(e0 * 2, "0"));
}
function numberToBytesLE(t0, e0) {
  return numberToBytesBE(t0, e0).reverse();
}
function ensureBytes(t0, e0, n0) {
  let r0;
  if (typeof e0 == "string")
    try {
      r0 = hexToBytes(e0);
    } catch (o0) {
      throw new Error(t0 + " must be hex string or Uint8Array, cause: " + o0);
    }
  else if (isBytes(e0))
    r0 = Uint8Array.from(e0);
  else
    throw new Error(t0 + " must be hex string or Uint8Array");
  const i0 = r0.length;
  if (typeof n0 == "number" && i0 !== n0)
    throw new Error(t0 + " of length " + n0 + " expected, got " + i0);
  return r0;
}
const isPosBig = (t0) => typeof t0 == "bigint" && _0n$4 <= t0;
function inRange$1(t0, e0, n0) {
  return isPosBig(t0) && isPosBig(e0) && isPosBig(n0) && e0 <= t0 && t0 < n0;
}
function aInRange(t0, e0, n0, r0) {
  if (!inRange$1(e0, n0, r0))
    throw new Error("expected valid " + t0 + ": " + n0 + " <= n < " + r0 + ", got " + e0);
}
function bitLen(t0) {
  let e0;
  for (e0 = 0; t0 > _0n$4; t0 >>= _1n$6, e0 += 1)
    ;
  return e0;
}
const bitMask = (t0) => (_1n$6 << BigInt(t0)) - _1n$6;
function createHmacDrbg(t0, e0, n0) {
  if (typeof t0 != "number" || t0 < 2)
    throw new Error("hashLen must be a number");
  if (typeof e0 != "number" || e0 < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n0 != "function")
    throw new Error("hmacFn must be a function");
  const r0 = (g0) => new Uint8Array(g0), i0 = (g0) => Uint8Array.of(g0);
  let o0 = r0(t0), s0 = r0(t0), a0 = 0;
  const c0 = () => {
    o0.fill(1), s0.fill(0), a0 = 0;
  }, l0 = (...g0) => n0(s0, o0, ...g0), u0 = (g0 = r0(0)) => {
    s0 = l0(i0(0), g0), o0 = l0(), g0.length !== 0 && (s0 = l0(i0(1), g0), o0 = l0());
  }, d0 = () => {
    if (a0++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let g0 = 0;
    const w0 = [];
    for (; g0 < e0; ) {
      o0 = l0();
      const y0 = o0.slice();
      w0.push(y0), g0 += o0.length;
    }
    return concatBytes(...w0);
  };
  return (g0, w0) => {
    c0(), u0(g0);
    let y0;
    for (; !(y0 = w0(d0())); )
      u0();
    return c0(), y0;
  };
}
function _validateObject(t0, e0, n0 = {}) {
  if (!t0 || typeof t0 != "object")
    throw new Error("expected valid options object");
  function r0(i0, o0, s0) {
    const a0 = t0[i0];
    if (s0 && a0 === void 0)
      return;
    const c0 = typeof a0;
    if (c0 !== o0 || a0 === null)
      throw new Error(`param "${i0}" is invalid: expected ${o0}, got ${c0}`);
  }
  Object.entries(e0).forEach(([i0, o0]) => r0(i0, o0, !1)), Object.entries(n0).forEach(([i0, o0]) => r0(i0, o0, !0));
}
function memoized(t0) {
  const e0 = /* @__PURE__ */ new WeakMap();
  return (n0, ...r0) => {
    const i0 = e0.get(n0);
    if (i0 !== void 0)
      return i0;
    const o0 = t0(n0, ...r0);
    return e0.set(n0, o0), o0;
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0), _1n$5 = BigInt(1), _2n$4 = /* @__PURE__ */ BigInt(2), _3n$1 = /* @__PURE__ */ BigInt(3), _4n$1 = /* @__PURE__ */ BigInt(4), _5n$1 = /* @__PURE__ */ BigInt(5), _8n$2 = /* @__PURE__ */ BigInt(8);
function mod(t0, e0) {
  const n0 = t0 % e0;
  return n0 >= _0n$3 ? n0 : e0 + n0;
}
function pow2(t0, e0, n0) {
  let r0 = t0;
  for (; e0-- > _0n$3; )
    r0 *= r0, r0 %= n0;
  return r0;
}
function invert(t0, e0) {
  if (t0 === _0n$3)
    throw new Error("invert: expected non-zero number");
  if (e0 <= _0n$3)
    throw new Error("invert: expected positive modulus, got " + e0);
  let n0 = mod(t0, e0), r0 = e0, i0 = _0n$3, o0 = _1n$5;
  for (; n0 !== _0n$3; ) {
    const a0 = r0 / n0, c0 = r0 % n0, l0 = i0 - o0 * a0;
    r0 = n0, n0 = c0, i0 = o0, o0 = l0;
  }
  if (r0 !== _1n$5)
    throw new Error("invert: does not exist");
  return mod(i0, e0);
}
function sqrt3mod4(t0, e0) {
  const n0 = (t0.ORDER + _1n$5) / _4n$1, r0 = t0.pow(e0, n0);
  if (!t0.eql(t0.sqr(r0), e0))
    throw new Error("Cannot find square root");
  return r0;
}
function sqrt5mod8(t0, e0) {
  const n0 = (t0.ORDER - _5n$1) / _8n$2, r0 = t0.mul(e0, _2n$4), i0 = t0.pow(r0, n0), o0 = t0.mul(e0, i0), s0 = t0.mul(t0.mul(o0, _2n$4), i0), a0 = t0.mul(o0, t0.sub(s0, t0.ONE));
  if (!t0.eql(t0.sqr(a0), e0))
    throw new Error("Cannot find square root");
  return a0;
}
function tonelliShanks(t0) {
  if (t0 < BigInt(3))
    throw new Error("sqrt is not defined for small field");
  let e0 = t0 - _1n$5, n0 = 0;
  for (; e0 % _2n$4 === _0n$3; )
    e0 /= _2n$4, n0++;
  let r0 = _2n$4;
  const i0 = Field(t0);
  for (; FpLegendre(i0, r0) === 1; )
    if (r0++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (n0 === 1)
    return sqrt3mod4;
  let o0 = i0.pow(r0, e0);
  const s0 = (e0 + _1n$5) / _2n$4;
  return function(c0, l0) {
    if (c0.is0(l0))
      return l0;
    if (FpLegendre(c0, l0) !== 1)
      throw new Error("Cannot find square root");
    let u0 = n0, d0 = c0.mul(c0.ONE, o0), h0 = c0.pow(l0, e0), g0 = c0.pow(l0, s0);
    for (; !c0.eql(h0, c0.ONE); ) {
      if (c0.is0(h0))
        return c0.ZERO;
      let w0 = 1, y0 = c0.sqr(h0);
      for (; !c0.eql(y0, c0.ONE); )
        if (w0++, y0 = c0.sqr(y0), w0 === u0)
          throw new Error("Cannot find square root");
      const E0 = _1n$5 << BigInt(u0 - w0 - 1), b0 = c0.pow(d0, E0);
      u0 = w0, d0 = c0.sqr(b0), h0 = c0.mul(h0, d0), g0 = c0.mul(g0, b0);
    }
    return g0;
  };
}
function FpSqrt(t0) {
  return t0 % _4n$1 === _3n$1 ? sqrt3mod4 : t0 % _8n$2 === _5n$1 ? sqrt5mod8 : tonelliShanks(t0);
}
const isNegativeLE = (t0, e0) => (mod(t0, e0) & _1n$5) === _1n$5, FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(t0) {
  const e0 = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  }, n0 = FIELD_FIELDS.reduce((r0, i0) => (r0[i0] = "function", r0), e0);
  return _validateObject(t0, n0), t0;
}
function FpPow(t0, e0, n0) {
  if (n0 < _0n$3)
    throw new Error("invalid exponent, negatives unsupported");
  if (n0 === _0n$3)
    return t0.ONE;
  if (n0 === _1n$5)
    return e0;
  let r0 = t0.ONE, i0 = e0;
  for (; n0 > _0n$3; )
    n0 & _1n$5 && (r0 = t0.mul(r0, i0)), i0 = t0.sqr(i0), n0 >>= _1n$5;
  return r0;
}
function FpInvertBatch(t0, e0, n0 = !1) {
  const r0 = new Array(e0.length).fill(n0 ? t0.ZERO : void 0), i0 = e0.reduce((s0, a0, c0) => t0.is0(a0) ? s0 : (r0[c0] = s0, t0.mul(s0, a0)), t0.ONE), o0 = t0.inv(i0);
  return e0.reduceRight((s0, a0, c0) => t0.is0(a0) ? s0 : (r0[c0] = t0.mul(s0, r0[c0]), t0.mul(s0, a0)), o0), r0;
}
function FpLegendre(t0, e0) {
  const n0 = (t0.ORDER - _1n$5) / _2n$4, r0 = t0.pow(e0, n0), i0 = t0.eql(r0, t0.ONE), o0 = t0.eql(r0, t0.ZERO), s0 = t0.eql(r0, t0.neg(t0.ONE));
  if (!i0 && !o0 && !s0)
    throw new Error("invalid Legendre symbol result");
  return i0 ? 1 : o0 ? 0 : -1;
}
function nLength(t0, e0) {
  e0 !== void 0 && anumber(e0);
  const n0 = e0 !== void 0 ? e0 : t0.toString(2).length, r0 = Math.ceil(n0 / 8);
  return { nBitLength: n0, nByteLength: r0 };
}
function Field(t0, e0, n0 = !1, r0 = {}) {
  if (t0 <= _0n$3)
    throw new Error("invalid field: expected ORDER > 0, got " + t0);
  let i0, o0;
  if (typeof e0 == "object" && e0 != null) {
    if (r0.sqrt || n0)
      throw new Error("cannot specify opts in two arguments");
    const u0 = e0;
    u0.BITS && (i0 = u0.BITS), u0.sqrt && (o0 = u0.sqrt), typeof u0.isLE == "boolean" && (n0 = u0.isLE);
  } else
    typeof e0 == "number" && (i0 = e0), r0.sqrt && (o0 = r0.sqrt);
  const { nBitLength: s0, nByteLength: a0 } = nLength(t0, i0);
  if (a0 > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let c0;
  const l0 = Object.freeze({
    ORDER: t0,
    isLE: n0,
    BITS: s0,
    BYTES: a0,
    MASK: bitMask(s0),
    ZERO: _0n$3,
    ONE: _1n$5,
    create: (u0) => mod(u0, t0),
    isValid: (u0) => {
      if (typeof u0 != "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof u0);
      return _0n$3 <= u0 && u0 < t0;
    },
    is0: (u0) => u0 === _0n$3,
    // is valid and invertible
    isValidNot0: (u0) => !l0.is0(u0) && l0.isValid(u0),
    isOdd: (u0) => (u0 & _1n$5) === _1n$5,
    neg: (u0) => mod(-u0, t0),
    eql: (u0, d0) => u0 === d0,
    sqr: (u0) => mod(u0 * u0, t0),
    add: (u0, d0) => mod(u0 + d0, t0),
    sub: (u0, d0) => mod(u0 - d0, t0),
    mul: (u0, d0) => mod(u0 * d0, t0),
    pow: (u0, d0) => FpPow(l0, u0, d0),
    div: (u0, d0) => mod(u0 * invert(d0, t0), t0),
    // Same as above, but doesn't normalize
    sqrN: (u0) => u0 * u0,
    addN: (u0, d0) => u0 + d0,
    subN: (u0, d0) => u0 - d0,
    mulN: (u0, d0) => u0 * d0,
    inv: (u0) => invert(u0, t0),
    sqrt: o0 || ((u0) => (c0 || (c0 = FpSqrt(t0)), c0(l0, u0))),
    toBytes: (u0) => n0 ? numberToBytesLE(u0, a0) : numberToBytesBE(u0, a0),
    fromBytes: (u0) => {
      if (u0.length !== a0)
        throw new Error("Field.fromBytes: expected " + a0 + " bytes, got " + u0.length);
      return n0 ? bytesToNumberLE(u0) : bytesToNumberBE(u0);
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (u0) => FpInvertBatch(l0, u0),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (u0, d0, h0) => h0 ? d0 : u0
  });
  return Object.freeze(l0);
}
function getFieldBytesLength(t0) {
  if (typeof t0 != "bigint")
    throw new Error("field order must be bigint");
  const e0 = t0.toString(2).length;
  return Math.ceil(e0 / 8);
}
function getMinHashLength(t0) {
  const e0 = getFieldBytesLength(t0);
  return e0 + Math.ceil(e0 / 2);
}
function mapHashToField(t0, e0, n0 = !1) {
  const r0 = t0.length, i0 = getFieldBytesLength(e0), o0 = getMinHashLength(e0);
  if (r0 < 16 || r0 < o0 || r0 > 1024)
    throw new Error("expected " + o0 + "-1024 bytes of input, got " + r0);
  const s0 = n0 ? bytesToNumberLE(t0) : bytesToNumberBE(t0), a0 = mod(s0, e0 - _1n$5) + _1n$5;
  return n0 ? numberToBytesLE(a0, i0) : numberToBytesBE(a0, i0);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$4 = BigInt(1);
function negateCt(t0, e0) {
  const n0 = e0.negate();
  return t0 ? n0 : e0;
}
function normalizeZ(t0, e0, n0) {
  const r0 = e0 === "pz" ? (s0) => s0.pz : (s0) => s0.ez, i0 = FpInvertBatch(t0.Fp, n0.map(r0));
  return n0.map((s0, a0) => s0.toAffine(i0[a0])).map(t0.fromAffine);
}
function validateW(t0, e0) {
  if (!Number.isSafeInteger(t0) || t0 <= 0 || t0 > e0)
    throw new Error("invalid window size, expected [1.." + e0 + "], got W=" + t0);
}
function calcWOpts(t0, e0) {
  validateW(t0, e0);
  const n0 = Math.ceil(e0 / t0) + 1, r0 = 2 ** (t0 - 1), i0 = 2 ** t0, o0 = bitMask(t0), s0 = BigInt(t0);
  return { windows: n0, windowSize: r0, mask: o0, maxNumber: i0, shiftBy: s0 };
}
function calcOffsets(t0, e0, n0) {
  const { windowSize: r0, mask: i0, maxNumber: o0, shiftBy: s0 } = n0;
  let a0 = Number(t0 & i0), c0 = t0 >> s0;
  a0 > r0 && (a0 -= o0, c0 += _1n$4);
  const l0 = e0 * r0, u0 = l0 + Math.abs(a0) - 1, d0 = a0 === 0, h0 = a0 < 0, g0 = e0 % 2 !== 0;
  return { nextN: c0, offset: u0, isZero: d0, isNeg: h0, isNegF: g0, offsetF: l0 };
}
function validateMSMPoints(t0, e0) {
  if (!Array.isArray(t0))
    throw new Error("array expected");
  t0.forEach((n0, r0) => {
    if (!(n0 instanceof e0))
      throw new Error("invalid point at index " + r0);
  });
}
function validateMSMScalars(t0, e0) {
  if (!Array.isArray(t0))
    throw new Error("array of scalars expected");
  t0.forEach((n0, r0) => {
    if (!e0.isValid(n0))
      throw new Error("invalid scalar at index " + r0);
  });
}
const pointPrecomputes = /* @__PURE__ */ new WeakMap(), pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(t0) {
  return pointWindowSizes.get(t0) || 1;
}
function assert0(t0) {
  if (t0 !== _0n$2)
    throw new Error("invalid wNAF");
}
function wNAF(t0, e0) {
  return {
    constTimeNegate: negateCt,
    hasPrecomputes(n0) {
      return getW(n0) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(n0, r0, i0 = t0.ZERO) {
      let o0 = n0;
      for (; r0 > _0n$2; )
        r0 & _1n$4 && (i0 = i0.add(o0)), o0 = o0.double(), r0 >>= _1n$4;
      return i0;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(n0, r0) {
      const { windows: i0, windowSize: o0 } = calcWOpts(r0, e0), s0 = [];
      let a0 = n0, c0 = a0;
      for (let l0 = 0; l0 < i0; l0++) {
        c0 = a0, s0.push(c0);
        for (let u0 = 1; u0 < o0; u0++)
          c0 = c0.add(a0), s0.push(c0);
        a0 = c0.double();
      }
      return s0;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(n0, r0, i0) {
      let o0 = t0.ZERO, s0 = t0.BASE;
      const a0 = calcWOpts(n0, e0);
      for (let c0 = 0; c0 < a0.windows; c0++) {
        const { nextN: l0, offset: u0, isZero: d0, isNeg: h0, isNegF: g0, offsetF: w0 } = calcOffsets(i0, c0, a0);
        i0 = l0, d0 ? s0 = s0.add(negateCt(g0, r0[w0])) : o0 = o0.add(negateCt(h0, r0[u0]));
      }
      return assert0(i0), { p: o0, f: s0 };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(n0, r0, i0, o0 = t0.ZERO) {
      const s0 = calcWOpts(n0, e0);
      for (let a0 = 0; a0 < s0.windows && i0 !== _0n$2; a0++) {
        const { nextN: c0, offset: l0, isZero: u0, isNeg: d0 } = calcOffsets(i0, a0, s0);
        if (i0 = c0, !u0) {
          const h0 = r0[l0];
          o0 = o0.add(d0 ? h0.negate() : h0);
        }
      }
      return assert0(i0), o0;
    },
    getPrecomputes(n0, r0, i0) {
      let o0 = pointPrecomputes.get(r0);
      return o0 || (o0 = this.precomputeWindow(r0, n0), n0 !== 1 && (typeof i0 == "function" && (o0 = i0(o0)), pointPrecomputes.set(r0, o0))), o0;
    },
    wNAFCached(n0, r0, i0) {
      const o0 = getW(n0);
      return this.wNAF(o0, this.getPrecomputes(o0, n0, i0), r0);
    },
    wNAFCachedUnsafe(n0, r0, i0, o0) {
      const s0 = getW(n0);
      return s0 === 1 ? this.unsafeLadder(n0, r0, o0) : this.wNAFUnsafe(s0, this.getPrecomputes(s0, n0, i0), r0, o0);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(n0, r0) {
      validateW(r0, e0), pointWindowSizes.set(n0, r0), pointPrecomputes.delete(n0);
    }
  };
}
function mulEndoUnsafe(t0, e0, n0, r0) {
  let i0 = e0, o0 = t0.ZERO, s0 = t0.ZERO;
  for (; n0 > _0n$2 || r0 > _0n$2; )
    n0 & _1n$4 && (o0 = o0.add(i0)), r0 & _1n$4 && (s0 = s0.add(i0)), i0 = i0.double(), n0 >>= _1n$4, r0 >>= _1n$4;
  return { p1: o0, p2: s0 };
}
function pippenger(t0, e0, n0, r0) {
  validateMSMPoints(n0, t0), validateMSMScalars(r0, e0);
  const i0 = n0.length, o0 = r0.length;
  if (i0 !== o0)
    throw new Error("arrays of points and scalars must have equal length");
  const s0 = t0.ZERO, a0 = bitLen(BigInt(i0));
  let c0 = 1;
  a0 > 12 ? c0 = a0 - 3 : a0 > 4 ? c0 = a0 - 2 : a0 > 0 && (c0 = 2);
  const l0 = bitMask(c0), u0 = new Array(Number(l0) + 1).fill(s0), d0 = Math.floor((e0.BITS - 1) / c0) * c0;
  let h0 = s0;
  for (let g0 = d0; g0 >= 0; g0 -= c0) {
    u0.fill(s0);
    for (let y0 = 0; y0 < o0; y0++) {
      const E0 = r0[y0], b0 = Number(E0 >> BigInt(g0) & l0);
      u0[b0] = u0[b0].add(n0[y0]);
    }
    let w0 = s0;
    for (let y0 = u0.length - 1, E0 = s0; y0 > 0; y0--)
      E0 = E0.add(u0[y0]), w0 = w0.add(E0);
    if (h0 = h0.add(w0), g0 !== 0)
      for (let y0 = 0; y0 < c0; y0++)
        h0 = h0.double();
  }
  return h0;
}
function createField(t0, e0) {
  if (e0) {
    if (e0.ORDER !== t0)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return validateField(e0), e0;
  } else
    return Field(t0);
}
function _createCurveFields(t0, e0, n0 = {}) {
  if (!e0 || typeof e0 != "object")
    throw new Error(`expected valid ${t0} CURVE object`);
  for (const a0 of ["p", "n", "h"]) {
    const c0 = e0[a0];
    if (!(typeof c0 == "bigint" && c0 > _0n$2))
      throw new Error(`CURVE.${a0} must be positive bigint`);
  }
  const r0 = createField(e0.p, n0.Fp), i0 = createField(e0.n, n0.Fn), s0 = ["Gx", "Gy", "a", t0 === "weierstrass" ? "b" : "d"];
  for (const a0 of s0)
    if (!r0.isValid(e0[a0]))
      throw new Error(`CURVE.${a0} must be valid field element of CURVE.Fp`);
  return { Fp: r0, Fn: i0 };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0), _1n$3 = BigInt(1), _2n$3 = BigInt(2), _8n$1 = BigInt(8), VERIFY_DEFAULT = { zip215: !0 };
function isEdValidXY(t0, e0, n0, r0) {
  const i0 = t0.sqr(n0), o0 = t0.sqr(r0), s0 = t0.add(t0.mul(e0.a, i0), o0), a0 = t0.add(t0.ONE, t0.mul(e0.d, t0.mul(i0, o0)));
  return t0.eql(s0, a0);
}
function edwards(t0, e0 = {}) {
  const { Fp: n0, Fn: r0 } = _createCurveFields("edwards", t0, e0), { h: i0, n: o0 } = t0;
  _validateObject(e0, {}, { uvRatio: "function" });
  const s0 = _2n$3 << BigInt(r0.BYTES * 8) - _1n$3, a0 = (y0) => n0.create(y0), c0 = e0.uvRatio || ((y0, E0) => {
    try {
      return { isValid: !0, value: n0.sqrt(n0.div(y0, E0)) };
    } catch {
      return { isValid: !1, value: _0n$1 };
    }
  });
  if (!isEdValidXY(n0, t0, t0.Gx, t0.Gy))
    throw new Error("bad curve params: generator point");
  function l0(y0, E0, b0 = !1) {
    const O0 = b0 ? _1n$3 : _0n$1;
    return aInRange("coordinate " + y0, E0, O0, s0), E0;
  }
  function u0(y0) {
    if (!(y0 instanceof g0))
      throw new Error("ExtendedPoint expected");
  }
  const d0 = memoized((y0, E0) => {
    const { ex: b0, ey: O0, ez: S0 } = y0, k0 = y0.is0();
    E0 == null && (E0 = k0 ? _8n$1 : n0.inv(S0));
    const D0 = a0(b0 * E0), z0 = a0(O0 * E0), G0 = a0(S0 * E0);
    if (k0)
      return { x: _0n$1, y: _1n$3 };
    if (G0 !== _1n$3)
      throw new Error("invZ was invalid");
    return { x: D0, y: z0 };
  }), h0 = memoized((y0) => {
    const { a: E0, d: b0 } = t0;
    if (y0.is0())
      throw new Error("bad point: ZERO");
    const { ex: O0, ey: S0, ez: k0, et: D0 } = y0, z0 = a0(O0 * O0), G0 = a0(S0 * S0), K0 = a0(k0 * k0), U0 = a0(K0 * K0), F0 = a0(z0 * E0), H0 = a0(K0 * a0(F0 + G0)), P0 = a0(U0 + a0(b0 * a0(z0 * G0)));
    if (H0 !== P0)
      throw new Error("bad point: equation left != right (1)");
    const I0 = a0(O0 * S0), f0 = a0(k0 * D0);
    if (I0 !== f0)
      throw new Error("bad point: equation left != right (2)");
    return !0;
  });
  class g0 {
    constructor(E0, b0, O0, S0) {
      this.ex = l0("x", E0), this.ey = l0("y", b0), this.ez = l0("z", O0, !0), this.et = l0("t", S0), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(E0) {
      if (E0 instanceof g0)
        throw new Error("extended point not allowed");
      const { x: b0, y: O0 } = E0 || {};
      return l0("x", b0), l0("y", O0), new g0(b0, O0, _1n$3, a0(b0 * O0));
    }
    static normalizeZ(E0) {
      return normalizeZ(g0, "ez", E0);
    }
    // Multiscalar Multiplication
    static msm(E0, b0) {
      return pippenger(g0, r0, E0, b0);
    }
    // "Private method", don't use it directly
    _setWindowSize(E0) {
      this.precompute(E0);
    }
    precompute(E0 = 8, b0 = !0) {
      return w0.setWindowSize(this, E0), b0 || this.multiply(_2n$3), this;
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      h0(this);
    }
    // Compare one point to another.
    equals(E0) {
      u0(E0);
      const { ex: b0, ey: O0, ez: S0 } = this, { ex: k0, ey: D0, ez: z0 } = E0, G0 = a0(b0 * z0), K0 = a0(k0 * S0), U0 = a0(O0 * z0), F0 = a0(D0 * S0);
      return G0 === K0 && U0 === F0;
    }
    is0() {
      return this.equals(g0.ZERO);
    }
    negate() {
      return new g0(a0(-this.ex), this.ey, this.ez, a0(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: E0 } = t0, { ex: b0, ey: O0, ez: S0 } = this, k0 = a0(b0 * b0), D0 = a0(O0 * O0), z0 = a0(_2n$3 * a0(S0 * S0)), G0 = a0(E0 * k0), K0 = b0 + O0, U0 = a0(a0(K0 * K0) - k0 - D0), F0 = G0 + D0, H0 = F0 - z0, P0 = G0 - D0, I0 = a0(U0 * H0), f0 = a0(F0 * P0), m0 = a0(U0 * P0), A0 = a0(H0 * F0);
      return new g0(I0, f0, A0, m0);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(E0) {
      u0(E0);
      const { a: b0, d: O0 } = t0, { ex: S0, ey: k0, ez: D0, et: z0 } = this, { ex: G0, ey: K0, ez: U0, et: F0 } = E0, H0 = a0(S0 * G0), P0 = a0(k0 * K0), I0 = a0(z0 * O0 * F0), f0 = a0(D0 * U0), m0 = a0((S0 + k0) * (G0 + K0) - H0 - P0), A0 = f0 - I0, x0 = f0 + I0, _0 = a0(P0 - b0 * H0), $0 = a0(m0 * A0), C0 = a0(x0 * _0), M0 = a0(m0 * _0), p0 = a0(A0 * x0);
      return new g0($0, C0, p0, M0);
    }
    subtract(E0) {
      return this.add(E0.negate());
    }
    // Constant-time multiplication.
    multiply(E0) {
      const b0 = E0;
      aInRange("scalar", b0, _1n$3, o0);
      const { p: O0, f: S0 } = w0.wNAFCached(this, b0, g0.normalizeZ);
      return g0.normalizeZ([O0, S0])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(E0, b0 = g0.ZERO) {
      const O0 = E0;
      return aInRange("scalar", O0, _0n$1, o0), O0 === _0n$1 ? g0.ZERO : this.is0() || O0 === _1n$3 ? this : w0.wNAFCachedUnsafe(this, O0, g0.normalizeZ, b0);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(i0).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return w0.wNAFCachedUnsafe(this, o0).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(E0) {
      return d0(this, E0);
    }
    clearCofactor() {
      return i0 === _1n$3 ? this : this.multiplyUnsafe(i0);
    }
    static fromBytes(E0, b0 = !1) {
      return abytes(E0), this.fromHex(E0, b0);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(E0, b0 = !1) {
      const { d: O0, a: S0 } = t0, k0 = n0.BYTES;
      E0 = ensureBytes("pointHex", E0, k0), abool("zip215", b0);
      const D0 = E0.slice(), z0 = E0[k0 - 1];
      D0[k0 - 1] = z0 & -129;
      const G0 = bytesToNumberLE(D0), K0 = b0 ? s0 : n0.ORDER;
      aInRange("pointHex.y", G0, _0n$1, K0);
      const U0 = a0(G0 * G0), F0 = a0(U0 - _1n$3), H0 = a0(O0 * U0 - S0);
      let { isValid: P0, value: I0 } = c0(F0, H0);
      if (!P0)
        throw new Error("Point.fromHex: invalid y coordinate");
      const f0 = (I0 & _1n$3) === _1n$3, m0 = (z0 & 128) !== 0;
      if (!b0 && I0 === _0n$1 && m0)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      return m0 !== f0 && (I0 = a0(-I0)), g0.fromAffine({ x: I0, y: G0 });
    }
    static fromPrivateScalar(E0) {
      return g0.BASE.multiply(E0);
    }
    toBytes() {
      const { x: E0, y: b0 } = this.toAffine(), O0 = numberToBytesLE(b0, n0.BYTES);
      return O0[O0.length - 1] |= E0 & _1n$3 ? 128 : 0, O0;
    }
    /** @deprecated use `toBytes` */
    toRawBytes() {
      return this.toBytes();
    }
    toHex() {
      return bytesToHex(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  g0.BASE = new g0(t0.Gx, t0.Gy, _1n$3, a0(t0.Gx * t0.Gy)), g0.ZERO = new g0(_0n$1, _1n$3, _1n$3, _0n$1), g0.Fp = n0, g0.Fn = r0;
  const w0 = wNAF(g0, r0.BYTES * 8);
  return g0;
}
function eddsa(t0, e0) {
  _validateObject(e0, {
    hash: "function"
  }, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash: n0, hash: r0 } = e0, { BASE: i0, Fp: o0, Fn: s0 } = t0, a0 = s0.ORDER, c0 = e0.randomBytes || randomBytes, l0 = e0.adjustScalarBytes || ((D0) => D0), u0 = e0.domain || ((D0, z0, G0) => {
    if (abool("phflag", G0), z0.length || G0)
      throw new Error("Contexts/pre-hash are not supported");
    return D0;
  });
  function d0(D0) {
    return s0.create(D0);
  }
  function h0(D0) {
    return d0(bytesToNumberLE(D0));
  }
  function g0(D0) {
    const z0 = o0.BYTES;
    D0 = ensureBytes("private key", D0, z0);
    const G0 = ensureBytes("hashed private key", r0(D0), 2 * z0), K0 = l0(G0.slice(0, z0)), U0 = G0.slice(z0, 2 * z0), F0 = h0(K0);
    return { head: K0, prefix: U0, scalar: F0 };
  }
  function w0(D0) {
    const { head: z0, prefix: G0, scalar: K0 } = g0(D0), U0 = i0.multiply(K0), F0 = U0.toBytes();
    return { head: z0, prefix: G0, scalar: K0, point: U0, pointBytes: F0 };
  }
  function y0(D0) {
    return w0(D0).pointBytes;
  }
  function E0(D0 = Uint8Array.of(), ...z0) {
    const G0 = concatBytes(...z0);
    return h0(r0(u0(G0, ensureBytes("context", D0), !!n0)));
  }
  function b0(D0, z0, G0 = {}) {
    D0 = ensureBytes("message", D0), n0 && (D0 = n0(D0));
    const { prefix: K0, scalar: U0, pointBytes: F0 } = w0(z0), H0 = E0(G0.context, K0, D0), P0 = i0.multiply(H0).toBytes(), I0 = E0(G0.context, P0, F0, D0), f0 = d0(H0 + I0 * U0);
    aInRange("signature.s", f0, _0n$1, a0);
    const m0 = o0.BYTES, A0 = concatBytes(P0, numberToBytesLE(f0, m0));
    return ensureBytes("result", A0, m0 * 2);
  }
  const O0 = VERIFY_DEFAULT;
  function S0(D0, z0, G0, K0 = O0) {
    const { context: U0, zip215: F0 } = K0, H0 = o0.BYTES;
    D0 = ensureBytes("signature", D0, 2 * H0), z0 = ensureBytes("message", z0), G0 = ensureBytes("publicKey", G0, H0), F0 !== void 0 && abool("zip215", F0), n0 && (z0 = n0(z0));
    const P0 = bytesToNumberLE(D0.slice(H0, 2 * H0));
    let I0, f0, m0;
    try {
      I0 = t0.fromHex(G0, F0), f0 = t0.fromHex(D0.slice(0, H0), F0), m0 = i0.multiplyUnsafe(P0);
    } catch {
      return !1;
    }
    if (!F0 && I0.isSmallOrder())
      return !1;
    const A0 = E0(U0, f0.toBytes(), I0.toBytes(), z0);
    return f0.add(I0.multiplyUnsafe(A0)).subtract(m0).clearCofactor().is0();
  }
  return i0.precompute(8), { getPublicKey: y0, sign: b0, verify: S0, utils: {
    getExtendedPublicKey: w0,
    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */
    randomPrivateKey: () => c0(o0.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(D0 = 8, z0 = t0.BASE) {
      return z0.precompute(D0, !1);
    }
  }, Point: t0 };
}
function _eddsa_legacy_opts_to_new(t0) {
  const e0 = {
    a: t0.a,
    d: t0.d,
    p: t0.Fp.ORDER,
    n: t0.n,
    h: t0.h,
    Gx: t0.Gx,
    Gy: t0.Gy
  }, n0 = t0.Fp, r0 = Field(e0.n, t0.nBitLength, !0), i0 = { Fp: n0, Fn: r0, uvRatio: t0.uvRatio }, o0 = {
    hash: t0.hash,
    randomBytes: t0.randomBytes,
    adjustScalarBytes: t0.adjustScalarBytes,
    domain: t0.domain,
    prehash: t0.prehash,
    mapToCurve: t0.mapToCurve
  };
  return { CURVE: e0, curveOpts: i0, eddsaOpts: o0 };
}
function _eddsa_new_output_to_legacy(t0, e0) {
  return Object.assign({}, e0, { ExtendedPoint: e0.Point, CURVE: t0 });
}
function twistedEdwards(t0) {
  const { CURVE: e0, curveOpts: n0, eddsaOpts: r0 } = _eddsa_legacy_opts_to_new(t0), i0 = edwards(e0, n0), o0 = eddsa(i0, r0);
  return _eddsa_new_output_to_legacy(t0, o0);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
BigInt(0);
const _1n$2 = BigInt(1), _2n$2 = BigInt(2);
BigInt(3);
const _5n = BigInt(5), _8n = BigInt(8), ed25519_CURVE = {
  p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
  n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
  h: _8n,
  a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
  d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
  Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
  Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
};
function ed25519_pow_2_252_3(t0) {
  const e0 = BigInt(10), n0 = BigInt(20), r0 = BigInt(40), i0 = BigInt(80), o0 = ed25519_CURVE.p, a0 = t0 * t0 % o0 * t0 % o0, c0 = pow2(a0, _2n$2, o0) * a0 % o0, l0 = pow2(c0, _1n$2, o0) * t0 % o0, u0 = pow2(l0, _5n, o0) * l0 % o0, d0 = pow2(u0, e0, o0) * u0 % o0, h0 = pow2(d0, n0, o0) * d0 % o0, g0 = pow2(h0, r0, o0) * h0 % o0, w0 = pow2(g0, i0, o0) * g0 % o0, y0 = pow2(w0, i0, o0) * g0 % o0, E0 = pow2(y0, e0, o0) * u0 % o0;
  return { pow_p_5_8: pow2(E0, _2n$2, o0) * t0 % o0, b2: a0 };
}
function adjustScalarBytes(t0) {
  return t0[0] &= 248, t0[31] &= 127, t0[31] |= 64, t0;
}
const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function uvRatio(t0, e0) {
  const n0 = ed25519_CURVE.p, r0 = mod(e0 * e0 * e0, n0), i0 = mod(r0 * r0 * e0, n0), o0 = ed25519_pow_2_252_3(t0 * i0).pow_p_5_8;
  let s0 = mod(t0 * r0 * o0, n0);
  const a0 = mod(e0 * s0 * s0, n0), c0 = s0, l0 = mod(s0 * ED25519_SQRT_M1, n0), u0 = a0 === t0, d0 = a0 === mod(-t0, n0), h0 = a0 === mod(-t0 * ED25519_SQRT_M1, n0);
  return u0 && (s0 = c0), (d0 || h0) && (s0 = l0), isNegativeLE(s0, n0) && (s0 = mod(-s0, n0)), { isValid: u0 || d0, value: s0 };
}
const Fp = /* @__PURE__ */ (() => Field(ed25519_CURVE.p, void 0, !0))(), ed25519Defaults = /* @__PURE__ */ (() => ({
  ...ed25519_CURVE,
  Fp,
  hash: sha512,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/v
  uvRatio
}))(), ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
var bn = { exports: {} };
bn.exports;
(function(t0) {
  (function(e0, n0) {
    function r0(I0, f0) {
      if (!I0)
        throw new Error(f0 || "Assertion failed");
    }
    function i0(I0, f0) {
      I0.super_ = f0;
      var m0 = function() {
      };
      m0.prototype = f0.prototype, I0.prototype = new m0(), I0.prototype.constructor = I0;
    }
    function o0(I0, f0, m0) {
      if (o0.isBN(I0))
        return I0;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, I0 !== null && ((f0 === "le" || f0 === "be") && (m0 = f0, f0 = 10), this._init(I0 || 0, f0 || 10, m0 || "be"));
    }
    typeof e0 == "object" ? e0.exports = o0 : n0.BN = o0, o0.BN = o0, o0.wordSize = 26;
    var s0;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? s0 = window.Buffer : s0 = require$$1.Buffer;
    } catch {
    }
    o0.isBN = function(f0) {
      return f0 instanceof o0 ? !0 : f0 !== null && typeof f0 == "object" && f0.constructor.wordSize === o0.wordSize && Array.isArray(f0.words);
    }, o0.max = function(f0, m0) {
      return f0.cmp(m0) > 0 ? f0 : m0;
    }, o0.min = function(f0, m0) {
      return f0.cmp(m0) < 0 ? f0 : m0;
    }, o0.prototype._init = function(f0, m0, A0) {
      if (typeof f0 == "number")
        return this._initNumber(f0, m0, A0);
      if (typeof f0 == "object")
        return this._initArray(f0, m0, A0);
      m0 === "hex" && (m0 = 16), r0(m0 === (m0 | 0) && m0 >= 2 && m0 <= 36), f0 = f0.toString().replace(/\s+/g, "");
      var x0 = 0;
      f0[0] === "-" && (x0++, this.negative = 1), x0 < f0.length && (m0 === 16 ? this._parseHex(f0, x0, A0) : (this._parseBase(f0, m0, x0), A0 === "le" && this._initArray(this.toArray(), m0, A0)));
    }, o0.prototype._initNumber = function(f0, m0, A0) {
      f0 < 0 && (this.negative = 1, f0 = -f0), f0 < 67108864 ? (this.words = [f0 & 67108863], this.length = 1) : f0 < 4503599627370496 ? (this.words = [
        f0 & 67108863,
        f0 / 67108864 & 67108863
      ], this.length = 2) : (r0(f0 < 9007199254740992), this.words = [
        f0 & 67108863,
        f0 / 67108864 & 67108863,
        1
      ], this.length = 3), A0 === "le" && this._initArray(this.toArray(), m0, A0);
    }, o0.prototype._initArray = function(f0, m0, A0) {
      if (r0(typeof f0.length == "number"), f0.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(f0.length / 3), this.words = new Array(this.length);
      for (var x0 = 0; x0 < this.length; x0++)
        this.words[x0] = 0;
      var _0, $0, C0 = 0;
      if (A0 === "be")
        for (x0 = f0.length - 1, _0 = 0; x0 >= 0; x0 -= 3)
          $0 = f0[x0] | f0[x0 - 1] << 8 | f0[x0 - 2] << 16, this.words[_0] |= $0 << C0 & 67108863, this.words[_0 + 1] = $0 >>> 26 - C0 & 67108863, C0 += 24, C0 >= 26 && (C0 -= 26, _0++);
      else if (A0 === "le")
        for (x0 = 0, _0 = 0; x0 < f0.length; x0 += 3)
          $0 = f0[x0] | f0[x0 + 1] << 8 | f0[x0 + 2] << 16, this.words[_0] |= $0 << C0 & 67108863, this.words[_0 + 1] = $0 >>> 26 - C0 & 67108863, C0 += 24, C0 >= 26 && (C0 -= 26, _0++);
      return this._strip();
    };
    function a0(I0, f0) {
      var m0 = I0.charCodeAt(f0);
      if (m0 >= 48 && m0 <= 57)
        return m0 - 48;
      if (m0 >= 65 && m0 <= 70)
        return m0 - 55;
      if (m0 >= 97 && m0 <= 102)
        return m0 - 87;
      r0(!1, "Invalid character in " + I0);
    }
    function c0(I0, f0, m0) {
      var A0 = a0(I0, m0);
      return m0 - 1 >= f0 && (A0 |= a0(I0, m0 - 1) << 4), A0;
    }
    o0.prototype._parseHex = function(f0, m0, A0) {
      this.length = Math.ceil((f0.length - m0) / 6), this.words = new Array(this.length);
      for (var x0 = 0; x0 < this.length; x0++)
        this.words[x0] = 0;
      var _0 = 0, $0 = 0, C0;
      if (A0 === "be")
        for (x0 = f0.length - 1; x0 >= m0; x0 -= 2)
          C0 = c0(f0, m0, x0) << _0, this.words[$0] |= C0 & 67108863, _0 >= 18 ? (_0 -= 18, $0 += 1, this.words[$0] |= C0 >>> 26) : _0 += 8;
      else {
        var M0 = f0.length - m0;
        for (x0 = M0 % 2 === 0 ? m0 + 1 : m0; x0 < f0.length; x0 += 2)
          C0 = c0(f0, m0, x0) << _0, this.words[$0] |= C0 & 67108863, _0 >= 18 ? (_0 -= 18, $0 += 1, this.words[$0] |= C0 >>> 26) : _0 += 8;
      }
      this._strip();
    };
    function l0(I0, f0, m0, A0) {
      for (var x0 = 0, _0 = 0, $0 = Math.min(I0.length, m0), C0 = f0; C0 < $0; C0++) {
        var M0 = I0.charCodeAt(C0) - 48;
        x0 *= A0, M0 >= 49 ? _0 = M0 - 49 + 10 : M0 >= 17 ? _0 = M0 - 17 + 10 : _0 = M0, r0(M0 >= 0 && _0 < A0, "Invalid character"), x0 += _0;
      }
      return x0;
    }
    o0.prototype._parseBase = function(f0, m0, A0) {
      this.words = [0], this.length = 1;
      for (var x0 = 0, _0 = 1; _0 <= 67108863; _0 *= m0)
        x0++;
      x0--, _0 = _0 / m0 | 0;
      for (var $0 = f0.length - A0, C0 = $0 % x0, M0 = Math.min($0, $0 - C0) + A0, p0 = 0, v0 = A0; v0 < M0; v0 += x0)
        p0 = l0(f0, v0, v0 + x0, m0), this.imuln(_0), this.words[0] + p0 < 67108864 ? this.words[0] += p0 : this._iaddn(p0);
      if (C0 !== 0) {
        var T0 = 1;
        for (p0 = l0(f0, v0, f0.length, m0), v0 = 0; v0 < C0; v0++)
          T0 *= m0;
        this.imuln(T0), this.words[0] + p0 < 67108864 ? this.words[0] += p0 : this._iaddn(p0);
      }
      this._strip();
    }, o0.prototype.copy = function(f0) {
      f0.words = new Array(this.length);
      for (var m0 = 0; m0 < this.length; m0++)
        f0.words[m0] = this.words[m0];
      f0.length = this.length, f0.negative = this.negative, f0.red = this.red;
    };
    function u0(I0, f0) {
      I0.words = f0.words, I0.length = f0.length, I0.negative = f0.negative, I0.red = f0.red;
    }
    if (o0.prototype._move = function(f0) {
      u0(f0, this);
    }, o0.prototype.clone = function() {
      var f0 = new o0(null);
      return this.copy(f0), f0;
    }, o0.prototype._expand = function(f0) {
      for (; this.length < f0; )
        this.words[this.length++] = 0;
      return this;
    }, o0.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, o0.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        o0.prototype[Symbol.for("nodejs.util.inspect.custom")] = d0;
      } catch {
        o0.prototype.inspect = d0;
      }
    else
      o0.prototype.inspect = d0;
    function d0() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var h0 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], g0 = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], w0 = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    o0.prototype.toString = function(f0, m0) {
      f0 = f0 || 10, m0 = m0 | 0 || 1;
      var A0;
      if (f0 === 16 || f0 === "hex") {
        A0 = "";
        for (var x0 = 0, _0 = 0, $0 = 0; $0 < this.length; $0++) {
          var C0 = this.words[$0], M0 = ((C0 << x0 | _0) & 16777215).toString(16);
          _0 = C0 >>> 24 - x0 & 16777215, x0 += 2, x0 >= 26 && (x0 -= 26, $0--), _0 !== 0 || $0 !== this.length - 1 ? A0 = h0[6 - M0.length] + M0 + A0 : A0 = M0 + A0;
        }
        for (_0 !== 0 && (A0 = _0.toString(16) + A0); A0.length % m0 !== 0; )
          A0 = "0" + A0;
        return this.negative !== 0 && (A0 = "-" + A0), A0;
      }
      if (f0 === (f0 | 0) && f0 >= 2 && f0 <= 36) {
        var p0 = g0[f0], v0 = w0[f0];
        A0 = "";
        var T0 = this.clone();
        for (T0.negative = 0; !T0.isZero(); ) {
          var L0 = T0.modrn(v0).toString(f0);
          T0 = T0.idivn(v0), T0.isZero() ? A0 = L0 + A0 : A0 = h0[p0 - L0.length] + L0 + A0;
        }
        for (this.isZero() && (A0 = "0" + A0); A0.length % m0 !== 0; )
          A0 = "0" + A0;
        return this.negative !== 0 && (A0 = "-" + A0), A0;
      }
      r0(!1, "Base should be between 2 and 36");
    }, o0.prototype.toNumber = function() {
      var f0 = this.words[0];
      return this.length === 2 ? f0 += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f0 += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r0(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f0 : f0;
    }, o0.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, s0 && (o0.prototype.toBuffer = function(f0, m0) {
      return this.toArrayLike(s0, f0, m0);
    }), o0.prototype.toArray = function(f0, m0) {
      return this.toArrayLike(Array, f0, m0);
    };
    var y0 = function(f0, m0) {
      return f0.allocUnsafe ? f0.allocUnsafe(m0) : new f0(m0);
    };
    o0.prototype.toArrayLike = function(f0, m0, A0) {
      this._strip();
      var x0 = this.byteLength(), _0 = A0 || Math.max(1, x0);
      r0(x0 <= _0, "byte array longer than desired length"), r0(_0 > 0, "Requested array length <= 0");
      var $0 = y0(f0, _0), C0 = m0 === "le" ? "LE" : "BE";
      return this["_toArrayLike" + C0]($0, x0), $0;
    }, o0.prototype._toArrayLikeLE = function(f0, m0) {
      for (var A0 = 0, x0 = 0, _0 = 0, $0 = 0; _0 < this.length; _0++) {
        var C0 = this.words[_0] << $0 | x0;
        f0[A0++] = C0 & 255, A0 < f0.length && (f0[A0++] = C0 >> 8 & 255), A0 < f0.length && (f0[A0++] = C0 >> 16 & 255), $0 === 6 ? (A0 < f0.length && (f0[A0++] = C0 >> 24 & 255), x0 = 0, $0 = 0) : (x0 = C0 >>> 24, $0 += 2);
      }
      if (A0 < f0.length)
        for (f0[A0++] = x0; A0 < f0.length; )
          f0[A0++] = 0;
    }, o0.prototype._toArrayLikeBE = function(f0, m0) {
      for (var A0 = f0.length - 1, x0 = 0, _0 = 0, $0 = 0; _0 < this.length; _0++) {
        var C0 = this.words[_0] << $0 | x0;
        f0[A0--] = C0 & 255, A0 >= 0 && (f0[A0--] = C0 >> 8 & 255), A0 >= 0 && (f0[A0--] = C0 >> 16 & 255), $0 === 6 ? (A0 >= 0 && (f0[A0--] = C0 >> 24 & 255), x0 = 0, $0 = 0) : (x0 = C0 >>> 24, $0 += 2);
      }
      if (A0 >= 0)
        for (f0[A0--] = x0; A0 >= 0; )
          f0[A0--] = 0;
    }, Math.clz32 ? o0.prototype._countBits = function(f0) {
      return 32 - Math.clz32(f0);
    } : o0.prototype._countBits = function(f0) {
      var m0 = f0, A0 = 0;
      return m0 >= 4096 && (A0 += 13, m0 >>>= 13), m0 >= 64 && (A0 += 7, m0 >>>= 7), m0 >= 8 && (A0 += 4, m0 >>>= 4), m0 >= 2 && (A0 += 2, m0 >>>= 2), A0 + m0;
    }, o0.prototype._zeroBits = function(f0) {
      if (f0 === 0)
        return 26;
      var m0 = f0, A0 = 0;
      return m0 & 8191 || (A0 += 13, m0 >>>= 13), m0 & 127 || (A0 += 7, m0 >>>= 7), m0 & 15 || (A0 += 4, m0 >>>= 4), m0 & 3 || (A0 += 2, m0 >>>= 2), m0 & 1 || A0++, A0;
    }, o0.prototype.bitLength = function() {
      var f0 = this.words[this.length - 1], m0 = this._countBits(f0);
      return (this.length - 1) * 26 + m0;
    };
    function E0(I0) {
      for (var f0 = new Array(I0.bitLength()), m0 = 0; m0 < f0.length; m0++) {
        var A0 = m0 / 26 | 0, x0 = m0 % 26;
        f0[m0] = I0.words[A0] >>> x0 & 1;
      }
      return f0;
    }
    o0.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var f0 = 0, m0 = 0; m0 < this.length; m0++) {
        var A0 = this._zeroBits(this.words[m0]);
        if (f0 += A0, A0 !== 26)
          break;
      }
      return f0;
    }, o0.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, o0.prototype.toTwos = function(f0) {
      return this.negative !== 0 ? this.abs().inotn(f0).iaddn(1) : this.clone();
    }, o0.prototype.fromTwos = function(f0) {
      return this.testn(f0 - 1) ? this.notn(f0).iaddn(1).ineg() : this.clone();
    }, o0.prototype.isNeg = function() {
      return this.negative !== 0;
    }, o0.prototype.neg = function() {
      return this.clone().ineg();
    }, o0.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, o0.prototype.iuor = function(f0) {
      for (; this.length < f0.length; )
        this.words[this.length++] = 0;
      for (var m0 = 0; m0 < f0.length; m0++)
        this.words[m0] = this.words[m0] | f0.words[m0];
      return this._strip();
    }, o0.prototype.ior = function(f0) {
      return r0((this.negative | f0.negative) === 0), this.iuor(f0);
    }, o0.prototype.or = function(f0) {
      return this.length > f0.length ? this.clone().ior(f0) : f0.clone().ior(this);
    }, o0.prototype.uor = function(f0) {
      return this.length > f0.length ? this.clone().iuor(f0) : f0.clone().iuor(this);
    }, o0.prototype.iuand = function(f0) {
      var m0;
      this.length > f0.length ? m0 = f0 : m0 = this;
      for (var A0 = 0; A0 < m0.length; A0++)
        this.words[A0] = this.words[A0] & f0.words[A0];
      return this.length = m0.length, this._strip();
    }, o0.prototype.iand = function(f0) {
      return r0((this.negative | f0.negative) === 0), this.iuand(f0);
    }, o0.prototype.and = function(f0) {
      return this.length > f0.length ? this.clone().iand(f0) : f0.clone().iand(this);
    }, o0.prototype.uand = function(f0) {
      return this.length > f0.length ? this.clone().iuand(f0) : f0.clone().iuand(this);
    }, o0.prototype.iuxor = function(f0) {
      var m0, A0;
      this.length > f0.length ? (m0 = this, A0 = f0) : (m0 = f0, A0 = this);
      for (var x0 = 0; x0 < A0.length; x0++)
        this.words[x0] = m0.words[x0] ^ A0.words[x0];
      if (this !== m0)
        for (; x0 < m0.length; x0++)
          this.words[x0] = m0.words[x0];
      return this.length = m0.length, this._strip();
    }, o0.prototype.ixor = function(f0) {
      return r0((this.negative | f0.negative) === 0), this.iuxor(f0);
    }, o0.prototype.xor = function(f0) {
      return this.length > f0.length ? this.clone().ixor(f0) : f0.clone().ixor(this);
    }, o0.prototype.uxor = function(f0) {
      return this.length > f0.length ? this.clone().iuxor(f0) : f0.clone().iuxor(this);
    }, o0.prototype.inotn = function(f0) {
      r0(typeof f0 == "number" && f0 >= 0);
      var m0 = Math.ceil(f0 / 26) | 0, A0 = f0 % 26;
      this._expand(m0), A0 > 0 && m0--;
      for (var x0 = 0; x0 < m0; x0++)
        this.words[x0] = ~this.words[x0] & 67108863;
      return A0 > 0 && (this.words[x0] = ~this.words[x0] & 67108863 >> 26 - A0), this._strip();
    }, o0.prototype.notn = function(f0) {
      return this.clone().inotn(f0);
    }, o0.prototype.setn = function(f0, m0) {
      r0(typeof f0 == "number" && f0 >= 0);
      var A0 = f0 / 26 | 0, x0 = f0 % 26;
      return this._expand(A0 + 1), m0 ? this.words[A0] = this.words[A0] | 1 << x0 : this.words[A0] = this.words[A0] & ~(1 << x0), this._strip();
    }, o0.prototype.iadd = function(f0) {
      var m0;
      if (this.negative !== 0 && f0.negative === 0)
        return this.negative = 0, m0 = this.isub(f0), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && f0.negative !== 0)
        return f0.negative = 0, m0 = this.isub(f0), f0.negative = 1, m0._normSign();
      var A0, x0;
      this.length > f0.length ? (A0 = this, x0 = f0) : (A0 = f0, x0 = this);
      for (var _0 = 0, $0 = 0; $0 < x0.length; $0++)
        m0 = (A0.words[$0] | 0) + (x0.words[$0] | 0) + _0, this.words[$0] = m0 & 67108863, _0 = m0 >>> 26;
      for (; _0 !== 0 && $0 < A0.length; $0++)
        m0 = (A0.words[$0] | 0) + _0, this.words[$0] = m0 & 67108863, _0 = m0 >>> 26;
      if (this.length = A0.length, _0 !== 0)
        this.words[this.length] = _0, this.length++;
      else if (A0 !== this)
        for (; $0 < A0.length; $0++)
          this.words[$0] = A0.words[$0];
      return this;
    }, o0.prototype.add = function(f0) {
      var m0;
      return f0.negative !== 0 && this.negative === 0 ? (f0.negative = 0, m0 = this.sub(f0), f0.negative ^= 1, m0) : f0.negative === 0 && this.negative !== 0 ? (this.negative = 0, m0 = f0.sub(this), this.negative = 1, m0) : this.length > f0.length ? this.clone().iadd(f0) : f0.clone().iadd(this);
    }, o0.prototype.isub = function(f0) {
      if (f0.negative !== 0) {
        f0.negative = 0;
        var m0 = this.iadd(f0);
        return f0.negative = 1, m0._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(f0), this.negative = 1, this._normSign();
      var A0 = this.cmp(f0);
      if (A0 === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var x0, _0;
      A0 > 0 ? (x0 = this, _0 = f0) : (x0 = f0, _0 = this);
      for (var $0 = 0, C0 = 0; C0 < _0.length; C0++)
        m0 = (x0.words[C0] | 0) - (_0.words[C0] | 0) + $0, $0 = m0 >> 26, this.words[C0] = m0 & 67108863;
      for (; $0 !== 0 && C0 < x0.length; C0++)
        m0 = (x0.words[C0] | 0) + $0, $0 = m0 >> 26, this.words[C0] = m0 & 67108863;
      if ($0 === 0 && C0 < x0.length && x0 !== this)
        for (; C0 < x0.length; C0++)
          this.words[C0] = x0.words[C0];
      return this.length = Math.max(this.length, C0), x0 !== this && (this.negative = 1), this._strip();
    }, o0.prototype.sub = function(f0) {
      return this.clone().isub(f0);
    };
    function b0(I0, f0, m0) {
      m0.negative = f0.negative ^ I0.negative;
      var A0 = I0.length + f0.length | 0;
      m0.length = A0, A0 = A0 - 1 | 0;
      var x0 = I0.words[0] | 0, _0 = f0.words[0] | 0, $0 = x0 * _0, C0 = $0 & 67108863, M0 = $0 / 67108864 | 0;
      m0.words[0] = C0;
      for (var p0 = 1; p0 < A0; p0++) {
        for (var v0 = M0 >>> 26, T0 = M0 & 67108863, L0 = Math.min(p0, f0.length - 1), B0 = Math.max(0, p0 - I0.length + 1); B0 <= L0; B0++) {
          var W0 = p0 - B0 | 0;
          x0 = I0.words[W0] | 0, _0 = f0.words[B0] | 0, $0 = x0 * _0 + T0, v0 += $0 / 67108864 | 0, T0 = $0 & 67108863;
        }
        m0.words[p0] = T0 | 0, M0 = v0 | 0;
      }
      return M0 !== 0 ? m0.words[p0] = M0 | 0 : m0.length--, m0._strip();
    }
    var O0 = function(f0, m0, A0) {
      var x0 = f0.words, _0 = m0.words, $0 = A0.words, C0 = 0, M0, p0, v0, T0 = x0[0] | 0, L0 = T0 & 8191, B0 = T0 >>> 13, W0 = x0[1] | 0, V0 = W0 & 8191, Q0 = W0 >>> 13, X0 = x0[2] | 0, J0 = X0 & 8191, yg = X0 >>> 13, _g = x0[3] | 0, wg = _g & 8191, $g = _g >>> 13, Eg = x0[4] | 0, bg = Eg & 8191, vg = Eg >>> 13, Ag = x0[5] | 0, Ig = Ag & 8191, Mg = Ag >>> 13, Sg = x0[6] | 0, Ng = Sg & 8191, Rg = Sg >>> 13, kg = x0[7] | 0, Dg = kg & 8191, j0 = kg >>> 13, N0 = x0[8] | 0, R0 = N0 & 8191, Y0 = N0 >>> 13, Z0 = x0[9] | 0, q0 = Z0 & 8191, mg = Z0 >>> 13, Lg = _0[0] | 0, Tg = Lg & 8191, Og = Lg >>> 13, Pg = _0[1] | 0, Cg = Pg & 8191, Ug = Pg >>> 13, im = _0[2] | 0, jg = im & 8191, Yg = im >>> 13, om = _0[3] | 0, Gg = om & 8191, Wg = om >>> 13, sm = _0[4] | 0, Bg = sm & 8191, Vg = sm >>> 13, am = _0[5] | 0, Qg = am & 8191, Zg = am >>> 13, tm = _0[6] | 0, Fg = tm & 8191, Hg = tm >>> 13, rm = _0[7] | 0, Kg = rm & 8191, zg = rm >>> 13, cm = _0[8] | 0, qg = cm & 8191, Xg = cm >>> 13, zm = _0[9] | 0, Jg = zm & 8191, em = zm >>> 13;
      A0.negative = f0.negative ^ m0.negative, A0.length = 19, M0 = Math.imul(L0, Tg), p0 = Math.imul(L0, Og), p0 = p0 + Math.imul(B0, Tg) | 0, v0 = Math.imul(B0, Og);
      var pm = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (pm >>> 26) | 0, pm &= 67108863, M0 = Math.imul(V0, Tg), p0 = Math.imul(V0, Og), p0 = p0 + Math.imul(Q0, Tg) | 0, v0 = Math.imul(Q0, Og), M0 = M0 + Math.imul(L0, Cg) | 0, p0 = p0 + Math.imul(L0, Ug) | 0, p0 = p0 + Math.imul(B0, Cg) | 0, v0 = v0 + Math.imul(B0, Ug) | 0;
      var gm = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (gm >>> 26) | 0, gm &= 67108863, M0 = Math.imul(J0, Tg), p0 = Math.imul(J0, Og), p0 = p0 + Math.imul(yg, Tg) | 0, v0 = Math.imul(yg, Og), M0 = M0 + Math.imul(V0, Cg) | 0, p0 = p0 + Math.imul(V0, Ug) | 0, p0 = p0 + Math.imul(Q0, Cg) | 0, v0 = v0 + Math.imul(Q0, Ug) | 0, M0 = M0 + Math.imul(L0, jg) | 0, p0 = p0 + Math.imul(L0, Yg) | 0, p0 = p0 + Math.imul(B0, jg) | 0, v0 = v0 + Math.imul(B0, Yg) | 0;
      var mm = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (mm >>> 26) | 0, mm &= 67108863, M0 = Math.imul(wg, Tg), p0 = Math.imul(wg, Og), p0 = p0 + Math.imul($g, Tg) | 0, v0 = Math.imul($g, Og), M0 = M0 + Math.imul(J0, Cg) | 0, p0 = p0 + Math.imul(J0, Ug) | 0, p0 = p0 + Math.imul(yg, Cg) | 0, v0 = v0 + Math.imul(yg, Ug) | 0, M0 = M0 + Math.imul(V0, jg) | 0, p0 = p0 + Math.imul(V0, Yg) | 0, p0 = p0 + Math.imul(Q0, jg) | 0, v0 = v0 + Math.imul(Q0, Yg) | 0, M0 = M0 + Math.imul(L0, Gg) | 0, p0 = p0 + Math.imul(L0, Wg) | 0, p0 = p0 + Math.imul(B0, Gg) | 0, v0 = v0 + Math.imul(B0, Wg) | 0;
      var ym = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (ym >>> 26) | 0, ym &= 67108863, M0 = Math.imul(bg, Tg), p0 = Math.imul(bg, Og), p0 = p0 + Math.imul(vg, Tg) | 0, v0 = Math.imul(vg, Og), M0 = M0 + Math.imul(wg, Cg) | 0, p0 = p0 + Math.imul(wg, Ug) | 0, p0 = p0 + Math.imul($g, Cg) | 0, v0 = v0 + Math.imul($g, Ug) | 0, M0 = M0 + Math.imul(J0, jg) | 0, p0 = p0 + Math.imul(J0, Yg) | 0, p0 = p0 + Math.imul(yg, jg) | 0, v0 = v0 + Math.imul(yg, Yg) | 0, M0 = M0 + Math.imul(V0, Gg) | 0, p0 = p0 + Math.imul(V0, Wg) | 0, p0 = p0 + Math.imul(Q0, Gg) | 0, v0 = v0 + Math.imul(Q0, Wg) | 0, M0 = M0 + Math.imul(L0, Bg) | 0, p0 = p0 + Math.imul(L0, Vg) | 0, p0 = p0 + Math.imul(B0, Bg) | 0, v0 = v0 + Math.imul(B0, Vg) | 0;
      var wm = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (wm >>> 26) | 0, wm &= 67108863, M0 = Math.imul(Ig, Tg), p0 = Math.imul(Ig, Og), p0 = p0 + Math.imul(Mg, Tg) | 0, v0 = Math.imul(Mg, Og), M0 = M0 + Math.imul(bg, Cg) | 0, p0 = p0 + Math.imul(bg, Ug) | 0, p0 = p0 + Math.imul(vg, Cg) | 0, v0 = v0 + Math.imul(vg, Ug) | 0, M0 = M0 + Math.imul(wg, jg) | 0, p0 = p0 + Math.imul(wg, Yg) | 0, p0 = p0 + Math.imul($g, jg) | 0, v0 = v0 + Math.imul($g, Yg) | 0, M0 = M0 + Math.imul(J0, Gg) | 0, p0 = p0 + Math.imul(J0, Wg) | 0, p0 = p0 + Math.imul(yg, Gg) | 0, v0 = v0 + Math.imul(yg, Wg) | 0, M0 = M0 + Math.imul(V0, Bg) | 0, p0 = p0 + Math.imul(V0, Vg) | 0, p0 = p0 + Math.imul(Q0, Bg) | 0, v0 = v0 + Math.imul(Q0, Vg) | 0, M0 = M0 + Math.imul(L0, Qg) | 0, p0 = p0 + Math.imul(L0, Zg) | 0, p0 = p0 + Math.imul(B0, Qg) | 0, v0 = v0 + Math.imul(B0, Zg) | 0;
      var _m = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (_m >>> 26) | 0, _m &= 67108863, M0 = Math.imul(Ng, Tg), p0 = Math.imul(Ng, Og), p0 = p0 + Math.imul(Rg, Tg) | 0, v0 = Math.imul(Rg, Og), M0 = M0 + Math.imul(Ig, Cg) | 0, p0 = p0 + Math.imul(Ig, Ug) | 0, p0 = p0 + Math.imul(Mg, Cg) | 0, v0 = v0 + Math.imul(Mg, Ug) | 0, M0 = M0 + Math.imul(bg, jg) | 0, p0 = p0 + Math.imul(bg, Yg) | 0, p0 = p0 + Math.imul(vg, jg) | 0, v0 = v0 + Math.imul(vg, Yg) | 0, M0 = M0 + Math.imul(wg, Gg) | 0, p0 = p0 + Math.imul(wg, Wg) | 0, p0 = p0 + Math.imul($g, Gg) | 0, v0 = v0 + Math.imul($g, Wg) | 0, M0 = M0 + Math.imul(J0, Bg) | 0, p0 = p0 + Math.imul(J0, Vg) | 0, p0 = p0 + Math.imul(yg, Bg) | 0, v0 = v0 + Math.imul(yg, Vg) | 0, M0 = M0 + Math.imul(V0, Qg) | 0, p0 = p0 + Math.imul(V0, Zg) | 0, p0 = p0 + Math.imul(Q0, Qg) | 0, v0 = v0 + Math.imul(Q0, Zg) | 0, M0 = M0 + Math.imul(L0, Fg) | 0, p0 = p0 + Math.imul(L0, Hg) | 0, p0 = p0 + Math.imul(B0, Fg) | 0, v0 = v0 + Math.imul(B0, Hg) | 0;
      var bm = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (bm >>> 26) | 0, bm &= 67108863, M0 = Math.imul(Dg, Tg), p0 = Math.imul(Dg, Og), p0 = p0 + Math.imul(j0, Tg) | 0, v0 = Math.imul(j0, Og), M0 = M0 + Math.imul(Ng, Cg) | 0, p0 = p0 + Math.imul(Ng, Ug) | 0, p0 = p0 + Math.imul(Rg, Cg) | 0, v0 = v0 + Math.imul(Rg, Ug) | 0, M0 = M0 + Math.imul(Ig, jg) | 0, p0 = p0 + Math.imul(Ig, Yg) | 0, p0 = p0 + Math.imul(Mg, jg) | 0, v0 = v0 + Math.imul(Mg, Yg) | 0, M0 = M0 + Math.imul(bg, Gg) | 0, p0 = p0 + Math.imul(bg, Wg) | 0, p0 = p0 + Math.imul(vg, Gg) | 0, v0 = v0 + Math.imul(vg, Wg) | 0, M0 = M0 + Math.imul(wg, Bg) | 0, p0 = p0 + Math.imul(wg, Vg) | 0, p0 = p0 + Math.imul($g, Bg) | 0, v0 = v0 + Math.imul($g, Vg) | 0, M0 = M0 + Math.imul(J0, Qg) | 0, p0 = p0 + Math.imul(J0, Zg) | 0, p0 = p0 + Math.imul(yg, Qg) | 0, v0 = v0 + Math.imul(yg, Zg) | 0, M0 = M0 + Math.imul(V0, Fg) | 0, p0 = p0 + Math.imul(V0, Hg) | 0, p0 = p0 + Math.imul(Q0, Fg) | 0, v0 = v0 + Math.imul(Q0, Hg) | 0, M0 = M0 + Math.imul(L0, Kg) | 0, p0 = p0 + Math.imul(L0, zg) | 0, p0 = p0 + Math.imul(B0, Kg) | 0, v0 = v0 + Math.imul(B0, zg) | 0;
      var Em = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (Em >>> 26) | 0, Em &= 67108863, M0 = Math.imul(R0, Tg), p0 = Math.imul(R0, Og), p0 = p0 + Math.imul(Y0, Tg) | 0, v0 = Math.imul(Y0, Og), M0 = M0 + Math.imul(Dg, Cg) | 0, p0 = p0 + Math.imul(Dg, Ug) | 0, p0 = p0 + Math.imul(j0, Cg) | 0, v0 = v0 + Math.imul(j0, Ug) | 0, M0 = M0 + Math.imul(Ng, jg) | 0, p0 = p0 + Math.imul(Ng, Yg) | 0, p0 = p0 + Math.imul(Rg, jg) | 0, v0 = v0 + Math.imul(Rg, Yg) | 0, M0 = M0 + Math.imul(Ig, Gg) | 0, p0 = p0 + Math.imul(Ig, Wg) | 0, p0 = p0 + Math.imul(Mg, Gg) | 0, v0 = v0 + Math.imul(Mg, Wg) | 0, M0 = M0 + Math.imul(bg, Bg) | 0, p0 = p0 + Math.imul(bg, Vg) | 0, p0 = p0 + Math.imul(vg, Bg) | 0, v0 = v0 + Math.imul(vg, Vg) | 0, M0 = M0 + Math.imul(wg, Qg) | 0, p0 = p0 + Math.imul(wg, Zg) | 0, p0 = p0 + Math.imul($g, Qg) | 0, v0 = v0 + Math.imul($g, Zg) | 0, M0 = M0 + Math.imul(J0, Fg) | 0, p0 = p0 + Math.imul(J0, Hg) | 0, p0 = p0 + Math.imul(yg, Fg) | 0, v0 = v0 + Math.imul(yg, Hg) | 0, M0 = M0 + Math.imul(V0, Kg) | 0, p0 = p0 + Math.imul(V0, zg) | 0, p0 = p0 + Math.imul(Q0, Kg) | 0, v0 = v0 + Math.imul(Q0, zg) | 0, M0 = M0 + Math.imul(L0, qg) | 0, p0 = p0 + Math.imul(L0, Xg) | 0, p0 = p0 + Math.imul(B0, qg) | 0, v0 = v0 + Math.imul(B0, Xg) | 0;
      var $m = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + ($m >>> 26) | 0, $m &= 67108863, M0 = Math.imul(q0, Tg), p0 = Math.imul(q0, Og), p0 = p0 + Math.imul(mg, Tg) | 0, v0 = Math.imul(mg, Og), M0 = M0 + Math.imul(R0, Cg) | 0, p0 = p0 + Math.imul(R0, Ug) | 0, p0 = p0 + Math.imul(Y0, Cg) | 0, v0 = v0 + Math.imul(Y0, Ug) | 0, M0 = M0 + Math.imul(Dg, jg) | 0, p0 = p0 + Math.imul(Dg, Yg) | 0, p0 = p0 + Math.imul(j0, jg) | 0, v0 = v0 + Math.imul(j0, Yg) | 0, M0 = M0 + Math.imul(Ng, Gg) | 0, p0 = p0 + Math.imul(Ng, Wg) | 0, p0 = p0 + Math.imul(Rg, Gg) | 0, v0 = v0 + Math.imul(Rg, Wg) | 0, M0 = M0 + Math.imul(Ig, Bg) | 0, p0 = p0 + Math.imul(Ig, Vg) | 0, p0 = p0 + Math.imul(Mg, Bg) | 0, v0 = v0 + Math.imul(Mg, Vg) | 0, M0 = M0 + Math.imul(bg, Qg) | 0, p0 = p0 + Math.imul(bg, Zg) | 0, p0 = p0 + Math.imul(vg, Qg) | 0, v0 = v0 + Math.imul(vg, Zg) | 0, M0 = M0 + Math.imul(wg, Fg) | 0, p0 = p0 + Math.imul(wg, Hg) | 0, p0 = p0 + Math.imul($g, Fg) | 0, v0 = v0 + Math.imul($g, Hg) | 0, M0 = M0 + Math.imul(J0, Kg) | 0, p0 = p0 + Math.imul(J0, zg) | 0, p0 = p0 + Math.imul(yg, Kg) | 0, v0 = v0 + Math.imul(yg, zg) | 0, M0 = M0 + Math.imul(V0, qg) | 0, p0 = p0 + Math.imul(V0, Xg) | 0, p0 = p0 + Math.imul(Q0, qg) | 0, v0 = v0 + Math.imul(Q0, Xg) | 0, M0 = M0 + Math.imul(L0, Jg) | 0, p0 = p0 + Math.imul(L0, em) | 0, p0 = p0 + Math.imul(B0, Jg) | 0, v0 = v0 + Math.imul(B0, em) | 0;
      var Am = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (Am >>> 26) | 0, Am &= 67108863, M0 = Math.imul(q0, Cg), p0 = Math.imul(q0, Ug), p0 = p0 + Math.imul(mg, Cg) | 0, v0 = Math.imul(mg, Ug), M0 = M0 + Math.imul(R0, jg) | 0, p0 = p0 + Math.imul(R0, Yg) | 0, p0 = p0 + Math.imul(Y0, jg) | 0, v0 = v0 + Math.imul(Y0, Yg) | 0, M0 = M0 + Math.imul(Dg, Gg) | 0, p0 = p0 + Math.imul(Dg, Wg) | 0, p0 = p0 + Math.imul(j0, Gg) | 0, v0 = v0 + Math.imul(j0, Wg) | 0, M0 = M0 + Math.imul(Ng, Bg) | 0, p0 = p0 + Math.imul(Ng, Vg) | 0, p0 = p0 + Math.imul(Rg, Bg) | 0, v0 = v0 + Math.imul(Rg, Vg) | 0, M0 = M0 + Math.imul(Ig, Qg) | 0, p0 = p0 + Math.imul(Ig, Zg) | 0, p0 = p0 + Math.imul(Mg, Qg) | 0, v0 = v0 + Math.imul(Mg, Zg) | 0, M0 = M0 + Math.imul(bg, Fg) | 0, p0 = p0 + Math.imul(bg, Hg) | 0, p0 = p0 + Math.imul(vg, Fg) | 0, v0 = v0 + Math.imul(vg, Hg) | 0, M0 = M0 + Math.imul(wg, Kg) | 0, p0 = p0 + Math.imul(wg, zg) | 0, p0 = p0 + Math.imul($g, Kg) | 0, v0 = v0 + Math.imul($g, zg) | 0, M0 = M0 + Math.imul(J0, qg) | 0, p0 = p0 + Math.imul(J0, Xg) | 0, p0 = p0 + Math.imul(yg, qg) | 0, v0 = v0 + Math.imul(yg, Xg) | 0, M0 = M0 + Math.imul(V0, Jg) | 0, p0 = p0 + Math.imul(V0, em) | 0, p0 = p0 + Math.imul(Q0, Jg) | 0, v0 = v0 + Math.imul(Q0, em) | 0;
      var Mm = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (Mm >>> 26) | 0, Mm &= 67108863, M0 = Math.imul(q0, jg), p0 = Math.imul(q0, Yg), p0 = p0 + Math.imul(mg, jg) | 0, v0 = Math.imul(mg, Yg), M0 = M0 + Math.imul(R0, Gg) | 0, p0 = p0 + Math.imul(R0, Wg) | 0, p0 = p0 + Math.imul(Y0, Gg) | 0, v0 = v0 + Math.imul(Y0, Wg) | 0, M0 = M0 + Math.imul(Dg, Bg) | 0, p0 = p0 + Math.imul(Dg, Vg) | 0, p0 = p0 + Math.imul(j0, Bg) | 0, v0 = v0 + Math.imul(j0, Vg) | 0, M0 = M0 + Math.imul(Ng, Qg) | 0, p0 = p0 + Math.imul(Ng, Zg) | 0, p0 = p0 + Math.imul(Rg, Qg) | 0, v0 = v0 + Math.imul(Rg, Zg) | 0, M0 = M0 + Math.imul(Ig, Fg) | 0, p0 = p0 + Math.imul(Ig, Hg) | 0, p0 = p0 + Math.imul(Mg, Fg) | 0, v0 = v0 + Math.imul(Mg, Hg) | 0, M0 = M0 + Math.imul(bg, Kg) | 0, p0 = p0 + Math.imul(bg, zg) | 0, p0 = p0 + Math.imul(vg, Kg) | 0, v0 = v0 + Math.imul(vg, zg) | 0, M0 = M0 + Math.imul(wg, qg) | 0, p0 = p0 + Math.imul(wg, Xg) | 0, p0 = p0 + Math.imul($g, qg) | 0, v0 = v0 + Math.imul($g, Xg) | 0, M0 = M0 + Math.imul(J0, Jg) | 0, p0 = p0 + Math.imul(J0, em) | 0, p0 = p0 + Math.imul(yg, Jg) | 0, v0 = v0 + Math.imul(yg, em) | 0;
      var Nm = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (Nm >>> 26) | 0, Nm &= 67108863, M0 = Math.imul(q0, Gg), p0 = Math.imul(q0, Wg), p0 = p0 + Math.imul(mg, Gg) | 0, v0 = Math.imul(mg, Wg), M0 = M0 + Math.imul(R0, Bg) | 0, p0 = p0 + Math.imul(R0, Vg) | 0, p0 = p0 + Math.imul(Y0, Bg) | 0, v0 = v0 + Math.imul(Y0, Vg) | 0, M0 = M0 + Math.imul(Dg, Qg) | 0, p0 = p0 + Math.imul(Dg, Zg) | 0, p0 = p0 + Math.imul(j0, Qg) | 0, v0 = v0 + Math.imul(j0, Zg) | 0, M0 = M0 + Math.imul(Ng, Fg) | 0, p0 = p0 + Math.imul(Ng, Hg) | 0, p0 = p0 + Math.imul(Rg, Fg) | 0, v0 = v0 + Math.imul(Rg, Hg) | 0, M0 = M0 + Math.imul(Ig, Kg) | 0, p0 = p0 + Math.imul(Ig, zg) | 0, p0 = p0 + Math.imul(Mg, Kg) | 0, v0 = v0 + Math.imul(Mg, zg) | 0, M0 = M0 + Math.imul(bg, qg) | 0, p0 = p0 + Math.imul(bg, Xg) | 0, p0 = p0 + Math.imul(vg, qg) | 0, v0 = v0 + Math.imul(vg, Xg) | 0, M0 = M0 + Math.imul(wg, Jg) | 0, p0 = p0 + Math.imul(wg, em) | 0, p0 = p0 + Math.imul($g, Jg) | 0, v0 = v0 + Math.imul($g, em) | 0;
      var Im = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (Im >>> 26) | 0, Im &= 67108863, M0 = Math.imul(q0, Bg), p0 = Math.imul(q0, Vg), p0 = p0 + Math.imul(mg, Bg) | 0, v0 = Math.imul(mg, Vg), M0 = M0 + Math.imul(R0, Qg) | 0, p0 = p0 + Math.imul(R0, Zg) | 0, p0 = p0 + Math.imul(Y0, Qg) | 0, v0 = v0 + Math.imul(Y0, Zg) | 0, M0 = M0 + Math.imul(Dg, Fg) | 0, p0 = p0 + Math.imul(Dg, Hg) | 0, p0 = p0 + Math.imul(j0, Fg) | 0, v0 = v0 + Math.imul(j0, Hg) | 0, M0 = M0 + Math.imul(Ng, Kg) | 0, p0 = p0 + Math.imul(Ng, zg) | 0, p0 = p0 + Math.imul(Rg, Kg) | 0, v0 = v0 + Math.imul(Rg, zg) | 0, M0 = M0 + Math.imul(Ig, qg) | 0, p0 = p0 + Math.imul(Ig, Xg) | 0, p0 = p0 + Math.imul(Mg, qg) | 0, v0 = v0 + Math.imul(Mg, Xg) | 0, M0 = M0 + Math.imul(bg, Jg) | 0, p0 = p0 + Math.imul(bg, em) | 0, p0 = p0 + Math.imul(vg, Jg) | 0, v0 = v0 + Math.imul(vg, em) | 0;
      var Sm = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (Sm >>> 26) | 0, Sm &= 67108863, M0 = Math.imul(q0, Qg), p0 = Math.imul(q0, Zg), p0 = p0 + Math.imul(mg, Qg) | 0, v0 = Math.imul(mg, Zg), M0 = M0 + Math.imul(R0, Fg) | 0, p0 = p0 + Math.imul(R0, Hg) | 0, p0 = p0 + Math.imul(Y0, Fg) | 0, v0 = v0 + Math.imul(Y0, Hg) | 0, M0 = M0 + Math.imul(Dg, Kg) | 0, p0 = p0 + Math.imul(Dg, zg) | 0, p0 = p0 + Math.imul(j0, Kg) | 0, v0 = v0 + Math.imul(j0, zg) | 0, M0 = M0 + Math.imul(Ng, qg) | 0, p0 = p0 + Math.imul(Ng, Xg) | 0, p0 = p0 + Math.imul(Rg, qg) | 0, v0 = v0 + Math.imul(Rg, Xg) | 0, M0 = M0 + Math.imul(Ig, Jg) | 0, p0 = p0 + Math.imul(Ig, em) | 0, p0 = p0 + Math.imul(Mg, Jg) | 0, v0 = v0 + Math.imul(Mg, em) | 0;
      var Rm = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (Rm >>> 26) | 0, Rm &= 67108863, M0 = Math.imul(q0, Fg), p0 = Math.imul(q0, Hg), p0 = p0 + Math.imul(mg, Fg) | 0, v0 = Math.imul(mg, Hg), M0 = M0 + Math.imul(R0, Kg) | 0, p0 = p0 + Math.imul(R0, zg) | 0, p0 = p0 + Math.imul(Y0, Kg) | 0, v0 = v0 + Math.imul(Y0, zg) | 0, M0 = M0 + Math.imul(Dg, qg) | 0, p0 = p0 + Math.imul(Dg, Xg) | 0, p0 = p0 + Math.imul(j0, qg) | 0, v0 = v0 + Math.imul(j0, Xg) | 0, M0 = M0 + Math.imul(Ng, Jg) | 0, p0 = p0 + Math.imul(Ng, em) | 0, p0 = p0 + Math.imul(Rg, Jg) | 0, v0 = v0 + Math.imul(Rg, em) | 0;
      var Cm = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (Cm >>> 26) | 0, Cm &= 67108863, M0 = Math.imul(q0, Kg), p0 = Math.imul(q0, zg), p0 = p0 + Math.imul(mg, Kg) | 0, v0 = Math.imul(mg, zg), M0 = M0 + Math.imul(R0, qg) | 0, p0 = p0 + Math.imul(R0, Xg) | 0, p0 = p0 + Math.imul(Y0, qg) | 0, v0 = v0 + Math.imul(Y0, Xg) | 0, M0 = M0 + Math.imul(Dg, Jg) | 0, p0 = p0 + Math.imul(Dg, em) | 0, p0 = p0 + Math.imul(j0, Jg) | 0, v0 = v0 + Math.imul(j0, em) | 0;
      var Om = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (Om >>> 26) | 0, Om &= 67108863, M0 = Math.imul(q0, qg), p0 = Math.imul(q0, Xg), p0 = p0 + Math.imul(mg, qg) | 0, v0 = Math.imul(mg, Xg), M0 = M0 + Math.imul(R0, Jg) | 0, p0 = p0 + Math.imul(R0, em) | 0, p0 = p0 + Math.imul(Y0, Jg) | 0, v0 = v0 + Math.imul(Y0, em) | 0;
      var xm = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      C0 = (v0 + (p0 >>> 13) | 0) + (xm >>> 26) | 0, xm &= 67108863, M0 = Math.imul(q0, Jg), p0 = Math.imul(q0, em), p0 = p0 + Math.imul(mg, Jg) | 0, v0 = Math.imul(mg, em);
      var Tm = (C0 + M0 | 0) + ((p0 & 8191) << 13) | 0;
      return C0 = (v0 + (p0 >>> 13) | 0) + (Tm >>> 26) | 0, Tm &= 67108863, $0[0] = pm, $0[1] = gm, $0[2] = mm, $0[3] = ym, $0[4] = wm, $0[5] = _m, $0[6] = bm, $0[7] = Em, $0[8] = $m, $0[9] = Am, $0[10] = Mm, $0[11] = Nm, $0[12] = Im, $0[13] = Sm, $0[14] = Rm, $0[15] = Cm, $0[16] = Om, $0[17] = xm, $0[18] = Tm, C0 !== 0 && ($0[19] = C0, A0.length++), A0;
    };
    Math.imul || (O0 = b0);
    function S0(I0, f0, m0) {
      m0.negative = f0.negative ^ I0.negative, m0.length = I0.length + f0.length;
      for (var A0 = 0, x0 = 0, _0 = 0; _0 < m0.length - 1; _0++) {
        var $0 = x0;
        x0 = 0;
        for (var C0 = A0 & 67108863, M0 = Math.min(_0, f0.length - 1), p0 = Math.max(0, _0 - I0.length + 1); p0 <= M0; p0++) {
          var v0 = _0 - p0, T0 = I0.words[v0] | 0, L0 = f0.words[p0] | 0, B0 = T0 * L0, W0 = B0 & 67108863;
          $0 = $0 + (B0 / 67108864 | 0) | 0, W0 = W0 + C0 | 0, C0 = W0 & 67108863, $0 = $0 + (W0 >>> 26) | 0, x0 += $0 >>> 26, $0 &= 67108863;
        }
        m0.words[_0] = C0, A0 = $0, $0 = x0;
      }
      return A0 !== 0 ? m0.words[_0] = A0 : m0.length--, m0._strip();
    }
    function k0(I0, f0, m0) {
      return S0(I0, f0, m0);
    }
    o0.prototype.mulTo = function(f0, m0) {
      var A0, x0 = this.length + f0.length;
      return this.length === 10 && f0.length === 10 ? A0 = O0(this, f0, m0) : x0 < 63 ? A0 = b0(this, f0, m0) : x0 < 1024 ? A0 = S0(this, f0, m0) : A0 = k0(this, f0, m0), A0;
    }, o0.prototype.mul = function(f0) {
      var m0 = new o0(null);
      return m0.words = new Array(this.length + f0.length), this.mulTo(f0, m0);
    }, o0.prototype.mulf = function(f0) {
      var m0 = new o0(null);
      return m0.words = new Array(this.length + f0.length), k0(this, f0, m0);
    }, o0.prototype.imul = function(f0) {
      return this.clone().mulTo(f0, this);
    }, o0.prototype.imuln = function(f0) {
      var m0 = f0 < 0;
      m0 && (f0 = -f0), r0(typeof f0 == "number"), r0(f0 < 67108864);
      for (var A0 = 0, x0 = 0; x0 < this.length; x0++) {
        var _0 = (this.words[x0] | 0) * f0, $0 = (_0 & 67108863) + (A0 & 67108863);
        A0 >>= 26, A0 += _0 / 67108864 | 0, A0 += $0 >>> 26, this.words[x0] = $0 & 67108863;
      }
      return A0 !== 0 && (this.words[x0] = A0, this.length++), m0 ? this.ineg() : this;
    }, o0.prototype.muln = function(f0) {
      return this.clone().imuln(f0);
    }, o0.prototype.sqr = function() {
      return this.mul(this);
    }, o0.prototype.isqr = function() {
      return this.imul(this.clone());
    }, o0.prototype.pow = function(f0) {
      var m0 = E0(f0);
      if (m0.length === 0)
        return new o0(1);
      for (var A0 = this, x0 = 0; x0 < m0.length && m0[x0] === 0; x0++, A0 = A0.sqr())
        ;
      if (++x0 < m0.length)
        for (var _0 = A0.sqr(); x0 < m0.length; x0++, _0 = _0.sqr())
          m0[x0] !== 0 && (A0 = A0.mul(_0));
      return A0;
    }, o0.prototype.iushln = function(f0) {
      r0(typeof f0 == "number" && f0 >= 0);
      var m0 = f0 % 26, A0 = (f0 - m0) / 26, x0 = 67108863 >>> 26 - m0 << 26 - m0, _0;
      if (m0 !== 0) {
        var $0 = 0;
        for (_0 = 0; _0 < this.length; _0++) {
          var C0 = this.words[_0] & x0, M0 = (this.words[_0] | 0) - C0 << m0;
          this.words[_0] = M0 | $0, $0 = C0 >>> 26 - m0;
        }
        $0 && (this.words[_0] = $0, this.length++);
      }
      if (A0 !== 0) {
        for (_0 = this.length - 1; _0 >= 0; _0--)
          this.words[_0 + A0] = this.words[_0];
        for (_0 = 0; _0 < A0; _0++)
          this.words[_0] = 0;
        this.length += A0;
      }
      return this._strip();
    }, o0.prototype.ishln = function(f0) {
      return r0(this.negative === 0), this.iushln(f0);
    }, o0.prototype.iushrn = function(f0, m0, A0) {
      r0(typeof f0 == "number" && f0 >= 0);
      var x0;
      m0 ? x0 = (m0 - m0 % 26) / 26 : x0 = 0;
      var _0 = f0 % 26, $0 = Math.min((f0 - _0) / 26, this.length), C0 = 67108863 ^ 67108863 >>> _0 << _0, M0 = A0;
      if (x0 -= $0, x0 = Math.max(0, x0), M0) {
        for (var p0 = 0; p0 < $0; p0++)
          M0.words[p0] = this.words[p0];
        M0.length = $0;
      }
      if ($0 !== 0)
        if (this.length > $0)
          for (this.length -= $0, p0 = 0; p0 < this.length; p0++)
            this.words[p0] = this.words[p0 + $0];
        else
          this.words[0] = 0, this.length = 1;
      var v0 = 0;
      for (p0 = this.length - 1; p0 >= 0 && (v0 !== 0 || p0 >= x0); p0--) {
        var T0 = this.words[p0] | 0;
        this.words[p0] = v0 << 26 - _0 | T0 >>> _0, v0 = T0 & C0;
      }
      return M0 && v0 !== 0 && (M0.words[M0.length++] = v0), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, o0.prototype.ishrn = function(f0, m0, A0) {
      return r0(this.negative === 0), this.iushrn(f0, m0, A0);
    }, o0.prototype.shln = function(f0) {
      return this.clone().ishln(f0);
    }, o0.prototype.ushln = function(f0) {
      return this.clone().iushln(f0);
    }, o0.prototype.shrn = function(f0) {
      return this.clone().ishrn(f0);
    }, o0.prototype.ushrn = function(f0) {
      return this.clone().iushrn(f0);
    }, o0.prototype.testn = function(f0) {
      r0(typeof f0 == "number" && f0 >= 0);
      var m0 = f0 % 26, A0 = (f0 - m0) / 26, x0 = 1 << m0;
      if (this.length <= A0)
        return !1;
      var _0 = this.words[A0];
      return !!(_0 & x0);
    }, o0.prototype.imaskn = function(f0) {
      r0(typeof f0 == "number" && f0 >= 0);
      var m0 = f0 % 26, A0 = (f0 - m0) / 26;
      if (r0(this.negative === 0, "imaskn works only with positive numbers"), this.length <= A0)
        return this;
      if (m0 !== 0 && A0++, this.length = Math.min(A0, this.length), m0 !== 0) {
        var x0 = 67108863 ^ 67108863 >>> m0 << m0;
        this.words[this.length - 1] &= x0;
      }
      return this._strip();
    }, o0.prototype.maskn = function(f0) {
      return this.clone().imaskn(f0);
    }, o0.prototype.iaddn = function(f0) {
      return r0(typeof f0 == "number"), r0(f0 < 67108864), f0 < 0 ? this.isubn(-f0) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f0 ? (this.words[0] = f0 - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f0), this.negative = 1, this) : this._iaddn(f0);
    }, o0.prototype._iaddn = function(f0) {
      this.words[0] += f0;
      for (var m0 = 0; m0 < this.length && this.words[m0] >= 67108864; m0++)
        this.words[m0] -= 67108864, m0 === this.length - 1 ? this.words[m0 + 1] = 1 : this.words[m0 + 1]++;
      return this.length = Math.max(this.length, m0 + 1), this;
    }, o0.prototype.isubn = function(f0) {
      if (r0(typeof f0 == "number"), r0(f0 < 67108864), f0 < 0)
        return this.iaddn(-f0);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(f0), this.negative = 1, this;
      if (this.words[0] -= f0, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var m0 = 0; m0 < this.length && this.words[m0] < 0; m0++)
          this.words[m0] += 67108864, this.words[m0 + 1] -= 1;
      return this._strip();
    }, o0.prototype.addn = function(f0) {
      return this.clone().iaddn(f0);
    }, o0.prototype.subn = function(f0) {
      return this.clone().isubn(f0);
    }, o0.prototype.iabs = function() {
      return this.negative = 0, this;
    }, o0.prototype.abs = function() {
      return this.clone().iabs();
    }, o0.prototype._ishlnsubmul = function(f0, m0, A0) {
      var x0 = f0.length + A0, _0;
      this._expand(x0);
      var $0, C0 = 0;
      for (_0 = 0; _0 < f0.length; _0++) {
        $0 = (this.words[_0 + A0] | 0) + C0;
        var M0 = (f0.words[_0] | 0) * m0;
        $0 -= M0 & 67108863, C0 = ($0 >> 26) - (M0 / 67108864 | 0), this.words[_0 + A0] = $0 & 67108863;
      }
      for (; _0 < this.length - A0; _0++)
        $0 = (this.words[_0 + A0] | 0) + C0, C0 = $0 >> 26, this.words[_0 + A0] = $0 & 67108863;
      if (C0 === 0)
        return this._strip();
      for (r0(C0 === -1), C0 = 0, _0 = 0; _0 < this.length; _0++)
        $0 = -(this.words[_0] | 0) + C0, C0 = $0 >> 26, this.words[_0] = $0 & 67108863;
      return this.negative = 1, this._strip();
    }, o0.prototype._wordDiv = function(f0, m0) {
      var A0 = this.length - f0.length, x0 = this.clone(), _0 = f0, $0 = _0.words[_0.length - 1] | 0, C0 = this._countBits($0);
      A0 = 26 - C0, A0 !== 0 && (_0 = _0.ushln(A0), x0.iushln(A0), $0 = _0.words[_0.length - 1] | 0);
      var M0 = x0.length - _0.length, p0;
      if (m0 !== "mod") {
        p0 = new o0(null), p0.length = M0 + 1, p0.words = new Array(p0.length);
        for (var v0 = 0; v0 < p0.length; v0++)
          p0.words[v0] = 0;
      }
      var T0 = x0.clone()._ishlnsubmul(_0, 1, M0);
      T0.negative === 0 && (x0 = T0, p0 && (p0.words[M0] = 1));
      for (var L0 = M0 - 1; L0 >= 0; L0--) {
        var B0 = (x0.words[_0.length + L0] | 0) * 67108864 + (x0.words[_0.length + L0 - 1] | 0);
        for (B0 = Math.min(B0 / $0 | 0, 67108863), x0._ishlnsubmul(_0, B0, L0); x0.negative !== 0; )
          B0--, x0.negative = 0, x0._ishlnsubmul(_0, 1, L0), x0.isZero() || (x0.negative ^= 1);
        p0 && (p0.words[L0] = B0);
      }
      return p0 && p0._strip(), x0._strip(), m0 !== "div" && A0 !== 0 && x0.iushrn(A0), {
        div: p0 || null,
        mod: x0
      };
    }, o0.prototype.divmod = function(f0, m0, A0) {
      if (r0(!f0.isZero()), this.isZero())
        return {
          div: new o0(0),
          mod: new o0(0)
        };
      var x0, _0, $0;
      return this.negative !== 0 && f0.negative === 0 ? ($0 = this.neg().divmod(f0, m0), m0 !== "mod" && (x0 = $0.div.neg()), m0 !== "div" && (_0 = $0.mod.neg(), A0 && _0.negative !== 0 && _0.iadd(f0)), {
        div: x0,
        mod: _0
      }) : this.negative === 0 && f0.negative !== 0 ? ($0 = this.divmod(f0.neg(), m0), m0 !== "mod" && (x0 = $0.div.neg()), {
        div: x0,
        mod: $0.mod
      }) : this.negative & f0.negative ? ($0 = this.neg().divmod(f0.neg(), m0), m0 !== "div" && (_0 = $0.mod.neg(), A0 && _0.negative !== 0 && _0.isub(f0)), {
        div: $0.div,
        mod: _0
      }) : f0.length > this.length || this.cmp(f0) < 0 ? {
        div: new o0(0),
        mod: this
      } : f0.length === 1 ? m0 === "div" ? {
        div: this.divn(f0.words[0]),
        mod: null
      } : m0 === "mod" ? {
        div: null,
        mod: new o0(this.modrn(f0.words[0]))
      } : {
        div: this.divn(f0.words[0]),
        mod: new o0(this.modrn(f0.words[0]))
      } : this._wordDiv(f0, m0);
    }, o0.prototype.div = function(f0) {
      return this.divmod(f0, "div", !1).div;
    }, o0.prototype.mod = function(f0) {
      return this.divmod(f0, "mod", !1).mod;
    }, o0.prototype.umod = function(f0) {
      return this.divmod(f0, "mod", !0).mod;
    }, o0.prototype.divRound = function(f0) {
      var m0 = this.divmod(f0);
      if (m0.mod.isZero())
        return m0.div;
      var A0 = m0.div.negative !== 0 ? m0.mod.isub(f0) : m0.mod, x0 = f0.ushrn(1), _0 = f0.andln(1), $0 = A0.cmp(x0);
      return $0 < 0 || _0 === 1 && $0 === 0 ? m0.div : m0.div.negative !== 0 ? m0.div.isubn(1) : m0.div.iaddn(1);
    }, o0.prototype.modrn = function(f0) {
      var m0 = f0 < 0;
      m0 && (f0 = -f0), r0(f0 <= 67108863);
      for (var A0 = (1 << 26) % f0, x0 = 0, _0 = this.length - 1; _0 >= 0; _0--)
        x0 = (A0 * x0 + (this.words[_0] | 0)) % f0;
      return m0 ? -x0 : x0;
    }, o0.prototype.modn = function(f0) {
      return this.modrn(f0);
    }, o0.prototype.idivn = function(f0) {
      var m0 = f0 < 0;
      m0 && (f0 = -f0), r0(f0 <= 67108863);
      for (var A0 = 0, x0 = this.length - 1; x0 >= 0; x0--) {
        var _0 = (this.words[x0] | 0) + A0 * 67108864;
        this.words[x0] = _0 / f0 | 0, A0 = _0 % f0;
      }
      return this._strip(), m0 ? this.ineg() : this;
    }, o0.prototype.divn = function(f0) {
      return this.clone().idivn(f0);
    }, o0.prototype.egcd = function(f0) {
      r0(f0.negative === 0), r0(!f0.isZero());
      var m0 = this, A0 = f0.clone();
      m0.negative !== 0 ? m0 = m0.umod(f0) : m0 = m0.clone();
      for (var x0 = new o0(1), _0 = new o0(0), $0 = new o0(0), C0 = new o0(1), M0 = 0; m0.isEven() && A0.isEven(); )
        m0.iushrn(1), A0.iushrn(1), ++M0;
      for (var p0 = A0.clone(), v0 = m0.clone(); !m0.isZero(); ) {
        for (var T0 = 0, L0 = 1; !(m0.words[0] & L0) && T0 < 26; ++T0, L0 <<= 1)
          ;
        if (T0 > 0)
          for (m0.iushrn(T0); T0-- > 0; )
            (x0.isOdd() || _0.isOdd()) && (x0.iadd(p0), _0.isub(v0)), x0.iushrn(1), _0.iushrn(1);
        for (var B0 = 0, W0 = 1; !(A0.words[0] & W0) && B0 < 26; ++B0, W0 <<= 1)
          ;
        if (B0 > 0)
          for (A0.iushrn(B0); B0-- > 0; )
            ($0.isOdd() || C0.isOdd()) && ($0.iadd(p0), C0.isub(v0)), $0.iushrn(1), C0.iushrn(1);
        m0.cmp(A0) >= 0 ? (m0.isub(A0), x0.isub($0), _0.isub(C0)) : (A0.isub(m0), $0.isub(x0), C0.isub(_0));
      }
      return {
        a: $0,
        b: C0,
        gcd: A0.iushln(M0)
      };
    }, o0.prototype._invmp = function(f0) {
      r0(f0.negative === 0), r0(!f0.isZero());
      var m0 = this, A0 = f0.clone();
      m0.negative !== 0 ? m0 = m0.umod(f0) : m0 = m0.clone();
      for (var x0 = new o0(1), _0 = new o0(0), $0 = A0.clone(); m0.cmpn(1) > 0 && A0.cmpn(1) > 0; ) {
        for (var C0 = 0, M0 = 1; !(m0.words[0] & M0) && C0 < 26; ++C0, M0 <<= 1)
          ;
        if (C0 > 0)
          for (m0.iushrn(C0); C0-- > 0; )
            x0.isOdd() && x0.iadd($0), x0.iushrn(1);
        for (var p0 = 0, v0 = 1; !(A0.words[0] & v0) && p0 < 26; ++p0, v0 <<= 1)
          ;
        if (p0 > 0)
          for (A0.iushrn(p0); p0-- > 0; )
            _0.isOdd() && _0.iadd($0), _0.iushrn(1);
        m0.cmp(A0) >= 0 ? (m0.isub(A0), x0.isub(_0)) : (A0.isub(m0), _0.isub(x0));
      }
      var T0;
      return m0.cmpn(1) === 0 ? T0 = x0 : T0 = _0, T0.cmpn(0) < 0 && T0.iadd(f0), T0;
    }, o0.prototype.gcd = function(f0) {
      if (this.isZero())
        return f0.abs();
      if (f0.isZero())
        return this.abs();
      var m0 = this.clone(), A0 = f0.clone();
      m0.negative = 0, A0.negative = 0;
      for (var x0 = 0; m0.isEven() && A0.isEven(); x0++)
        m0.iushrn(1), A0.iushrn(1);
      do {
        for (; m0.isEven(); )
          m0.iushrn(1);
        for (; A0.isEven(); )
          A0.iushrn(1);
        var _0 = m0.cmp(A0);
        if (_0 < 0) {
          var $0 = m0;
          m0 = A0, A0 = $0;
        } else if (_0 === 0 || A0.cmpn(1) === 0)
          break;
        m0.isub(A0);
      } while (!0);
      return A0.iushln(x0);
    }, o0.prototype.invm = function(f0) {
      return this.egcd(f0).a.umod(f0);
    }, o0.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, o0.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, o0.prototype.andln = function(f0) {
      return this.words[0] & f0;
    }, o0.prototype.bincn = function(f0) {
      r0(typeof f0 == "number");
      var m0 = f0 % 26, A0 = (f0 - m0) / 26, x0 = 1 << m0;
      if (this.length <= A0)
        return this._expand(A0 + 1), this.words[A0] |= x0, this;
      for (var _0 = x0, $0 = A0; _0 !== 0 && $0 < this.length; $0++) {
        var C0 = this.words[$0] | 0;
        C0 += _0, _0 = C0 >>> 26, C0 &= 67108863, this.words[$0] = C0;
      }
      return _0 !== 0 && (this.words[$0] = _0, this.length++), this;
    }, o0.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, o0.prototype.cmpn = function(f0) {
      var m0 = f0 < 0;
      if (this.negative !== 0 && !m0)
        return -1;
      if (this.negative === 0 && m0)
        return 1;
      this._strip();
      var A0;
      if (this.length > 1)
        A0 = 1;
      else {
        m0 && (f0 = -f0), r0(f0 <= 67108863, "Number is too big");
        var x0 = this.words[0] | 0;
        A0 = x0 === f0 ? 0 : x0 < f0 ? -1 : 1;
      }
      return this.negative !== 0 ? -A0 | 0 : A0;
    }, o0.prototype.cmp = function(f0) {
      if (this.negative !== 0 && f0.negative === 0)
        return -1;
      if (this.negative === 0 && f0.negative !== 0)
        return 1;
      var m0 = this.ucmp(f0);
      return this.negative !== 0 ? -m0 | 0 : m0;
    }, o0.prototype.ucmp = function(f0) {
      if (this.length > f0.length)
        return 1;
      if (this.length < f0.length)
        return -1;
      for (var m0 = 0, A0 = this.length - 1; A0 >= 0; A0--) {
        var x0 = this.words[A0] | 0, _0 = f0.words[A0] | 0;
        if (x0 !== _0) {
          x0 < _0 ? m0 = -1 : x0 > _0 && (m0 = 1);
          break;
        }
      }
      return m0;
    }, o0.prototype.gtn = function(f0) {
      return this.cmpn(f0) === 1;
    }, o0.prototype.gt = function(f0) {
      return this.cmp(f0) === 1;
    }, o0.prototype.gten = function(f0) {
      return this.cmpn(f0) >= 0;
    }, o0.prototype.gte = function(f0) {
      return this.cmp(f0) >= 0;
    }, o0.prototype.ltn = function(f0) {
      return this.cmpn(f0) === -1;
    }, o0.prototype.lt = function(f0) {
      return this.cmp(f0) === -1;
    }, o0.prototype.lten = function(f0) {
      return this.cmpn(f0) <= 0;
    }, o0.prototype.lte = function(f0) {
      return this.cmp(f0) <= 0;
    }, o0.prototype.eqn = function(f0) {
      return this.cmpn(f0) === 0;
    }, o0.prototype.eq = function(f0) {
      return this.cmp(f0) === 0;
    }, o0.red = function(f0) {
      return new H0(f0);
    }, o0.prototype.toRed = function(f0) {
      return r0(!this.red, "Already a number in reduction context"), r0(this.negative === 0, "red works only with positives"), f0.convertTo(this)._forceRed(f0);
    }, o0.prototype.fromRed = function() {
      return r0(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, o0.prototype._forceRed = function(f0) {
      return this.red = f0, this;
    }, o0.prototype.forceRed = function(f0) {
      return r0(!this.red, "Already a number in reduction context"), this._forceRed(f0);
    }, o0.prototype.redAdd = function(f0) {
      return r0(this.red, "redAdd works only with red numbers"), this.red.add(this, f0);
    }, o0.prototype.redIAdd = function(f0) {
      return r0(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f0);
    }, o0.prototype.redSub = function(f0) {
      return r0(this.red, "redSub works only with red numbers"), this.red.sub(this, f0);
    }, o0.prototype.redISub = function(f0) {
      return r0(this.red, "redISub works only with red numbers"), this.red.isub(this, f0);
    }, o0.prototype.redShl = function(f0) {
      return r0(this.red, "redShl works only with red numbers"), this.red.shl(this, f0);
    }, o0.prototype.redMul = function(f0) {
      return r0(this.red, "redMul works only with red numbers"), this.red._verify2(this, f0), this.red.mul(this, f0);
    }, o0.prototype.redIMul = function(f0) {
      return r0(this.red, "redMul works only with red numbers"), this.red._verify2(this, f0), this.red.imul(this, f0);
    }, o0.prototype.redSqr = function() {
      return r0(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, o0.prototype.redISqr = function() {
      return r0(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, o0.prototype.redSqrt = function() {
      return r0(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, o0.prototype.redInvm = function() {
      return r0(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, o0.prototype.redNeg = function() {
      return r0(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, o0.prototype.redPow = function(f0) {
      return r0(this.red && !f0.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f0);
    };
    var D0 = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function z0(I0, f0) {
      this.name = I0, this.p = new o0(f0, 16), this.n = this.p.bitLength(), this.k = new o0(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    z0.prototype._tmp = function() {
      var f0 = new o0(null);
      return f0.words = new Array(Math.ceil(this.n / 13)), f0;
    }, z0.prototype.ireduce = function(f0) {
      var m0 = f0, A0;
      do
        this.split(m0, this.tmp), m0 = this.imulK(m0), m0 = m0.iadd(this.tmp), A0 = m0.bitLength();
      while (A0 > this.n);
      var x0 = A0 < this.n ? -1 : m0.ucmp(this.p);
      return x0 === 0 ? (m0.words[0] = 0, m0.length = 1) : x0 > 0 ? m0.isub(this.p) : m0.strip !== void 0 ? m0.strip() : m0._strip(), m0;
    }, z0.prototype.split = function(f0, m0) {
      f0.iushrn(this.n, 0, m0);
    }, z0.prototype.imulK = function(f0) {
      return f0.imul(this.k);
    };
    function G0() {
      z0.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i0(G0, z0), G0.prototype.split = function(f0, m0) {
      for (var A0 = 4194303, x0 = Math.min(f0.length, 9), _0 = 0; _0 < x0; _0++)
        m0.words[_0] = f0.words[_0];
      if (m0.length = x0, f0.length <= 9) {
        f0.words[0] = 0, f0.length = 1;
        return;
      }
      var $0 = f0.words[9];
      for (m0.words[m0.length++] = $0 & A0, _0 = 10; _0 < f0.length; _0++) {
        var C0 = f0.words[_0] | 0;
        f0.words[_0 - 10] = (C0 & A0) << 4 | $0 >>> 22, $0 = C0;
      }
      $0 >>>= 22, f0.words[_0 - 10] = $0, $0 === 0 && f0.length > 10 ? f0.length -= 10 : f0.length -= 9;
    }, G0.prototype.imulK = function(f0) {
      f0.words[f0.length] = 0, f0.words[f0.length + 1] = 0, f0.length += 2;
      for (var m0 = 0, A0 = 0; A0 < f0.length; A0++) {
        var x0 = f0.words[A0] | 0;
        m0 += x0 * 977, f0.words[A0] = m0 & 67108863, m0 = x0 * 64 + (m0 / 67108864 | 0);
      }
      return f0.words[f0.length - 1] === 0 && (f0.length--, f0.words[f0.length - 1] === 0 && f0.length--), f0;
    };
    function K0() {
      z0.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i0(K0, z0);
    function U0() {
      z0.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i0(U0, z0);
    function F0() {
      z0.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i0(F0, z0), F0.prototype.imulK = function(f0) {
      for (var m0 = 0, A0 = 0; A0 < f0.length; A0++) {
        var x0 = (f0.words[A0] | 0) * 19 + m0, _0 = x0 & 67108863;
        x0 >>>= 26, f0.words[A0] = _0, m0 = x0;
      }
      return m0 !== 0 && (f0.words[f0.length++] = m0), f0;
    }, o0._prime = function(f0) {
      if (D0[f0])
        return D0[f0];
      var m0;
      if (f0 === "k256")
        m0 = new G0();
      else if (f0 === "p224")
        m0 = new K0();
      else if (f0 === "p192")
        m0 = new U0();
      else if (f0 === "p25519")
        m0 = new F0();
      else
        throw new Error("Unknown prime " + f0);
      return D0[f0] = m0, m0;
    };
    function H0(I0) {
      if (typeof I0 == "string") {
        var f0 = o0._prime(I0);
        this.m = f0.p, this.prime = f0;
      } else
        r0(I0.gtn(1), "modulus must be greater than 1"), this.m = I0, this.prime = null;
    }
    H0.prototype._verify1 = function(f0) {
      r0(f0.negative === 0, "red works only with positives"), r0(f0.red, "red works only with red numbers");
    }, H0.prototype._verify2 = function(f0, m0) {
      r0((f0.negative | m0.negative) === 0, "red works only with positives"), r0(
        f0.red && f0.red === m0.red,
        "red works only with red numbers"
      );
    }, H0.prototype.imod = function(f0) {
      return this.prime ? this.prime.ireduce(f0)._forceRed(this) : (u0(f0, f0.umod(this.m)._forceRed(this)), f0);
    }, H0.prototype.neg = function(f0) {
      return f0.isZero() ? f0.clone() : this.m.sub(f0)._forceRed(this);
    }, H0.prototype.add = function(f0, m0) {
      this._verify2(f0, m0);
      var A0 = f0.add(m0);
      return A0.cmp(this.m) >= 0 && A0.isub(this.m), A0._forceRed(this);
    }, H0.prototype.iadd = function(f0, m0) {
      this._verify2(f0, m0);
      var A0 = f0.iadd(m0);
      return A0.cmp(this.m) >= 0 && A0.isub(this.m), A0;
    }, H0.prototype.sub = function(f0, m0) {
      this._verify2(f0, m0);
      var A0 = f0.sub(m0);
      return A0.cmpn(0) < 0 && A0.iadd(this.m), A0._forceRed(this);
    }, H0.prototype.isub = function(f0, m0) {
      this._verify2(f0, m0);
      var A0 = f0.isub(m0);
      return A0.cmpn(0) < 0 && A0.iadd(this.m), A0;
    }, H0.prototype.shl = function(f0, m0) {
      return this._verify1(f0), this.imod(f0.ushln(m0));
    }, H0.prototype.imul = function(f0, m0) {
      return this._verify2(f0, m0), this.imod(f0.imul(m0));
    }, H0.prototype.mul = function(f0, m0) {
      return this._verify2(f0, m0), this.imod(f0.mul(m0));
    }, H0.prototype.isqr = function(f0) {
      return this.imul(f0, f0.clone());
    }, H0.prototype.sqr = function(f0) {
      return this.mul(f0, f0);
    }, H0.prototype.sqrt = function(f0) {
      if (f0.isZero())
        return f0.clone();
      var m0 = this.m.andln(3);
      if (r0(m0 % 2 === 1), m0 === 3) {
        var A0 = this.m.add(new o0(1)).iushrn(2);
        return this.pow(f0, A0);
      }
      for (var x0 = this.m.subn(1), _0 = 0; !x0.isZero() && x0.andln(1) === 0; )
        _0++, x0.iushrn(1);
      r0(!x0.isZero());
      var $0 = new o0(1).toRed(this), C0 = $0.redNeg(), M0 = this.m.subn(1).iushrn(1), p0 = this.m.bitLength();
      for (p0 = new o0(2 * p0 * p0).toRed(this); this.pow(p0, M0).cmp(C0) !== 0; )
        p0.redIAdd(C0);
      for (var v0 = this.pow(p0, x0), T0 = this.pow(f0, x0.addn(1).iushrn(1)), L0 = this.pow(f0, x0), B0 = _0; L0.cmp($0) !== 0; ) {
        for (var W0 = L0, V0 = 0; W0.cmp($0) !== 0; V0++)
          W0 = W0.redSqr();
        r0(V0 < B0);
        var Q0 = this.pow(v0, new o0(1).iushln(B0 - V0 - 1));
        T0 = T0.redMul(Q0), v0 = Q0.redSqr(), L0 = L0.redMul(v0), B0 = V0;
      }
      return T0;
    }, H0.prototype.invm = function(f0) {
      var m0 = f0._invmp(this.m);
      return m0.negative !== 0 ? (m0.negative = 0, this.imod(m0).redNeg()) : this.imod(m0);
    }, H0.prototype.pow = function(f0, m0) {
      if (m0.isZero())
        return new o0(1).toRed(this);
      if (m0.cmpn(1) === 0)
        return f0.clone();
      var A0 = 4, x0 = new Array(1 << A0);
      x0[0] = new o0(1).toRed(this), x0[1] = f0;
      for (var _0 = 2; _0 < x0.length; _0++)
        x0[_0] = this.mul(x0[_0 - 1], f0);
      var $0 = x0[0], C0 = 0, M0 = 0, p0 = m0.bitLength() % 26;
      for (p0 === 0 && (p0 = 26), _0 = m0.length - 1; _0 >= 0; _0--) {
        for (var v0 = m0.words[_0], T0 = p0 - 1; T0 >= 0; T0--) {
          var L0 = v0 >> T0 & 1;
          if ($0 !== x0[0] && ($0 = this.sqr($0)), L0 === 0 && C0 === 0) {
            M0 = 0;
            continue;
          }
          C0 <<= 1, C0 |= L0, M0++, !(M0 !== A0 && (_0 !== 0 || T0 !== 0)) && ($0 = this.mul($0, x0[C0]), M0 = 0, C0 = 0);
        }
        p0 = 26;
      }
      return $0;
    }, H0.prototype.convertTo = function(f0) {
      var m0 = f0.umod(this.m);
      return m0 === f0 ? m0.clone() : m0;
    }, H0.prototype.convertFrom = function(f0) {
      var m0 = f0.clone();
      return m0.red = null, m0;
    }, o0.mont = function(f0) {
      return new P0(f0);
    };
    function P0(I0) {
      H0.call(this, I0), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o0(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i0(P0, H0), P0.prototype.convertTo = function(f0) {
      return this.imod(f0.ushln(this.shift));
    }, P0.prototype.convertFrom = function(f0) {
      var m0 = this.imod(f0.mul(this.rinv));
      return m0.red = null, m0;
    }, P0.prototype.imul = function(f0, m0) {
      if (f0.isZero() || m0.isZero())
        return f0.words[0] = 0, f0.length = 1, f0;
      var A0 = f0.imul(m0), x0 = A0.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), _0 = A0.isub(x0).iushrn(this.shift), $0 = _0;
      return _0.cmp(this.m) >= 0 ? $0 = _0.isub(this.m) : _0.cmpn(0) < 0 && ($0 = _0.iadd(this.m)), $0._forceRed(this);
    }, P0.prototype.mul = function(f0, m0) {
      if (f0.isZero() || m0.isZero())
        return new o0(0)._forceRed(this);
      var A0 = f0.mul(m0), x0 = A0.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), _0 = A0.isub(x0).iushrn(this.shift), $0 = _0;
      return _0.cmp(this.m) >= 0 ? $0 = _0.isub(this.m) : _0.cmpn(0) < 0 && ($0 = _0.iadd(this.m)), $0._forceRed(this);
    }, P0.prototype.invm = function(f0) {
      var m0 = this.imod(f0._invmp(this.m).mul(this.r2));
      return m0._forceRed(this);
    };
  })(t0, commonjsGlobal);
})(bn);
var bnExports = bn.exports;
const BN = /* @__PURE__ */ getDefaultExportFromCjs(bnExports);
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t0, e0) {
  var n0 = buffer, r0 = n0.Buffer;
  function i0(s0, a0) {
    for (var c0 in s0)
      a0[c0] = s0[c0];
  }
  r0.from && r0.alloc && r0.allocUnsafe && r0.allocUnsafeSlow ? t0.exports = n0 : (i0(n0, e0), e0.Buffer = o0);
  function o0(s0, a0, c0) {
    return r0(s0, a0, c0);
  }
  o0.prototype = Object.create(r0.prototype), i0(r0, o0), o0.from = function(s0, a0, c0) {
    if (typeof s0 == "number")
      throw new TypeError("Argument must not be a number");
    return r0(s0, a0, c0);
  }, o0.alloc = function(s0, a0, c0) {
    if (typeof s0 != "number")
      throw new TypeError("Argument must be a number");
    var l0 = r0(s0);
    return a0 !== void 0 ? typeof c0 == "string" ? l0.fill(a0, c0) : l0.fill(a0) : l0.fill(0), l0;
  }, o0.allocUnsafe = function(s0) {
    if (typeof s0 != "number")
      throw new TypeError("Argument must be a number");
    return r0(s0);
  }, o0.allocUnsafeSlow = function(s0) {
    if (typeof s0 != "number")
      throw new TypeError("Argument must be a number");
    return n0.SlowBuffer(s0);
  };
})(safeBuffer, safeBuffer.exports);
var safeBufferExports = safeBuffer.exports, _Buffer = safeBufferExports.Buffer;
function base(t0) {
  if (t0.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var e0 = new Uint8Array(256), n0 = 0; n0 < e0.length; n0++)
    e0[n0] = 255;
  for (var r0 = 0; r0 < t0.length; r0++) {
    var i0 = t0.charAt(r0), o0 = i0.charCodeAt(0);
    if (e0[o0] !== 255)
      throw new TypeError(i0 + " is ambiguous");
    e0[o0] = r0;
  }
  var s0 = t0.length, a0 = t0.charAt(0), c0 = Math.log(s0) / Math.log(256), l0 = Math.log(256) / Math.log(s0);
  function u0(g0) {
    if ((Array.isArray(g0) || g0 instanceof Uint8Array) && (g0 = _Buffer.from(g0)), !_Buffer.isBuffer(g0))
      throw new TypeError("Expected Buffer");
    if (g0.length === 0)
      return "";
    for (var w0 = 0, y0 = 0, E0 = 0, b0 = g0.length; E0 !== b0 && g0[E0] === 0; )
      E0++, w0++;
    for (var O0 = (b0 - E0) * l0 + 1 >>> 0, S0 = new Uint8Array(O0); E0 !== b0; ) {
      for (var k0 = g0[E0], D0 = 0, z0 = O0 - 1; (k0 !== 0 || D0 < y0) && z0 !== -1; z0--, D0++)
        k0 += 256 * S0[z0] >>> 0, S0[z0] = k0 % s0 >>> 0, k0 = k0 / s0 >>> 0;
      if (k0 !== 0)
        throw new Error("Non-zero carry");
      y0 = D0, E0++;
    }
    for (var G0 = O0 - y0; G0 !== O0 && S0[G0] === 0; )
      G0++;
    for (var K0 = a0.repeat(w0); G0 < O0; ++G0)
      K0 += t0.charAt(S0[G0]);
    return K0;
  }
  function d0(g0) {
    if (typeof g0 != "string")
      throw new TypeError("Expected String");
    if (g0.length === 0)
      return _Buffer.alloc(0);
    for (var w0 = 0, y0 = 0, E0 = 0; g0[w0] === a0; )
      y0++, w0++;
    for (var b0 = (g0.length - w0) * c0 + 1 >>> 0, O0 = new Uint8Array(b0); w0 < g0.length; ) {
      var S0 = g0.charCodeAt(w0);
      if (S0 > 255)
        return;
      var k0 = e0[S0];
      if (k0 === 255)
        return;
      for (var D0 = 0, z0 = b0 - 1; (k0 !== 0 || D0 < E0) && z0 !== -1; z0--, D0++)
        k0 += s0 * O0[z0] >>> 0, O0[z0] = k0 % 256 >>> 0, k0 = k0 / 256 >>> 0;
      if (k0 !== 0)
        throw new Error("Non-zero carry");
      E0 = D0, w0++;
    }
    for (var G0 = b0 - E0; G0 !== b0 && O0[G0] === 0; )
      G0++;
    var K0 = _Buffer.allocUnsafe(y0 + (b0 - G0));
    K0.fill(0, 0, y0);
    for (var U0 = y0; G0 !== b0; )
      K0[U0++] = O0[G0++];
    return K0;
  }
  function h0(g0) {
    var w0 = d0(g0);
    if (w0)
      return w0;
    throw new Error("Non-base" + s0 + " character");
  }
  return {
    encode: u0,
    decodeUnsafe: d0,
    decode: h0
  };
}
var src = base, basex = src, ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", bs58 = basex(ALPHABET);
const bs58$1 = /* @__PURE__ */ getDefaultExportFromCjs(bs58), sha256 = sha256$1;
var lib = {};
function inRange(t0, e0, n0) {
  return e0 <= t0 && t0 <= n0;
}
function ToDictionary(t0) {
  if (t0 === void 0)
    return {};
  if (t0 === Object(t0))
    return t0;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(t0) {
  for (var e0 = String(t0), n0 = e0.length, r0 = 0, i0 = []; r0 < n0; ) {
    var o0 = e0.charCodeAt(r0);
    if (o0 < 55296 || o0 > 57343)
      i0.push(o0);
    else if (56320 <= o0 && o0 <= 57343)
      i0.push(65533);
    else if (55296 <= o0 && o0 <= 56319)
      if (r0 === n0 - 1)
        i0.push(65533);
      else {
        var s0 = t0.charCodeAt(r0 + 1);
        if (56320 <= s0 && s0 <= 57343) {
          var a0 = o0 & 1023, c0 = s0 & 1023;
          i0.push(65536 + (a0 << 10) + c0), r0 += 1;
        } else
          i0.push(65533);
      }
    r0 += 1;
  }
  return i0;
}
function codePointsToString(t0) {
  for (var e0 = "", n0 = 0; n0 < t0.length; ++n0) {
    var r0 = t0[n0];
    r0 <= 65535 ? e0 += String.fromCharCode(r0) : (r0 -= 65536, e0 += String.fromCharCode(
      (r0 >> 10) + 55296,
      (r0 & 1023) + 56320
    ));
  }
  return e0;
}
var end_of_stream = -1;
function Stream(t0) {
  this.tokens = [].slice.call(t0);
}
Stream.prototype = {
  /**
   * @return {boolean} True if end-of-stream has been hit.
   */
  endOfStream: function() {
    return !this.tokens.length;
  },
  /**
   * When a token is read from a stream, the first token in the
   * stream must be returned and subsequently removed, and
   * end-of-stream must be returned otherwise.
   *
   * @return {number} Get the next token from the stream, or
   * end_of_stream.
   */
  read: function() {
    return this.tokens.length ? this.tokens.shift() : end_of_stream;
  },
  /**
   * When one or more tokens are prepended to a stream, those tokens
   * must be inserted, in given order, before the first token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
   */
  prepend: function(t0) {
    if (Array.isArray(t0))
      for (var e0 = (
        /**@type {!Array.<number>}*/
        t0
      ); e0.length; )
        this.tokens.unshift(e0.pop());
    else
      this.tokens.unshift(t0);
  },
  /**
   * When one or more tokens are pushed to a stream, those tokens
   * must be inserted, in given order, after the last token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
   */
  push: function(t0) {
    if (Array.isArray(t0))
      for (var e0 = (
        /**@type {!Array.<number>}*/
        t0
      ); e0.length; )
        this.tokens.push(e0.shift());
    else
      this.tokens.push(t0);
  }
};
var finished = -1;
function decoderError(t0, e0) {
  if (t0)
    throw TypeError("Decoder error");
  return e0 || 65533;
}
var DEFAULT_ENCODING = "utf-8";
function TextDecoder$1(t0, e0) {
  if (!(this instanceof TextDecoder$1))
    return new TextDecoder$1(t0, e0);
  if (t0 = t0 !== void 0 ? String(t0).toLowerCase() : DEFAULT_ENCODING, t0 !== DEFAULT_ENCODING)
    throw new Error("Encoding not supported. Only utf-8 is supported");
  e0 = ToDictionary(e0), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = !!e0.fatal, this._ignoreBOM = !!e0.ignoreBOM, Object.defineProperty(this, "encoding", { value: "utf-8" }), Object.defineProperty(this, "fatal", { value: this._fatal }), Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
TextDecoder$1.prototype = {
  /**
   * @param {ArrayBufferView=} input The buffer of bytes to decode.
   * @param {Object=} options
   * @return {string} The decoded string.
   */
  decode: function t0(e0, n0) {
    var r0;
    typeof e0 == "object" && e0 instanceof ArrayBuffer ? r0 = new Uint8Array(e0) : typeof e0 == "object" && "buffer" in e0 && e0.buffer instanceof ArrayBuffer ? r0 = new Uint8Array(
      e0.buffer,
      e0.byteOffset,
      e0.byteLength
    ) : r0 = new Uint8Array(0), n0 = ToDictionary(n0), this._streaming || (this._decoder = new UTF8Decoder({ fatal: this._fatal }), this._BOMseen = !1), this._streaming = !!n0.stream;
    for (var i0 = new Stream(r0), o0 = [], s0; !i0.endOfStream() && (s0 = this._decoder.handler(i0, i0.read()), s0 !== finished); )
      s0 !== null && (Array.isArray(s0) ? o0.push.apply(
        o0,
        /**@type {!Array.<number>}*/
        s0
      ) : o0.push(s0));
    if (!this._streaming) {
      do {
        if (s0 = this._decoder.handler(i0, i0.read()), s0 === finished)
          break;
        s0 !== null && (Array.isArray(s0) ? o0.push.apply(
          o0,
          /**@type {!Array.<number>}*/
          s0
        ) : o0.push(s0));
      } while (!i0.endOfStream());
      this._decoder = null;
    }
    return o0.length && ["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (o0[0] === 65279 ? (this._BOMseen = !0, o0.shift()) : this._BOMseen = !0), codePointsToString(o0);
  }
};
function TextEncoder$1(t0, e0) {
  if (!(this instanceof TextEncoder$1))
    return new TextEncoder$1(t0, e0);
  if (t0 = t0 !== void 0 ? String(t0).toLowerCase() : DEFAULT_ENCODING, t0 !== DEFAULT_ENCODING)
    throw new Error("Encoding not supported. Only utf-8 is supported");
  e0 = ToDictionary(e0), this._streaming = !1, this._encoder = null, this._options = { fatal: !!e0.fatal }, Object.defineProperty(this, "encoding", { value: "utf-8" });
}
TextEncoder$1.prototype = {
  /**
   * @param {string=} opt_string The string to encode.
   * @param {Object=} options
   * @return {Uint8Array} Encoded bytes, as a Uint8Array.
   */
  encode: function t0(e0, n0) {
    e0 = e0 ? String(e0) : "", n0 = ToDictionary(n0), this._streaming || (this._encoder = new UTF8Encoder(this._options)), this._streaming = !!n0.stream;
    for (var r0 = [], i0 = new Stream(stringToCodePoints(e0)), o0; !i0.endOfStream() && (o0 = this._encoder.handler(i0, i0.read()), o0 !== finished); )
      Array.isArray(o0) ? r0.push.apply(
        r0,
        /**@type {!Array.<number>}*/
        o0
      ) : r0.push(o0);
    if (!this._streaming) {
      for (; o0 = this._encoder.handler(i0, i0.read()), o0 !== finished; )
        Array.isArray(o0) ? r0.push.apply(
          r0,
          /**@type {!Array.<number>}*/
          o0
        ) : r0.push(o0);
      this._encoder = null;
    }
    return new Uint8Array(r0);
  }
};
function UTF8Decoder(t0) {
  var e0 = t0.fatal, n0 = 0, r0 = 0, i0 = 0, o0 = 128, s0 = 191;
  this.handler = function(a0, c0) {
    if (c0 === end_of_stream && i0 !== 0)
      return i0 = 0, decoderError(e0);
    if (c0 === end_of_stream)
      return finished;
    if (i0 === 0) {
      if (inRange(c0, 0, 127))
        return c0;
      if (inRange(c0, 194, 223))
        i0 = 1, n0 = c0 - 192;
      else if (inRange(c0, 224, 239))
        c0 === 224 && (o0 = 160), c0 === 237 && (s0 = 159), i0 = 2, n0 = c0 - 224;
      else if (inRange(c0, 240, 244))
        c0 === 240 && (o0 = 144), c0 === 244 && (s0 = 143), i0 = 3, n0 = c0 - 240;
      else
        return decoderError(e0);
      return n0 = n0 << 6 * i0, null;
    }
    if (!inRange(c0, o0, s0))
      return n0 = i0 = r0 = 0, o0 = 128, s0 = 191, a0.prepend(c0), decoderError(e0);
    if (o0 = 128, s0 = 191, r0 += 1, n0 += c0 - 128 << 6 * (i0 - r0), r0 !== i0)
      return null;
    var l0 = n0;
    return n0 = i0 = r0 = 0, l0;
  };
}
function UTF8Encoder(t0) {
  t0.fatal, this.handler = function(e0, n0) {
    if (n0 === end_of_stream)
      return finished;
    if (inRange(n0, 0, 127))
      return n0;
    var r0, i0;
    inRange(n0, 128, 2047) ? (r0 = 1, i0 = 192) : inRange(n0, 2048, 65535) ? (r0 = 2, i0 = 224) : inRange(n0, 65536, 1114111) && (r0 = 3, i0 = 240);
    for (var o0 = [(n0 >> 6 * r0) + i0]; r0 > 0; ) {
      var s0 = n0 >> 6 * (r0 - 1);
      o0.push(128 | s0 & 63), r0 -= 1;
    }
    return o0;
  };
}
const encoding$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TextDecoder: TextDecoder$1,
  TextEncoder: TextEncoder$1
}, Symbol.toStringTag, { value: "Module" })), require$$2 = /* @__PURE__ */ getAugmentedNamespace(encoding$1);
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(t0, e0, n0, r0) {
  r0 === void 0 && (r0 = n0), Object.defineProperty(t0, r0, { enumerable: !0, get: function() {
    return e0[n0];
  } });
} : function(t0, e0, n0, r0) {
  r0 === void 0 && (r0 = n0), t0[r0] = e0[n0];
}), __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(t0, e0) {
  Object.defineProperty(t0, "default", { enumerable: !0, value: e0 });
} : function(t0, e0) {
  t0.default = e0;
}), __decorate = commonjsGlobal && commonjsGlobal.__decorate || function(t0, e0, n0, r0) {
  var i0 = arguments.length, o0 = i0 < 3 ? e0 : r0 === null ? r0 = Object.getOwnPropertyDescriptor(e0, n0) : r0, s0;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o0 = Reflect.decorate(t0, e0, n0, r0);
  else
    for (var a0 = t0.length - 1; a0 >= 0; a0--)
      (s0 = t0[a0]) && (o0 = (i0 < 3 ? s0(o0) : i0 > 3 ? s0(e0, n0, o0) : s0(e0, n0)) || o0);
  return i0 > 3 && o0 && Object.defineProperty(e0, n0, o0), o0;
}, __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(t0) {
  if (t0 && t0.__esModule)
    return t0;
  var e0 = {};
  if (t0 != null)
    for (var n0 in t0)
      n0 !== "default" && Object.hasOwnProperty.call(t0, n0) && __createBinding(e0, t0, n0);
  return __setModuleDefault(e0, t0), e0;
}, __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(t0) {
  return t0 && t0.__esModule ? t0 : { default: t0 };
};
Object.defineProperty(lib, "__esModule", { value: !0 });
var deserializeUnchecked_1 = lib.deserializeUnchecked = deserialize_1 = lib.deserialize = serialize_1 = lib.serialize = lib.BinaryReader = lib.BinaryWriter = lib.BorshError = lib.baseDecode = lib.baseEncode = void 0;
const bn_js_1 = __importDefault(bnExports), bs58_1 = __importDefault(bs58), encoding = __importStar(require$$2), ResolvedTextDecoder = typeof TextDecoder != "function" ? encoding.TextDecoder : TextDecoder, textDecoder = new ResolvedTextDecoder("utf-8", { fatal: !0 });
function baseEncode(t0) {
  return typeof t0 == "string" && (t0 = Buffer.from(t0, "utf8")), bs58_1.default.encode(Buffer.from(t0));
}
lib.baseEncode = baseEncode;
function baseDecode(t0) {
  return Buffer.from(bs58_1.default.decode(t0));
}
lib.baseDecode = baseDecode;
const INITIAL_LENGTH = 1024;
class BorshError extends Error {
  constructor(e0) {
    super(e0), this.fieldPath = [], this.originalMessage = e0;
  }
  addToFieldPath(e0) {
    this.fieldPath.splice(0, 0, e0), this.message = this.originalMessage + ": " + this.fieldPath.join(".");
  }
}
lib.BorshError = BorshError;
class BinaryWriter {
  constructor() {
    this.buf = Buffer.alloc(INITIAL_LENGTH), this.length = 0;
  }
  maybeResize() {
    this.buf.length < 16 + this.length && (this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]));
  }
  writeU8(e0) {
    this.maybeResize(), this.buf.writeUInt8(e0, this.length), this.length += 1;
  }
  writeU16(e0) {
    this.maybeResize(), this.buf.writeUInt16LE(e0, this.length), this.length += 2;
  }
  writeU32(e0) {
    this.maybeResize(), this.buf.writeUInt32LE(e0, this.length), this.length += 4;
  }
  writeU64(e0) {
    this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1.default(e0).toArray("le", 8)));
  }
  writeU128(e0) {
    this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1.default(e0).toArray("le", 16)));
  }
  writeU256(e0) {
    this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1.default(e0).toArray("le", 32)));
  }
  writeU512(e0) {
    this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1.default(e0).toArray("le", 64)));
  }
  writeBuffer(e0) {
    this.buf = Buffer.concat([
      Buffer.from(this.buf.subarray(0, this.length)),
      e0,
      Buffer.alloc(INITIAL_LENGTH)
    ]), this.length += e0.length;
  }
  writeString(e0) {
    this.maybeResize();
    const n0 = Buffer.from(e0, "utf8");
    this.writeU32(n0.length), this.writeBuffer(n0);
  }
  writeFixedArray(e0) {
    this.writeBuffer(Buffer.from(e0));
  }
  writeArray(e0, n0) {
    this.maybeResize(), this.writeU32(e0.length);
    for (const r0 of e0)
      this.maybeResize(), n0(r0);
  }
  toArray() {
    return this.buf.subarray(0, this.length);
  }
}
lib.BinaryWriter = BinaryWriter;
function handlingRangeError(t0, e0, n0) {
  const r0 = n0.value;
  n0.value = function(...i0) {
    try {
      return r0.apply(this, i0);
    } catch (o0) {
      if (o0 instanceof RangeError) {
        const s0 = o0.code;
        if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(s0) >= 0)
          throw new BorshError("Reached the end of buffer when deserializing");
      }
      throw o0;
    }
  };
}
class BinaryReader {
  constructor(e0) {
    this.buf = e0, this.offset = 0;
  }
  readU8() {
    const e0 = this.buf.readUInt8(this.offset);
    return this.offset += 1, e0;
  }
  readU16() {
    const e0 = this.buf.readUInt16LE(this.offset);
    return this.offset += 2, e0;
  }
  readU32() {
    const e0 = this.buf.readUInt32LE(this.offset);
    return this.offset += 4, e0;
  }
  readU64() {
    const e0 = this.readBuffer(8);
    return new bn_js_1.default(e0, "le");
  }
  readU128() {
    const e0 = this.readBuffer(16);
    return new bn_js_1.default(e0, "le");
  }
  readU256() {
    const e0 = this.readBuffer(32);
    return new bn_js_1.default(e0, "le");
  }
  readU512() {
    const e0 = this.readBuffer(64);
    return new bn_js_1.default(e0, "le");
  }
  readBuffer(e0) {
    if (this.offset + e0 > this.buf.length)
      throw new BorshError(`Expected buffer length ${e0} isn't within bounds`);
    const n0 = this.buf.slice(this.offset, this.offset + e0);
    return this.offset += e0, n0;
  }
  readString() {
    const e0 = this.readU32(), n0 = this.readBuffer(e0);
    try {
      return textDecoder.decode(n0);
    } catch (r0) {
      throw new BorshError(`Error decoding UTF-8 string: ${r0}`);
    }
  }
  readFixedArray(e0) {
    return new Uint8Array(this.readBuffer(e0));
  }
  readArray(e0) {
    const n0 = this.readU32(), r0 = Array();
    for (let i0 = 0; i0 < n0; ++i0)
      r0.push(e0());
    return r0;
  }
}
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU8", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU16", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU32", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU64", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU128", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU256", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU512", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readString", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readFixedArray", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readArray", null);
lib.BinaryReader = BinaryReader;
function capitalizeFirstLetter(t0) {
  return t0.charAt(0).toUpperCase() + t0.slice(1);
}
function serializeField(t0, e0, n0, r0, i0) {
  try {
    if (typeof r0 == "string")
      i0[`write${capitalizeFirstLetter(r0)}`](n0);
    else if (r0 instanceof Array)
      if (typeof r0[0] == "number") {
        if (n0.length !== r0[0])
          throw new BorshError(`Expecting byte array of length ${r0[0]}, but got ${n0.length} bytes`);
        i0.writeFixedArray(n0);
      } else if (r0.length === 2 && typeof r0[1] == "number") {
        if (n0.length !== r0[1])
          throw new BorshError(`Expecting byte array of length ${r0[1]}, but got ${n0.length} bytes`);
        for (let o0 = 0; o0 < r0[1]; o0++)
          serializeField(t0, null, n0[o0], r0[0], i0);
      } else
        i0.writeArray(n0, (o0) => {
          serializeField(t0, e0, o0, r0[0], i0);
        });
    else if (r0.kind !== void 0)
      switch (r0.kind) {
        case "option": {
          n0 == null ? i0.writeU8(0) : (i0.writeU8(1), serializeField(t0, e0, n0, r0.type, i0));
          break;
        }
        case "map": {
          i0.writeU32(n0.size), n0.forEach((o0, s0) => {
            serializeField(t0, e0, s0, r0.key, i0), serializeField(t0, e0, o0, r0.value, i0);
          });
          break;
        }
        default:
          throw new BorshError(`FieldType ${r0} unrecognized`);
      }
    else
      serializeStruct(t0, n0, i0);
  } catch (o0) {
    throw o0 instanceof BorshError && o0.addToFieldPath(e0), o0;
  }
}
function serializeStruct(t0, e0, n0) {
  if (typeof e0.borshSerialize == "function") {
    e0.borshSerialize(n0);
    return;
  }
  const r0 = t0.get(e0.constructor);
  if (!r0)
    throw new BorshError(`Class ${e0.constructor.name} is missing in schema`);
  if (r0.kind === "struct")
    r0.fields.map(([i0, o0]) => {
      serializeField(t0, i0, e0[i0], o0, n0);
    });
  else if (r0.kind === "enum") {
    const i0 = e0[r0.field];
    for (let o0 = 0; o0 < r0.values.length; ++o0) {
      const [s0, a0] = r0.values[o0];
      if (s0 === i0) {
        n0.writeU8(o0), serializeField(t0, s0, e0[s0], a0, n0);
        break;
      }
    }
  } else
    throw new BorshError(`Unexpected schema kind: ${r0.kind} for ${e0.constructor.name}`);
}
function serialize(t0, e0, n0 = BinaryWriter) {
  const r0 = new n0();
  return serializeStruct(t0, e0, r0), r0.toArray();
}
var serialize_1 = lib.serialize = serialize;
function deserializeField(t0, e0, n0, r0) {
  try {
    if (typeof n0 == "string")
      return r0[`read${capitalizeFirstLetter(n0)}`]();
    if (n0 instanceof Array) {
      if (typeof n0[0] == "number")
        return r0.readFixedArray(n0[0]);
      if (typeof n0[1] == "number") {
        const i0 = [];
        for (let o0 = 0; o0 < n0[1]; o0++)
          i0.push(deserializeField(t0, null, n0[0], r0));
        return i0;
      } else
        return r0.readArray(() => deserializeField(t0, e0, n0[0], r0));
    }
    if (n0.kind === "option")
      return r0.readU8() ? deserializeField(t0, e0, n0.type, r0) : void 0;
    if (n0.kind === "map") {
      let i0 = /* @__PURE__ */ new Map();
      const o0 = r0.readU32();
      for (let s0 = 0; s0 < o0; s0++) {
        const a0 = deserializeField(t0, e0, n0.key, r0), c0 = deserializeField(t0, e0, n0.value, r0);
        i0.set(a0, c0);
      }
      return i0;
    }
    return deserializeStruct(t0, n0, r0);
  } catch (i0) {
    throw i0 instanceof BorshError && i0.addToFieldPath(e0), i0;
  }
}
function deserializeStruct(t0, e0, n0) {
  if (typeof e0.borshDeserialize == "function")
    return e0.borshDeserialize(n0);
  const r0 = t0.get(e0);
  if (!r0)
    throw new BorshError(`Class ${e0.name} is missing in schema`);
  if (r0.kind === "struct") {
    const i0 = {};
    for (const [o0, s0] of t0.get(e0).fields)
      i0[o0] = deserializeField(t0, o0, s0, n0);
    return new e0(i0);
  }
  if (r0.kind === "enum") {
    const i0 = n0.readU8();
    if (i0 >= r0.values.length)
      throw new BorshError(`Enum index: ${i0} is out of range`);
    const [o0, s0] = r0.values[i0], a0 = deserializeField(t0, o0, s0, n0);
    return new e0({ [o0]: a0 });
  }
  throw new BorshError(`Unexpected schema kind: ${r0.kind} for ${e0.constructor.name}`);
}
function deserialize(t0, e0, n0, r0 = BinaryReader) {
  const i0 = new r0(n0), o0 = deserializeStruct(t0, e0, i0);
  if (i0.offset < n0.length)
    throw new BorshError(`Unexpected ${n0.length - i0.offset} bytes after deserialized data`);
  return o0;
}
var deserialize_1 = lib.deserialize = deserialize;
function deserializeUnchecked(t0, e0, n0, r0 = BinaryReader) {
  const i0 = new r0(n0);
  return deserializeStruct(t0, e0, i0);
}
deserializeUnchecked_1 = lib.deserializeUnchecked = deserializeUnchecked;
var Layout$1 = {};
Object.defineProperty(Layout$1, "__esModule", { value: !0 });
Layout$1.s16 = Layout$1.s8 = Layout$1.nu64be = Layout$1.u48be = Layout$1.u40be = Layout$1.u32be = Layout$1.u24be = Layout$1.u16be = nu64 = Layout$1.nu64 = Layout$1.u48 = Layout$1.u40 = u32 = Layout$1.u32 = Layout$1.u24 = u16 = Layout$1.u16 = u8 = Layout$1.u8 = offset = Layout$1.offset = Layout$1.greedy = Layout$1.Constant = Layout$1.UTF8 = Layout$1.CString = Layout$1.Blob = Layout$1.Boolean = Layout$1.BitField = Layout$1.BitStructure = Layout$1.VariantLayout = Layout$1.Union = Layout$1.UnionLayoutDiscriminator = Layout$1.UnionDiscriminator = Layout$1.Structure = Layout$1.Sequence = Layout$1.DoubleBE = Layout$1.Double = Layout$1.FloatBE = Layout$1.Float = Layout$1.NearInt64BE = Layout$1.NearInt64 = Layout$1.NearUInt64BE = Layout$1.NearUInt64 = Layout$1.IntBE = Layout$1.Int = Layout$1.UIntBE = Layout$1.UInt = Layout$1.OffsetLayout = Layout$1.GreedyCount = Layout$1.ExternalLayout = Layout$1.bindConstructorLayout = Layout$1.nameWithProperty = Layout$1.Layout = Layout$1.uint8ArrayToBuffer = Layout$1.checkUint8Array = void 0;
Layout$1.constant = Layout$1.utf8 = Layout$1.cstr = blob = Layout$1.blob = Layout$1.unionLayoutDiscriminator = Layout$1.union = seq = Layout$1.seq = Layout$1.bits = struct = Layout$1.struct = Layout$1.f64be = Layout$1.f64 = Layout$1.f32be = Layout$1.f32 = Layout$1.ns64be = Layout$1.s48be = Layout$1.s40be = Layout$1.s32be = Layout$1.s24be = Layout$1.s16be = ns64 = Layout$1.ns64 = Layout$1.s48 = Layout$1.s40 = Layout$1.s32 = Layout$1.s24 = void 0;
const buffer_1 = buffer;
function checkUint8Array(t0) {
  if (!(t0 instanceof Uint8Array))
    throw new TypeError("b must be a Uint8Array");
}
Layout$1.checkUint8Array = checkUint8Array;
function uint8ArrayToBuffer(t0) {
  return checkUint8Array(t0), buffer_1.Buffer.from(t0.buffer, t0.byteOffset, t0.length);
}
Layout$1.uint8ArrayToBuffer = uint8ArrayToBuffer;
class Layout {
  constructor(e0, n0) {
    if (!Number.isInteger(e0))
      throw new TypeError("span must be an integer");
    this.span = e0, this.property = n0;
  }
  /** Function to create an Object into which decoded properties will
   * be written.
   *
   * Used only for layouts that {@link Layout#decode|decode} to Object
   * instances, which means:
   * * {@link Structure}
   * * {@link Union}
   * * {@link VariantLayout}
   * * {@link BitStructure}
   *
   * If left undefined the JavaScript representation of these layouts
   * will be Object instances.
   *
   * See {@link bindConstructorLayout}.
   */
  makeDestinationObject() {
    return {};
  }
  /**
   * Calculate the span of a specific instance of a layout.
   *
   * @param {Uint8Array} b - the buffer that contains an encoded instance.
   *
   * @param {Number} [offset] - the offset at which the encoded instance
   * starts.  If absent a zero offset is inferred.
   *
   * @return {Number} - the number of bytes covered by the layout
   * instance.  If this method is not overridden in a subclass the
   * definition-time constant {@link Layout#span|span} will be
   * returned.
   *
   * @throws {RangeError} - if the length of the value cannot be
   * determined.
   */
  getSpan(e0, n0) {
    if (0 > this.span)
      throw new RangeError("indeterminate span");
    return this.span;
  }
  /**
   * Replicate the layout using a new property.
   *
   * This function must be used to get a structurally-equivalent layout
   * with a different name since all {@link Layout} instances are
   * immutable.
   *
   * **NOTE** This is a shallow copy.  All fields except {@link
   * Layout#property|property} are strictly equal to the origin layout.
   *
   * @param {String} property - the value for {@link
   * Layout#property|property} in the replica.
   *
   * @returns {Layout} - the copy with {@link Layout#property|property}
   * set to `property`.
   */
  replicate(e0) {
    const n0 = Object.create(this.constructor.prototype);
    return Object.assign(n0, this), n0.property = e0, n0;
  }
  /**
   * Create an object from layout properties and an array of values.
   *
   * **NOTE** This function returns `undefined` if invoked on a layout
   * that does not return its value as an Object.  Objects are
   * returned for things that are a {@link Structure}, which includes
   * {@link VariantLayout|variant layouts} if they are structures, and
   * excludes {@link Union}s.  If you want this feature for a union
   * you must use {@link Union.getVariant|getVariant} to select the
   * desired layout.
   *
   * @param {Array} values - an array of values that correspond to the
   * default order for properties.  As with {@link Layout#decode|decode}
   * layout elements that have no property name are skipped when
   * iterating over the array values.  Only the top-level properties are
   * assigned; arguments are not assigned to properties of contained
   * layouts.  Any unused values are ignored.
   *
   * @return {(Object|undefined)}
   */
  fromArray(e0) {
  }
}
Layout$1.Layout = Layout;
function nameWithProperty(t0, e0) {
  return e0.property ? t0 + "[" + e0.property + "]" : t0;
}
Layout$1.nameWithProperty = nameWithProperty;
function bindConstructorLayout(t0, e0) {
  if (typeof t0 != "function")
    throw new TypeError("Class must be constructor");
  if (Object.prototype.hasOwnProperty.call(t0, "layout_"))
    throw new Error("Class is already bound to a layout");
  if (!(e0 && e0 instanceof Layout))
    throw new TypeError("layout must be a Layout");
  if (Object.prototype.hasOwnProperty.call(e0, "boundConstructor_"))
    throw new Error("layout is already bound to a constructor");
  t0.layout_ = e0, e0.boundConstructor_ = t0, e0.makeDestinationObject = () => new t0(), Object.defineProperty(t0.prototype, "encode", {
    value(n0, r0) {
      return e0.encode(this, n0, r0);
    },
    writable: !0
  }), Object.defineProperty(t0, "decode", {
    value(n0, r0) {
      return e0.decode(n0, r0);
    },
    writable: !0
  });
}
Layout$1.bindConstructorLayout = bindConstructorLayout;
class ExternalLayout extends Layout {
  /**
   * Return `true` iff the external layout decodes to an unsigned
   * integer layout.
   *
   * In that case it can be used as the source of {@link
   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
   * or as {@link UnionLayoutDiscriminator#layout|external union
   * discriminators}.
   *
   * @abstract
   */
  isCount() {
    throw new Error("ExternalLayout is abstract");
  }
}
Layout$1.ExternalLayout = ExternalLayout;
class GreedyCount extends ExternalLayout {
  constructor(e0 = 1, n0) {
    if (!Number.isInteger(e0) || 0 >= e0)
      throw new TypeError("elementSpan must be a (positive) integer");
    super(-1, n0), this.elementSpan = e0;
  }
  /** @override */
  isCount() {
    return !0;
  }
  /** @override */
  decode(e0, n0 = 0) {
    checkUint8Array(e0);
    const r0 = e0.length - n0;
    return Math.floor(r0 / this.elementSpan);
  }
  /** @override */
  encode(e0, n0, r0) {
    return 0;
  }
}
Layout$1.GreedyCount = GreedyCount;
class OffsetLayout extends ExternalLayout {
  constructor(e0, n0 = 0, r0) {
    if (!(e0 instanceof Layout))
      throw new TypeError("layout must be a Layout");
    if (!Number.isInteger(n0))
      throw new TypeError("offset must be integer or undefined");
    super(e0.span, r0 || e0.property), this.layout = e0, this.offset = n0;
  }
  /** @override */
  isCount() {
    return this.layout instanceof UInt || this.layout instanceof UIntBE;
  }
  /** @override */
  decode(e0, n0 = 0) {
    return this.layout.decode(e0, n0 + this.offset);
  }
  /** @override */
  encode(e0, n0, r0 = 0) {
    return this.layout.encode(e0, n0, r0 + this.offset);
  }
}
Layout$1.OffsetLayout = OffsetLayout;
class UInt extends Layout {
  constructor(e0, n0) {
    if (super(e0, n0), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  /** @override */
  decode(e0, n0 = 0) {
    return uint8ArrayToBuffer(e0).readUIntLE(n0, this.span);
  }
  /** @override */
  encode(e0, n0, r0 = 0) {
    return uint8ArrayToBuffer(n0).writeUIntLE(e0, r0, this.span), this.span;
  }
}
Layout$1.UInt = UInt;
class UIntBE extends Layout {
  constructor(e0, n0) {
    if (super(e0, n0), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  /** @override */
  decode(e0, n0 = 0) {
    return uint8ArrayToBuffer(e0).readUIntBE(n0, this.span);
  }
  /** @override */
  encode(e0, n0, r0 = 0) {
    return uint8ArrayToBuffer(n0).writeUIntBE(e0, r0, this.span), this.span;
  }
}
Layout$1.UIntBE = UIntBE;
class Int extends Layout {
  constructor(e0, n0) {
    if (super(e0, n0), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  /** @override */
  decode(e0, n0 = 0) {
    return uint8ArrayToBuffer(e0).readIntLE(n0, this.span);
  }
  /** @override */
  encode(e0, n0, r0 = 0) {
    return uint8ArrayToBuffer(n0).writeIntLE(e0, r0, this.span), this.span;
  }
}
Layout$1.Int = Int;
class IntBE extends Layout {
  constructor(e0, n0) {
    if (super(e0, n0), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  /** @override */
  decode(e0, n0 = 0) {
    return uint8ArrayToBuffer(e0).readIntBE(n0, this.span);
  }
  /** @override */
  encode(e0, n0, r0 = 0) {
    return uint8ArrayToBuffer(n0).writeIntBE(e0, r0, this.span), this.span;
  }
}
Layout$1.IntBE = IntBE;
const V2E32 = Math.pow(2, 32);
function divmodInt64(t0) {
  const e0 = Math.floor(t0 / V2E32), n0 = t0 - e0 * V2E32;
  return { hi32: e0, lo32: n0 };
}
function roundedInt64(t0, e0) {
  return t0 * V2E32 + e0;
}
class NearUInt64 extends Layout {
  constructor(e0) {
    super(8, e0);
  }
  /** @override */
  decode(e0, n0 = 0) {
    const r0 = uint8ArrayToBuffer(e0), i0 = r0.readUInt32LE(n0), o0 = r0.readUInt32LE(n0 + 4);
    return roundedInt64(o0, i0);
  }
  /** @override */
  encode(e0, n0, r0 = 0) {
    const i0 = divmodInt64(e0), o0 = uint8ArrayToBuffer(n0);
    return o0.writeUInt32LE(i0.lo32, r0), o0.writeUInt32LE(i0.hi32, r0 + 4), 8;
  }
}
Layout$1.NearUInt64 = NearUInt64;
class NearUInt64BE extends Layout {
  constructor(e0) {
    super(8, e0);
  }
  /** @override */
  decode(e0, n0 = 0) {
    const r0 = uint8ArrayToBuffer(e0), i0 = r0.readUInt32BE(n0), o0 = r0.readUInt32BE(n0 + 4);
    return roundedInt64(i0, o0);
  }
  /** @override */
  encode(e0, n0, r0 = 0) {
    const i0 = divmodInt64(e0), o0 = uint8ArrayToBuffer(n0);
    return o0.writeUInt32BE(i0.hi32, r0), o0.writeUInt32BE(i0.lo32, r0 + 4), 8;
  }
}
Layout$1.NearUInt64BE = NearUInt64BE;
class NearInt64 extends Layout {
  constructor(e0) {
    super(8, e0);
  }
  /** @override */
  decode(e0, n0 = 0) {
    const r0 = uint8ArrayToBuffer(e0), i0 = r0.readUInt32LE(n0), o0 = r0.readInt32LE(n0 + 4);
    return roundedInt64(o0, i0);
  }
  /** @override */
  encode(e0, n0, r0 = 0) {
    const i0 = divmodInt64(e0), o0 = uint8ArrayToBuffer(n0);
    return o0.writeUInt32LE(i0.lo32, r0), o0.writeInt32LE(i0.hi32, r0 + 4), 8;
  }
}
Layout$1.NearInt64 = NearInt64;
class NearInt64BE extends Layout {
  constructor(e0) {
    super(8, e0);
  }
  /** @override */
  decode(e0, n0 = 0) {
    const r0 = uint8ArrayToBuffer(e0), i0 = r0.readInt32BE(n0), o0 = r0.readUInt32BE(n0 + 4);
    return roundedInt64(i0, o0);
  }
  /** @override */
  encode(e0, n0, r0 = 0) {
    const i0 = divmodInt64(e0), o0 = uint8ArrayToBuffer(n0);
    return o0.writeInt32BE(i0.hi32, r0), o0.writeUInt32BE(i0.lo32, r0 + 4), 8;
  }
}
Layout$1.NearInt64BE = NearInt64BE;
class Float extends Layout {
  constructor(e0) {
    super(4, e0);
  }
  /** @override */
  decode(e0, n0 = 0) {
    return uint8ArrayToBuffer(e0).readFloatLE(n0);
  }
  /** @override */
  encode(e0, n0, r0 = 0) {
    return uint8ArrayToBuffer(n0).writeFloatLE(e0, r0), 4;
  }
}
Layout$1.Float = Float;
class FloatBE extends Layout {
  constructor(e0) {
    super(4, e0);
  }
  /** @override */
  decode(e0, n0 = 0) {
    return uint8ArrayToBuffer(e0).readFloatBE(n0);
  }
  /** @override */
  encode(e0, n0, r0 = 0) {
    return uint8ArrayToBuffer(n0).writeFloatBE(e0, r0), 4;
  }
}
Layout$1.FloatBE = FloatBE;
class Double extends Layout {
  constructor(e0) {
    super(8, e0);
  }
  /** @override */
  decode(e0, n0 = 0) {
    return uint8ArrayToBuffer(e0).readDoubleLE(n0);
  }
  /** @override */
  encode(e0, n0, r0 = 0) {
    return uint8ArrayToBuffer(n0).writeDoubleLE(e0, r0), 8;
  }
}
Layout$1.Double = Double;
class DoubleBE extends Layout {
  constructor(e0) {
    super(8, e0);
  }
  /** @override */
  decode(e0, n0 = 0) {
    return uint8ArrayToBuffer(e0).readDoubleBE(n0);
  }
  /** @override */
  encode(e0, n0, r0 = 0) {
    return uint8ArrayToBuffer(n0).writeDoubleBE(e0, r0), 8;
  }
}
Layout$1.DoubleBE = DoubleBE;
class Sequence extends Layout {
  constructor(e0, n0, r0) {
    if (!(e0 instanceof Layout))
      throw new TypeError("elementLayout must be a Layout");
    if (!(n0 instanceof ExternalLayout && n0.isCount() || Number.isInteger(n0) && 0 <= n0))
      throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
    let i0 = -1;
    !(n0 instanceof ExternalLayout) && 0 < e0.span && (i0 = n0 * e0.span), super(i0, r0), this.elementLayout = e0, this.count = n0;
  }
  /** @override */
  getSpan(e0, n0 = 0) {
    if (0 <= this.span)
      return this.span;
    let r0 = 0, i0 = this.count;
    if (i0 instanceof ExternalLayout && (i0 = i0.decode(e0, n0)), 0 < this.elementLayout.span)
      r0 = i0 * this.elementLayout.span;
    else {
      let o0 = 0;
      for (; o0 < i0; )
        r0 += this.elementLayout.getSpan(e0, n0 + r0), ++o0;
    }
    return r0;
  }
  /** @override */
  decode(e0, n0 = 0) {
    const r0 = [];
    let i0 = 0, o0 = this.count;
    for (o0 instanceof ExternalLayout && (o0 = o0.decode(e0, n0)); i0 < o0; )
      r0.push(this.elementLayout.decode(e0, n0)), n0 += this.elementLayout.getSpan(e0, n0), i0 += 1;
    return r0;
  }
  /** Implement {@link Layout#encode|encode} for {@link Sequence}.
   *
   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
   * the unused space in the buffer is left unchanged.  If `src` is
   * longer than {@link Sequence#count|count} the unneeded elements are
   * ignored.
   *
   * **NOTE** If {@link Layout#count|count} is an instance of {@link
   * ExternalLayout} then the length of `src` will be encoded as the
   * count after `src` is encoded. */
  encode(e0, n0, r0 = 0) {
    const i0 = this.elementLayout, o0 = e0.reduce((s0, a0) => s0 + i0.encode(a0, n0, r0 + s0), 0);
    return this.count instanceof ExternalLayout && this.count.encode(e0.length, n0, r0), o0;
  }
}
Layout$1.Sequence = Sequence;
class Structure extends Layout {
  constructor(e0, n0, r0) {
    if (!(Array.isArray(e0) && e0.reduce((o0, s0) => o0 && s0 instanceof Layout, !0)))
      throw new TypeError("fields must be array of Layout instances");
    typeof n0 == "boolean" && r0 === void 0 && (r0 = n0, n0 = void 0);
    for (const o0 of e0)
      if (0 > o0.span && o0.property === void 0)
        throw new Error("fields cannot contain unnamed variable-length layout");
    let i0 = -1;
    try {
      i0 = e0.reduce((o0, s0) => o0 + s0.getSpan(), 0);
    } catch {
    }
    super(i0, n0), this.fields = e0, this.decodePrefixes = !!r0;
  }
  /** @override */
  getSpan(e0, n0 = 0) {
    if (0 <= this.span)
      return this.span;
    let r0 = 0;
    try {
      r0 = this.fields.reduce((i0, o0) => {
        const s0 = o0.getSpan(e0, n0);
        return n0 += s0, i0 + s0;
      }, 0);
    } catch {
      throw new RangeError("indeterminate span");
    }
    return r0;
  }
  /** @override */
  decode(e0, n0 = 0) {
    checkUint8Array(e0);
    const r0 = this.makeDestinationObject();
    for (const i0 of this.fields)
      if (i0.property !== void 0 && (r0[i0.property] = i0.decode(e0, n0)), n0 += i0.getSpan(e0, n0), this.decodePrefixes && e0.length === n0)
        break;
    return r0;
  }
  /** Implement {@link Layout#encode|encode} for {@link Structure}.
   *
   * If `src` is missing a property for a member with a defined {@link
   * Layout#property|property} the corresponding region of the buffer is
   * left unmodified. */
  encode(e0, n0, r0 = 0) {
    const i0 = r0;
    let o0 = 0, s0 = 0;
    for (const a0 of this.fields) {
      let c0 = a0.span;
      if (s0 = 0 < c0 ? c0 : 0, a0.property !== void 0) {
        const l0 = e0[a0.property];
        l0 !== void 0 && (s0 = a0.encode(l0, n0, r0), 0 > c0 && (c0 = a0.getSpan(n0, r0)));
      }
      o0 = r0, r0 += c0;
    }
    return o0 + s0 - i0;
  }
  /** @override */
  fromArray(e0) {
    const n0 = this.makeDestinationObject();
    for (const r0 of this.fields)
      r0.property !== void 0 && 0 < e0.length && (n0[r0.property] = e0.shift());
    return n0;
  }
  /**
   * Get access to the layout of a given property.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Layout} - the layout associated with `property`, or
   * undefined if there is no such property.
   */
  layoutFor(e0) {
    if (typeof e0 != "string")
      throw new TypeError("property must be string");
    for (const n0 of this.fields)
      if (n0.property === e0)
        return n0;
  }
  /**
   * Get the offset of a structure member.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Number} - the offset in bytes to the start of `property`
   * within the structure, or undefined if `property` is not a field
   * within the structure.  If the property is a member but follows a
   * variable-length structure member a negative number will be
   * returned.
   */
  offsetOf(e0) {
    if (typeof e0 != "string")
      throw new TypeError("property must be string");
    let n0 = 0;
    for (const r0 of this.fields) {
      if (r0.property === e0)
        return n0;
      0 > r0.span ? n0 = -1 : 0 <= n0 && (n0 += r0.span);
    }
  }
}
Layout$1.Structure = Structure;
class UnionDiscriminator {
  constructor(e0) {
    this.property = e0;
  }
  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
   *
   * The implementation of this method need not reference the buffer if
   * variant information is available through other means. */
  decode(e0, n0) {
    throw new Error("UnionDiscriminator is abstract");
  }
  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
   *
   * The implementation of this method need not store the value if
   * variant information is maintained through other means. */
  encode(e0, n0, r0) {
    throw new Error("UnionDiscriminator is abstract");
  }
}
Layout$1.UnionDiscriminator = UnionDiscriminator;
class UnionLayoutDiscriminator extends UnionDiscriminator {
  constructor(e0, n0) {
    if (!(e0 instanceof ExternalLayout && e0.isCount()))
      throw new TypeError("layout must be an unsigned integer ExternalLayout");
    super(n0 || e0.property || "variant"), this.layout = e0;
  }
  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
  decode(e0, n0) {
    return this.layout.decode(e0, n0);
  }
  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
  encode(e0, n0, r0) {
    return this.layout.encode(e0, n0, r0);
  }
}
Layout$1.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
class Union extends Layout {
  constructor(e0, n0, r0) {
    let i0;
    if (e0 instanceof UInt || e0 instanceof UIntBE)
      i0 = new UnionLayoutDiscriminator(new OffsetLayout(e0));
    else if (e0 instanceof ExternalLayout && e0.isCount())
      i0 = new UnionLayoutDiscriminator(e0);
    else if (e0 instanceof UnionDiscriminator)
      i0 = e0;
    else
      throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
    if (n0 === void 0 && (n0 = null), !(n0 === null || n0 instanceof Layout))
      throw new TypeError("defaultLayout must be null or a Layout");
    if (n0 !== null) {
      if (0 > n0.span)
        throw new Error("defaultLayout must have constant span");
      n0.property === void 0 && (n0 = n0.replicate("content"));
    }
    let o0 = -1;
    n0 && (o0 = n0.span, 0 <= o0 && (e0 instanceof UInt || e0 instanceof UIntBE) && (o0 += i0.layout.span)), super(o0, r0), this.discriminator = i0, this.usesPrefixDiscriminator = e0 instanceof UInt || e0 instanceof UIntBE, this.defaultLayout = n0, this.registry = {};
    let s0 = this.defaultGetSourceVariant.bind(this);
    this.getSourceVariant = function(a0) {
      return s0(a0);
    }, this.configGetSourceVariant = function(a0) {
      s0 = a0.bind(this);
    };
  }
  /** @override */
  getSpan(e0, n0 = 0) {
    if (0 <= this.span)
      return this.span;
    const r0 = this.getVariant(e0, n0);
    if (!r0)
      throw new Error("unable to determine span for unrecognized variant");
    return r0.getSpan(e0, n0);
  }
  /**
   * Method to infer a registered Union variant compatible with `src`.
   *
   * The first satisfied rule in the following sequence defines the
   * return value:
   * * If `src` has properties matching the Union discriminator and
   *   the default layout, `undefined` is returned regardless of the
   *   value of the discriminator property (this ensures the default
   *   layout will be used);
   * * If `src` has a property matching the Union discriminator, the
   *   value of the discriminator identifies a registered variant, and
   *   either (a) the variant has no layout, or (b) `src` has the
   *   variant's property, then the variant is returned (because the
   *   source satisfies the constraints of the variant it identifies);
   * * If `src` does not have a property matching the Union
   *   discriminator, but does have a property matching a registered
   *   variant, then the variant is returned (because the source
   *   matches a variant without an explicit conflict);
   * * An error is thrown (because we either can't identify a variant,
   *   or we were explicitly told the variant but can't satisfy it).
   *
   * @param {Object} src - an object presumed to be compatible with
   * the content of the Union.
   *
   * @return {(undefined|VariantLayout)} - as described above.
   *
   * @throws {Error} - if `src` cannot be associated with a default or
   * registered variant.
   */
  defaultGetSourceVariant(e0) {
    if (Object.prototype.hasOwnProperty.call(e0, this.discriminator.property)) {
      if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(e0, this.defaultLayout.property))
        return;
      const n0 = this.registry[e0[this.discriminator.property]];
      if (n0 && (!n0.layout || n0.property && Object.prototype.hasOwnProperty.call(e0, n0.property)))
        return n0;
    } else
      for (const n0 in this.registry) {
        const r0 = this.registry[n0];
        if (r0.property && Object.prototype.hasOwnProperty.call(e0, r0.property))
          return r0;
      }
    throw new Error("unable to infer src variant");
  }
  /** Implement {@link Layout#decode|decode} for {@link Union}.
   *
   * If the variant is {@link Union#addVariant|registered} the return
   * value is an instance of that variant, with no explicit
   * discriminator.  Otherwise the {@link Union#defaultLayout|default
   * layout} is used to decode the content. */
  decode(e0, n0 = 0) {
    let r0;
    const i0 = this.discriminator, o0 = i0.decode(e0, n0), s0 = this.registry[o0];
    if (s0 === void 0) {
      const a0 = this.defaultLayout;
      let c0 = 0;
      this.usesPrefixDiscriminator && (c0 = i0.layout.span), r0 = this.makeDestinationObject(), r0[i0.property] = o0, r0[a0.property] = a0.decode(e0, n0 + c0);
    } else
      r0 = s0.decode(e0, n0);
    return r0;
  }
  /** Implement {@link Layout#encode|encode} for {@link Union}.
   *
   * This API assumes the `src` object is consistent with the union's
   * {@link Union#defaultLayout|default layout}.  To encode variants
   * use the appropriate variant-specific {@link VariantLayout#encode}
   * method. */
  encode(e0, n0, r0 = 0) {
    const i0 = this.getSourceVariant(e0);
    if (i0 === void 0) {
      const o0 = this.discriminator, s0 = this.defaultLayout;
      let a0 = 0;
      return this.usesPrefixDiscriminator && (a0 = o0.layout.span), o0.encode(e0[o0.property], n0, r0), a0 + s0.encode(e0[s0.property], n0, r0 + a0);
    }
    return i0.encode(e0, n0, r0);
  }
  /** Register a new variant structure within a union.  The newly
   * created variant is returned.
   *
   * @param {Number} variant - initializer for {@link
   * VariantLayout#variant|variant}.
   *
   * @param {Layout} layout - initializer for {@link
   * VariantLayout#layout|layout}.
   *
   * @param {String} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {VariantLayout} */
  addVariant(e0, n0, r0) {
    const i0 = new VariantLayout(this, e0, n0, r0);
    return this.registry[e0] = i0, i0;
  }
  /**
   * Get the layout associated with a registered variant.
   *
   * If `vb` does not produce a registered variant the function returns
   * `undefined`.
   *
   * @param {(Number|Uint8Array)} vb - either the variant number, or a
   * buffer from which the discriminator is to be read.
   *
   * @param {Number} offset - offset into `vb` for the start of the
   * union.  Used only when `vb` is an instance of {Uint8Array}.
   *
   * @return {({VariantLayout}|undefined)}
   */
  getVariant(e0, n0 = 0) {
    let r0;
    return e0 instanceof Uint8Array ? r0 = this.discriminator.decode(e0, n0) : r0 = e0, this.registry[r0];
  }
}
Layout$1.Union = Union;
class VariantLayout extends Layout {
  constructor(e0, n0, r0, i0) {
    if (!(e0 instanceof Union))
      throw new TypeError("union must be a Union");
    if (!Number.isInteger(n0) || 0 > n0)
      throw new TypeError("variant must be a (non-negative) integer");
    if (typeof r0 == "string" && i0 === void 0 && (i0 = r0, r0 = null), r0) {
      if (!(r0 instanceof Layout))
        throw new TypeError("layout must be a Layout");
      if (e0.defaultLayout !== null && 0 <= r0.span && r0.span > e0.defaultLayout.span)
        throw new Error("variant span exceeds span of containing union");
      if (typeof i0 != "string")
        throw new TypeError("variant must have a String property");
    }
    let o0 = e0.span;
    0 > e0.span && (o0 = r0 ? r0.span : 0, 0 <= o0 && e0.usesPrefixDiscriminator && (o0 += e0.discriminator.layout.span)), super(o0, i0), this.union = e0, this.variant = n0, this.layout = r0 || null;
  }
  /** @override */
  getSpan(e0, n0 = 0) {
    if (0 <= this.span)
      return this.span;
    let r0 = 0;
    this.union.usesPrefixDiscriminator && (r0 = this.union.discriminator.layout.span);
    let i0 = 0;
    return this.layout && (i0 = this.layout.getSpan(e0, n0 + r0)), r0 + i0;
  }
  /** @override */
  decode(e0, n0 = 0) {
    const r0 = this.makeDestinationObject();
    if (this !== this.union.getVariant(e0, n0))
      throw new Error("variant mismatch");
    let i0 = 0;
    return this.union.usesPrefixDiscriminator && (i0 = this.union.discriminator.layout.span), this.layout ? r0[this.property] = this.layout.decode(e0, n0 + i0) : this.property ? r0[this.property] = !0 : this.union.usesPrefixDiscriminator && (r0[this.union.discriminator.property] = this.variant), r0;
  }
  /** @override */
  encode(e0, n0, r0 = 0) {
    let i0 = 0;
    if (this.union.usesPrefixDiscriminator && (i0 = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(e0, this.property))
      throw new TypeError("variant lacks property " + this.property);
    this.union.discriminator.encode(this.variant, n0, r0);
    let o0 = i0;
    if (this.layout && (this.layout.encode(e0[this.property], n0, r0 + i0), o0 += this.layout.getSpan(n0, r0 + i0), 0 <= this.union.span && o0 > this.union.span))
      throw new Error("encoded variant overruns containing union");
    return o0;
  }
  /** Delegate {@link Layout#fromArray|fromArray} to {@link
   * VariantLayout#layout|layout}. */
  fromArray(e0) {
    if (this.layout)
      return this.layout.fromArray(e0);
  }
}
Layout$1.VariantLayout = VariantLayout;
function fixBitwiseResult(t0) {
  return 0 > t0 && (t0 += 4294967296), t0;
}
class BitStructure extends Layout {
  constructor(e0, n0, r0) {
    if (!(e0 instanceof UInt || e0 instanceof UIntBE))
      throw new TypeError("word must be a UInt or UIntBE layout");
    if (typeof n0 == "string" && r0 === void 0 && (r0 = n0, n0 = !1), 4 < e0.span)
      throw new RangeError("word cannot exceed 32 bits");
    super(e0.span, r0), this.word = e0, this.msb = !!n0, this.fields = [];
    let i0 = 0;
    this._packedSetValue = function(o0) {
      return i0 = fixBitwiseResult(o0), this;
    }, this._packedGetValue = function() {
      return i0;
    };
  }
  /** @override */
  decode(e0, n0 = 0) {
    const r0 = this.makeDestinationObject(), i0 = this.word.decode(e0, n0);
    this._packedSetValue(i0);
    for (const o0 of this.fields)
      o0.property !== void 0 && (r0[o0.property] = o0.decode(e0));
    return r0;
  }
  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
   *
   * If `src` is missing a property for a member with a defined {@link
   * Layout#property|property} the corresponding region of the packed
   * value is left unmodified.  Unused bits are also left unmodified. */
  encode(e0, n0, r0 = 0) {
    const i0 = this.word.decode(n0, r0);
    this._packedSetValue(i0);
    for (const o0 of this.fields)
      if (o0.property !== void 0) {
        const s0 = e0[o0.property];
        s0 !== void 0 && o0.encode(s0);
      }
    return this.word.encode(this._packedGetValue(), n0, r0);
  }
  /** Register a new bitfield with a containing bit structure.  The
   * resulting bitfield is returned.
   *
   * @param {Number} bits - initializer for {@link BitField#bits|bits}.
   *
   * @param {string} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {BitField} */
  addField(e0, n0) {
    const r0 = new BitField(this, e0, n0);
    return this.fields.push(r0), r0;
  }
  /** As with {@link BitStructure#addField|addField} for single-bit
   * fields with `boolean` value representation.
   *
   * @param {string} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {Boolean} */
  // `Boolean` conflicts with the native primitive type
  // eslint-disable-next-line @typescript-eslint/ban-types
  addBoolean(e0) {
    const n0 = new Boolean$1(this, e0);
    return this.fields.push(n0), n0;
  }
  /**
   * Get access to the bit field for a given property.
   *
   * @param {String} property - the bit field of interest.
   *
   * @return {BitField} - the field associated with `property`, or
   * undefined if there is no such property.
   */
  fieldFor(e0) {
    if (typeof e0 != "string")
      throw new TypeError("property must be string");
    for (const n0 of this.fields)
      if (n0.property === e0)
        return n0;
  }
}
Layout$1.BitStructure = BitStructure;
class BitField {
  constructor(e0, n0, r0) {
    if (!(e0 instanceof BitStructure))
      throw new TypeError("container must be a BitStructure");
    if (!Number.isInteger(n0) || 0 >= n0)
      throw new TypeError("bits must be positive integer");
    const i0 = 8 * e0.span, o0 = e0.fields.reduce((s0, a0) => s0 + a0.bits, 0);
    if (n0 + o0 > i0)
      throw new Error("bits too long for span remainder (" + (i0 - o0) + " of " + i0 + " remain)");
    this.container = e0, this.bits = n0, this.valueMask = (1 << n0) - 1, n0 === 32 && (this.valueMask = 4294967295), this.start = o0, this.container.msb && (this.start = i0 - o0 - n0), this.wordMask = fixBitwiseResult(this.valueMask << this.start), this.property = r0;
  }
  /** Store a value into the corresponding subsequence of the containing
   * bit field. */
  decode(e0, n0) {
    const r0 = this.container._packedGetValue();
    return fixBitwiseResult(r0 & this.wordMask) >>> this.start;
  }
  /** Store a value into the corresponding subsequence of the containing
   * bit field.
   *
   * **NOTE** This is not a specialization of {@link
   * Layout#encode|Layout.encode} and there is no return value. */
  encode(e0) {
    if (typeof e0 != "number" || !Number.isInteger(e0) || e0 !== fixBitwiseResult(e0 & this.valueMask))
      throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
    const n0 = this.container._packedGetValue(), r0 = fixBitwiseResult(e0 << this.start);
    this.container._packedSetValue(fixBitwiseResult(n0 & ~this.wordMask) | r0);
  }
}
Layout$1.BitField = BitField;
let Boolean$1 = class extends BitField {
  constructor(e0, n0) {
    super(e0, 1, n0);
  }
  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
   *
   * @returns {boolean} */
  decode(e0, n0) {
    return !!super.decode(e0, n0);
  }
  /** @override */
  encode(e0) {
    typeof e0 == "boolean" && (e0 = +e0), super.encode(e0);
  }
};
Layout$1.Boolean = Boolean$1;
let Blob$1 = class extends Layout {
  constructor(e0, n0) {
    if (!(e0 instanceof ExternalLayout && e0.isCount() || Number.isInteger(e0) && 0 <= e0))
      throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
    let r0 = -1;
    e0 instanceof ExternalLayout || (r0 = e0), super(r0, n0), this.length = e0;
  }
  /** @override */
  getSpan(e0, n0) {
    let r0 = this.span;
    return 0 > r0 && (r0 = this.length.decode(e0, n0)), r0;
  }
  /** @override */
  decode(e0, n0 = 0) {
    let r0 = this.span;
    return 0 > r0 && (r0 = this.length.decode(e0, n0)), uint8ArrayToBuffer(e0).slice(n0, n0 + r0);
  }
  /** Implement {@link Layout#encode|encode} for {@link Blob}.
   *
   * **NOTE** If {@link Layout#count|count} is an instance of {@link
   * ExternalLayout} then the length of `src` will be encoded as the
   * count after `src` is encoded. */
  encode(e0, n0, r0) {
    let i0 = this.length;
    if (this.length instanceof ExternalLayout && (i0 = e0.length), !(e0 instanceof Uint8Array && i0 === e0.length))
      throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + i0 + ") Uint8Array as src");
    if (r0 + i0 > n0.length)
      throw new RangeError("encoding overruns Uint8Array");
    const o0 = uint8ArrayToBuffer(e0);
    return uint8ArrayToBuffer(n0).write(o0.toString("hex"), r0, i0, "hex"), this.length instanceof ExternalLayout && this.length.encode(i0, n0, r0), i0;
  }
};
Layout$1.Blob = Blob$1;
class CString extends Layout {
  constructor(e0) {
    super(-1, e0);
  }
  /** @override */
  getSpan(e0, n0 = 0) {
    checkUint8Array(e0);
    let r0 = n0;
    for (; r0 < e0.length && e0[r0] !== 0; )
      r0 += 1;
    return 1 + r0 - n0;
  }
  /** @override */
  decode(e0, n0 = 0) {
    const r0 = this.getSpan(e0, n0);
    return uint8ArrayToBuffer(e0).slice(n0, n0 + r0 - 1).toString("utf-8");
  }
  /** @override */
  encode(e0, n0, r0 = 0) {
    typeof e0 != "string" && (e0 = String(e0));
    const i0 = buffer_1.Buffer.from(e0, "utf8"), o0 = i0.length;
    if (r0 + o0 > n0.length)
      throw new RangeError("encoding overruns Buffer");
    const s0 = uint8ArrayToBuffer(n0);
    return i0.copy(s0, r0), s0[r0 + o0] = 0, o0 + 1;
  }
}
Layout$1.CString = CString;
class UTF8 extends Layout {
  constructor(e0, n0) {
    if (typeof e0 == "string" && n0 === void 0 && (n0 = e0, e0 = void 0), e0 === void 0)
      e0 = -1;
    else if (!Number.isInteger(e0))
      throw new TypeError("maxSpan must be an integer");
    super(-1, n0), this.maxSpan = e0;
  }
  /** @override */
  getSpan(e0, n0 = 0) {
    return checkUint8Array(e0), e0.length - n0;
  }
  /** @override */
  decode(e0, n0 = 0) {
    const r0 = this.getSpan(e0, n0);
    if (0 <= this.maxSpan && this.maxSpan < r0)
      throw new RangeError("text length exceeds maxSpan");
    return uint8ArrayToBuffer(e0).slice(n0, n0 + r0).toString("utf-8");
  }
  /** @override */
  encode(e0, n0, r0 = 0) {
    typeof e0 != "string" && (e0 = String(e0));
    const i0 = buffer_1.Buffer.from(e0, "utf8"), o0 = i0.length;
    if (0 <= this.maxSpan && this.maxSpan < o0)
      throw new RangeError("text length exceeds maxSpan");
    if (r0 + o0 > n0.length)
      throw new RangeError("encoding overruns Buffer");
    return i0.copy(uint8ArrayToBuffer(n0), r0), o0;
  }
}
Layout$1.UTF8 = UTF8;
class Constant extends Layout {
  constructor(e0, n0) {
    super(0, n0), this.value = e0;
  }
  /** @override */
  decode(e0, n0) {
    return this.value;
  }
  /** @override */
  encode(e0, n0, r0) {
    return 0;
  }
}
Layout$1.Constant = Constant;
Layout$1.greedy = (t0, e0) => new GreedyCount(t0, e0);
var offset = Layout$1.offset = (t0, e0, n0) => new OffsetLayout(t0, e0, n0), u8 = Layout$1.u8 = (t0) => new UInt(1, t0), u16 = Layout$1.u16 = (t0) => new UInt(2, t0);
Layout$1.u24 = (t0) => new UInt(3, t0);
var u32 = Layout$1.u32 = (t0) => new UInt(4, t0);
Layout$1.u40 = (t0) => new UInt(5, t0);
Layout$1.u48 = (t0) => new UInt(6, t0);
var nu64 = Layout$1.nu64 = (t0) => new NearUInt64(t0);
Layout$1.u16be = (t0) => new UIntBE(2, t0);
Layout$1.u24be = (t0) => new UIntBE(3, t0);
Layout$1.u32be = (t0) => new UIntBE(4, t0);
Layout$1.u40be = (t0) => new UIntBE(5, t0);
Layout$1.u48be = (t0) => new UIntBE(6, t0);
Layout$1.nu64be = (t0) => new NearUInt64BE(t0);
Layout$1.s8 = (t0) => new Int(1, t0);
Layout$1.s16 = (t0) => new Int(2, t0);
Layout$1.s24 = (t0) => new Int(3, t0);
Layout$1.s32 = (t0) => new Int(4, t0);
Layout$1.s40 = (t0) => new Int(5, t0);
Layout$1.s48 = (t0) => new Int(6, t0);
var ns64 = Layout$1.ns64 = (t0) => new NearInt64(t0);
Layout$1.s16be = (t0) => new IntBE(2, t0);
Layout$1.s24be = (t0) => new IntBE(3, t0);
Layout$1.s32be = (t0) => new IntBE(4, t0);
Layout$1.s40be = (t0) => new IntBE(5, t0);
Layout$1.s48be = (t0) => new IntBE(6, t0);
Layout$1.ns64be = (t0) => new NearInt64BE(t0);
Layout$1.f32 = (t0) => new Float(t0);
Layout$1.f32be = (t0) => new FloatBE(t0);
Layout$1.f64 = (t0) => new Double(t0);
Layout$1.f64be = (t0) => new DoubleBE(t0);
var struct = Layout$1.struct = (t0, e0, n0) => new Structure(t0, e0, n0);
Layout$1.bits = (t0, e0, n0) => new BitStructure(t0, e0, n0);
var seq = Layout$1.seq = (t0, e0, n0) => new Sequence(t0, e0, n0);
Layout$1.union = (t0, e0, n0) => new Union(t0, e0, n0);
Layout$1.unionLayoutDiscriminator = (t0, e0) => new UnionLayoutDiscriminator(t0, e0);
var blob = Layout$1.blob = (t0, e0) => new Blob$1(t0, e0);
Layout$1.cstr = (t0) => new CString(t0);
Layout$1.utf8 = (t0, e0) => new UTF8(t0, e0);
Layout$1.constant = (t0, e0) => new Constant(t0, e0);
var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1, SOLANA_ERROR__INVALID_NONCE = 2, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3, SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4, SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5, SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6, SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7, SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8, SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9, SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10, SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700, SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603, SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602, SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601, SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013, SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001, SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002, SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003, SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004, SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005, SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006, SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008, SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009, SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010, SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011, SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4, SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001, SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002, SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003, SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004, SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4, SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001, SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002, SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003, SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004, SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005, SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006, SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007, SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3, SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3, SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001, SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002, SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003, SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001, SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002, SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3, SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005, SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006, SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007, SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009, SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010, SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011, SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012, SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013, SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014, SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015, SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016, SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018, SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019, SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024, SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030, SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031, SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032, SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033, SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037, SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038, SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042, SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043, SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044, SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047, SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048, SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049, SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053, SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054, SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3, SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008, SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009, SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010, SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001, SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002, SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003, SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009, SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010, SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012, SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013, SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014, SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015, SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016, SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017, SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018, SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019, SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020, SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003, SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004, SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006, SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007, SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008, SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009, SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011, SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013, SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014, SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017, SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021, SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022, SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029, SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030, SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031, SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033, SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034, SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035, SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036, SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001, SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002, SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003, SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004, SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005, SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006, SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007, SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008, SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009, SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010, SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011, SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012, SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013, SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014, SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015, SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016, SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017, SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018, SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019, SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020, SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021, SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022, SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5, SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001, SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002, SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 819e4, SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004, SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 99e5, SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001, SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002, SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003, SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;
function encodeValue(t0) {
  return Array.isArray(t0) ? "%5B" + t0.map(encodeValue).join(
    "%2C%20"
    /* ", " */
  ) + /* "]" */
  "%5D" : typeof t0 == "bigint" ? `${t0}n` : encodeURIComponent(
    String(
      t0 != null && Object.getPrototypeOf(t0) === null ? (
        // Plain objects with no prototype don't have a `toString` method.
        // Convert them before stringifying them.
        { ...t0 }
      ) : t0
    )
  );
}
function encodeObjectContextEntry([t0, e0]) {
  return `${t0}=${encodeValue(e0)}`;
}
function encodeContextObject(t0) {
  const e0 = Object.entries(t0).map(encodeObjectContextEntry).join("&");
  return btoa(e0);
}
var SolanaErrorMessages = {
  [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: "Account not found at address: $address",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: "Expected decoded account at address: $address",
  [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: "Failed to decode account data at address: $address",
  [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: "Accounts not found at addresses: $addresses",
  [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: "Unable to find a viable program address bump seed.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: "$putativeAddress is not a base58-encoded address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: "The `CryptoKey` must be an `Ed25519` public key.",
  [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: "Invalid seeds; point must fall off the Ed25519 curve.",
  [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
  [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
  [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
  [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
  [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: "Program address cannot end with PDA marker.",
  [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: "The network has progressed past the last block for which this transaction could have been committed.",
  [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: "Codec [$codecDescription] cannot decode empty byte arrays.",
  [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
  [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: "Encoder and decoder must either both be fixed-size or variable-size.",
  [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
  [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: "Expected a fixed-size codec, got a variable-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
  [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: "Expected a variable-size codec, got a fixed-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
  [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
  [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
  [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
  [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: "Invalid literal union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: "Expected [$codecDescription] to have $expected items, got $actual.",
  [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: "Invalid value $value for base $base with alphabet $alphabet.",
  [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
  [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
  [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
  [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
  [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
  [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: "No random values implementation could be found.",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: "instruction requires an uninitialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: "instruction tries to borrow reference for an account which is already borrowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "instruction left account with an outstanding borrowed reference",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: "program other than the account's owner changed the size of the account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: "account data too small for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: "instruction expected an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: "An account does not have enough lamports to be rent-exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: "Program arithmetic overflowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: "Failed to serialize or deserialize account data: $encodedData",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: "Builtin programs must consume compute units",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: "Cross-program invocation call depth too deep",
  [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: "Computational budget exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: "custom program error: #$code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: "instruction contains duplicate accounts",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: "instruction modifications of multiply-passed account differ",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: "executable accounts must be rent exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: "instruction changed executable accounts data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: "instruction changed the balance of an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: "instruction changed executable bit of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: "instruction modified data of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: "instruction spent from the balance of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: "generic instruction error",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: "Provided owner is not allowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: "Account is immutable",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: "Incorrect authority provided",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: "incorrect program id for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: "insufficient funds for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: "invalid account data for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: "Invalid account owner",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: "invalid program argument",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: "program returned invalid error code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: "invalid instruction data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: "Failed to reallocate account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: "Provided seeds do not result in a valid address",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: "Accounts data allocations exceeded the maximum allowed per transaction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: "Max accounts exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: "Max instruction trace length exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: "Length of the seed is too long for address generation",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: "An account required by the instruction is missing",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: "missing required signature for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: "instruction illegally modified the program id of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: "insufficient account keys for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: "Cross-program invocation with unauthorized signer or writable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: "Failed to create program execution environment",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: "Program failed to compile",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: "Program failed to complete",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: "instruction modified data of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: "instruction changed the balance of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: "Cross-program invocation reentrancy not allowed for this instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: "instruction modified rent epoch of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: "sum of account balances before and after instruction do not match",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: "instruction requires an initialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: "",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: "Unsupported program id",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: "Unsupported sysvar",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: "The instruction does not have any accounts.",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: "The instruction does not have any data.",
  [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
  [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__INVALID_NONCE]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
  [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: "Minimum context slot has not been reached",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: "Node is unhealthy; behind by $numSlotsBehind slots",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: "No snapshot",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: "Transaction simulation failed",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: "Transaction history is not available from this node",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: "Transaction signature length mismatch",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: "Transaction signature verification failure",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: "$__serverMessage",
  [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: "Key pair bytes must be of length 64, got $byteLength.",
  [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: "Expected private key bytes with length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: "The provided private key does not match the provided public key.",
  [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
  [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: "Lamports value must be in the range [0, 2e64-1]",
  [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: "`$value` cannot be parsed as a `BigInt`",
  [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: "$message",
  [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: "`$value` cannot be parsed as a `Number`",
  [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: "No nonce account could be found at address `$nonceAccountAddress`",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: "WebSocket was closed before payload could be added to the send buffer",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: "WebSocket connection closed",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: "WebSocket failed to connect",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: "Failed to obtain a subscription id from the server",
  [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: "Could not find an API plan for RPC method: `$method`",
  [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: "HTTP error ($statusCode): $message",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
  [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
  [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: "The provided value does not implement the `KeyPairSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: "The provided value does not implement the `MessageModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: "The provided value does not implement the `MessagePartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: "The provided value does not implement any of the `MessageSigner` interfaces",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: "The provided value does not implement the `TransactionModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: "The provided value does not implement the `TransactionPartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: "The provided value does not implement the `TransactionSendingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: "The provided value does not implement any of the `TransactionSigner` interfaces",
  [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: "More than one `TransactionSendingSigner` was identified.",
  [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
  [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
  [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: "Cannot export a non-extractable key.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: "No digest implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: `This runtime does not support the generation of Ed25519 key pairs.

Install @solana/webcrypto-ed25519-polyfill and call its \`install\` function before generating keys in environments that do not support Ed25519.

For a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.`,
  [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: "No signature verification implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: "No key generation implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: "No signing implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: "No key export implementation could be found.",
  [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "Transaction processing left an account with an outstanding borrowed reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: "Account in use",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: "Account loaded twice",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: "Attempt to debit an account but found no record of a prior credit.",
  [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: "Transaction loads an address table account that doesn't exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: "This transaction has already been processed",
  [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: "Blockhash not found",
  [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: "Loader call chain is too deep",
  [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: "Transactions are currently disabled due to cluster maintenance",
  [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: "Transaction contains a duplicate instruction ($index) that is not allowed",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: "Insufficient funds for fee",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: "This account may not be used to pay transaction fees",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: "Transaction contains an invalid account reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: "Transaction loads an address table account with invalid data",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: "Transaction address table lookup uses an invalid index",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: "Transaction loads an address table account with an invalid owner",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: "This program may not be used for executing instructions",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: "Transaction loads a writable account that cannot be written",
  [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: "Transaction exceeded max loaded accounts data size cap",
  [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: "Transaction requires a fee but has no signature present",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: "Attempt to load a program that does not exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
  [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: "ResanitizationNeeded",
  [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: "Transaction failed to sanitize accounts offsets correctly",
  [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: "Transaction did not pass signature verification",
  [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: "Transaction locked too many accounts",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: "Sum of account balances before and after transaction do not match",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: "The transaction failed with the error `$errorName`",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: "Transaction version is unsupported",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: "Transaction would exceed account data limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: "Transaction would exceed total account data limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: "Transaction would exceed max account limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: "Transaction would exceed max Block Cost Limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: "Transaction would exceed max Vote Cost Limit",
  [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: "Attempted to sign a transaction with an address that is not a signer for it",
  [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: "Transaction is missing an address at index: $index.",
  [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: "Transaction has no expected signers therefore it cannot be encoded",
  [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: "Transaction does not have a blockhash lifetime",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: "Transaction is not a durable nonce transaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: "No fee payer set in CompiledTransaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: "Could not find program address at index $index",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: "Transaction is missing a fee payer.",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: "Transaction first instruction is not advance nonce account instruction.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: "Transaction with no instructions cannot be durable nonce transaction.",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
  [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
  [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: "Transaction is missing signatures for addresses: $addresses.",
  [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
}, START_INDEX = "i", TYPE = "t";
function getHumanReadableErrorMessage(t0, e0 = {}) {
  const n0 = SolanaErrorMessages[t0];
  if (n0.length === 0)
    return "";
  let r0;
  function i0(s0) {
    if (r0[TYPE] === 2) {
      const a0 = n0.slice(r0[START_INDEX] + 1, s0);
      o0.push(
        a0 in e0 ? (
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          `${e0[a0]}`
        ) : `$${a0}`
      );
    } else
      r0[TYPE] === 1 && o0.push(n0.slice(r0[START_INDEX], s0));
  }
  const o0 = [];
  return n0.split("").forEach((s0, a0) => {
    if (a0 === 0) {
      r0 = {
        [START_INDEX]: 0,
        [TYPE]: n0[0] === "\\" ? 0 : n0[0] === "$" ? 2 : 1
        /* Text */
      };
      return;
    }
    let c0;
    switch (r0[TYPE]) {
      case 0:
        c0 = {
          [START_INDEX]: a0,
          [TYPE]: 1
          /* Text */
        };
        break;
      case 1:
        s0 === "\\" ? c0 = {
          [START_INDEX]: a0,
          [TYPE]: 0
          /* EscapeSequence */
        } : s0 === "$" && (c0 = {
          [START_INDEX]: a0,
          [TYPE]: 2
          /* Variable */
        });
        break;
      case 2:
        s0 === "\\" ? c0 = {
          [START_INDEX]: a0,
          [TYPE]: 0
          /* EscapeSequence */
        } : s0 === "$" ? c0 = {
          [START_INDEX]: a0,
          [TYPE]: 2
          /* Variable */
        } : s0.match(/\w/) || (c0 = {
          [START_INDEX]: a0,
          [TYPE]: 1
          /* Text */
        });
        break;
    }
    c0 && (r0 !== c0 && i0(a0), r0 = c0);
  }), i0(), o0.join("");
}
function getErrorMessage(t0, e0 = {}) {
  if (process.env.NODE_ENV !== "production")
    return getHumanReadableErrorMessage(t0, e0);
  {
    let n0 = `Solana error #${t0}; Decode this error by running \`npx @solana/errors decode -- ${t0}`;
    return Object.keys(e0).length && (n0 += ` '${encodeContextObject(e0)}'`), `${n0}\``;
  }
}
var SolanaError = class extends Error {
  constructor(...[e0, n0]) {
    let r0, i0;
    if (n0) {
      const { cause: s0, ...a0 } = n0;
      s0 && (i0 = { cause: s0 }), Object.keys(a0).length > 0 && (r0 = a0);
    }
    const o0 = getErrorMessage(e0, r0);
    super(o0, i0);
    /**
     * Indicates the root cause of this {@link SolanaError}, if any.
     *
     * For example, a transaction error might have an instruction error as its root cause. In this
     * case, you will be able to access the instruction error on the transaction error as `cause`.
     */
    xg(this, "cause", this.cause);
    /**
     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.
     */
    xg(this, "context");
    this.context = {
      __code: e0,
      ...r0
    }, this.name = "SolanaError";
  }
};
function getEncodedSize(t0, e0) {
  return "fixedSize" in e0 ? e0.fixedSize : e0.getSizeFromValue(t0);
}
function createEncoder(t0) {
  return Object.freeze({
    ...t0,
    encode: (e0) => {
      const n0 = new Uint8Array(getEncodedSize(e0, t0));
      return t0.write(e0, n0, 0), n0;
    }
  });
}
function createDecoder(t0) {
  return Object.freeze({
    ...t0,
    decode: (e0, n0 = 0) => t0.read(e0, n0)[0]
  });
}
function isFixedSize(t0) {
  return "fixedSize" in t0 && typeof t0.fixedSize == "number";
}
function combineCodec(t0, e0) {
  if (isFixedSize(t0) !== isFixedSize(e0))
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
  if (isFixedSize(t0) && isFixedSize(e0) && t0.fixedSize !== e0.fixedSize)
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {
      decoderFixedSize: e0.fixedSize,
      encoderFixedSize: t0.fixedSize
    });
  if (!isFixedSize(t0) && !isFixedSize(e0) && t0.maxSize !== e0.maxSize)
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {
      decoderMaxSize: e0.maxSize,
      encoderMaxSize: t0.maxSize
    });
  return {
    ...e0,
    ...t0,
    decode: e0.decode,
    encode: t0.encode,
    read: e0.read,
    write: t0.write
  };
}
function assertByteArrayIsNotEmptyForCodec(t0, e0, n0 = 0) {
  if (e0.length - n0 <= 0)
    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {
      codecDescription: t0
    });
}
function assertByteArrayHasEnoughBytesForCodec(t0, e0, n0, r0 = 0) {
  const i0 = n0.length - r0;
  if (i0 < e0)
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
      bytesLength: i0,
      codecDescription: t0,
      expected: e0
    });
}
function assertNumberIsBetweenForCodec(t0, e0, n0, r0) {
  if (r0 < e0 || r0 > n0)
    throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {
      codecDescription: t0,
      max: n0,
      min: e0,
      value: r0
    });
}
function isLittleEndian(t0) {
  return t0?.endian !== 1;
}
function numberEncoderFactory(t0) {
  return createEncoder({
    fixedSize: t0.size,
    write(e0, n0, r0) {
      t0.range && assertNumberIsBetweenForCodec(t0.name, t0.range[0], t0.range[1], e0);
      const i0 = new ArrayBuffer(t0.size);
      return t0.set(new DataView(i0), e0, isLittleEndian(t0.config)), n0.set(new Uint8Array(i0), r0), r0 + t0.size;
    }
  });
}
function numberDecoderFactory(t0) {
  return createDecoder({
    fixedSize: t0.size,
    read(e0, n0 = 0) {
      assertByteArrayIsNotEmptyForCodec(t0.name, e0, n0), assertByteArrayHasEnoughBytesForCodec(t0.name, t0.size, e0, n0);
      const r0 = new DataView(toArrayBuffer(e0, n0, t0.size));
      return [t0.get(r0, isLittleEndian(t0.config)), n0 + t0.size];
    }
  });
}
function toArrayBuffer(t0, e0, n0) {
  const r0 = t0.byteOffset + (e0 ?? 0), i0 = n0 ?? t0.byteLength;
  return t0.buffer.slice(r0, r0 + i0);
}
var getU64Encoder = (t0 = {}) => numberEncoderFactory({
  config: t0,
  name: "u64",
  range: [0n, BigInt("0xffffffffffffffff")],
  set: (e0, n0, r0) => e0.setBigUint64(0, BigInt(n0), r0),
  size: 8
}), getU64Decoder = (t0 = {}) => numberDecoderFactory({
  config: t0,
  get: (e0, n0) => e0.getBigUint64(0, n0),
  name: "u64",
  size: 8
}), getU64Codec = (t0 = {}) => combineCodec(getU64Encoder(t0), getU64Decoder(t0));
class StructError extends TypeError {
  constructor(e0, n0) {
    let r0;
    const { message: i0, explanation: o0, ...s0 } = e0, { path: a0 } = e0, c0 = a0.length === 0 ? i0 : `At path: ${a0.join(".")} -- ${i0}`;
    super(o0 ?? c0), o0 != null && (this.cause = c0), Object.assign(this, s0), this.name = this.constructor.name, this.failures = () => r0 ?? (r0 = [e0, ...n0()]);
  }
}
function isIterable(t0) {
  return isObject(t0) && typeof t0[Symbol.iterator] == "function";
}
function isObject(t0) {
  return typeof t0 == "object" && t0 != null;
}
function isNonArrayObject(t0) {
  return isObject(t0) && !Array.isArray(t0);
}
function print(t0) {
  return typeof t0 == "symbol" ? t0.toString() : typeof t0 == "string" ? JSON.stringify(t0) : `${t0}`;
}
function shiftIterator(t0) {
  const { done: e0, value: n0 } = t0.next();
  return e0 ? void 0 : n0;
}
function toFailure(t0, e0, n0, r0) {
  if (t0 === !0)
    return;
  t0 === !1 ? t0 = {} : typeof t0 == "string" && (t0 = { message: t0 });
  const { path: i0, branch: o0 } = e0, { type: s0 } = n0, { refinement: a0, message: c0 = `Expected a value of type \`${s0}\`${a0 ? ` with refinement \`${a0}\`` : ""}, but received: \`${print(r0)}\`` } = t0;
  return {
    value: r0,
    type: s0,
    refinement: a0,
    key: i0[i0.length - 1],
    path: i0,
    branch: o0,
    ...t0,
    message: c0
  };
}
function* toFailures(t0, e0, n0, r0) {
  isIterable(t0) || (t0 = [t0]);
  for (const i0 of t0) {
    const o0 = toFailure(i0, e0, n0, r0);
    o0 && (yield o0);
  }
}
function* run(t0, e0, n0 = {}) {
  const { path: r0 = [], branch: i0 = [t0], coerce: o0 = !1, mask: s0 = !1 } = n0, a0 = { path: r0, branch: i0, mask: s0 };
  o0 && (t0 = e0.coercer(t0, a0));
  let c0 = "valid";
  for (const l0 of e0.validator(t0, a0))
    l0.explanation = n0.message, c0 = "not_valid", yield [l0, void 0];
  for (let [l0, u0, d0] of e0.entries(t0, a0)) {
    const h0 = run(u0, d0, {
      path: l0 === void 0 ? r0 : [...r0, l0],
      branch: l0 === void 0 ? i0 : [...i0, u0],
      coerce: o0,
      mask: s0,
      message: n0.message
    });
    for (const g0 of h0)
      g0[0] ? (c0 = g0[0].refinement != null ? "not_refined" : "not_valid", yield [g0[0], void 0]) : o0 && (u0 = g0[1], l0 === void 0 ? t0 = u0 : t0 instanceof Map ? t0.set(l0, u0) : t0 instanceof Set ? t0.add(u0) : isObject(t0) && (u0 !== void 0 || l0 in t0) && (t0[l0] = u0));
  }
  if (c0 !== "not_valid")
    for (const l0 of e0.refiner(t0, a0))
      l0.explanation = n0.message, c0 = "not_refined", yield [l0, void 0];
  c0 === "valid" && (yield [void 0, t0]);
}
let Struct$1 = class {
  constructor(e0) {
    const { type: n0, schema: r0, validator: i0, refiner: o0, coercer: s0 = (c0) => c0, entries: a0 = function* () {
    } } = e0;
    this.type = n0, this.schema = r0, this.entries = a0, this.coercer = s0, i0 ? this.validator = (c0, l0) => {
      const u0 = i0(c0, l0);
      return toFailures(u0, l0, this, c0);
    } : this.validator = () => [], o0 ? this.refiner = (c0, l0) => {
      const u0 = o0(c0, l0);
      return toFailures(u0, l0, this, c0);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(e0, n0) {
    return assert$1(e0, this, n0);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(e0, n0) {
    return create(e0, this, n0);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(e0) {
    return is(e0, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema. Masking applies recursively to
   * props of `object` structs only.
   */
  mask(e0, n0) {
    return mask(e0, this, n0);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `coerce` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful. Also, `mask` will turn on
   * masking of the unknown `object` props recursively if passed.
   */
  validate(e0, n0 = {}) {
    return validate(e0, this, n0);
  }
};
function assert$1(t0, e0, n0) {
  const r0 = validate(t0, e0, { message: n0 });
  if (r0[0])
    throw r0[0];
}
function create(t0, e0, n0) {
  const r0 = validate(t0, e0, { coerce: !0, message: n0 });
  if (r0[0])
    throw r0[0];
  return r0[1];
}
function mask(t0, e0, n0) {
  const r0 = validate(t0, e0, { coerce: !0, mask: !0, message: n0 });
  if (r0[0])
    throw r0[0];
  return r0[1];
}
function is(t0, e0) {
  return !validate(t0, e0)[0];
}
function validate(t0, e0, n0 = {}) {
  const r0 = run(t0, e0, n0), i0 = shiftIterator(r0);
  return i0[0] ? [new StructError(i0[0], function* () {
    for (const s0 of r0)
      s0[0] && (yield s0[0]);
  }), void 0] : [void 0, i0[1]];
}
function define(t0, e0) {
  return new Struct$1({ type: t0, schema: null, validator: e0 });
}
function any() {
  return define("any", () => !0);
}
function array(t0) {
  return new Struct$1({
    type: "array",
    schema: t0,
    *entries(e0) {
      if (t0 && Array.isArray(e0))
        for (const [n0, r0] of e0.entries())
          yield [n0, r0, t0];
    },
    coercer(e0) {
      return Array.isArray(e0) ? e0.slice() : e0;
    },
    validator(e0) {
      return Array.isArray(e0) || `Expected an array value, but received: ${print(e0)}`;
    }
  });
}
function boolean() {
  return define("boolean", (t0) => typeof t0 == "boolean");
}
function instance(t0) {
  return define("instance", (e0) => e0 instanceof t0 || `Expected a \`${t0.name}\` instance, but received: ${print(e0)}`);
}
function literal(t0) {
  const e0 = print(t0), n0 = typeof t0;
  return new Struct$1({
    type: "literal",
    schema: n0 === "string" || n0 === "number" || n0 === "boolean" ? t0 : null,
    validator(r0) {
      return r0 === t0 || `Expected the literal \`${e0}\`, but received: ${print(r0)}`;
    }
  });
}
function never() {
  return define("never", () => !1);
}
function nullable(t0) {
  return new Struct$1({
    ...t0,
    validator: (e0, n0) => e0 === null || t0.validator(e0, n0),
    refiner: (e0, n0) => e0 === null || t0.refiner(e0, n0)
  });
}
function number() {
  return define("number", (t0) => typeof t0 == "number" && !isNaN(t0) || `Expected a number, but received: ${print(t0)}`);
}
function optional(t0) {
  return new Struct$1({
    ...t0,
    validator: (e0, n0) => e0 === void 0 || t0.validator(e0, n0),
    refiner: (e0, n0) => e0 === void 0 || t0.refiner(e0, n0)
  });
}
function record(t0, e0) {
  return new Struct$1({
    type: "record",
    schema: null,
    *entries(n0) {
      if (isObject(n0))
        for (const r0 in n0) {
          const i0 = n0[r0];
          yield [r0, r0, t0], yield [r0, i0, e0];
        }
    },
    validator(n0) {
      return isNonArrayObject(n0) || `Expected an object, but received: ${print(n0)}`;
    },
    coercer(n0) {
      return isNonArrayObject(n0) ? { ...n0 } : n0;
    }
  });
}
function string() {
  return define("string", (t0) => typeof t0 == "string" || `Expected a string, but received: ${print(t0)}`);
}
function tuple(t0) {
  const e0 = never();
  return new Struct$1({
    type: "tuple",
    schema: null,
    *entries(n0) {
      if (Array.isArray(n0)) {
        const r0 = Math.max(t0.length, n0.length);
        for (let i0 = 0; i0 < r0; i0++)
          yield [i0, n0[i0], t0[i0] || e0];
      }
    },
    validator(n0) {
      return Array.isArray(n0) || `Expected an array, but received: ${print(n0)}`;
    },
    coercer(n0) {
      return Array.isArray(n0) ? n0.slice() : n0;
    }
  });
}
function type(t0) {
  const e0 = Object.keys(t0);
  return new Struct$1({
    type: "type",
    schema: t0,
    *entries(n0) {
      if (isObject(n0))
        for (const r0 of e0)
          yield [r0, n0[r0], t0[r0]];
    },
    validator(n0) {
      return isNonArrayObject(n0) || `Expected an object, but received: ${print(n0)}`;
    },
    coercer(n0) {
      return isNonArrayObject(n0) ? { ...n0 } : n0;
    }
  });
}
function union(t0) {
  const e0 = t0.map((n0) => n0.type).join(" | ");
  return new Struct$1({
    type: "union",
    schema: null,
    coercer(n0, r0) {
      for (const i0 of t0) {
        const [o0, s0] = i0.validate(n0, {
          coerce: !0,
          mask: r0.mask
        });
        if (!o0)
          return s0;
      }
      return n0;
    },
    validator(n0, r0) {
      const i0 = [];
      for (const o0 of t0) {
        const [...s0] = run(n0, o0, r0), [a0] = s0;
        if (a0[0])
          for (const [c0] of s0)
            c0 && i0.push(c0);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${e0}\`, but received: ${print(n0)}`,
        ...i0
      ];
    }
  });
}
function unknown() {
  return define("unknown", () => !0);
}
function coerce(t0, e0, n0) {
  return new Struct$1({
    ...t0,
    coercer: (r0, i0) => is(r0, e0) ? t0.coercer(n0(r0, i0), i0) : t0.coercer(r0, i0)
  });
}
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser), uuid$1 = require$$0.v4, generateRequest$1 = function(t0, e0, n0, r0) {
  if (typeof t0 != "string")
    throw new TypeError(t0 + " must be a string");
  r0 = r0 || {};
  const i0 = typeof r0.version == "number" ? r0.version : 2;
  if (i0 !== 1 && i0 !== 2)
    throw new TypeError(i0 + " must be 1 or 2");
  const o0 = {
    method: t0
  };
  if (i0 === 2 && (o0.jsonrpc = "2.0"), e0) {
    if (typeof e0 != "object" && !Array.isArray(e0))
      throw new TypeError(e0 + " must be an object, array or omitted");
    o0.params = e0;
  }
  if (typeof n0 > "u") {
    const s0 = typeof r0.generator == "function" ? r0.generator : function() {
      return uuid$1();
    };
    o0.id = s0(o0, r0);
  } else
    i0 === 2 && n0 === null ? r0.notificationIdNull && (o0.id = null) : o0.id = n0;
  return o0;
};
var generateRequest_1 = generateRequest$1;
const uuid = require$$0.v4, generateRequest = generateRequest_1, ClientBrowser = function(t0, e0) {
  if (!(this instanceof ClientBrowser))
    return new ClientBrowser(t0, e0);
  e0 || (e0 = {}), this.options = {
    reviver: typeof e0.reviver < "u" ? e0.reviver : null,
    replacer: typeof e0.replacer < "u" ? e0.replacer : null,
    generator: typeof e0.generator < "u" ? e0.generator : function() {
      return uuid();
    },
    version: typeof e0.version < "u" ? e0.version : 2,
    notificationIdNull: typeof e0.notificationIdNull == "boolean" ? e0.notificationIdNull : !1
  }, this.callServer = t0;
};
ClientBrowser.prototype.request = function(t0, e0, n0, r0) {
  const i0 = this;
  let o0 = null;
  const s0 = Array.isArray(t0) && typeof e0 == "function";
  if (this.options.version === 1 && s0)
    throw new TypeError("JSON-RPC 1.0 does not support batching");
  if (s0 || !s0 && t0 && typeof t0 == "object" && typeof e0 == "function")
    r0 = e0, o0 = t0;
  else {
    typeof n0 == "function" && (r0 = n0, n0 = void 0);
    const l0 = typeof r0 == "function";
    try {
      o0 = generateRequest(t0, e0, n0, {
        generator: this.options.generator,
        version: this.options.version,
        notificationIdNull: this.options.notificationIdNull
      });
    } catch (u0) {
      if (l0)
        return r0(u0);
      throw u0;
    }
    if (!l0)
      return o0;
  }
  let c0;
  try {
    c0 = JSON.stringify(o0, this.options.replacer);
  } catch (l0) {
    return r0(l0);
  }
  return this.callServer(c0, function(l0, u0) {
    i0._parseResponse(l0, u0, r0);
  }), o0;
};
ClientBrowser.prototype._parseResponse = function(t0, e0, n0) {
  if (t0) {
    n0(t0);
    return;
  }
  if (!e0)
    return n0();
  let r0;
  try {
    r0 = JSON.parse(e0, this.options.reviver);
  } catch (i0) {
    return n0(i0);
  }
  if (n0.length === 3)
    if (Array.isArray(r0)) {
      const i0 = function(s0) {
        return typeof s0.error < "u";
      }, o0 = function(s0) {
        return !i0(s0);
      };
      return n0(null, r0.filter(i0), r0.filter(o0));
    } else
      return n0(null, r0.error, r0.result);
  n0(null, r0);
};
class HMAC extends Hash {
  constructor(e0, n0) {
    super(), this.finished = !1, this.destroyed = !1, ahash(e0);
    const r0 = toBytes(n0);
    if (this.iHash = e0.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i0 = this.blockLen, o0 = new Uint8Array(i0);
    o0.set(r0.length > i0 ? e0.create().update(r0).digest() : r0);
    for (let s0 = 0; s0 < o0.length; s0++)
      o0[s0] ^= 54;
    this.iHash.update(o0), this.oHash = e0.create();
    for (let s0 = 0; s0 < o0.length; s0++)
      o0[s0] ^= 106;
    this.oHash.update(o0), clean(o0);
  }
  update(e0) {
    return aexists(this), this.iHash.update(e0), this;
  }
  digestInto(e0) {
    aexists(this), abytes(e0, this.outputLen), this.finished = !0, this.iHash.digestInto(e0), this.oHash.update(e0), this.oHash.digestInto(e0), this.destroy();
  }
  digest() {
    const e0 = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e0), e0;
  }
  _cloneInto(e0) {
    e0 || (e0 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n0, iHash: r0, finished: i0, destroyed: o0, blockLen: s0, outputLen: a0 } = this;
    return e0 = e0, e0.finished = i0, e0.destroyed = o0, e0.blockLen = s0, e0.outputLen = a0, e0.oHash = n0._cloneInto(e0.oHash), e0.iHash = r0._cloneInto(e0.iHash), e0;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const hmac = (t0, e0, n0) => new HMAC(t0, e0).update(n0).digest();
hmac.create = (t0, e0) => new HMAC(t0, e0);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validateSigVerOpts(t0) {
  t0.lowS !== void 0 && abool("lowS", t0.lowS), t0.prehash !== void 0 && abool("prehash", t0.prehash);
}
class DERErr extends Error {
  constructor(e0 = "") {
    super(e0);
  }
}
const DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (t0, e0) => {
      const { Err: n0 } = DER;
      if (t0 < 0 || t0 > 256)
        throw new n0("tlv.encode: wrong tag");
      if (e0.length & 1)
        throw new n0("tlv.encode: unpadded data");
      const r0 = e0.length / 2, i0 = numberToHexUnpadded(r0);
      if (i0.length / 2 & 128)
        throw new n0("tlv.encode: long form length too big");
      const o0 = r0 > 127 ? numberToHexUnpadded(i0.length / 2 | 128) : "";
      return numberToHexUnpadded(t0) + o0 + i0 + e0;
    },
    // v - value, l - left bytes (unparsed)
    decode(t0, e0) {
      const { Err: n0 } = DER;
      let r0 = 0;
      if (t0 < 0 || t0 > 256)
        throw new n0("tlv.encode: wrong tag");
      if (e0.length < 2 || e0[r0++] !== t0)
        throw new n0("tlv.decode: wrong tlv");
      const i0 = e0[r0++], o0 = !!(i0 & 128);
      let s0 = 0;
      if (!o0)
        s0 = i0;
      else {
        const c0 = i0 & 127;
        if (!c0)
          throw new n0("tlv.decode(long): indefinite length not supported");
        if (c0 > 4)
          throw new n0("tlv.decode(long): byte length is too big");
        const l0 = e0.subarray(r0, r0 + c0);
        if (l0.length !== c0)
          throw new n0("tlv.decode: length bytes not complete");
        if (l0[0] === 0)
          throw new n0("tlv.decode(long): zero leftmost byte");
        for (const u0 of l0)
          s0 = s0 << 8 | u0;
        if (r0 += c0, s0 < 128)
          throw new n0("tlv.decode(long): not minimal encoding");
      }
      const a0 = e0.subarray(r0, r0 + s0);
      if (a0.length !== s0)
        throw new n0("tlv.decode: wrong value length");
      return { v: a0, l: e0.subarray(r0 + s0) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(t0) {
      const { Err: e0 } = DER;
      if (t0 < _0n)
        throw new e0("integer: negative integers are not allowed");
      let n0 = numberToHexUnpadded(t0);
      if (Number.parseInt(n0[0], 16) & 8 && (n0 = "00" + n0), n0.length & 1)
        throw new e0("unexpected DER parsing assertion: unpadded hex");
      return n0;
    },
    decode(t0) {
      const { Err: e0 } = DER;
      if (t0[0] & 128)
        throw new e0("invalid signature integer: negative");
      if (t0[0] === 0 && !(t0[1] & 128))
        throw new e0("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE(t0);
    }
  },
  toSig(t0) {
    const { Err: e0, _int: n0, _tlv: r0 } = DER, i0 = ensureBytes("signature", t0), { v: o0, l: s0 } = r0.decode(48, i0);
    if (s0.length)
      throw new e0("invalid signature: left bytes after parsing");
    const { v: a0, l: c0 } = r0.decode(2, o0), { v: l0, l: u0 } = r0.decode(2, c0);
    if (u0.length)
      throw new e0("invalid signature: left bytes after parsing");
    return { r: n0.decode(a0), s: n0.decode(l0) };
  },
  hexFromSig(t0) {
    const { _tlv: e0, _int: n0 } = DER, r0 = e0.encode(2, n0.encode(t0.r)), i0 = e0.encode(2, n0.encode(t0.s)), o0 = r0 + i0;
    return e0.encode(48, o0);
  }
}, _0n = BigInt(0), _1n$1 = BigInt(1), _2n$1 = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function _legacyHelperEquat(t0, e0, n0) {
  function r0(i0) {
    const o0 = t0.sqr(i0), s0 = t0.mul(o0, i0);
    return t0.add(t0.add(s0, t0.mul(i0, e0)), n0);
  }
  return r0;
}
function _legacyHelperNormPriv(t0, e0, n0) {
  const { BYTES: r0 } = t0;
  function i0(o0) {
    let s0;
    if (typeof o0 == "bigint")
      s0 = o0;
    else {
      let a0 = ensureBytes("private key", o0);
      if (e0) {
        if (!e0.includes(a0.length * 2))
          throw new Error("invalid private key");
        const c0 = new Uint8Array(r0);
        c0.set(a0, c0.length - a0.length), a0 = c0;
      }
      try {
        s0 = t0.fromBytes(a0);
      } catch {
        throw new Error(`invalid private key: expected ui8a of size ${r0}, got ${typeof o0}`);
      }
    }
    if (n0 && (s0 = t0.create(s0)), !t0.isValidNot0(s0))
      throw new Error("invalid private key: out of range [1..N-1]");
    return s0;
  }
  return i0;
}
function weierstrassN(t0, e0 = {}) {
  const { Fp: n0, Fn: r0 } = _createCurveFields("weierstrass", t0, e0), { h: i0, n: o0 } = t0;
  _validateObject(e0, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo: s0 } = e0;
  if (s0 && (!n0.is0(t0.a) || typeof s0.beta != "bigint" || typeof s0.splitScalar != "function"))
    throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
  function a0() {
    if (!n0.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function c0(K0, U0, F0) {
    const { x: H0, y: P0 } = U0.toAffine(), I0 = n0.toBytes(H0);
    if (abool("isCompressed", F0), F0) {
      a0();
      const f0 = !n0.isOdd(P0);
      return concatBytes(pprefix(f0), I0);
    } else
      return concatBytes(Uint8Array.of(4), I0, n0.toBytes(P0));
  }
  function l0(K0) {
    abytes(K0);
    const U0 = n0.BYTES, F0 = U0 + 1, H0 = 2 * U0 + 1, P0 = K0.length, I0 = K0[0], f0 = K0.subarray(1);
    if (P0 === F0 && (I0 === 2 || I0 === 3)) {
      const m0 = n0.fromBytes(f0);
      if (!n0.isValid(m0))
        throw new Error("bad point: is not on curve, wrong x");
      const A0 = h0(m0);
      let x0;
      try {
        x0 = n0.sqrt(A0);
      } catch (C0) {
        const M0 = C0 instanceof Error ? ": " + C0.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + M0);
      }
      a0();
      const _0 = n0.isOdd(x0);
      return (I0 & 1) === 1 !== _0 && (x0 = n0.neg(x0)), { x: m0, y: x0 };
    } else if (P0 === H0 && I0 === 4) {
      const m0 = n0.fromBytes(f0.subarray(U0 * 0, U0 * 1)), A0 = n0.fromBytes(f0.subarray(U0 * 1, U0 * 2));
      if (!g0(m0, A0))
        throw new Error("bad point: is not on curve");
      return { x: m0, y: A0 };
    } else
      throw new Error(`bad point: got length ${P0}, expected compressed=${F0} or uncompressed=${H0}`);
  }
  const u0 = e0.toBytes || c0, d0 = e0.fromBytes || l0, h0 = _legacyHelperEquat(n0, t0.a, t0.b);
  function g0(K0, U0) {
    const F0 = n0.sqr(U0), H0 = h0(K0);
    return n0.eql(F0, H0);
  }
  if (!g0(t0.Gx, t0.Gy))
    throw new Error("bad curve params: generator point");
  const w0 = n0.mul(n0.pow(t0.a, _3n), _4n), y0 = n0.mul(n0.sqr(t0.b), BigInt(27));
  if (n0.is0(n0.add(w0, y0)))
    throw new Error("bad curve params: a or b");
  function E0(K0, U0, F0 = !1) {
    if (!n0.isValid(U0) || F0 && n0.is0(U0))
      throw new Error(`bad point coordinate ${K0}`);
    return U0;
  }
  function b0(K0) {
    if (!(K0 instanceof D0))
      throw new Error("ProjectivePoint expected");
  }
  const O0 = memoized((K0, U0) => {
    const { px: F0, py: H0, pz: P0 } = K0;
    if (n0.eql(P0, n0.ONE))
      return { x: F0, y: H0 };
    const I0 = K0.is0();
    U0 == null && (U0 = I0 ? n0.ONE : n0.inv(P0));
    const f0 = n0.mul(F0, U0), m0 = n0.mul(H0, U0), A0 = n0.mul(P0, U0);
    if (I0)
      return { x: n0.ZERO, y: n0.ZERO };
    if (!n0.eql(A0, n0.ONE))
      throw new Error("invZ was invalid");
    return { x: f0, y: m0 };
  }), S0 = memoized((K0) => {
    if (K0.is0()) {
      if (e0.allowInfinityPoint && !n0.is0(K0.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: U0, y: F0 } = K0.toAffine();
    if (!n0.isValid(U0) || !n0.isValid(F0))
      throw new Error("bad point: x or y not field elements");
    if (!g0(U0, F0))
      throw new Error("bad point: equation left != right");
    if (!K0.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  function k0(K0, U0, F0, H0, P0) {
    return F0 = new D0(n0.mul(F0.px, K0), F0.py, F0.pz), U0 = negateCt(H0, U0), F0 = negateCt(P0, F0), U0.add(F0);
  }
  class D0 {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(U0, F0, H0) {
      this.px = E0("x", U0), this.py = E0("y", F0, !0), this.pz = E0("z", H0), Object.freeze(this);
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(U0) {
      const { x: F0, y: H0 } = U0 || {};
      if (!U0 || !n0.isValid(F0) || !n0.isValid(H0))
        throw new Error("invalid affine point");
      if (U0 instanceof D0)
        throw new Error("projective point not allowed");
      return n0.is0(F0) && n0.is0(H0) ? D0.ZERO : new D0(F0, H0, n0.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(U0) {
      return normalizeZ(D0, "pz", U0);
    }
    static fromBytes(U0) {
      return abytes(U0), D0.fromHex(U0);
    }
    /** Converts hash string or Uint8Array to Point. */
    static fromHex(U0) {
      const F0 = D0.fromAffine(d0(ensureBytes("pointHex", U0)));
      return F0.assertValidity(), F0;
    }
    /** Multiplies generator point by privateKey. */
    static fromPrivateKey(U0) {
      const F0 = _legacyHelperNormPriv(r0, e0.allowedPrivateKeyLengths, e0.wrapPrivateKey);
      return D0.BASE.multiply(F0(U0));
    }
    /** Multiscalar Multiplication */
    static msm(U0, F0) {
      return pippenger(D0, r0, U0, F0);
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(U0 = 8, F0 = !0) {
      return G0.setWindowSize(this, U0), F0 || this.multiply(_3n), this;
    }
    /** "Private method", don't use it directly */
    _setWindowSize(U0) {
      this.precompute(U0);
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      S0(this);
    }
    hasEvenY() {
      const { y: U0 } = this.toAffine();
      if (!n0.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !n0.isOdd(U0);
    }
    /** Compare one point to another. */
    equals(U0) {
      b0(U0);
      const { px: F0, py: H0, pz: P0 } = this, { px: I0, py: f0, pz: m0 } = U0, A0 = n0.eql(n0.mul(F0, m0), n0.mul(I0, P0)), x0 = n0.eql(n0.mul(H0, m0), n0.mul(f0, P0));
      return A0 && x0;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new D0(this.px, n0.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: U0, b: F0 } = t0, H0 = n0.mul(F0, _3n), { px: P0, py: I0, pz: f0 } = this;
      let m0 = n0.ZERO, A0 = n0.ZERO, x0 = n0.ZERO, _0 = n0.mul(P0, P0), $0 = n0.mul(I0, I0), C0 = n0.mul(f0, f0), M0 = n0.mul(P0, I0);
      return M0 = n0.add(M0, M0), x0 = n0.mul(P0, f0), x0 = n0.add(x0, x0), m0 = n0.mul(U0, x0), A0 = n0.mul(H0, C0), A0 = n0.add(m0, A0), m0 = n0.sub($0, A0), A0 = n0.add($0, A0), A0 = n0.mul(m0, A0), m0 = n0.mul(M0, m0), x0 = n0.mul(H0, x0), C0 = n0.mul(U0, C0), M0 = n0.sub(_0, C0), M0 = n0.mul(U0, M0), M0 = n0.add(M0, x0), x0 = n0.add(_0, _0), _0 = n0.add(x0, _0), _0 = n0.add(_0, C0), _0 = n0.mul(_0, M0), A0 = n0.add(A0, _0), C0 = n0.mul(I0, f0), C0 = n0.add(C0, C0), _0 = n0.mul(C0, M0), m0 = n0.sub(m0, _0), x0 = n0.mul(C0, $0), x0 = n0.add(x0, x0), x0 = n0.add(x0, x0), new D0(m0, A0, x0);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(U0) {
      b0(U0);
      const { px: F0, py: H0, pz: P0 } = this, { px: I0, py: f0, pz: m0 } = U0;
      let A0 = n0.ZERO, x0 = n0.ZERO, _0 = n0.ZERO;
      const $0 = t0.a, C0 = n0.mul(t0.b, _3n);
      let M0 = n0.mul(F0, I0), p0 = n0.mul(H0, f0), v0 = n0.mul(P0, m0), T0 = n0.add(F0, H0), L0 = n0.add(I0, f0);
      T0 = n0.mul(T0, L0), L0 = n0.add(M0, p0), T0 = n0.sub(T0, L0), L0 = n0.add(F0, P0);
      let B0 = n0.add(I0, m0);
      return L0 = n0.mul(L0, B0), B0 = n0.add(M0, v0), L0 = n0.sub(L0, B0), B0 = n0.add(H0, P0), A0 = n0.add(f0, m0), B0 = n0.mul(B0, A0), A0 = n0.add(p0, v0), B0 = n0.sub(B0, A0), _0 = n0.mul($0, L0), A0 = n0.mul(C0, v0), _0 = n0.add(A0, _0), A0 = n0.sub(p0, _0), _0 = n0.add(p0, _0), x0 = n0.mul(A0, _0), p0 = n0.add(M0, M0), p0 = n0.add(p0, M0), v0 = n0.mul($0, v0), L0 = n0.mul(C0, L0), p0 = n0.add(p0, v0), v0 = n0.sub(M0, v0), v0 = n0.mul($0, v0), L0 = n0.add(L0, v0), M0 = n0.mul(p0, L0), x0 = n0.add(x0, M0), M0 = n0.mul(B0, L0), A0 = n0.mul(T0, A0), A0 = n0.sub(A0, M0), M0 = n0.mul(T0, p0), _0 = n0.mul(B0, _0), _0 = n0.add(_0, M0), new D0(A0, x0, _0);
    }
    subtract(U0) {
      return this.add(U0.negate());
    }
    is0() {
      return this.equals(D0.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(U0) {
      const { endo: F0 } = e0;
      if (!r0.isValidNot0(U0))
        throw new Error("invalid scalar: out of range");
      let H0, P0;
      const I0 = (f0) => G0.wNAFCached(this, f0, D0.normalizeZ);
      if (F0) {
        const { k1neg: f0, k1: m0, k2neg: A0, k2: x0 } = F0.splitScalar(U0), { p: _0, f: $0 } = I0(m0), { p: C0, f: M0 } = I0(x0);
        P0 = $0.add(M0), H0 = k0(F0.beta, _0, C0, f0, A0);
      } else {
        const { p: f0, f: m0 } = I0(U0);
        H0 = f0, P0 = m0;
      }
      return D0.normalizeZ([H0, P0])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(U0) {
      const { endo: F0 } = e0, H0 = this;
      if (!r0.isValid(U0))
        throw new Error("invalid scalar: out of range");
      if (U0 === _0n || H0.is0())
        return D0.ZERO;
      if (U0 === _1n$1)
        return H0;
      if (G0.hasPrecomputes(this))
        return this.multiply(U0);
      if (F0) {
        const { k1neg: P0, k1: I0, k2neg: f0, k2: m0 } = F0.splitScalar(U0), { p1: A0, p2: x0 } = mulEndoUnsafe(D0, H0, I0, m0);
        return k0(F0.beta, A0, x0, P0, f0);
      } else
        return G0.wNAFCachedUnsafe(H0, U0);
    }
    multiplyAndAddUnsafe(U0, F0, H0) {
      const P0 = this.multiplyUnsafe(F0).add(U0.multiplyUnsafe(H0));
      return P0.is0() ? void 0 : P0;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(U0) {
      return O0(this, U0);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: U0 } = e0;
      return i0 === _1n$1 ? !0 : U0 ? U0(D0, this) : G0.wNAFCachedUnsafe(this, o0).is0();
    }
    clearCofactor() {
      const { clearCofactor: U0 } = e0;
      return i0 === _1n$1 ? this : U0 ? U0(D0, this) : this.multiplyUnsafe(i0);
    }
    toBytes(U0 = !0) {
      return abool("isCompressed", U0), this.assertValidity(), u0(D0, this, U0);
    }
    /** @deprecated use `toBytes` */
    toRawBytes(U0 = !0) {
      return this.toBytes(U0);
    }
    toHex(U0 = !0) {
      return bytesToHex(this.toBytes(U0));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  D0.BASE = new D0(t0.Gx, t0.Gy, n0.ONE), D0.ZERO = new D0(n0.ZERO, n0.ONE, n0.ZERO), D0.Fp = n0, D0.Fn = r0;
  const z0 = r0.BITS, G0 = wNAF(D0, e0.endo ? Math.ceil(z0 / 2) : z0);
  return D0;
}
function pprefix(t0) {
  return Uint8Array.of(t0 ? 2 : 3);
}
function ecdsa(t0, e0, n0 = {}) {
  _validateObject(e0, { hash: "function" }, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const r0 = e0.randomBytes || randomBytes, i0 = e0.hmac || ((H0, ...P0) => hmac(e0.hash, H0, concatBytes(...P0))), { Fp: o0, Fn: s0 } = t0, { ORDER: a0, BITS: c0 } = s0;
  function l0(H0) {
    const P0 = a0 >> _1n$1;
    return H0 > P0;
  }
  function u0(H0) {
    return l0(H0) ? s0.neg(H0) : H0;
  }
  function d0(H0, P0) {
    if (!s0.isValidNot0(P0))
      throw new Error(`invalid signature ${H0}: out of range 1..CURVE.n`);
  }
  class h0 {
    constructor(P0, I0, f0) {
      d0("r", P0), d0("s", I0), this.r = P0, this.s = I0, f0 != null && (this.recovery = f0), Object.freeze(this);
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(P0) {
      const I0 = s0.BYTES, f0 = ensureBytes("compactSignature", P0, I0 * 2);
      return new h0(s0.fromBytes(f0.subarray(0, I0)), s0.fromBytes(f0.subarray(I0, I0 * 2)));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(P0) {
      const { r: I0, s: f0 } = DER.toSig(ensureBytes("DER", P0));
      return new h0(I0, f0);
    }
    /**
     * @todo remove
     * @deprecated
     */
    assertValidity() {
    }
    addRecoveryBit(P0) {
      return new h0(this.r, this.s, P0);
    }
    // ProjPointType<bigint>
    recoverPublicKey(P0) {
      const I0 = o0.ORDER, { r: f0, s: m0, recovery: A0 } = this;
      if (A0 == null || ![0, 1, 2, 3].includes(A0))
        throw new Error("recovery id invalid");
      if (a0 * _2n$1 < I0 && A0 > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const _0 = A0 === 2 || A0 === 3 ? f0 + a0 : f0;
      if (!o0.isValid(_0))
        throw new Error("recovery id 2 or 3 invalid");
      const $0 = o0.toBytes(_0), C0 = t0.fromHex(concatBytes(pprefix((A0 & 1) === 0), $0)), M0 = s0.inv(_0), p0 = S0(ensureBytes("msgHash", P0)), v0 = s0.create(-p0 * M0), T0 = s0.create(m0 * M0), L0 = t0.BASE.multiplyUnsafe(v0).add(C0.multiplyUnsafe(T0));
      if (L0.is0())
        throw new Error("point at infinify");
      return L0.assertValidity(), L0;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return l0(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new h0(this.r, s0.neg(this.s), this.recovery) : this;
    }
    toBytes(P0) {
      if (P0 === "compact")
        return concatBytes(s0.toBytes(this.r), s0.toBytes(this.s));
      if (P0 === "der")
        return hexToBytes(DER.hexFromSig(this));
      throw new Error("invalid format");
    }
    // DER-encoded
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return bytesToHex(this.toBytes("der"));
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return bytesToHex(this.toBytes("compact"));
    }
  }
  const g0 = _legacyHelperNormPriv(s0, n0.allowedPrivateKeyLengths, n0.wrapPrivateKey), w0 = {
    isValidPrivateKey(H0) {
      try {
        return g0(H0), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: g0,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const H0 = a0;
      return mapHashToField(r0(getMinHashLength(H0)), H0);
    },
    precompute(H0 = 8, P0 = t0.BASE) {
      return P0.precompute(H0, !1);
    }
  };
  function y0(H0, P0 = !0) {
    return t0.fromPrivateKey(H0).toBytes(P0);
  }
  function E0(H0) {
    if (typeof H0 == "bigint")
      return !1;
    if (H0 instanceof t0)
      return !0;
    const I0 = ensureBytes("key", H0).length, f0 = o0.BYTES, m0 = f0 + 1, A0 = 2 * f0 + 1;
    if (!(n0.allowedPrivateKeyLengths || s0.BYTES === m0))
      return I0 === m0 || I0 === A0;
  }
  function b0(H0, P0, I0 = !0) {
    if (E0(H0) === !0)
      throw new Error("first arg must be private key");
    if (E0(P0) === !1)
      throw new Error("second arg must be public key");
    return t0.fromHex(P0).multiply(g0(H0)).toBytes(I0);
  }
  const O0 = e0.bits2int || function(H0) {
    if (H0.length > 8192)
      throw new Error("input is too large");
    const P0 = bytesToNumberBE(H0), I0 = H0.length * 8 - c0;
    return I0 > 0 ? P0 >> BigInt(I0) : P0;
  }, S0 = e0.bits2int_modN || function(H0) {
    return s0.create(O0(H0));
  }, k0 = bitMask(c0);
  function D0(H0) {
    return aInRange("num < 2^" + c0, H0, _0n, k0), s0.toBytes(H0);
  }
  function z0(H0, P0, I0 = G0) {
    if (["recovered", "canonical"].some((T0) => T0 in I0))
      throw new Error("sign() legacy options not supported");
    const { hash: f0 } = e0;
    let { lowS: m0, prehash: A0, extraEntropy: x0 } = I0;
    m0 == null && (m0 = !0), H0 = ensureBytes("msgHash", H0), validateSigVerOpts(I0), A0 && (H0 = ensureBytes("prehashed msgHash", f0(H0)));
    const _0 = S0(H0), $0 = g0(P0), C0 = [D0($0), D0(_0)];
    if (x0 != null && x0 !== !1) {
      const T0 = x0 === !0 ? r0(o0.BYTES) : x0;
      C0.push(ensureBytes("extraEntropy", T0));
    }
    const M0 = concatBytes(...C0), p0 = _0;
    function v0(T0) {
      const L0 = O0(T0);
      if (!s0.isValidNot0(L0))
        return;
      const B0 = s0.inv(L0), W0 = t0.BASE.multiply(L0).toAffine(), V0 = s0.create(W0.x);
      if (V0 === _0n)
        return;
      const Q0 = s0.create(B0 * s0.create(p0 + V0 * $0));
      if (Q0 === _0n)
        return;
      let X0 = (W0.x === V0 ? 0 : 2) | Number(W0.y & _1n$1), J0 = Q0;
      return m0 && l0(Q0) && (J0 = u0(Q0), X0 ^= 1), new h0(V0, J0, X0);
    }
    return { seed: M0, k2sig: v0 };
  }
  const G0 = { lowS: e0.lowS, prehash: !1 }, K0 = { lowS: e0.lowS, prehash: !1 };
  function U0(H0, P0, I0 = G0) {
    const { seed: f0, k2sig: m0 } = z0(H0, P0, I0);
    return createHmacDrbg(e0.hash.outputLen, s0.BYTES, i0)(f0, m0);
  }
  t0.BASE.precompute(8);
  function F0(H0, P0, I0, f0 = K0) {
    const m0 = H0;
    P0 = ensureBytes("msgHash", P0), I0 = ensureBytes("publicKey", I0), validateSigVerOpts(f0);
    const { lowS: A0, prehash: x0, format: _0 } = f0;
    if ("strict" in f0)
      throw new Error("options.strict was renamed to lowS");
    if (_0 !== void 0 && !["compact", "der", "js"].includes(_0))
      throw new Error('format must be "compact", "der" or "js"');
    const $0 = typeof m0 == "string" || isBytes(m0), C0 = !$0 && !_0 && typeof m0 == "object" && m0 !== null && typeof m0.r == "bigint" && typeof m0.s == "bigint";
    if (!$0 && !C0)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let M0, p0;
    try {
      if (C0)
        if (_0 === void 0 || _0 === "js")
          M0 = new h0(m0.r, m0.s);
        else
          throw new Error("invalid format");
      if ($0) {
        try {
          _0 !== "compact" && (M0 = h0.fromDER(m0));
        } catch (J0) {
          if (!(J0 instanceof DER.Err))
            throw J0;
        }
        !M0 && _0 !== "der" && (M0 = h0.fromCompact(m0));
      }
      p0 = t0.fromHex(I0);
    } catch {
      return !1;
    }
    if (!M0 || A0 && M0.hasHighS())
      return !1;
    x0 && (P0 = e0.hash(P0));
    const { r: v0, s: T0 } = M0, L0 = S0(P0), B0 = s0.inv(T0), W0 = s0.create(L0 * B0), V0 = s0.create(v0 * B0), Q0 = t0.BASE.multiplyUnsafe(W0).add(p0.multiplyUnsafe(V0));
    return Q0.is0() ? !1 : s0.create(Q0.x) === v0;
  }
  return Object.freeze({
    getPublicKey: y0,
    getSharedSecret: b0,
    sign: U0,
    verify: F0,
    utils: w0,
    Point: t0,
    Signature: h0
  });
}
function _weierstrass_legacy_opts_to_new(t0) {
  const e0 = {
    a: t0.a,
    b: t0.b,
    p: t0.Fp.ORDER,
    n: t0.n,
    h: t0.h,
    Gx: t0.Gx,
    Gy: t0.Gy
  }, n0 = t0.Fp, r0 = Field(e0.n, t0.nBitLength), i0 = {
    Fp: n0,
    Fn: r0,
    allowedPrivateKeyLengths: t0.allowedPrivateKeyLengths,
    allowInfinityPoint: t0.allowInfinityPoint,
    endo: t0.endo,
    wrapPrivateKey: t0.wrapPrivateKey,
    isTorsionFree: t0.isTorsionFree,
    clearCofactor: t0.clearCofactor,
    fromBytes: t0.fromBytes,
    toBytes: t0.toBytes
  };
  return { CURVE: e0, curveOpts: i0 };
}
function _ecdsa_legacy_opts_to_new(t0) {
  const { CURVE: e0, curveOpts: n0 } = _weierstrass_legacy_opts_to_new(t0), r0 = {
    hash: t0.hash,
    hmac: t0.hmac,
    randomBytes: t0.randomBytes,
    lowS: t0.lowS,
    bits2int: t0.bits2int,
    bits2int_modN: t0.bits2int_modN
  };
  return { CURVE: e0, curveOpts: n0, ecdsaOpts: r0 };
}
function _ecdsa_new_output_to_legacy(t0, e0) {
  return Object.assign({}, e0, {
    ProjectivePoint: e0.Point,
    CURVE: t0
  });
}
function weierstrass(t0) {
  const { CURVE: e0, curveOpts: n0, ecdsaOpts: r0 } = _ecdsa_legacy_opts_to_new(t0), i0 = weierstrassN(e0, n0), o0 = ecdsa(i0, r0, n0);
  return _ecdsa_new_output_to_legacy(t0, o0);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function createCurve(t0, e0) {
  const n0 = (r0) => weierstrass({ ...t0, hash: r0 });
  return { ...n0(e0), create: n0 };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
BigInt(0);
const _1n = BigInt(1), _2n = BigInt(2), divNearest = (t0, e0) => (t0 + e0 / _2n) / e0;
function sqrtMod(t0) {
  const e0 = secp256k1_CURVE.p, n0 = BigInt(3), r0 = BigInt(6), i0 = BigInt(11), o0 = BigInt(22), s0 = BigInt(23), a0 = BigInt(44), c0 = BigInt(88), l0 = t0 * t0 * t0 % e0, u0 = l0 * l0 * t0 % e0, d0 = pow2(u0, n0, e0) * u0 % e0, h0 = pow2(d0, n0, e0) * u0 % e0, g0 = pow2(h0, _2n, e0) * l0 % e0, w0 = pow2(g0, i0, e0) * g0 % e0, y0 = pow2(w0, o0, e0) * w0 % e0, E0 = pow2(y0, a0, e0) * y0 % e0, b0 = pow2(E0, c0, e0) * E0 % e0, O0 = pow2(b0, a0, e0) * y0 % e0, S0 = pow2(O0, n0, e0) * u0 % e0, k0 = pow2(S0, s0, e0) * w0 % e0, D0 = pow2(k0, r0, e0) * l0 % e0, z0 = pow2(D0, _2n, e0);
  if (!Fpk1.eql(Fpk1.sqr(z0), t0))
    throw new Error("Cannot find square root");
  return z0;
}
const Fpk1 = Field(secp256k1_CURVE.p, void 0, void 0, { sqrt: sqrtMod }), secp256k1 = createCurve({
  ...secp256k1_CURVE,
  Fp: Fpk1,
  lowS: !0,
  // Allow only low-S signatures by default in sign() and verify()
  endo: {
    // Endomorphism, see above
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (t0) => {
      const e0 = secp256k1_CURVE.n, n0 = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r0 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i0 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), o0 = n0, s0 = BigInt("0x100000000000000000000000000000000"), a0 = divNearest(o0 * t0, e0), c0 = divNearest(-r0 * t0, e0);
      let l0 = mod(t0 - a0 * n0 - c0 * i0, e0), u0 = mod(-a0 * r0 - c0 * o0, e0);
      const d0 = l0 > s0, h0 = u0 > s0;
      if (d0 && (l0 = e0 - l0), h0 && (u0 = e0 - u0), l0 > s0 || u0 > s0)
        throw new Error("splitScalar: Endomorphism failed, k=" + t0);
      return { k1neg: d0, k1: l0, k2neg: h0, k2: u0 };
    }
  }
}, sha256$1);
ed25519.utils.randomPrivateKey;
ed25519.getPublicKey;
function isOnCurve(t0) {
  try {
    return ed25519.ExtendedPoint.fromHex(t0), !0;
  } catch {
    return !1;
  }
}
const sign = (t0, e0) => ed25519.sign(t0, e0.slice(0, 32)), verify = ed25519.verify, toBuffer = (t0) => buffer.Buffer.isBuffer(t0) ? t0 : t0 instanceof Uint8Array ? buffer.Buffer.from(t0.buffer, t0.byteOffset, t0.byteLength) : buffer.Buffer.from(t0);
class Struct {
  constructor(e0) {
    Object.assign(this, e0);
  }
  encode() {
    return buffer.Buffer.from(serialize_1(SOLANA_SCHEMA, this));
  }
  static decode(e0) {
    return deserialize_1(SOLANA_SCHEMA, this, e0);
  }
  static decodeUnchecked(e0) {
    return deserializeUnchecked_1(SOLANA_SCHEMA, this, e0);
  }
}
const SOLANA_SCHEMA = /* @__PURE__ */ new Map();
var _PublicKey;
const MAX_SEED_LENGTH = 32, PUBLIC_KEY_LENGTH = 32;
function isPublicKeyData(t0) {
  return t0._bn !== void 0;
}
let uniquePublicKeyCounter = 1;
class PublicKey extends Struct {
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(e0) {
    if (super({}), this._bn = void 0, isPublicKeyData(e0))
      this._bn = e0._bn;
    else {
      if (typeof e0 == "string") {
        const n0 = bs58$1.decode(e0);
        if (n0.length != PUBLIC_KEY_LENGTH)
          throw new Error("Invalid public key input");
        this._bn = new BN(n0);
      } else
        this._bn = new BN(e0);
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH)
        throw new Error("Invalid public key input");
    }
  }
  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  static unique() {
    const e0 = new PublicKey(uniquePublicKeyCounter);
    return uniquePublicKeyCounter += 1, new PublicKey(e0.toBuffer());
  }
  /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */
  /**
   * Checks if two publicKeys are equal
   */
  equals(e0) {
    return this._bn.eq(e0._bn);
  }
  /**
   * Return the base-58 representation of the public key
   */
  toBase58() {
    return bs58$1.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  /**
   * Return the byte array representation of the public key in big endian
   */
  toBytes() {
    const e0 = this.toBuffer();
    return new Uint8Array(e0.buffer, e0.byteOffset, e0.byteLength);
  }
  /**
   * Return the Buffer representation of the public key in big endian
   */
  toBuffer() {
    const e0 = this._bn.toArrayLike(buffer.Buffer);
    if (e0.length === PUBLIC_KEY_LENGTH)
      return e0;
    const n0 = buffer.Buffer.alloc(32);
    return e0.copy(n0, 32 - e0.length), n0;
  }
  get [Symbol.toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  /**
   * Return the base-58 representation of the public key
   */
  toString() {
    return this.toBase58();
  }
  /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */
  /* eslint-disable require-await */
  static async createWithSeed(e0, n0, r0) {
    const i0 = buffer.Buffer.concat([e0.toBuffer(), buffer.Buffer.from(n0), r0.toBuffer()]), o0 = sha256(i0);
    return new PublicKey(o0);
  }
  /**
   * Derive a program address from seeds and a program ID.
   */
  /* eslint-disable require-await */
  static createProgramAddressSync(e0, n0) {
    let r0 = buffer.Buffer.alloc(0);
    e0.forEach(function(o0) {
      if (o0.length > MAX_SEED_LENGTH)
        throw new TypeError("Max seed length exceeded");
      r0 = buffer.Buffer.concat([r0, toBuffer(o0)]);
    }), r0 = buffer.Buffer.concat([r0, n0.toBuffer(), buffer.Buffer.from("ProgramDerivedAddress")]);
    const i0 = sha256(r0);
    if (isOnCurve(i0))
      throw new Error("Invalid seeds, address must fall off the curve");
    return new PublicKey(i0);
  }
  /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */
  /* eslint-disable require-await */
  static async createProgramAddress(e0, n0) {
    return this.createProgramAddressSync(e0, n0);
  }
  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */
  static findProgramAddressSync(e0, n0) {
    let r0 = 255, i0;
    for (; r0 != 0; ) {
      try {
        const o0 = e0.concat(buffer.Buffer.from([r0]));
        i0 = this.createProgramAddressSync(o0, n0);
      } catch (o0) {
        if (o0 instanceof TypeError)
          throw o0;
        r0--;
        continue;
      }
      return [i0, r0];
    }
    throw new Error("Unable to find a viable program address nonce");
  }
  /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */
  static async findProgramAddress(e0, n0) {
    return this.findProgramAddressSync(e0, n0);
  }
  /**
   * Check that a pubkey is on the ed25519 curve.
   */
  static isOnCurve(e0) {
    const n0 = new PublicKey(e0);
    return isOnCurve(n0.toBytes());
  }
}
_PublicKey = PublicKey;
PublicKey.default = new _PublicKey("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
new PublicKey("BPFLoader1111111111111111111111111111111111");
const PACKET_DATA_SIZE = 1280 - 40 - 8, VERSION_PREFIX_MASK = 127, SIGNATURE_LENGTH_IN_BYTES = 64;
class MessageAccountKeys {
  constructor(e0, n0) {
    this.staticAccountKeys = void 0, this.accountKeysFromLookups = void 0, this.staticAccountKeys = e0, this.accountKeysFromLookups = n0;
  }
  keySegments() {
    const e0 = [this.staticAccountKeys];
    return this.accountKeysFromLookups && (e0.push(this.accountKeysFromLookups.writable), e0.push(this.accountKeysFromLookups.readonly)), e0;
  }
  get(e0) {
    for (const n0 of this.keySegments()) {
      if (e0 < n0.length)
        return n0[e0];
      e0 -= n0.length;
    }
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(e0) {
    if (this.length > 255 + 1)
      throw new Error("Account index overflow encountered during compilation");
    const r0 = /* @__PURE__ */ new Map();
    this.keySegments().flat().forEach((o0, s0) => {
      r0.set(o0.toBase58(), s0);
    });
    const i0 = (o0) => {
      const s0 = r0.get(o0.toBase58());
      if (s0 === void 0)
        throw new Error("Encountered an unknown instruction account key during compilation");
      return s0;
    };
    return e0.map((o0) => ({
      programIdIndex: i0(o0.programId),
      accountKeyIndexes: o0.keys.map((s0) => i0(s0.pubkey)),
      data: o0.data
    }));
  }
}
const publicKey = (t0 = "publicKey") => blob(32, t0), rustString = (t0 = "string") => {
  const e0 = struct([u32("length"), u32("lengthPadding"), blob(offset(u32(), -8), "chars")], t0), n0 = e0.decode.bind(e0), r0 = e0.encode.bind(e0), i0 = e0;
  return i0.decode = (o0, s0) => n0(o0, s0).chars.toString(), i0.encode = (o0, s0, a0) => {
    const c0 = {
      chars: buffer.Buffer.from(o0, "utf8")
    };
    return r0(c0, s0, a0);
  }, i0.alloc = (o0) => u32().span + u32().span + buffer.Buffer.from(o0, "utf8").length, i0;
}, authorized = (t0 = "authorized") => struct([publicKey("staker"), publicKey("withdrawer")], t0), lockup = (t0 = "lockup") => struct([ns64("unixTimestamp"), ns64("epoch"), publicKey("custodian")], t0), voteInit = (t0 = "voteInit") => struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), u8("commission")], t0), voteAuthorizeWithSeedArgs = (t0 = "voteAuthorizeWithSeedArgs") => struct([u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], t0);
function decodeLength(t0) {
  let e0 = 0, n0 = 0;
  for (; ; ) {
    let r0 = t0.shift();
    if (e0 |= (r0 & 127) << n0 * 7, n0 += 1, !(r0 & 128))
      break;
  }
  return e0;
}
function encodeLength(t0, e0) {
  let n0 = e0;
  for (; ; ) {
    let r0 = n0 & 127;
    if (n0 >>= 7, n0 == 0) {
      t0.push(r0);
      break;
    } else
      r0 |= 128, t0.push(r0);
  }
}
function assert(t0, e0) {
  if (!t0)
    throw new Error(e0 || "Assertion failed");
}
class CompiledKeys {
  constructor(e0, n0) {
    this.payer = void 0, this.keyMetaMap = void 0, this.payer = e0, this.keyMetaMap = n0;
  }
  static compile(e0, n0) {
    const r0 = /* @__PURE__ */ new Map(), i0 = (s0) => {
      const a0 = s0.toBase58();
      let c0 = r0.get(a0);
      return c0 === void 0 && (c0 = {
        isSigner: !1,
        isWritable: !1,
        isInvoked: !1
      }, r0.set(a0, c0)), c0;
    }, o0 = i0(n0);
    o0.isSigner = !0, o0.isWritable = !0;
    for (const s0 of e0) {
      i0(s0.programId).isInvoked = !0;
      for (const a0 of s0.keys) {
        const c0 = i0(a0.pubkey);
        c0.isSigner || (c0.isSigner = a0.isSigner), c0.isWritable || (c0.isWritable = a0.isWritable);
      }
    }
    return new CompiledKeys(n0, r0);
  }
  getMessageComponents() {
    const e0 = [...this.keyMetaMap.entries()];
    assert(e0.length <= 256, "Max static account keys length exceeded");
    const n0 = e0.filter(([, c0]) => c0.isSigner && c0.isWritable), r0 = e0.filter(([, c0]) => c0.isSigner && !c0.isWritable), i0 = e0.filter(([, c0]) => !c0.isSigner && c0.isWritable), o0 = e0.filter(([, c0]) => !c0.isSigner && !c0.isWritable), s0 = {
      numRequiredSignatures: n0.length + r0.length,
      numReadonlySignedAccounts: r0.length,
      numReadonlyUnsignedAccounts: o0.length
    };
    {
      assert(n0.length > 0, "Expected at least one writable signer key");
      const [c0] = n0[0];
      assert(c0 === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const a0 = [...n0.map(([c0]) => new PublicKey(c0)), ...r0.map(([c0]) => new PublicKey(c0)), ...i0.map(([c0]) => new PublicKey(c0)), ...o0.map(([c0]) => new PublicKey(c0))];
    return [s0, a0];
  }
  extractTableLookup(e0) {
    const [n0, r0] = this.drainKeysFoundInLookupTable(e0.state.addresses, (s0) => !s0.isSigner && !s0.isInvoked && s0.isWritable), [i0, o0] = this.drainKeysFoundInLookupTable(e0.state.addresses, (s0) => !s0.isSigner && !s0.isInvoked && !s0.isWritable);
    if (!(n0.length === 0 && i0.length === 0))
      return [{
        accountKey: e0.key,
        writableIndexes: n0,
        readonlyIndexes: i0
      }, {
        writable: r0,
        readonly: o0
      }];
  }
  /** @internal */
  drainKeysFoundInLookupTable(e0, n0) {
    const r0 = new Array(), i0 = new Array();
    for (const [o0, s0] of this.keyMetaMap.entries())
      if (n0(s0)) {
        const a0 = new PublicKey(o0), c0 = e0.findIndex((l0) => l0.equals(a0));
        c0 >= 0 && (assert(c0 < 256, "Max lookup table index exceeded"), r0.push(c0), i0.push(a0), this.keyMetaMap.delete(o0));
      }
    return [r0, i0];
  }
}
const END_OF_BUFFER_ERROR_MESSAGE = "Reached end of buffer unexpectedly";
function guardedShift(t0) {
  if (t0.length === 0)
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
  return t0.shift();
}
function guardedSplice(t0, ...e0) {
  const [n0] = e0;
  if (e0.length === 2 ? n0 + (e0[1] ?? 0) > t0.length : n0 >= t0.length)
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
  return t0.splice(...e0);
}
class Message {
  constructor(e0) {
    this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = /* @__PURE__ */ new Map(), this.header = e0.header, this.accountKeys = e0.accountKeys.map((n0) => new PublicKey(n0)), this.recentBlockhash = e0.recentBlockhash, this.instructions = e0.instructions, this.instructions.forEach((n0) => this.indexToProgramIds.set(n0.programIdIndex, this.accountKeys[n0.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((e0) => ({
      programIdIndex: e0.programIdIndex,
      accountKeyIndexes: e0.accounts,
      data: bs58$1.decode(e0.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys(this.staticAccountKeys);
  }
  static compile(e0) {
    const n0 = CompiledKeys.compile(e0.instructions, e0.payerKey), [r0, i0] = n0.getMessageComponents(), s0 = new MessageAccountKeys(i0).compileInstructions(e0.instructions).map((a0) => ({
      programIdIndex: a0.programIdIndex,
      accounts: a0.accountKeyIndexes,
      data: bs58$1.encode(a0.data)
    }));
    return new Message({
      header: r0,
      accountKeys: i0,
      recentBlockhash: e0.recentBlockhash,
      instructions: s0
    });
  }
  isAccountSigner(e0) {
    return e0 < this.header.numRequiredSignatures;
  }
  isAccountWritable(e0) {
    const n0 = this.header.numRequiredSignatures;
    if (e0 >= this.header.numRequiredSignatures) {
      const r0 = e0 - n0, o0 = this.accountKeys.length - n0 - this.header.numReadonlyUnsignedAccounts;
      return r0 < o0;
    } else {
      const r0 = n0 - this.header.numReadonlySignedAccounts;
      return e0 < r0;
    }
  }
  isProgramId(e0) {
    return this.indexToProgramIds.has(e0);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((e0, n0) => !this.isProgramId(n0));
  }
  serialize() {
    const e0 = this.accountKeys.length;
    let n0 = [];
    encodeLength(n0, e0);
    const r0 = this.instructions.map((d0) => {
      const {
        accounts: h0,
        programIdIndex: g0
      } = d0, w0 = Array.from(bs58$1.decode(d0.data));
      let y0 = [];
      encodeLength(y0, h0.length);
      let E0 = [];
      return encodeLength(E0, w0.length), {
        programIdIndex: g0,
        keyIndicesCount: buffer.Buffer.from(y0),
        keyIndices: h0,
        dataLength: buffer.Buffer.from(E0),
        data: w0
      };
    });
    let i0 = [];
    encodeLength(i0, r0.length);
    let o0 = buffer.Buffer.alloc(PACKET_DATA_SIZE);
    buffer.Buffer.from(i0).copy(o0);
    let s0 = i0.length;
    r0.forEach((d0) => {
      const g0 = struct([u8("programIdIndex"), blob(d0.keyIndicesCount.length, "keyIndicesCount"), seq(u8("keyIndex"), d0.keyIndices.length, "keyIndices"), blob(d0.dataLength.length, "dataLength"), seq(u8("userdatum"), d0.data.length, "data")]).encode(d0, o0, s0);
      s0 += g0;
    }), o0 = o0.slice(0, s0);
    const a0 = struct([blob(1, "numRequiredSignatures"), blob(1, "numReadonlySignedAccounts"), blob(1, "numReadonlyUnsignedAccounts"), blob(n0.length, "keyCount"), seq(publicKey("key"), e0, "keys"), publicKey("recentBlockhash")]), c0 = {
      numRequiredSignatures: buffer.Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: buffer.Buffer.from(n0),
      keys: this.accountKeys.map((d0) => toBuffer(d0.toBytes())),
      recentBlockhash: bs58$1.decode(this.recentBlockhash)
    };
    let l0 = buffer.Buffer.alloc(2048);
    const u0 = a0.encode(c0, l0);
    return o0.copy(l0, u0), l0.slice(0, u0 + o0.length);
  }
  /**
   * Decode a compiled message into a Message object.
   */
  static from(e0) {
    let n0 = [...e0];
    const r0 = guardedShift(n0);
    if (r0 !== (r0 & VERSION_PREFIX_MASK))
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    const i0 = guardedShift(n0), o0 = guardedShift(n0), s0 = decodeLength(n0);
    let a0 = [];
    for (let h0 = 0; h0 < s0; h0++) {
      const g0 = guardedSplice(n0, 0, PUBLIC_KEY_LENGTH);
      a0.push(new PublicKey(buffer.Buffer.from(g0)));
    }
    const c0 = guardedSplice(n0, 0, PUBLIC_KEY_LENGTH), l0 = decodeLength(n0);
    let u0 = [];
    for (let h0 = 0; h0 < l0; h0++) {
      const g0 = guardedShift(n0), w0 = decodeLength(n0), y0 = guardedSplice(n0, 0, w0), E0 = decodeLength(n0), b0 = guardedSplice(n0, 0, E0), O0 = bs58$1.encode(buffer.Buffer.from(b0));
      u0.push({
        programIdIndex: g0,
        accounts: y0,
        data: O0
      });
    }
    const d0 = {
      header: {
        numRequiredSignatures: r0,
        numReadonlySignedAccounts: i0,
        numReadonlyUnsignedAccounts: o0
      },
      recentBlockhash: bs58$1.encode(buffer.Buffer.from(c0)),
      accountKeys: a0,
      instructions: u0
    };
    return new Message(d0);
  }
}
const DEFAULT_SIGNATURE = buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
class TransactionInstruction {
  constructor(e0) {
    this.keys = void 0, this.programId = void 0, this.data = buffer.Buffer.alloc(0), this.programId = e0.programId, this.keys = e0.keys, e0.data && (this.data = e0.data);
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey: e0,
        isSigner: n0,
        isWritable: r0
      }) => ({
        pubkey: e0.toJSON(),
        isSigner: n0,
        isWritable: r0
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
}
class Transaction {
  /**
   * The first (payer) Transaction signature
   *
   * @returns {Buffer | null} Buffer of payer's signature
   */
  get signature() {
    return this.signatures.length > 0 ? this.signatures[0].signature : null;
  }
  /**
   * The transaction fee payer
   */
  // Construct a transaction with a blockhash and lastValidBlockHeight
  // Construct a transaction using a durable nonce
  /**
   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
   * Please supply a `TransactionBlockhashCtor` instead.
   */
  /**
   * Construct an empty Transaction
   */
  constructor(e0) {
    if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this.minNonceContextSlot = void 0, this._message = void 0, this._json = void 0, !!e0)
      if (e0.feePayer && (this.feePayer = e0.feePayer), e0.signatures && (this.signatures = e0.signatures), Object.prototype.hasOwnProperty.call(e0, "nonceInfo")) {
        const {
          minContextSlot: n0,
          nonceInfo: r0
        } = e0;
        this.minNonceContextSlot = n0, this.nonceInfo = r0;
      } else if (Object.prototype.hasOwnProperty.call(e0, "lastValidBlockHeight")) {
        const {
          blockhash: n0,
          lastValidBlockHeight: r0
        } = e0;
        this.recentBlockhash = n0, this.lastValidBlockHeight = r0;
      } else {
        const {
          recentBlockhash: n0,
          nonceInfo: r0
        } = e0;
        r0 && (this.nonceInfo = r0), this.recentBlockhash = n0;
      }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((e0) => e0.toJSON()),
      signers: this.signatures.map(({
        publicKey: e0
      }) => e0.toJSON())
    };
  }
  /**
   * Add one or more instructions to this Transaction
   *
   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
   */
  add(...e0) {
    if (e0.length === 0)
      throw new Error("No instructions");
    return e0.forEach((n0) => {
      "instructions" in n0 ? this.instructions = this.instructions.concat(n0.instructions) : "data" in n0 && "programId" in n0 && "keys" in n0 ? this.instructions.push(n0) : this.instructions.push(new TransactionInstruction(n0));
    }), this;
  }
  /**
   * Compile transaction data
   */
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))
      return this._message;
    let e0, n0;
    if (this.nonceInfo ? (e0 = this.nonceInfo.nonce, this.instructions[0] != this.nonceInfo.nonceInstruction ? n0 = [this.nonceInfo.nonceInstruction, ...this.instructions] : n0 = this.instructions) : (e0 = this.recentBlockhash, n0 = this.instructions), !e0)
      throw new Error("Transaction recentBlockhash required");
    n0.length < 1 && console.warn("No instructions provided");
    let r0;
    if (this.feePayer)
      r0 = this.feePayer;
    else if (this.signatures.length > 0 && this.signatures[0].publicKey)
      r0 = this.signatures[0].publicKey;
    else
      throw new Error("Transaction fee payer required");
    for (let y0 = 0; y0 < n0.length; y0++)
      if (n0[y0].programId === void 0)
        throw new Error(`Transaction instruction index ${y0} has undefined program id`);
    const i0 = [], o0 = [];
    n0.forEach((y0) => {
      y0.keys.forEach((b0) => {
        o0.push({
          ...b0
        });
      });
      const E0 = y0.programId.toString();
      i0.includes(E0) || i0.push(E0);
    }), i0.forEach((y0) => {
      o0.push({
        pubkey: new PublicKey(y0),
        isSigner: !1,
        isWritable: !1
      });
    });
    const s0 = [];
    o0.forEach((y0) => {
      const E0 = y0.pubkey.toString(), b0 = s0.findIndex((O0) => O0.pubkey.toString() === E0);
      b0 > -1 ? (s0[b0].isWritable = s0[b0].isWritable || y0.isWritable, s0[b0].isSigner = s0[b0].isSigner || y0.isSigner) : s0.push(y0);
    }), s0.sort(function(y0, E0) {
      if (y0.isSigner !== E0.isSigner)
        return y0.isSigner ? -1 : 1;
      if (y0.isWritable !== E0.isWritable)
        return y0.isWritable ? -1 : 1;
      const b0 = {
        localeMatcher: "best fit",
        usage: "sort",
        sensitivity: "variant",
        ignorePunctuation: !1,
        numeric: !1,
        caseFirst: "lower"
      };
      return y0.pubkey.toBase58().localeCompare(E0.pubkey.toBase58(), "en", b0);
    });
    const a0 = s0.findIndex((y0) => y0.pubkey.equals(r0));
    if (a0 > -1) {
      const [y0] = s0.splice(a0, 1);
      y0.isSigner = !0, y0.isWritable = !0, s0.unshift(y0);
    } else
      s0.unshift({
        pubkey: r0,
        isSigner: !0,
        isWritable: !0
      });
    for (const y0 of this.signatures) {
      const E0 = s0.findIndex((b0) => b0.pubkey.equals(y0.publicKey));
      if (E0 > -1)
        s0[E0].isSigner || (s0[E0].isSigner = !0, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));
      else
        throw new Error(`unknown signer: ${y0.publicKey.toString()}`);
    }
    let c0 = 0, l0 = 0, u0 = 0;
    const d0 = [], h0 = [];
    s0.forEach(({
      pubkey: y0,
      isSigner: E0,
      isWritable: b0
    }) => {
      E0 ? (d0.push(y0.toString()), c0 += 1, b0 || (l0 += 1)) : (h0.push(y0.toString()), b0 || (u0 += 1));
    });
    const g0 = d0.concat(h0), w0 = n0.map((y0) => {
      const {
        data: E0,
        programId: b0
      } = y0;
      return {
        programIdIndex: g0.indexOf(b0.toString()),
        accounts: y0.keys.map((O0) => g0.indexOf(O0.pubkey.toString())),
        data: bs58$1.encode(E0)
      };
    });
    return w0.forEach((y0) => {
      assert(y0.programIdIndex >= 0), y0.accounts.forEach((E0) => assert(E0 >= 0));
    }), new Message({
      header: {
        numRequiredSignatures: c0,
        numReadonlySignedAccounts: l0,
        numReadonlyUnsignedAccounts: u0
      },
      accountKeys: g0,
      recentBlockhash: e0,
      instructions: w0
    });
  }
  /**
   * @internal
   */
  _compile() {
    const e0 = this.compileMessage(), n0 = e0.accountKeys.slice(0, e0.header.numRequiredSignatures);
    return this.signatures.length === n0.length && this.signatures.every((i0, o0) => n0[o0].equals(i0.publicKey)) || (this.signatures = n0.map((r0) => ({
      signature: null,
      publicKey: r0
    }))), e0;
  }
  /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */
  serializeMessage() {
    return this._compile().serialize();
  }
  /**
   * Get the estimated fee associated with a transaction
   *
   * @param {Connection} connection Connection to RPC Endpoint.
   *
   * @returns {Promise<number | null>} The estimated fee for the transaction
   */
  async getEstimatedFee(e0) {
    return (await e0.getFeeForMessage(this.compileMessage())).value;
  }
  /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   *
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */
  setSigners(...e0) {
    if (e0.length === 0)
      throw new Error("No signers");
    const n0 = /* @__PURE__ */ new Set();
    this.signatures = e0.filter((r0) => {
      const i0 = r0.toString();
      return n0.has(i0) ? !1 : (n0.add(i0), !0);
    }).map((r0) => ({
      signature: null,
      publicKey: r0
    }));
  }
  /**
   * Sign the Transaction with the specified signers. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  sign(...e0) {
    if (e0.length === 0)
      throw new Error("No signers");
    const n0 = /* @__PURE__ */ new Set(), r0 = [];
    for (const o0 of e0) {
      const s0 = o0.publicKey.toString();
      n0.has(s0) || (n0.add(s0), r0.push(o0));
    }
    this.signatures = r0.map((o0) => ({
      signature: null,
      publicKey: o0.publicKey
    }));
    const i0 = this._compile();
    this._partialSign(i0, ...r0);
  }
  /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  partialSign(...e0) {
    if (e0.length === 0)
      throw new Error("No signers");
    const n0 = /* @__PURE__ */ new Set(), r0 = [];
    for (const o0 of e0) {
      const s0 = o0.publicKey.toString();
      n0.has(s0) || (n0.add(s0), r0.push(o0));
    }
    const i0 = this._compile();
    this._partialSign(i0, ...r0);
  }
  /**
   * @internal
   */
  _partialSign(e0, ...n0) {
    const r0 = e0.serialize();
    n0.forEach((i0) => {
      const o0 = sign(r0, i0.secretKey);
      this._addSignature(i0.publicKey, toBuffer(o0));
    });
  }
  /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * @param {PublicKey} pubkey Public key that will be added to the transaction.
   * @param {Buffer} signature An externally created signature to add to the transaction.
   */
  addSignature(e0, n0) {
    this._compile(), this._addSignature(e0, n0);
  }
  /**
   * @internal
   */
  _addSignature(e0, n0) {
    assert(n0.length === 64);
    const r0 = this.signatures.findIndex((i0) => e0.equals(i0.publicKey));
    if (r0 < 0)
      throw new Error(`unknown signer: ${e0.toString()}`);
    this.signatures[r0].signature = buffer.Buffer.from(n0);
  }
  /**
   * Verify signatures of a Transaction
   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
   * If no boolean is provided, we expect a fully signed Transaction by default.
   *
   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
   */
  verifySignatures(e0 = !0) {
    return !this._getMessageSignednessErrors(this.serializeMessage(), e0);
  }
  /**
   * @internal
   */
  _getMessageSignednessErrors(e0, n0) {
    const r0 = {};
    for (const {
      signature: i0,
      publicKey: o0
    } of this.signatures)
      i0 === null ? n0 && (r0.missing || (r0.missing = [])).push(o0) : verify(i0, e0, o0.toBytes()) || (r0.invalid || (r0.invalid = [])).push(o0);
    return r0.invalid || r0.missing ? r0 : void 0;
  }
  /**
   * Serialize the Transaction in the wire format.
   *
   * @param {Buffer} [config] Config of transaction.
   *
   * @returns {Buffer} Signature of transaction in wire format.
   */
  serialize(e0) {
    const {
      requireAllSignatures: n0,
      verifySignatures: r0
    } = Object.assign({
      requireAllSignatures: !0,
      verifySignatures: !0
    }, e0), i0 = this.serializeMessage();
    if (r0) {
      const o0 = this._getMessageSignednessErrors(i0, n0);
      if (o0) {
        let s0 = "Signature verification failed.";
        throw o0.invalid && (s0 += `
Invalid signature for public key${o0.invalid.length === 1 ? "" : "(s)"} [\`${o0.invalid.map((a0) => a0.toBase58()).join("`, `")}\`].`), o0.missing && (s0 += `
Missing signature for public key${o0.missing.length === 1 ? "" : "(s)"} [\`${o0.missing.map((a0) => a0.toBase58()).join("`, `")}\`].`), new Error(s0);
      }
    }
    return this._serialize(i0);
  }
  /**
   * @internal
   */
  _serialize(e0) {
    const {
      signatures: n0
    } = this, r0 = [];
    encodeLength(r0, n0.length);
    const i0 = r0.length + n0.length * 64 + e0.length, o0 = buffer.Buffer.alloc(i0);
    return assert(n0.length < 256), buffer.Buffer.from(r0).copy(o0, 0), n0.forEach(({
      signature: s0
    }, a0) => {
      s0 !== null && (assert(s0.length === 64, "signature has invalid length"), buffer.Buffer.from(s0).copy(o0, r0.length + a0 * 64));
    }), e0.copy(o0, r0.length + n0.length * 64), assert(o0.length <= PACKET_DATA_SIZE, `Transaction too large: ${o0.length} > ${PACKET_DATA_SIZE}`), o0;
  }
  /**
   * Deprecated method
   * @internal
   */
  get keys() {
    return assert(this.instructions.length === 1), this.instructions[0].keys.map((e0) => e0.pubkey);
  }
  /**
   * Deprecated method
   * @internal
   */
  get programId() {
    return assert(this.instructions.length === 1), this.instructions[0].programId;
  }
  /**
   * Deprecated method
   * @internal
   */
  get data() {
    return assert(this.instructions.length === 1), this.instructions[0].data;
  }
  /**
   * Parse a wire transaction into a Transaction object.
   *
   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
   *
   * @returns {Transaction} Transaction associated with the signature
   */
  static from(e0) {
    let n0 = [...e0];
    const r0 = decodeLength(n0);
    let i0 = [];
    for (let o0 = 0; o0 < r0; o0++) {
      const s0 = guardedSplice(n0, 0, SIGNATURE_LENGTH_IN_BYTES);
      i0.push(bs58$1.encode(buffer.Buffer.from(s0)));
    }
    return Transaction.populate(Message.from(n0), i0);
  }
  /**
   * Populate Transaction object from message and signatures
   *
   * @param {Message} message Message of transaction
   * @param {Array<string>} signatures List of signatures to assign to the transaction
   *
   * @returns {Transaction} The populated Transaction
   */
  static populate(e0, n0 = []) {
    const r0 = new Transaction();
    return r0.recentBlockhash = e0.recentBlockhash, e0.header.numRequiredSignatures > 0 && (r0.feePayer = e0.accountKeys[0]), n0.forEach((i0, o0) => {
      const s0 = {
        signature: i0 == bs58$1.encode(DEFAULT_SIGNATURE) ? null : bs58$1.decode(i0),
        publicKey: e0.accountKeys[o0]
      };
      r0.signatures.push(s0);
    }), e0.instructions.forEach((i0) => {
      const o0 = i0.accounts.map((s0) => {
        const a0 = e0.accountKeys[s0];
        return {
          pubkey: a0,
          isSigner: r0.signatures.some((c0) => c0.publicKey.toString() === a0.toString()) || e0.isAccountSigner(s0),
          isWritable: e0.isAccountWritable(s0)
        };
      });
      r0.instructions.push(new TransactionInstruction({
        keys: o0,
        programId: e0.accountKeys[i0.programIdIndex],
        data: bs58$1.decode(i0.data)
      }));
    }), r0._message = e0, r0._json = r0.toJSON(), r0;
  }
}
new PublicKey("SysvarC1ock11111111111111111111111111111111");
new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
new PublicKey("Sysvar1nstructions1111111111111111111111111");
new PublicKey("SysvarRecentB1ockHashes11111111111111111111");
new PublicKey("SysvarRent111111111111111111111111111111111");
new PublicKey("SysvarRewards111111111111111111111111111111");
new PublicKey("SysvarS1otHashes111111111111111111111111111");
new PublicKey("SysvarS1otHistory11111111111111111111111111");
new PublicKey("SysvarStakeHistory1111111111111111111111111");
const FeeCalculatorLayout = nu64("lamportsPerSignature"), NonceAccountLayout = struct([u32("version"), u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), struct([FeeCalculatorLayout], "feeCalculator")]);
NonceAccountLayout.span;
function u64(t0) {
  const e0 = blob(8, t0), n0 = e0.decode.bind(e0), r0 = e0.encode.bind(e0), i0 = e0, o0 = getU64Codec();
  return i0.decode = (s0, a0) => {
    const c0 = n0(s0, a0);
    return o0.decode(c0);
  }, i0.encode = (s0, a0, c0) => {
    const l0 = o0.encode(s0);
    return r0(l0, a0, c0);
  }, i0;
}
Object.freeze({
  Create: {
    index: 0,
    layout: struct([u32("instruction"), ns64("lamports"), ns64("space"), publicKey("programId")])
  },
  Assign: {
    index: 1,
    layout: struct([u32("instruction"), publicKey("programId")])
  },
  Transfer: {
    index: 2,
    layout: struct([u32("instruction"), u64("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: struct([u32("instruction"), publicKey("base"), rustString("seed"), ns64("lamports"), ns64("space"), publicKey("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: struct([u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: struct([u32("instruction"), publicKey("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: struct([u32("instruction"), publicKey("authorized")])
  },
  Allocate: {
    index: 8,
    layout: struct([u32("instruction"), ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: struct([u32("instruction"), publicKey("base"), rustString("seed"), ns64("space"), publicKey("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: struct([u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: struct([u32("instruction"), u64("lamports"), rustString("seed"), publicKey("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: struct([u32("instruction")])
  }
});
new PublicKey("11111111111111111111111111111111");
new PublicKey("BPFLoader2111111111111111111111111111111111");
struct([
  u32("typeIndex"),
  u64("deactivationSlot"),
  nu64("lastExtendedSlot"),
  u8("lastExtendedStartIndex"),
  u8(),
  // option
  seq(publicKey(), offset(u8(), -1), "authority")
]);
const PublicKeyFromString = coerce(instance(PublicKey), string(), (t0) => new PublicKey(t0)), RawAccountDataResult = tuple([string(), literal("base64")]), BufferFromRawAccountData = coerce(instance(buffer.Buffer), RawAccountDataResult, (t0) => buffer.Buffer.from(t0[0], "base64"));
function createRpcResult(t0) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result: t0
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
const UnknownRpcResult = createRpcResult(unknown());
function jsonRpcResult(t0) {
  return coerce(createRpcResult(t0), UnknownRpcResult, (e0) => "error" in e0 ? e0 : {
    ...e0,
    result: create(e0.result, t0)
  });
}
function jsonRpcResultAndContext(t0) {
  return jsonRpcResult(type({
    context: type({
      slot: number()
    }),
    value: t0
  }));
}
function notificationResultAndContext(t0) {
  return type({
    context: type({
      slot: number()
    }),
    value: t0
  });
}
const GetInflationGovernorResult = type({
  foundation: number(),
  foundationTerm: number(),
  initial: number(),
  taper: number(),
  terminal: number()
});
jsonRpcResult(array(nullable(type({
  epoch: number(),
  effectiveSlot: number(),
  amount: number(),
  postBalance: number(),
  commission: optional(nullable(number()))
}))));
const GetRecentPrioritizationFeesResult = array(type({
  slot: number(),
  prioritizationFee: number()
})), GetInflationRateResult = type({
  total: number(),
  validator: number(),
  foundation: number(),
  epoch: number()
}), GetEpochInfoResult = type({
  epoch: number(),
  slotIndex: number(),
  slotsInEpoch: number(),
  absoluteSlot: number(),
  blockHeight: optional(number()),
  transactionCount: optional(number())
}), GetEpochScheduleResult = type({
  slotsPerEpoch: number(),
  leaderScheduleSlotOffset: number(),
  warmup: boolean(),
  firstNormalEpoch: number(),
  firstNormalSlot: number()
}), GetLeaderScheduleResult = record(string(), array(number())), TransactionErrorResult = nullable(union([type({}), string()])), SignatureStatusResult = type({
  err: TransactionErrorResult
}), SignatureReceivedResult = literal("receivedSignature");
type({
  "solana-core": string(),
  "feature-set": optional(number())
});
const ParsedInstructionStruct = type({
  program: string(),
  programId: PublicKeyFromString,
  parsed: unknown()
}), PartiallyDecodedInstructionStruct = type({
  programId: PublicKeyFromString,
  accounts: array(PublicKeyFromString),
  data: string()
});
jsonRpcResultAndContext(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number(),
    data: array(string()),
    rentEpoch: optional(number())
  }))))),
  unitsConsumed: optional(number()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal("base64")])
  }))),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(union([ParsedInstructionStruct, PartiallyDecodedInstructionStruct]))
  }))))
}));
jsonRpcResultAndContext(type({
  byIdentity: record(string(), array(number())),
  range: type({
    firstSlot: number(),
    lastSlot: number()
  })
}));
jsonRpcResult(GetInflationGovernorResult);
jsonRpcResult(GetInflationRateResult);
jsonRpcResult(GetRecentPrioritizationFeesResult);
jsonRpcResult(GetEpochInfoResult);
jsonRpcResult(GetEpochScheduleResult);
jsonRpcResult(GetLeaderScheduleResult);
jsonRpcResult(number());
jsonRpcResultAndContext(type({
  total: number(),
  circulating: number(),
  nonCirculating: number(),
  nonCirculatingAccounts: array(PublicKeyFromString)
}));
const TokenAmountResult = type({
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
});
jsonRpcResultAndContext(array(type({
  address: PublicKeyFromString,
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
})));
jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: BufferFromRawAccountData,
    rentEpoch: number()
  })
})));
const ParsedAccountDataResult = type({
  program: string(),
  parsed: unknown(),
  space: number()
});
jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: ParsedAccountDataResult,
    rentEpoch: number()
  })
})));
jsonRpcResultAndContext(array(type({
  lamports: number(),
  address: PublicKeyFromString
})));
const AccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: BufferFromRawAccountData,
  rentEpoch: number()
});
type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
const ParsedOrRawAccountData = coerce(union([instance(buffer.Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (t0) => Array.isArray(t0) ? create(t0, BufferFromRawAccountData) : t0), ParsedAccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: ParsedOrRawAccountData,
  rentEpoch: number()
});
type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
});
type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number(),
  inactive: number()
});
jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));
jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));
type({
  subscription: number(),
  result: notificationResultAndContext(AccountInfoResult)
});
const ProgramAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
type({
  subscription: number(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
});
const SlotInfoResult = type({
  parent: number(),
  slot: number(),
  root: number()
});
type({
  subscription: number(),
  result: SlotInfoResult
});
const SlotUpdateResult = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("createdBank"),
  parent: number(),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("frozen"),
  slot: number(),
  timestamp: number(),
  stats: type({
    numTransactionEntries: number(),
    numSuccessfulTransactions: number(),
    numFailedTransactions: number(),
    maxTransactionsPerEntry: number()
  })
}), type({
  type: literal("dead"),
  slot: number(),
  timestamp: number(),
  err: string()
})]);
type({
  subscription: number(),
  result: SlotUpdateResult
});
type({
  subscription: number(),
  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
});
type({
  subscription: number(),
  result: number()
});
type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
});
const VoteAccountInfoResult = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number(), number(), number()])),
  commission: number(),
  lastVote: number(),
  rootSlot: nullable(number())
});
jsonRpcResult(type({
  current: array(VoteAccountInfoResult),
  delinquent: array(VoteAccountInfoResult)
}));
const ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]), SignatureStatusResponse = type({
  slot: number(),
  confirmations: nullable(number()),
  err: TransactionErrorResult,
  confirmationStatus: optional(ConfirmationStatus)
});
jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));
jsonRpcResult(number());
const AddressTableLookupStruct = type({
  accountKey: PublicKeyFromString,
  writableIndexes: array(number()),
  readonlyIndexes: array(number())
}), ConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number(),
      numReadonlySignedAccounts: number(),
      numReadonlyUnsignedAccounts: number()
    }),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct))
  })
}), AnnotatedAccountKey = type({
  pubkey: PublicKeyFromString,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
}), ConfirmedTransactionAccountsModeResult = type({
  accountKeys: array(AnnotatedAccountKey),
  signatures: array(string())
}), ParsedInstructionResult = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString
}), RawInstructionResult = type({
  accounts: array(PublicKeyFromString),
  data: string(),
  programId: PublicKeyFromString
}), InstructionResult = union([RawInstructionResult, ParsedInstructionResult]), UnknownInstructionResult = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]), ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (t0) => "accounts" in t0 ? create(t0, RawInstructionResult) : create(t0, ParsedInstructionResult)), ParsedConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey),
    instructions: array(ParsedOrRawInstruction),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
  })
}), TokenBalanceResult = type({
  accountIndex: number(),
  mint: string(),
  owner: optional(string()),
  programId: optional(string()),
  uiTokenAmount: TokenAmountResult
}), LoadedAddressesResult = type({
  writable: array(PublicKeyFromString),
  readonly: array(PublicKeyFromString)
}), ConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    }))
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
}), ParsedConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(ParsedOrRawInstruction)
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
}), TransactionVersionStruct = union([literal(0), literal("legacy")]), RewardsResult = type({
  pubkey: string(),
  lamports: number(),
  postBalance: nullable(number()),
  rewardType: nullable(string()),
  commission: optional(nullable(number()))
});
jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number())
})));
jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  signatures: array(string()),
  blockTime: nullable(number())
})));
jsonRpcResult(nullable(type({
  slot: number(),
  meta: nullable(ConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number())),
  transaction: ConfirmedTransactionResult,
  version: optional(TransactionVersionStruct)
})));
jsonRpcResult(nullable(type({
  slot: number(),
  transaction: ParsedConfirmedTransactionResult,
  meta: nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number())),
  version: optional(TransactionVersionStruct)
})));
jsonRpcResultAndContext(type({
  blockhash: string(),
  lastValidBlockHeight: number()
}));
jsonRpcResultAndContext(boolean());
const PerfSampleResult = type({
  slot: number(),
  numTransactions: number(),
  numSlots: number(),
  samplePeriodSecs: number()
});
jsonRpcResult(array(PerfSampleResult));
jsonRpcResultAndContext(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number()
  })
})));
jsonRpcResult(string());
jsonRpcResult(string());
const LogsResult = type({
  err: TransactionErrorResult,
  logs: array(string()),
  signature: string()
});
type({
  result: notificationResultAndContext(LogsResult),
  subscription: number()
});
Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: struct([u32("instruction"), u64("recentSlot"), u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: struct([u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: struct([u32("instruction"), u64(), seq(publicKey(), offset(u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: struct([u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: struct([u32("instruction")])
  }
});
new PublicKey("AddressLookupTab1e1111111111111111111111111");
Object.freeze({
  RequestUnits: {
    index: 0,
    layout: struct([u8("instruction"), u32("units"), u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: struct([u8("instruction"), u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: struct([u8("instruction"), u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: struct([u8("instruction"), u64("microLamports")])
  }
});
new PublicKey("ComputeBudget111111111111111111111111111111");
struct([u8("numSignatures"), u8("padding"), u16("signatureOffset"), u16("signatureInstructionIndex"), u16("publicKeyOffset"), u16("publicKeyInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u16("messageInstructionIndex")]);
new PublicKey("Ed25519SigVerify111111111111111111111111111");
secp256k1.utils.isValidPrivateKey;
struct([u8("numSignatures"), u16("signatureOffset"), u8("signatureInstructionIndex"), u16("ethAddressOffset"), u8("ethAddressInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u8("messageInstructionIndex"), blob(20, "ethAddress"), blob(64, "signature"), u8("recoveryId")]);
new PublicKey("KeccakSecp256k11111111111111111111111111111");
var _Lockup;
new PublicKey("StakeConfig11111111111111111111111111111111");
class Lockup {
  /**
   * Create a new Lockup object
   */
  constructor(e0, n0, r0) {
    this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = e0, this.epoch = n0, this.custodian = r0;
  }
  /**
   * Default, inactive Lockup value
   */
}
_Lockup = Lockup;
Lockup.default = new _Lockup(0, 0, PublicKey.default);
Object.freeze({
  Initialize: {
    index: 0,
    layout: struct([u32("instruction"), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: struct([u32("instruction"), publicKey("newAuthorized"), u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: struct([u32("instruction")])
  },
  Split: {
    index: 3,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: struct([u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: struct([u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: struct([u32("instruction"), publicKey("newAuthorized"), u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
  }
});
new PublicKey("Stake11111111111111111111111111111111111111");
Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: struct([u32("instruction"), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: struct([u32("instruction"), publicKey("newAuthorized"), u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: struct([u32("instruction"), ns64("lamports")])
  },
  UpdateValidatorIdentity: {
    index: 4,
    layout: struct([u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: struct([u32("instruction"), voteAuthorizeWithSeedArgs()])
  }
});
new PublicKey("Vote111111111111111111111111111111111111111");
new PublicKey("Va1idator1nfo111111111111111111111111111111");
type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  iconUrl: optional(string()),
  keybaseUsername: optional(string())
});
new PublicKey("Vote111111111111111111111111111111111111111");
struct([
  publicKey("nodePubkey"),
  publicKey("authorizedWithdrawer"),
  u8("commission"),
  nu64(),
  // votes.length
  seq(struct([nu64("slot"), u32("confirmationCount")]), offset(u32(), -8), "votes"),
  u8("rootSlotValid"),
  nu64("rootSlot"),
  nu64(),
  // authorizedVoters.length
  seq(struct([nu64("epoch"), publicKey("authorizedVoter")]), offset(u32(), -8), "authorizedVoters"),
  struct([seq(struct([publicKey("authorizedPubkey"), nu64("epochOfLastAuthorizedSwitch"), nu64("targetEpoch")]), 32, "buf"), nu64("idx"), u8("isEmpty")], "priorVoters"),
  nu64(),
  // epochCredits.length
  seq(struct([nu64("epoch"), nu64("credits"), nu64("prevCredits")]), offset(u32(), -8), "epochCredits"),
  struct([nu64("slot"), nu64("timestamp")], "lastTimestamp")
]);
class H extends WalletAccount {
  constructor(n0, r0, i0, o0, s0, a0) {
    super({ nodeUrl: r0 }, n0, i0);
    xg(this, "keychain");
    xg(this, "modal");
    xg(this, "options");
    this.keychain = o0, this.options = s0, this.modal = a0;
  }
  /**
   * Invoke execute function in account contract
   *
   * @param calls the invocation object or an array of them, containing:
   * - contractAddress - the address of the contract
   * - entrypoint - the entrypoint of the contract
   * - calldata - (defaults to []) the calldata
   * - signature - (defaults to []) the signature
   * @param abis (optional) the abi of the contract for better displaying
   *
   * @returns response from addTransaction
   */
  async execute(n0) {
    return n0 = r(n0), new Promise(async (r0, i0) => {
      const o0 = await this.keychain.execute(
        n0,
        void 0,
        void 0,
        !1,
        this.options?.feeSource
      );
      if (o0.code === w$3.SUCCESS) {
        r0(o0);
        return;
      }
      if (this.options?.propagateSessionErrors && o0.code !== w$3.USER_INTERACTION_REQUIRED) {
        i0(o0.error);
        return;
      }
      this.modal.open();
      const s0 = await this.keychain.execute(
        n0,
        void 0,
        void 0,
        !0,
        o0.error
      );
      if (s0.code === w$3.SUCCESS) {
        r0(s0), this.modal.close();
        return;
      }
      i0(s0.error);
    });
  }
  /**
   * Sign an JSON object for off-chain usage with the starknet private key and return the signature
   * This adds a message prefix so it cant be interchanged with transactions
   *
   * @param json - JSON object to be signed
   * @returns the signature of the JSON object
   * @throws {Error} if the JSON object is not a valid JSON
   */
  async signMessage(n0) {
    return new Promise(async (r0, i0) => {
      const o0 = await this.keychain.signMessage(n0, "", !0);
      if (!("code" in o0)) {
        r0(o0);
        return;
      }
      this.modal.open();
      const s0 = await this.keychain.signMessage(n0, "", !1);
      "code" in s0 ? i0(s0.error) : r0(s0), this.modal.close();
    });
  }
}
var b;
(function(t0) {
  t0.Call = "call", t0.Reply = "reply", t0.Syn = "syn", t0.SynAck = "synAck", t0.Ack = "ack";
})(b || (b = {}));
var v;
(function(t0) {
  t0.Fulfilled = "fulfilled", t0.Rejected = "rejected";
})(v || (v = {}));
var N;
(function(t0) {
  t0.ConnectionDestroyed = "ConnectionDestroyed", t0.ConnectionTimeout = "ConnectionTimeout", t0.NoIframeSrc = "NoIframeSrc";
})(N || (N = {}));
var z;
(function(t0) {
  t0.DataCloneError = "DataCloneError";
})(z || (z = {}));
var A;
(function(t0) {
  t0.Message = "message";
})(A || (A = {}));
const Re = (t0, e0) => {
  const n0 = [];
  let r0 = !1;
  return {
    destroy(i0) {
      r0 || (r0 = !0, e0(`${t0}: Destroying connection`), n0.forEach((o0) => {
        o0(i0);
      }));
    },
    onDestroy(i0) {
      r0 ? i0() : n0.push(i0);
    }
  };
}, Se = (t0) => (...e0) => {
  t0 && console.log("[Penpal]", ...e0);
}, Pe = {
  "http:": "80",
  "https:": "443"
}, De = /^(https?:)?\/\/([^/:]+)?(:(\d+))?/, Ne = ["file:", "data:"], Me = (t0) => {
  if (t0 && Ne.find((a0) => t0.startsWith(a0)))
    return "null";
  const e0 = document.location, n0 = De.exec(t0);
  let r0, i0, o0;
  n0 ? (r0 = n0[1] ? n0[1] : e0.protocol, i0 = n0[2], o0 = n0[4]) : (r0 = e0.protocol, i0 = e0.hostname, o0 = e0.port);
  const s0 = o0 && o0 !== Pe[r0] ? `:${o0}` : "";
  return `${r0}//${i0}${s0}`;
}, K = ({ name: t0, message: e0, stack: n0 }) => ({
  name: t0,
  message: e0,
  stack: n0
}), Be = (t0) => {
  const e0 = new Error();
  return Object.keys(t0).forEach((n0) => e0[n0] = t0[n0]), e0;
}, Te = (t0, e0, n0) => {
  const { localName: r0, local: i0, remote: o0, originForSending: s0, originForReceiving: a0 } = t0;
  let c0 = !1;
  const l0 = (u0) => {
    if (u0.source !== o0 || u0.data.penpal !== b.Call)
      return;
    if (a0 !== "*" && u0.origin !== a0) {
      n0(`${r0} received message from origin ${u0.origin} which did not match expected origin ${a0}`);
      return;
    }
    const d0 = u0.data, { methodName: h0, args: g0, id: w0 } = d0;
    n0(`${r0}: Received ${h0}() call`);
    const y0 = (E0) => (b0) => {
      if (n0(`${r0}: Sending ${h0}() reply`), c0) {
        n0(`${r0}: Unable to send ${h0}() reply due to destroyed connection`);
        return;
      }
      const O0 = {
        penpal: b.Reply,
        id: w0,
        resolution: E0,
        returnValue: b0
      };
      E0 === v.Rejected && b0 instanceof Error && (O0.returnValue = K(b0), O0.returnValueIsError = !0);
      try {
        o0.postMessage(O0, s0);
      } catch (S0) {
        if (S0.name === z.DataCloneError) {
          const k0 = {
            penpal: b.Reply,
            id: w0,
            resolution: v.Rejected,
            returnValue: K(S0),
            returnValueIsError: !0
          };
          o0.postMessage(k0, s0);
        }
        throw S0;
      }
    };
    new Promise((E0) => E0(e0[h0].call(e0, u0.origin).apply(e0, g0))).then(y0(v.Fulfilled), y0(v.Rejected));
  };
  return i0.addEventListener(A.Message, l0), () => {
    c0 = !0, i0.removeEventListener(A.Message, l0);
  };
};
let Qe = 0;
const Ue = () => ++Qe, re = ".", ne = (t0) => t0 ? t0.split(re) : [], $e = (t0) => t0.join(re), ze = (t0, e0) => {
  const n0 = ne(e0 || "");
  return n0.push(t0), $e(n0);
}, Oe = (t0, e0, n0) => {
  const r0 = ne(e0);
  return r0.reduce((i0, o0, s0) => (typeof i0[o0] > "u" && (i0[o0] = {}), s0 === r0.length - 1 && (i0[o0] = n0), i0[o0]), t0), t0;
}, se = (t0, e0) => {
  const n0 = {};
  return Object.keys(t0).forEach((r0) => {
    const i0 = t0[r0], o0 = ze(r0, e0);
    typeof i0 == "object" && Object.assign(n0, se(i0, o0)), typeof i0 == "function" && (n0[o0] = i0);
  }), n0;
}, Le = (t0) => {
  const e0 = {};
  for (const n0 in t0)
    Oe(e0, n0, t0[n0]);
  return e0;
}, Ye = (t0, e0, n0, r0, i0) => {
  const { localName: o0, local: s0, remote: a0, originForSending: c0, originForReceiving: l0 } = e0;
  let u0 = !1;
  i0(`${o0}: Connecting call sender`);
  const d0 = (g0) => (...w0) => {
    i0(`${o0}: Sending ${g0}() call`);
    let y0;
    try {
      a0.closed && (y0 = !0);
    } catch {
      y0 = !0;
    }
    if (y0 && r0(), u0) {
      const E0 = new Error(`Unable to send ${g0}() call due to destroyed connection`);
      throw E0.code = N.ConnectionDestroyed, E0;
    }
    return new Promise((E0, b0) => {
      const O0 = Ue(), S0 = (D0) => {
        if (D0.source !== a0 || D0.data.penpal !== b.Reply || D0.data.id !== O0)
          return;
        if (l0 !== "*" && D0.origin !== l0) {
          i0(`${o0} received message from origin ${D0.origin} which did not match expected origin ${l0}`);
          return;
        }
        const z0 = D0.data;
        i0(`${o0}: Received ${g0}() reply`), s0.removeEventListener(A.Message, S0);
        let G0 = z0.returnValue;
        z0.returnValueIsError && (G0 = Be(G0)), (z0.resolution === v.Fulfilled ? E0 : b0)(G0);
      };
      s0.addEventListener(A.Message, S0);
      const k0 = {
        penpal: b.Call,
        id: O0,
        methodName: g0,
        args: w0
      };
      a0.postMessage(k0, c0);
    });
  }, h0 = n0.reduce((g0, w0) => (g0[w0] = d0(w0), g0), {});
  return Object.assign(t0, Le(h0)), () => {
    u0 = !0;
  };
}, Fe = (t0, e0, n0, r0, i0) => {
  const { destroy: o0, onDestroy: s0 } = r0;
  let a0, c0;
  const l0 = {};
  return (u0) => {
    if (e0 !== "*" && u0.origin !== e0) {
      i0(`Parent: Handshake - Received ACK message from origin ${u0.origin} which did not match expected origin ${e0}`);
      return;
    }
    i0("Parent: Handshake - Received ACK");
    const d0 = {
      localName: "Parent",
      local: window,
      remote: u0.source,
      originForSending: n0,
      originForReceiving: e0
    };
    a0 && a0(), a0 = Te(d0, t0, i0), s0(a0), c0 && c0.forEach((g0) => {
      delete l0[g0];
    }), c0 = u0.data.methodNames;
    const h0 = Ye(l0, d0, c0, o0, i0);
    return s0(h0), l0;
  };
}, We = (t0, e0, n0, r0) => (i0) => {
  if (!i0.source)
    return;
  if (n0 !== "*" && i0.origin !== n0) {
    t0(`Parent: Handshake - Received SYN message from origin ${i0.origin} which did not match expected origin ${n0}`);
    return;
  }
  t0("Parent: Handshake - Received SYN, responding with SYN-ACK");
  const o0 = {
    penpal: b.SynAck,
    methodNames: Object.keys(e0)
  };
  i0.source.postMessage(o0, r0);
}, He = 6e4, Ke = (t0, e0) => {
  const { destroy: n0, onDestroy: r0 } = e0, i0 = setInterval(() => {
    t0.isConnected || (clearInterval(i0), n0());
  }, He);
  r0(() => {
    clearInterval(i0);
  });
}, je = (t0, e0) => {
  let n0;
  return t0 !== void 0 && (n0 = window.setTimeout(() => {
    const r0 = new Error(`Connection timed out after ${t0}ms`);
    r0.code = N.ConnectionTimeout, e0(r0);
  }, t0)), () => {
    clearTimeout(n0);
  };
}, qe = (t0) => {
  if (!t0.src && !t0.srcdoc) {
    const e0 = new Error("Iframe must have src or srcdoc property defined.");
    throw e0.code = N.NoIframeSrc, e0;
  }
}, Xe = (t0) => {
  let { iframe: e0, methods: n0 = {}, childOrigin: r0, timeout: i0, debug: o0 = !1 } = t0;
  const s0 = Se(o0), a0 = Re("Parent", s0), { onDestroy: c0, destroy: l0 } = a0;
  r0 || (qe(e0), r0 = Me(e0.src));
  const u0 = r0 === "null" ? "*" : r0, d0 = se(n0), h0 = We(s0, d0, r0, u0), g0 = Fe(d0, r0, u0, a0, s0);
  return {
    promise: new Promise((w0, y0) => {
      const E0 = je(i0, l0), b0 = (O0) => {
        if (!(O0.source !== e0.contentWindow || !O0.data)) {
          if (O0.data.penpal === b.Syn) {
            h0(O0);
            return;
          }
          if (O0.data.penpal === b.Ack) {
            const S0 = g0(O0);
            S0 && (E0(), w0(S0));
            return;
          }
        }
      };
      window.addEventListener(A.Message, b0), s0("Parent: Awaiting handshake"), Ke(e0, a0), c0((O0) => {
        window.removeEventListener(A.Message, b0), O0 && y0(O0);
      });
    }),
    destroy() {
      l0();
    }
  };
};
class Ge {
  constructor({
    id: e0,
    url: n0,
    preset: r0,
    onClose: i0,
    onConnect: o0,
    methods: s0 = {}
  }) {
    xg(this, "url");
    xg(this, "iframe");
    xg(this, "container");
    xg(this, "onClose");
    xg(this, "child");
    xg(this, "closeTimeout");
    if (typeof document > "u" || typeof window > "u")
      return;
    r0 && n0.searchParams.set("preset", r0), this.url = n0;
    const a0 = document.createElement("iframe");
    a0.src = n0.toString(), a0.id = e0, a0.style.border = "none", a0.sandbox.add("allow-forms"), a0.sandbox.add("allow-popups"), a0.sandbox.add("allow-popups-to-escape-sandbox"), a0.sandbox.add("allow-scripts"), a0.sandbox.add("allow-same-origin"), a0.allow = "publickey-credentials-create *; publickey-credentials-get *; clipboard-write", document.hasStorageAccess && a0.sandbox.add("allow-storage-access-by-user-activation");
    const c0 = document.createElement("div");
    c0.id = "controller", c0.style.position = "fixed", c0.style.height = "100%", c0.style.width = "100%", c0.style.top = "0", c0.style.left = "0", c0.style.zIndex = "10000", c0.style.backgroundColor = "rgba(0,0,0,0.6)", c0.style.display = "none", c0.style.alignItems = "center", c0.style.justifyContent = "center", c0.style.transition = "opacity 0.2s ease", c0.style.opacity = "0", c0.style.pointerEvents = "auto", c0.appendChild(a0), c0.addEventListener("click", (d0) => {
      d0.target === c0 && (e0 === "controller-keychain" && this.child && this.child.reset?.().catch((h0) => console.error("Error resetting context:", h0)), this.close());
    }), this.iframe = a0, this.container = c0, Xe({
      iframe: this.iframe,
      methods: {
        close: (d0) => () => this.close(),
        reload: (d0) => () => window.location.reload(),
        ...s0
      }
    }).promise.then((d0) => {
      this.child = d0, o0(d0);
    }), this.resize(), window.addEventListener("resize", () => this.resize());
    const l0 = new MutationObserver(() => {
      if (typeof document > "u")
        return;
      const d0 = document.getElementById("controller");
      document.body && e0 === "controller-keychain" && !d0 && (document.body.appendChild(c0), l0.disconnect());
    });
    l0.observe(document.documentElement, {
      childList: !0,
      subtree: !0
    });
    const u0 = document.getElementById("controller");
    document.body && e0 === "controller-keychain" && !u0 && document.body.appendChild(c0), this.onClose = i0;
  }
  open() {
    !this.container || typeof document > "u" || !document.body || (this.closeTimeout && (clearTimeout(this.closeTimeout), this.closeTimeout = void 0), document.body.style.overflow = "hidden", this.container.style.display = "flex", requestAnimationFrame(() => {
      this.container && (this.container.style.opacity = "1");
    }));
  }
  close() {
    !this.container || typeof document > "u" || !document.body || (this.onClose?.(), document.body.style.overflow = "auto", this.container.style.opacity = "0", this.closeTimeout = setTimeout(() => {
      this.container && (this.container.style.display = "none"), this.closeTimeout = void 0;
    }, 200));
  }
  sendBackward() {
    this.container && (this.container.style.zIndex = "9999");
  }
  sendForward() {
    this.container && (this.container.style.zIndex = "10000");
  }
  resize() {
    if (!(!this.iframe || typeof window > "u")) {
      if (this.iframe.style.userSelect = "none", window.innerWidth < 768) {
        this.iframe.style.height = "100%", this.iframe.style.width = "100%", this.iframe.style.borderRadius = "0";
        return;
      }
      this.iframe.style.height = "600px", this.iframe.style.width = "432px", this.iframe.style.borderRadius = "8px";
    }
  }
  isOpen() {
    return this.container?.style.display !== "none";
  }
}
const Ve = "6.13.7";
function j(t0, e0, n0) {
  for (let r0 in e0) {
    let i0 = e0[r0];
    Object.defineProperty(t0, r0, { enumerable: !0, value: i0, writable: !1 });
  }
}
function C(t0) {
  if (t0 == null)
    return "null";
  if (Array.isArray(t0))
    return "[ " + t0.map(C).join(", ") + " ]";
  if (t0 instanceof Uint8Array) {
    const e0 = "0123456789abcdef";
    let n0 = "0x";
    for (let r0 = 0; r0 < t0.length; r0++)
      n0 += e0[t0[r0] >> 4], n0 += e0[t0[r0] & 15];
    return n0;
  }
  if (typeof t0 == "object" && typeof t0.toJSON == "function")
    return C(t0.toJSON());
  switch (typeof t0) {
    case "boolean":
    case "symbol":
      return t0.toString();
    case "bigint":
      return BigInt(t0).toString();
    case "number":
      return t0.toString();
    case "string":
      return JSON.stringify(t0);
    case "object": {
      const e0 = Object.keys(t0);
      return e0.sort(), "{ " + e0.map((n0) => `${C(n0)}: ${C(t0[n0])}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function Je(t0, e0, n0) {
  let r0 = t0;
  {
    const o0 = [];
    if (n0) {
      if ("message" in n0 || "code" in n0 || "name" in n0)
        throw new Error(`value will overwrite populated values: ${C(n0)}`);
      for (const s0 in n0) {
        if (s0 === "shortMessage")
          continue;
        const a0 = n0[s0];
        o0.push(s0 + "=" + C(a0));
      }
    }
    o0.push(`code=${e0}`), o0.push(`version=${Ve}`), o0.length && (t0 += " (" + o0.join(", ") + ")");
  }
  let i0;
  switch (e0) {
    case "INVALID_ARGUMENT":
      i0 = new TypeError(t0);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      i0 = new RangeError(t0);
      break;
    default:
      i0 = new Error(t0);
  }
  return j(i0, { code: e0 }), n0 && Object.assign(i0, n0), i0.shortMessage == null && j(i0, { shortMessage: r0 }), i0;
}
function Ze(t0, e0, n0, r0) {
  if (!t0)
    throw Je(e0, n0, r0);
}
function D(t0, e0, n0, r0) {
  Ze(t0, e0, "INVALID_ARGUMENT", { argument: n0, value: r0 });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((t0, e0) => {
  try {
    if ("test".normalize(e0) !== "test")
      throw new Error("bad");
    if (e0 === "NFD" && "".normalize("NFD") !== "e")
      throw new Error("broken");
    t0.push(e0);
  } catch {
  }
  return t0;
}, []);
function et(t0, e0, n0) {
  if (t0 instanceof Uint8Array)
    return t0;
  if (typeof t0 == "string" && t0.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const r0 = new Uint8Array((t0.length - 2) / 2);
    let i0 = 2;
    for (let o0 = 0; o0 < r0.length; o0++)
      r0[o0] = parseInt(t0.substring(i0, i0 + 2), 16), i0 += 2;
    return r0;
  }
  D(!1, "invalid BytesLike value", e0 || "value", t0);
}
function O(t0, e0) {
  return et(t0, e0);
}
const q = "0123456789abcdef";
function tt(t0) {
  const e0 = O(t0);
  let n0 = "0x";
  for (let r0 = 0; r0 < e0.length; r0++) {
    const i0 = e0[r0];
    n0 += q[(i0 & 240) >> 4] + q[i0 & 15];
  }
  return n0;
}
function X(t0) {
  if (!Number.isSafeInteger(t0) || t0 < 0)
    throw new Error(`Wrong positive integer: ${t0}`);
}
function oe(t0, ...e0) {
  if (!(t0 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (e0.length > 0 && !e0.includes(t0.length))
    throw new Error(`Expected Uint8Array of length ${e0}, not of length=${t0.length}`);
}
function G(t0, e0 = !0) {
  if (t0.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e0 && t0.finished)
    throw new Error("Hash#digest() has already been called");
}
function rt(t0, e0) {
  oe(t0);
  const n0 = e0.outputLen;
  if (t0.length < n0)
    throw new Error(`digestInto() expects output buffer of length at least ${n0}`);
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const nt = (t0) => t0 instanceof Uint8Array, st = (t0) => new Uint32Array(t0.buffer, t0.byteOffset, Math.floor(t0.byteLength / 4)), ot = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!ot)
  throw new Error("Non little-endian hardware is not supported");
function at(t0) {
  if (typeof t0 != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t0}`);
  return new Uint8Array(new TextEncoder().encode(t0));
}
function ae(t0) {
  if (typeof t0 == "string" && (t0 = at(t0)), !nt(t0))
    throw new Error(`expected Uint8Array, got ${typeof t0}`);
  return t0;
}
class it {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function ct(t0) {
  const e0 = (r0) => t0().update(ae(r0)).digest(), n0 = t0();
  return e0.outputLen = n0.outputLen, e0.blockLen = n0.blockLen, e0.create = () => t0(), e0;
}
const B = /* @__PURE__ */ BigInt(2 ** 32 - 1), V = /* @__PURE__ */ BigInt(32);
function lt(t0, e0 = !1) {
  return e0 ? { h: Number(t0 & B), l: Number(t0 >> V & B) } : { h: Number(t0 >> V & B) | 0, l: Number(t0 & B) | 0 };
}
function dt(t0, e0 = !1) {
  let n0 = new Uint32Array(t0.length), r0 = new Uint32Array(t0.length);
  for (let i0 = 0; i0 < t0.length; i0++) {
    const { h: o0, l: s0 } = lt(t0[i0], e0);
    [n0[i0], r0[i0]] = [o0, s0];
  }
  return [n0, r0];
}
const ht = (t0, e0, n0) => t0 << n0 | e0 >>> 32 - n0, ut = (t0, e0, n0) => e0 << n0 | t0 >>> 32 - n0, ft = (t0, e0, n0) => e0 << n0 - 32 | t0 >>> 64 - n0, pt = (t0, e0, n0) => t0 << n0 - 32 | e0 >>> 64 - n0, [ie, ce, le] = [[], [], []], mt = /* @__PURE__ */ BigInt(0), P = /* @__PURE__ */ BigInt(1), gt = /* @__PURE__ */ BigInt(2), yt = /* @__PURE__ */ BigInt(7), bt = /* @__PURE__ */ BigInt(256), wt = /* @__PURE__ */ BigInt(113);
for (let t0 = 0, e0 = P, n0 = 1, r0 = 0; t0 < 24; t0++) {
  [n0, r0] = [r0, (2 * n0 + 3 * r0) % 5], ie.push(2 * (5 * r0 + n0)), ce.push((t0 + 1) * (t0 + 2) / 2 % 64);
  let i0 = mt;
  for (let o0 = 0; o0 < 7; o0++)
    e0 = (e0 << P ^ (e0 >> yt) * wt) % bt, e0 & gt && (i0 ^= P << (P << /* @__PURE__ */ BigInt(o0)) - P);
  le.push(i0);
}
const [_t, kt] = /* @__PURE__ */ dt(le, !0), J = (t0, e0, n0) => n0 > 32 ? ft(t0, e0, n0) : ht(t0, e0, n0), Z = (t0, e0, n0) => n0 > 32 ? pt(t0, e0, n0) : ut(t0, e0, n0);
function At(t0, e0 = 24) {
  const n0 = new Uint32Array(10);
  for (let r0 = 24 - e0; r0 < 24; r0++) {
    for (let s0 = 0; s0 < 10; s0++)
      n0[s0] = t0[s0] ^ t0[s0 + 10] ^ t0[s0 + 20] ^ t0[s0 + 30] ^ t0[s0 + 40];
    for (let s0 = 0; s0 < 10; s0 += 2) {
      const a0 = (s0 + 8) % 10, c0 = (s0 + 2) % 10, l0 = n0[c0], u0 = n0[c0 + 1], d0 = J(l0, u0, 1) ^ n0[a0], h0 = Z(l0, u0, 1) ^ n0[a0 + 1];
      for (let g0 = 0; g0 < 50; g0 += 10)
        t0[s0 + g0] ^= d0, t0[s0 + g0 + 1] ^= h0;
    }
    let i0 = t0[2], o0 = t0[3];
    for (let s0 = 0; s0 < 24; s0++) {
      const a0 = ce[s0], c0 = J(i0, o0, a0), l0 = Z(i0, o0, a0), u0 = ie[s0];
      i0 = t0[u0], o0 = t0[u0 + 1], t0[u0] = c0, t0[u0 + 1] = l0;
    }
    for (let s0 = 0; s0 < 50; s0 += 10) {
      for (let a0 = 0; a0 < 10; a0++)
        n0[a0] = t0[s0 + a0];
      for (let a0 = 0; a0 < 10; a0++)
        t0[s0 + a0] ^= ~n0[(a0 + 2) % 10] & n0[(a0 + 4) % 10];
    }
    t0[0] ^= _t[r0], t0[1] ^= kt[r0];
  }
  n0.fill(0);
}
class L extends it {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e0, n0, r0, i0 = !1, o0 = 24) {
    if (super(), this.blockLen = e0, this.suffix = n0, this.outputLen = r0, this.enableXOF = i0, this.rounds = o0, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, X(r0), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = st(this.state);
  }
  keccak() {
    At(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(e0) {
    G(this);
    const { blockLen: n0, state: r0 } = this;
    e0 = ae(e0);
    const i0 = e0.length;
    for (let o0 = 0; o0 < i0; ) {
      const s0 = Math.min(n0 - this.pos, i0 - o0);
      for (let a0 = 0; a0 < s0; a0++)
        r0[this.pos++] ^= e0[o0++];
      this.pos === n0 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e0, suffix: n0, pos: r0, blockLen: i0 } = this;
    e0[r0] ^= n0, n0 & 128 && r0 === i0 - 1 && this.keccak(), e0[i0 - 1] ^= 128, this.keccak();
  }
  writeInto(e0) {
    G(this, !1), oe(e0), this.finish();
    const n0 = this.state, { blockLen: r0 } = this;
    for (let i0 = 0, o0 = e0.length; i0 < o0; ) {
      this.posOut >= r0 && this.keccak();
      const s0 = Math.min(r0 - this.posOut, o0 - i0);
      e0.set(n0.subarray(this.posOut, this.posOut + s0), i0), this.posOut += s0, i0 += s0;
    }
    return e0;
  }
  xofInto(e0) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e0);
  }
  xof(e0) {
    return X(e0), this.xofInto(new Uint8Array(e0));
  }
  digestInto(e0) {
    if (rt(e0, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e0), this.destroy(), e0;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e0) {
    const { blockLen: n0, suffix: r0, outputLen: i0, rounds: o0, enableXOF: s0 } = this;
    return e0 || (e0 = new L(n0, r0, i0, s0, o0)), e0.state32.set(this.state32), e0.pos = this.pos, e0.posOut = this.posOut, e0.finished = this.finished, e0.rounds = o0, e0.suffix = r0, e0.outputLen = i0, e0.enableXOF = s0, e0.destroyed = this.destroyed, e0;
  }
}
const It = (t0, e0, n0) => ct(() => new L(e0, t0, n0)), vt = /* @__PURE__ */ It(1, 136, 256 / 8);
let de = !1;
const he = function(t0) {
  return vt(t0);
};
let ue = he;
function M(t0) {
  const e0 = O(t0, "data");
  return tt(ue(e0));
}
M._ = he;
M.lock = function() {
  de = !0;
};
M.register = function(t0) {
  if (de)
    throw new TypeError("keccak256 is locked");
  ue = t0;
};
Object.freeze(M);
const Et = BigInt(0), xt = BigInt(36);
function ee(t0) {
  t0 = t0.toLowerCase();
  const e0 = t0.substring(2).split(""), n0 = new Uint8Array(40);
  for (let i0 = 0; i0 < 40; i0++)
    n0[i0] = e0[i0].charCodeAt(0);
  const r0 = O(M(n0));
  for (let i0 = 0; i0 < 40; i0 += 2)
    r0[i0 >> 1] >> 4 >= 8 && (e0[i0] = e0[i0].toUpperCase()), (r0[i0 >> 1] & 15) >= 8 && (e0[i0 + 1] = e0[i0 + 1].toUpperCase());
  return "0x" + e0.join("");
}
const Y = {};
for (let t0 = 0; t0 < 10; t0++)
  Y[String(t0)] = String(t0);
for (let t0 = 0; t0 < 26; t0++)
  Y[String.fromCharCode(65 + t0)] = String(10 + t0);
const te = 15;
function Ct(t0) {
  t0 = t0.toUpperCase(), t0 = t0.substring(4) + t0.substring(0, 2) + "00";
  let e0 = t0.split("").map((r0) => Y[r0]).join("");
  for (; e0.length >= te; ) {
    let r0 = e0.substring(0, te);
    e0 = parseInt(r0, 10) % 97 + e0.substring(r0.length);
  }
  let n0 = String(98 - parseInt(e0, 10) % 97);
  for (; n0.length < 2; )
    n0 = "0" + n0;
  return n0;
}
const Rt = function() {
  const t0 = {};
  for (let e0 = 0; e0 < 36; e0++) {
    const n0 = "0123456789abcdefghijklmnopqrstuvwxyz"[e0];
    t0[n0] = BigInt(e0);
  }
  return t0;
}();
function St(t0) {
  t0 = t0.toLowerCase();
  let e0 = Et;
  for (let n0 = 0; n0 < t0.length; n0++)
    e0 = e0 * xt + Rt[t0[n0]];
  return e0;
}
function m(t0) {
  if (D(typeof t0 == "string", "invalid address", "address", t0), t0.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    t0.startsWith("0x") || (t0 = "0x" + t0);
    const e0 = ee(t0);
    return D(!t0.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e0 === t0, "bad address checksum", "address", t0), e0;
  }
  if (t0.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    D(t0.substring(2, 4) === Ct(t0), "bad icap checksum", "address", t0);
    let e0 = St(t0.substring(4)).toString(16);
    for (; e0.length < 40; )
      e0 = "0" + e0;
    return ee("0x" + e0);
  }
  D(!1, "invalid address", "address", t0);
}
class Pt {
  constructor() {
    xg(this, "type", "argent");
    xg(this, "platform", "starknet");
    xg(this, "wallet");
    xg(this, "account");
    xg(this, "connectedAccounts", []);
  }
  isAvailable() {
    return typeof window < "u" && !!window.starknet_argentX;
  }
  getInfo() {
    const e0 = this.isAvailable();
    return {
      type: this.type,
      available: e0,
      version: e0 ? window.starknet_argentX?.version || "Unknown" : void 0,
      chainId: e0 ? window.starknet_argentX?.chainId : void 0,
      name: "Argent",
      platform: this.platform
    };
  }
  async connect() {
    if (this.account)
      return { success: !0, wallet: this.type, account: this.account };
    try {
      if (!this.isAvailable())
        throw new Error("Argent is not available");
      const { wallet: e0, connectorData: n0 } = await K$2({
        connectors: [new L$3({ options: { id: "argentX" } })]
      });
      if (!e0)
        throw new Error("No wallet found");
      return this.wallet = e0, this.account = n0?.account, { success: !0, wallet: this.type, account: this.account };
    } catch (e0) {
      return console.error("Error connecting to Argent:", e0), {
        success: !1,
        wallet: this.type,
        error: e0.message || "Unknown error"
      };
    }
  }
  getConnectedAccounts() {
    return this.connectedAccounts;
  }
  async signTypedData(e0) {
    try {
      if (!this.isAvailable() || !this.wallet)
        throw new Error("Argent is not connected");
      const n0 = await this.wallet.request({
        type: "wallet_signTypedData",
        params: e0
      });
      return { success: !0, wallet: this.type, result: n0 };
    } catch (n0) {
      return console.error("Error signing typed data with Argent:", n0), {
        success: !1,
        wallet: this.type,
        error: n0.message || "Unknown error"
      };
    }
  }
  async sendTransaction(e0) {
    return {
      success: !1,
      wallet: this.type,
      error: "Not implemented"
    };
  }
  async switchChain(e0) {
    return console.warn(
      "Chain switching for Argent may require custom implementation"
    ), !1;
  }
  async getBalance(e0) {
    try {
      if (!this.isAvailable() || !this.wallet)
        throw new Error("Argent is not connected");
      return {
        success: !0,
        wallet: this.type,
        result: "Implement based on Argent API"
      };
    } catch (n0) {
      return console.error("Error getting balance from Argent:", n0), {
        success: !1,
        wallet: this.type,
        error: n0.message || "Unknown error"
      };
    }
  }
}
function Dt(t0) {
  if (typeof window > "u")
    return;
  const e0 = (n0) => t0(n0.detail);
  return window.addEventListener("eip6963:announceProvider", e0), window.dispatchEvent(new CustomEvent("eip6963:requestProvider")), () => window.removeEventListener("eip6963:announceProvider", e0);
}
function fe() {
  const t0 = /* @__PURE__ */ new Set();
  let e0 = [];
  const n0 = () => Dt((i0) => {
    e0.some(({ info: o0 }) => o0.uuid === i0.info.uuid) || (e0 = [...e0, i0], t0.forEach((o0) => o0(e0, { added: [i0] })));
  });
  let r0 = n0();
  return {
    _listeners() {
      return t0;
    },
    clear() {
      t0.forEach((i0) => i0([], { removed: [...e0] })), e0 = [];
    },
    destroy() {
      this.clear(), t0.clear(), r0?.();
    },
    findProvider({ rdns: i0 }) {
      return e0.find((o0) => o0.info.rdns === i0);
    },
    getProviders() {
      return e0;
    },
    reset() {
      this.clear(), r0?.(), r0 = n0();
    },
    subscribe(i0, { emitImmediately: o0 } = {}) {
      return t0.add(i0), o0 && i0(e0, { added: e0 }), () => t0.delete(i0);
    }
  };
}
class Nt {
  constructor() {
    xg(this, "type", "metamask");
    xg(this, "platform", "ethereum");
    xg(this, "MMSDK");
    xg(this, "store", fe());
    xg(this, "account");
    xg(this, "connectedAccounts", []);
    this.MMSDK = new tf({
      dappMetadata: {
        name: "Cartridge Controller",
        url: window.location.href
      }
    }), this.isAvailable() && this.MMSDK.sdkInitPromise?.then(() => {
      this.MMSDK.getProvider()?.request({
        method: "eth_accounts"
      }).then((e0) => {
        e0 && e0.length > 0 && (this.account = m(e0[0]), this.connectedAccounts = e0.map(m));
      }), this.MMSDK.getProvider()?.on("accountsChanged", (e0) => {
        Array.isArray(e0) && e0.length > 0 && (this.account = m(e0?.[0]), this.connectedAccounts = e0.map(m));
      });
    });
  }
  isAvailable() {
    return typeof window < "u" && this.store.getProviders().some((e0) => e0.info.rdns === "io.metamask");
  }
  getInfo() {
    const e0 = this.isAvailable();
    return {
      type: this.type,
      available: e0,
      version: e0 ? window.ethereum?.version || "Unknown" : void 0,
      chainId: e0 ? window.ethereum?.chainId : void 0,
      name: "MetaMask",
      platform: this.platform,
      connectedAccounts: this.connectedAccounts
    };
  }
  async connect() {
    if (this.account)
      return { success: !0, wallet: this.type, account: this.account };
    try {
      if (!this.isAvailable())
        throw new Error("MetaMask is not available");
      const e0 = await this.MMSDK.connect();
      if (e0 && e0.length > 0)
        return this.account = m(e0[0]), this.connectedAccounts = e0.map(
          (n0) => m(n0)
        ), { success: !0, wallet: this.type, account: this.account };
      throw new Error("No accounts found");
    } catch (e0) {
      return console.error("Error connecting to MetaMask:", e0), {
        success: !1,
        wallet: this.type,
        error: e0.message || "Unknown error"
      };
    }
  }
  getConnectedAccounts() {
    return this.connectedAccounts;
  }
  async signTransaction(e0) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("MetaMask is not connected");
      const n0 = this.MMSDK.getProvider();
      if (!n0)
        throw new Error("MetaMask is not connected");
      const r0 = await n0.request({
        method: "eth_sendTransaction",
        params: [e0]
      });
      return { success: !0, wallet: this.type, result: r0 };
    } catch (n0) {
      return console.error("Error signing transaction with MetaMask:", n0), {
        success: !1,
        wallet: this.type,
        error: n0.message || "Unknown error"
      };
    }
  }
  async signMessage(e0, n0) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("MetaMask is not connected");
      const r0 = await this.MMSDK.getProvider()?.request({
        method: "personal_sign",
        params: [n0 || this.account, e0]
      });
      return { success: !0, wallet: this.type, result: r0 };
    } catch (r0) {
      return console.error("Error signing message with MetaMask:", r0), {
        success: !1,
        wallet: this.type,
        error: r0.message || "Unknown error"
      };
    }
  }
  async signTypedData(e0) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("MetaMask is not connected");
      const n0 = this.MMSDK.getProvider();
      if (!n0)
        throw new Error("MetaMask is not connected");
      const r0 = await n0.request({
        method: "eth_signTypedData_v4",
        params: [this.account, JSON.stringify(e0)]
      });
      return { success: !0, wallet: this.type, result: r0 };
    } catch (n0) {
      return console.error("Error signing typed data with MetaMask:", n0), {
        success: !1,
        wallet: this.type,
        error: n0.message || "Unknown error"
      };
    }
  }
  async sendTransaction(e0) {
    return {
      success: !1,
      wallet: this.type,
      error: "Not implemented"
    };
  }
  async switchChain(e0) {
    try {
      if (!this.isAvailable())
        throw new Error("MetaMask is not available");
      const n0 = this.MMSDK.getProvider();
      if (!n0)
        throw new Error("MetaMask is not connected");
      try {
        return await n0.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: e0 }]
        }), !0;
      } catch (r0) {
        throw r0.code === 4902 && console.warn("Chain not added to MetaMask"), r0;
      }
    } catch (n0) {
      return console.error("Error switching chain for MetaMask:", n0), !1;
    }
  }
  async getBalance(e0) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("MetaMask is not connected");
      if (e0)
        return {
          success: !1,
          wallet: this.type,
          error: "Not implemented for ERC20"
        };
      {
        const n0 = this.MMSDK.getProvider();
        if (!n0)
          throw new Error("MetaMask is not connected");
        const r0 = await n0.request({
          method: "eth_getBalance",
          params: [this.account, "latest"]
        });
        return { success: !0, wallet: this.type, result: r0 };
      }
    } catch (n0) {
      return console.error("Error getting balance from MetaMask:", n0), {
        success: !1,
        wallet: this.type,
        error: n0.message || "Unknown error"
      };
    }
  }
}
class Mt {
  constructor() {
    xg(this, "type", "phantom");
    xg(this, "platform", "solana");
    xg(this, "account");
    xg(this, "connectedAccounts", []);
  }
  getProvider() {
    if (typeof window > "u")
      throw new Error("Not ready");
    const e0 = window.solana;
    if (!e0?.isPhantom)
      throw new Error("Phantom is not available");
    return e0;
  }
  isAvailable() {
    return typeof window < "u" && !!window.solana?.isPhantom;
  }
  getInfo() {
    const e0 = this.isAvailable();
    return {
      type: this.type,
      available: e0,
      version: "Unknown",
      name: "Phantom",
      platform: this.platform
    };
  }
  async connect() {
    if (this.account)
      return { success: !0, wallet: this.type, account: this.account };
    try {
      if (!this.isAvailable())
        throw new Error("Phantom is not available");
      const e0 = await this.getProvider().connect();
      if (e0.publicKey)
        return this.account = e0.publicKey.toString(), { success: !0, wallet: this.type, account: this.account };
      throw new Error("No accounts found");
    } catch (e0) {
      return console.error("Error connecting to Phantom:", e0), {
        success: !1,
        wallet: this.type,
        error: e0.message || "Unknown error"
      };
    }
  }
  getConnectedAccounts() {
    return this.connectedAccounts;
  }
  async signMessage(e0) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Phantom is not connected");
      const n0 = new TextEncoder().encode(e0), r0 = await this.getProvider().signMessage(
        n0,
        "utf8"
      );
      return { success: !0, wallet: this.type, result: r0 };
    } catch (n0) {
      return console.error("Error signing message with Phantom:", n0), {
        success: !1,
        wallet: this.type,
        error: n0.message || "Unknown error"
      };
    }
  }
  async sendTransaction(e0) {
    if (!this.isAvailable() || !this.account)
      throw new Error("Phantom is not connected");
    try {
      const n0 = Transaction.from(e0), r0 = await this.getProvider().signAndSendTransaction(n0);
      return {
        success: !0,
        wallet: this.type,
        result: r0
      };
    } catch (n0) {
      return console.error("Error sending transaction with Phantom:", n0), {
        success: !1,
        wallet: this.type,
        error: n0.message || "Unknown error"
      };
    }
  }
  async switchChain(e0) {
    return console.warn("Chain switching not supported for Phantom"), !1;
  }
  async getBalance(e0) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Phantom is not connected");
      return {
        success: !0,
        wallet: this.type,
        result: "Implement based on Phantom API"
      };
    } catch (n0) {
      return console.error("Error getting balance from Phantom:", n0), {
        success: !1,
        wallet: this.type,
        error: n0.message || "Unknown error"
      };
    }
  }
}
const Bt = "io.rabby";
class Tt {
  constructor() {
    xg(this, "type", "rabby");
    xg(this, "platform", "ethereum");
    xg(this, "account");
    xg(this, "store", fe());
    xg(this, "provider");
    xg(this, "connectedAccounts", []);
    this.provider = this.store.getProviders().find((e0) => e0.info.rdns === Bt), this.provider?.provider.request({
      method: "eth_accounts"
    }).then((e0) => {
      this.connectedAccounts = e0.map(m), e0.length > 0 && (this.account = m(e0?.[0]));
    }), this.provider?.provider?.on("accountsChanged", (e0) => {
      e0 && (this.connectedAccounts = e0.map((n0) => m(n0)), this.account = m(e0?.[0]));
    });
  }
  isAvailable() {
    return typeof window < "u" && !!this.provider;
  }
  getInfo() {
    const e0 = this.isAvailable();
    return {
      type: this.type,
      available: e0,
      version: e0 ? window.ethereum?.version || "Unknown" : void 0,
      chainId: e0 ? window.ethereum?.chainId : void 0,
      name: "Rabby",
      platform: this.platform,
      connectedAccounts: this.connectedAccounts
    };
  }
  async connect(e0) {
    if (e0 && this.connectedAccounts.includes(m(e0)) && (this.account = m(e0)), this.account)
      return { success: !0, wallet: this.type, account: this.account };
    try {
      if (!this.isAvailable())
        throw new Error("Rabby is not available");
      const n0 = await this.provider?.provider.request({
        method: "eth_requestAccounts"
      });
      if (n0 && n0.length > 0)
        return this.account = m(n0[0]), this.connectedAccounts = n0.map(m), { success: !0, wallet: this.type, account: this.account };
      throw new Error("No accounts found");
    } catch (n0) {
      return console.error("Error connecting to Rabby:", n0), {
        success: !1,
        wallet: this.type,
        error: n0.message || "Unknown error"
      };
    }
  }
  getConnectedAccounts() {
    return this.connectedAccounts;
  }
  async signTransaction(e0) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Rabby is not connected");
      const n0 = this.provider?.provider;
      if (!n0)
        throw new Error("Rabby is not connected");
      const r0 = await n0.request({
        method: "eth_sendTransaction",
        params: [e0]
      });
      return { success: !0, wallet: this.type, result: r0 };
    } catch (n0) {
      return console.error("Error signing transaction with Rabby:", n0), {
        success: !1,
        wallet: this.type,
        error: n0.message || "Unknown error"
      };
    }
  }
  async signMessage(e0, n0) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Rabby is not connected");
      const r0 = await this.provider?.provider.request({
        method: "personal_sign",
        params: [n0 || this.account, e0]
      });
      return { success: !0, wallet: this.type, result: r0 };
    } catch (r0) {
      return console.error("Error signing message with Rabby:", r0), {
        success: !1,
        wallet: this.type,
        error: r0.message || "Unknown error"
      };
    }
  }
  async signTypedData(e0) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Rabby is not connected");
      const n0 = this.provider?.provider;
      if (!n0)
        throw new Error("Rabby is not connected");
      const r0 = await n0.request({
        method: "eth_signTypedData_v4",
        params: [this.account, JSON.stringify(e0)]
      });
      return { success: !0, wallet: this.type, result: r0 };
    } catch (n0) {
      return console.error("Error signing typed data with Rabby:", n0), {
        success: !1,
        wallet: this.type,
        error: n0.message || "Unknown error"
      };
    }
  }
  async sendTransaction(e0) {
    return {
      success: !1,
      wallet: this.type,
      error: "Not implemented"
    };
  }
  async switchChain(e0) {
    try {
      if (!this.isAvailable())
        throw new Error("Rabby is not available");
      const n0 = this.provider?.provider;
      if (!n0)
        throw new Error("Rabby is not connected");
      try {
        return await n0.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: e0 }]
        }), !0;
      } catch (r0) {
        throw r0.code === 4902 && console.warn("Chain not added to Rabby"), r0;
      }
    } catch (n0) {
      return console.error("Error switching chain for Rabby:", n0), !1;
    }
  }
  async getBalance(e0) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Rabby is not connected");
      if (e0)
        return {
          success: !1,
          wallet: this.type,
          error: "Not implemented for ERC20"
        };
      {
        const n0 = this.provider?.provider;
        if (!n0)
          throw new Error("Rabby is not connected");
        const r0 = await n0.request({
          method: "eth_getBalance",
          params: [this.account, "latest"]
        });
        return { success: !0, wallet: this.type, result: r0 };
      }
    } catch (n0) {
      return console.error("Error getting balance from Rabby:", n0), {
        success: !1,
        wallet: this.type,
        error: n0.message || "Unknown error"
      };
    }
  }
}
class Qt {
  constructor() {
    xg(this, "walletAdapters");
    if (this.walletAdapters = /* @__PURE__ */ new Map(), typeof window > "u")
      return;
    const e0 = new Nt();
    e0.isAvailable() && this.walletAdapters.set("metamask", e0);
    const n0 = new Mt();
    n0.isAvailable() && this.walletAdapters.set("phantom", n0);
    const r0 = new Pt();
    r0.isAvailable() && this.walletAdapters.set("argent", r0);
    const i0 = new Tt();
    i0.isAvailable() && this.walletAdapters.set("rabby", i0), window.wallet_bridge = this;
  }
  getIFrameMethods() {
    return {
      externalDetectWallets: (e0) => () => this.detectWallets(),
      externalConnectWallet: (e0) => (n0) => this.connectWallet(n0),
      externalSignMessage: (e0) => (n0, r0) => this.signMessage(n0, r0),
      externalSignTypedData: (e0) => (n0, r0) => this.signTypedData(n0, r0),
      externalSendTransaction: (e0) => (n0, r0) => this.sendTransaction(n0, r0),
      externalGetBalance: (e0) => (n0, r0) => this.getBalance(n0, r0)
    };
  }
  async detectWallets() {
    return Array.from(this.walletAdapters.values()).map(
      (e0) => e0.getInfo()
    );
  }
  getWalletAdapterByType(e0) {
    const n0 = this.walletAdapters.get(e0);
    if (!n0)
      throw new Error(`Unsupported wallet type: ${e0}`);
    return n0;
  }
  handleError(e0, n0, r0, i0) {
    const o0 = n0 instanceof Error ? n0.message : "Unknown error";
    let s0 = "unknown";
    if (typeof e0 == "string") {
      const a0 = this.getConnectedWalletAdapter(e0);
      s0 = i0 ?? a0?.type ?? e0;
    } else
      s0 = e0;
    return console.error(`Error ${r0} with ${e0} wallet:`, n0), {
      success: !1,
      wallet: s0,
      error: o0
    };
  }
  async connectWallet(e0) {
    try {
      const n0 = await this.getWalletAdapterByType(e0).connect();
      if (n0.success && n0.account)
        console.log(
          `Wallet ${e0} connected with address ${n0.account}`
        );
      else if (n0.success && !n0.account)
        return console.error(
          `Wallet ${e0} connected successfully but did not provide an address.`
        ), {
          ...n0,
          success: !1,
          error: "Wallet connected but address not found."
        };
      return n0;
    } catch (n0) {
      return this.handleError(e0, n0, "connecting to");
    }
  }
  getConnectedWalletAdapter(e0) {
    let n0;
    if (typeof e0 == "string") {
      const r0 = m(e0);
      n0 = this.walletAdapters.values().find((i0) => i0.getConnectedAccounts().includes(r0));
    } else
      n0 = this.walletAdapters.get(e0);
    if (!n0)
      throw new Error(
        `Wallet with identifier ${e0} is not connected or supported`
      );
    return n0;
  }
  async signMessage(e0, n0) {
    let r0;
    try {
      if (r0 = this.getConnectedWalletAdapter(e0), !r0.signMessage)
        throw new Error(
          `Wallet type ${r0.type} (identifier: ${e0}) does not support signing messages`
        );
      return await r0.signMessage(n0, e0);
    } catch (i0) {
      return this.handleError(
        e0,
        i0,
        "signing message with",
        r0?.type
      );
    }
  }
  async signTypedData(e0, n0) {
    let r0;
    try {
      if (r0 = this.getConnectedWalletAdapter(e0), !r0.signTypedData)
        throw new Error(
          `Wallet type ${r0.type} (identifier: ${e0}) does not support signing typed data`
        );
      return await r0.signTypedData(n0);
    } catch (i0) {
      return this.handleError(
        e0,
        i0,
        "signing typed data with",
        r0?.type
      );
    }
  }
  async sendTransaction(e0, n0) {
    let r0;
    try {
      return r0 = this.getConnectedWalletAdapter(e0), await r0.sendTransaction(n0);
    } catch (i0) {
      return this.handleError(
        e0,
        i0,
        "sending transaction with",
        r0?.type
      );
    }
  }
  async getBalance(e0, n0) {
    let r0;
    try {
      return r0 = this.getConnectedWalletAdapter(e0), await r0.getBalance(n0);
    } catch (i0) {
      return this.handleError(
        e0,
        i0,
        "getting balance from",
        r0?.type
      );
    }
  }
}
class Ut extends Ge {
  constructor({
    url: n0,
    policies: r0,
    version: i0,
    slot: o0,
    namespace: s0,
    tokens: a0,
    ...c0
  }) {
    const l0 = new URL(n0 ?? f$3), u0 = new Qt();
    r0 && l0.searchParams.set(
      "policies",
      encodeURIComponent(JSON.stringify(r0))
    ), i0 && l0.searchParams.set("v", encodeURIComponent(i0)), o0 && l0.searchParams.set("ps", encodeURIComponent(o0)), s0 && l0.searchParams.set("ns", encodeURIComponent(s0)), a0?.erc20 && l0.searchParams.set(
      "erc20",
      encodeURIComponent(a0.erc20.toString())
    );
    super({
      ...c0,
      id: "controller-keychain",
      url: l0,
      methods: u0.getIFrameMethods()
    });
    xg(this, "walletBridge");
    this.walletBridge = u0, typeof window < "u" && (window.external_wallets = this.walletBridge);
  }
  getWalletBridge() {
    return this.walletBridge;
  }
}
class Ht extends b$5 {
  constructor(n0 = {}) {
    super();
    xg(this, "keychain");
    xg(this, "options");
    xg(this, "iframes");
    xg(this, "selectedChain");
    xg(this, "chains");
    const r0 = [{ rpcUrl: "https://api.cartridge.gg/x/starknet/sepolia" }, { rpcUrl: "https://api.cartridge.gg/x/starknet/mainnet" }, ...n0.chains || []], i0 = n0.defaultChainId || constants.StarknetChainId.SN_MAIN;
    this.selectedChain = i0, this.chains = /* @__PURE__ */ new Map(), this.iframes = {
      keychain: new Ut({
        ...n0,
        onClose: this.keychain?.reset,
        onConnect: (o0) => {
          this.keychain = o0;
        },
        version: T$5
      })
    }, this.options = { ...n0, chains: r0, defaultChainId: i0 }, this.initializeChains(r0), typeof window < "u" && (window.starknet_controller = this);
  }
  isReady() {
    return !!this.keychain;
  }
  async logout() {
    if (!this.keychain) {
      console.error(new j$6().message);
      return;
    }
    try {
      await this.disconnect(), document.querySelectorAll('iframe[id^="controller-"]').forEach((n0) => {
        const r0 = n0.parentElement;
        r0 && (r0.style.opacity = "0", setTimeout(() => {
          r0.style.display = "none";
        }, 200));
      }), document.body && (document.body.style.overflow = "auto"), window.location.reload();
    } catch (n0) {
      throw console.error("Logout failed:", n0), n0;
    }
  }
  async probe() {
    try {
      if (await this.waitForKeychain(), !this.keychain) {
        console.error(new j$6().message);
        return;
      }
      const n0 = await this.keychain.probe(this.rpcUrl());
      let r0 = n0?.rpcUrl || this.rpcUrl();
      this.account = new H(
        this,
        r0,
        n0.address,
        this.keychain,
        this.options,
        this.iframes.keychain
      );
    } catch (n0) {
      console.error(n0);
      return;
    }
    return this.account;
  }
  async connect() {
    if (this.account)
      return this.account;
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new j$6().message);
      return;
    }
    typeof document < "u" && document.hasStorageAccess && (await document.hasStorageAccess() || await document.requestStorageAccess()), this.iframes.keychain.open();
    try {
      let n0 = await this.keychain.connect(
        // Policy precedence logic:
        // 1. If shouldOverridePresetPolicies is true and policies are provided, use policies
        // 2. Otherwise, if preset is defined, use empty object (let preset take precedence)
        // 3. Otherwise, use provided policies or empty object
        this.options.shouldOverridePresetPolicies && this.options.policies ? this.options.policies : this.options.preset ? {} : this.options.policies || {},
        this.rpcUrl(),
        this.options.signupOptions
      );
      if (n0.code !== w$3.SUCCESS)
        throw new Error(n0.message);
      return n0 = n0, this.account = new H(
        this,
        this.rpcUrl(),
        n0.address,
        this.keychain,
        this.options,
        this.iframes.keychain
      ), this.account;
    } catch (n0) {
      console.log(n0);
    } finally {
      this.iframes.keychain.close();
    }
  }
  async switchStarknetChain(n0) {
    if (!this.keychain || !this.iframes.keychain)
      return console.error(new j$6().message), !1;
    try {
      if (this.selectedChain = n0, (await this.keychain.probe(this.rpcUrl())).rpcUrl === this.rpcUrl())
        return !0;
      await this.keychain.switchChain(this.rpcUrl());
    } catch (r0) {
      return console.error(r0), !1;
    }
    return this.emitNetworkChanged(n0), !0;
  }
  addStarknetChain(n0) {
    return Promise.resolve(!0);
  }
  async disconnect() {
    if (!this.keychain) {
      console.error(new j$6().message);
      return;
    }
    return typeof document < "u" && document.hasStorageAccess && (await document.hasStorageAccess() || await document.requestStorageAccess()), this.account = void 0, this.keychain.disconnect();
  }
  async openProfile(n0 = "inventory") {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new j$6().message);
      return;
    }
    if (!this.account) {
      console.error("Account is not ready");
      return;
    }
    const r0 = await this.keychain.username();
    await this.keychain.navigate(`/account/${r0}/${n0}`), this.iframes.keychain.open();
  }
  async openProfileTo(n0) {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new j$6().message);
      return;
    }
    if (!this.account) {
      console.error("Account is not ready");
      return;
    }
    const r0 = await this.keychain.username();
    await this.keychain.navigate(`/account/${r0}/${n0}`), this.iframes.keychain.open();
  }
  async openProfileAt(n0) {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new j$6().message);
      return;
    }
    if (!this.account) {
      console.error("Account is not ready");
      return;
    }
    await this.keychain.navigate(n0), this.iframes.keychain.open();
  }
  openSettings() {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new j$6().message);
      return;
    }
    this.iframes.keychain.open(), this.keychain.openSettings();
  }
  revoke(n0, r0) {
    return this.keychain ? this.keychain.revoke(n0) : (console.error(new j$6().message), null);
  }
  rpcUrl() {
    const n0 = this.chains.get(this.selectedChain);
    if (!n0) {
      const r0 = Array.from(this.chains.keys()).map(
        (i0) => shortString.decodeShortString(i0)
      );
      throw new Error(
        `Chain not found: ${shortString.decodeShortString(this.selectedChain)}. Available chains: ${r0.join(", ")}`
      );
    }
    return n0.rpcUrl;
  }
  username() {
    if (!this.keychain) {
      console.error(new j$6().message);
      return;
    }
    return this.keychain.username();
  }
  openPurchaseCredits() {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new j$6().message);
      return;
    }
    this.iframes.keychain.open(), this.keychain.openPurchaseCredits();
  }
  openStarterPack(n0) {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new j$6().message);
      return;
    }
    this.keychain.navigate(`/starter-pack/${n0}`).then(() => {
      this.iframes.keychain.open();
    });
  }
  async openExecute(n0, r0) {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new j$6().message);
      return;
    }
    let i0 = this.selectedChain;
    r0 && this.switchStarknetChain(r0), this.iframes.keychain.open();
    const o0 = await this.keychain.execute(n0, void 0, void 0, !0);
    return this.iframes.keychain.close(), r0 && this.switchStarknetChain(i0), {
      status: !(o0 && (o0.code === w$3.NOT_CONNECTED || o0.code === w$3.CANCELED)),
      transactionHash: o0?.transaction_hash
    };
  }
  async delegateAccount() {
    return this.keychain ? await this.keychain.delegateAccount() : (console.error(new j$6().message), null);
  }
  initializeChains(n0) {
    for (const r0 of n0)
      try {
        const i0 = new URL(r0.rpcUrl), o0 = k$3(i0), s0 = o0 === constants.StarknetChainId.SN_MAIN, a0 = o0 === constants.StarknetChainId.SN_SEPOLIA, c0 = i0.hostname === "api.cartridge.gg", l0 = i0.hostname === "localhost" || i0.hostname === "127.0.0.1";
        if ((s0 || a0) && !(c0 || l0))
          throw new Error(
            `Only Cartridge RPC providers are allowed for ${s0 ? "mainnet" : "sepolia"}. Please use: https://api.cartridge.gg/x/starknet/${s0 ? "mainnet" : "sepolia"}`
          );
        this.chains.set(o0, r0);
      } catch (i0) {
        throw console.error(`Failed to parse chainId for ${r0.rpcUrl}:`, i0), i0;
      }
    this.chains.has(this.selectedChain) || console.warn(
      `Selected chain ${this.selectedChain} not found in configured chains. Available chains: ${Array.from(this.chains.keys()).join(", ")}`
    );
  }
  waitForKeychain({
    timeout: n0 = 5e4,
    interval: r0 = 100
  } = {}) {
    return new Promise((i0, o0) => {
      const s0 = Date.now(), a0 = setInterval(() => {
        if (Date.now() - s0 > n0) {
          clearInterval(a0), o0(new Error("Timeout waiting for keychain"));
          return;
        }
        this.keychain && (clearInterval(a0), i0());
      }, r0);
    });
  }
}
const CONTROLLER_ICON = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjgwMCIgdmlld0JveD0iMCAwIDgwMCA4MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2RfNTExMl83ODIpIj4KPHBhdGggZD0iTTQ2OS4yMzYgNzBDNDgyLjM5IDcwIDQ5My4wNTMgODAuNjYzIDQ5My4wNTMgOTMuODE2NFYxNDcuMTQ3TDUxNS4zMzggMTQ3LjE0N0w1MTUuNDI4IDE0Ny4xNDdMNTE1LjU1NCAxNDcuMTQ3TDUxNS44MjYgMTQ3LjE0OUM1MTYuMDE2IDE0Ny4xNTEgNTE2LjIyNSAxNDcuMTUzIDUxNi40NTEgMTQ3LjE1N0M1MTYuOTA0IDE0Ny4xNjQgNTE3LjQyOCAxNDcuMTc2IDUxOC4wMiAxNDcuMTk1QzUxOS4yMDEgMTQ3LjIzNCA1MjAuNjYgMTQ3LjMwNCA1MjIuMzYxIDE0Ny40MjRDNTI1Ljc0MSAxNDcuNjYzIDUzMC4xODUgMTQ4LjExNCA1MzUuMzYzIDE0OC45NjlDNTQ1LjAwMSAxNTAuNTYyIDU1OC41NTYgMTUzLjc4IDU3Mi45MTggMTYwLjYwM0w3MzAuNDIgMjI2LjY3MUw3MzIuMTAxIDIyNy41MDVDNzcxLjc4NyAyNDcuMTc3IDc4OS45OTMgMjg2LjI5NiA3ODkuOTkzIDMyMi4wMzZWNTg1Ljg2NUM3ODkuOTkzIDU4Ni4wNTQgNzg5Ljk5NCA1ODYuMjU0IDc4OS45OTQgNTg2LjQ2M0w3ODkuOTk2IDU4Ni45MTNDNzkwLjAzOCA1OTcuMDk2IDc5MC4xNjEgNjI2Ljk5NiA3NjQuMjMxIDY1Mi44MjNMNzE0Ljc2IDcwMi4wOTVMNzE0LjY0MSA3MDIuMjE1QzcwNC42MDEgNzEyLjI3NSA2OTIuMTIzIDcyMC42NTIgNjc2LjI4NCA3MjQuODc5QzY2NC4zOSA3MjguMDU0IDY1Mi44MjcgNzI3Ljk2NiA2NDguNjM3IDcyNy45MzRMNjQ4LjYxOSA3MjcuOTMzQzY0OC40MDkgNzI3LjkzMiA2NDguMjE5IDcyNy45MyA2NDguMDQ3IDcyNy45M0w2NDcuNzUyIDcyNy45MjlINDgwLjcyMUM0NzQuMDk0IDcyNy45MjkgNDY4LjcyMSA3MjIuNTU2IDQ2OC43MjEgNzE1LjkyOVY2NjguMzg4SDMyOC41ODZDMzI4LjU4NiA2NzIuNjI5IDMyOC41NzIgNjk4LjA1MiAzMjguNTYxIDcxNS45NDRDMzI4LjU1NyA3MjIuNTY5IDMyMy4xODYgNzI3LjkyOSAzMTYuNTYxIDcyNy45MjlIMTUyLjI0NkMxNTIuMTA0IDcyNy45MjkgMTUxLjk0MiA3MjcuOTI5IDE1MS43NjIgNzI3LjkzMUwxNTEuMzYyIDcyNy45MzRDMTQ3LjE3MiA3MjcuOTY2IDEzNS42MDkgNzI4LjA1NCAxMjMuNzE0IDcyNC44NzlDMTA3Ljg3MyA3MjAuNjUxIDk1LjM5MzggNzEyLjI3MiA4NS4zNTI5IDcwMi4yMUw4NS4yMzg2IDcwMi4wOTVMMzUuNjcgNjUyLjcyNUwzNS41NzIzIDY1Mi42MjdDOS44NjI0MiA2MjYuNzggOS45NjY3IDU5Ny4xODUgMTAuMDAzIDU4Ni44NzRDMTAuMDA0MyA1ODYuNTEzIDEwLjAwNTUgNTg2LjE3NyAxMC4wMDU1IDU4NS44NjVWMzIyLjAzNkMxMC4wMDU1IDI4Ni40MyAyOC4xNjYyIDI0Ny4xOTkgNjcuODk3NyAyMjcuNTA1TDY5LjU3OSAyMjYuNjcxTDIyNy4wODEgMTYwLjYwM0MyNDEuNDQzIDE1My43OCAyNTQuOTk4IDE1MC41NjIgMjY0LjYzNiAxNDguOTY5QzI2OS44MTQgMTQ4LjExNCAyNzQuMjU4IDE0Ny42NjMgMjc3LjYzOCAxNDcuNDI0QzI3OS4zMzggMTQ3LjMwNCAyODAuNzk4IDE0Ny4yMzQgMjgxLjk3OSAxNDcuMTk1QzI4Mi41NzEgMTQ3LjE3NiAyODMuMDk1IDE0Ny4xNjQgMjgzLjU0NyAxNDcuMTU3TDI4My45MTcgMTQ3LjE1MkwyODQuMTczIDE0Ny4xNDlMMjg0LjQ0NSAxNDcuMTQ3TDI4NC41NzEgMTQ3LjE0N0wyODQuNjYgMTQ3LjE0N0wzMDYuOTQyIDE0Ny4xNDdWOTMuODE2NEMzMDYuOTQyIDgwLjY2MyAzMTcuNjA1IDcwIDMzMC43NTggNzBINDY5LjIzNloiIGZpbGw9IiMxOTFBMUEiLz4KPHBhdGggZD0iTTM2Ni40ODMgMTI5LjU0SDQzMy41MTJWMjA2LjY4N0gzNjYuNDgzVjEyOS41NFoiIGZpbGw9IiNGQkNCNEEiLz4KPHBhdGggZD0iTTI2OS4wMSA2MDIuNDI5SDE0NC4wMDhDMTM1Ljc2OCA2MDIuNDI5IDEzNS43NjggNTk0LjE0NiAxMzUuNzY4IDU5NC4xNDZWMjgwLjg1QzEzNS43NjggMjgwLjg1IDEzNS43NjggMjcyLjY0NCAxNDQuMDA4IDI3Mi42NDRIMzY2LjQ4M0wzNjYuNDgzIDIwNi42ODdIMjg0LjY5QzI4NC42OSAyMDYuNjg3IDI2OC4xMzQgMjA2LjY4NyAyNTEuNTc5IDIxNC44OTNMOTQuMzQxNCAyODAuODVDNzcuNzg2MSAyODkuMDU3IDY5LjU0NjkgMzA1LjYyMyA2OS41NDY5IDMyMi4wMzVWNTg1Ljg2M0M2OS41NDY5IDU5NC4xNDcgNjkuNTQ2OSA2MDIuMzUzIDc3Ljc4NjEgNjEwLjYzNkwxMjcuNDUyIDY2MC4xMDRDMTM1LjY5MSA2NjguMzg3IDE0MS45MjggNjY4LjM4NyAxNTIuMjQ3IDY2OC4zODdIMjY5LjAyOUMyNjkuMDM3IDY0OC4zNCAyNjkuMDQ2IDYyNC42NTUgMjY5LjA1NCA2MDIuODg3SDUyOC4wMTNWNjY4LjM4N0g2NDcuNzUzQzY1OC4wNzEgNjY4LjM4NyA2NjQuMzA4IDY2OC4zODcgNjcyLjU0NyA2NjAuMTA0TDcyMi4yMTMgNjEwLjYzNkM3MzAuNDUzIDYwMi40MjkgNzMwLjQ1MyA1OTQuMTQ3IDczMC40NTMgNTg1Ljg2M1YzMjIuMDM1QzczMC40NTMgMzA1LjU0NiA3MjIuMjEzIDI4OS4wNTcgNzA1LjY1OCAyODAuODVMNTQ4LjQyMSAyMTQuODkzQzUzMS44NjUgMjA2LjY4NyA1MTUuMzEgMjA2LjY4NyA1MTUuMzEgMjA2LjY4N0g0MzMuNTEyTDQzMy41MTIgMjcyLjY0NEg2NTYuMDY5QzY2NC4zMDggMjcyLjY0NCA2NjQuMzA4IDI4MC44NSA2NjQuMzA4IDI4MC44NVY1OTQuMTQ2QzY2NC4zMDggNTk0LjE0NiA2NjQuMzA4IDYwMi40MjkgNjU2LjA2OSA2MDIuNDI5SDUyOC4yNjJWNTM3LjM5NkgyNjkuMDc1QzI2OS4wNzUgNTQzLjcwNyAyNjkuMDE3IDU5Ni45MTIgMjY5LjAxIDYwMi40MjlaIiBmaWxsPSIjRkJDQjRBIi8+CjxwYXRoIGQ9Ik0yNjkuMDA5IDQzNi4xNzJINTI4LjI2MlYzNzAuNjgxSDI2OS4wNzVDMjY5LjA3NSAzNzcuMzczIDI2OS4wMDkgNDM2Ljc4OCAyNjkuMDA5IDQzNi4xNzJaIiBmaWxsPSIjRkJDQjRBIi8+CjwvZz4KPGRlZnM+CjxmaWx0ZXIgaWQ9ImZpbHRlcjBfZF81MTEyXzc4MiIgeD0iLTQiIHk9IjAiIHdpZHRoPSI4MDgiIGhlaWdodD0iODA4IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+CjxmZUNvbG9yTWF0cml4IGluPSJTb3VyY2VBbHBoYSIgdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEyNyAwIiByZXN1bHQ9ImhhcmRBbHBoYSIvPgo8ZmVPZmZzZXQgZHk9IjQiLz4KPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iMiIvPgo8ZmVDb21wb3NpdGUgaW4yPSJoYXJkQWxwaGEiIG9wZXJhdG9yPSJvdXQiLz4KPGZlQ29sb3JNYXRyaXggdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMjUgMCIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9ImVmZmVjdDFfZHJvcFNoYWRvd181MTEyXzc4MiIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9ImVmZmVjdDFfZHJvcFNoYWRvd181MTEyXzc4MiIgcmVzdWx0PSJzaGFwZSIvPgo8L2ZpbHRlcj4KPC9kZWZzPgo8L3N2Zz4K";
class ControllerConnector extends Connector {
  constructor(n0 = {}) {
    super();
    xg(this, "controller");
    this.controller = this.available() ? new Ht(n0) : null;
  }
  get id() {
    return "controller";
  }
  get name() {
    return "Cartridge Controller";
  }
  get icon() {
    return { light: CONTROLLER_ICON, dark: CONTROLLER_ICON };
  }
  available() {
    return typeof window < "u";
  }
  async ready() {
    return !!this.controller && this.controller.isReady();
  }
  async connect(n0) {
    if (!this.controller)
      throw new ConnectorNotConnectedError();
    const r0 = await this.controller.connect();
    if (!r0)
      throw new UserNotConnectedError();
    const i0 = await this.chainId();
    return this.emit("connect", { account: r0.address, chainId: i0 }), {
      account: r0.address,
      chainId: i0
    };
  }
  async disconnect() {
    if (!this.controller)
      throw new ConnectorNotConnectedError();
    return this.emit("disconnect"), this.controller.disconnect();
  }
  async account(n0) {
    if (!this.controller)
      throw new ConnectorNotConnectedError();
    const r0 = await this.controller.probe();
    if (!r0)
      throw new UserNotConnectedError();
    return r0;
  }
  async chainId() {
    if (!this.controller)
      throw new ConnectorNotConnectedError();
    const n0 = await this.controller.probe();
    if (!n0)
      throw new UserNotConnectedError();
    return BigInt(await n0.getChainId());
  }
  async request(n0) {
    if (!this.controller)
      throw new ConnectorNotConnectedError();
    if (n0.type === "wallet_signTypedData" && !n0.params.types.StarknetDomain)
      throw new Error(
        "Controller requires a SNIP-12 version 1 domain separator. See: https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md#domain-separator"
      );
    try {
      return await this.controller.request(n0);
    } catch {
      throw new UserRejectedRequestError();
    }
  }
  get wallet() {
    if (!this.controller)
      throw new ConnectorNotConnectedError();
    return this.controller;
  }
}
export {
  ControllerConnector as C,
  F$1 as F,
  I1 as I,
  L$5 as L,
  Q$2 as Q,
  R1 as R,
  T$1 as T,
  q$3 as a,
  bl$1 as b,
  q$5 as q,
  wl$1 as w
};
