import { bytes as r } from "./_assert.js";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const i = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), y = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, s = (e) => e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
function p(e) {
  for (let t = 0; t < e.length; t++)
    e[t] = s(e[t]);
}
const a = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function l(e) {
  r(e);
  let t = "";
  for (let n = 0; n < e.length; n++)
    t += a[e[n]];
  return t;
}
function f(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function u(e) {
  return typeof e == "string" && (e = f(e)), r(e), e;
}
class b {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function g(e) {
  const t = (o) => e().update(u(o)).digest(), n = e();
  return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t;
}
export {
  b as Hash,
  s as byteSwap,
  p as byteSwap32,
  l as bytesToHex,
  y as isLE,
  u as toBytes,
  i as u32,
  f as utf8ToBytes,
  g as wrapConstructor
};
