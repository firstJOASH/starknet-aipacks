"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});require("lodash-es");const m=require("starknet"),C=require("./adjustment.cjs"),f=require("./argentMaxFee.cjs"),P=require("../../chains/starknet/address.cjs"),F=a=>{const{type:r,deployment:e,transactions:s}=a;if(r==="paymaster")return s.maxFee+((e==null?void 0:e.maxFee)??0n);if(e&&!P.isEqualAddress(e.feeTokenAddress,s.feeTokenAddress))throw Error("Cannot calculate estimated fees for different tokens");const n=!s.overallFee&&!(e!=null&&e.overallFee),t=i=>n?l(i):d(i),u=e?t(e):0n,c=t(s);return u+c},d=a=>{const{l1Gas:r,l2Gas:e,l1DataGas:s}=a;return r.gasConsumed*r.gasPrice+e.gasConsumed*e.gasPrice+s.gasConsumed*s.gasPrice},l=a=>d(G(a)),G=(a,r=C.calculateCubeRootAdjustment)=>{const e=10000n,{l1Gas:s,l2Gas:n,l1DataGas:t}=a,u=s.gasConsumed*s.gasPrice+n.gasConsumed*n.gasPrice+t.gasConsumed*t.gasPrice;if(u<0)throw Error("Cannot calculate max fee for negative fee");const c=m.num.toBigInt(f.argentMaxFee({estimatedFee:u})),i=Number(c)/Number(u),g=r(i),o=BigInt(Math.trunc(g*Number(e)));return{...a,l1Gas:{gasConsumed:s.gasConsumed*o/e,gasPrice:s.gasPrice*o/e},l2Gas:{gasConsumed:n.gasConsumed*o/e,gasPrice:n.gasPrice*o/e},l1DataGas:{gasConsumed:t.gasConsumed*o/e,gasPrice:t.gasPrice*o/e}}};exports.estimatedFeeToMaxFeeTotal=l;exports.estimatedFeeToTotal=d;exports.estimatedFeesToMaxFeeTotalV2=F;
