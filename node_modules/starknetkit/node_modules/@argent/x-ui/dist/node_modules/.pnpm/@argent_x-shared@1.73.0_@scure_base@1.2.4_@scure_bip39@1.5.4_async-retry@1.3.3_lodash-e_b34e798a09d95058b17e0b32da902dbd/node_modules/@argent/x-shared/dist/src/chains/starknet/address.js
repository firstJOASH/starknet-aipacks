import { memoize as i } from "lodash-es";
import { getChecksumAddress as u, validateChecksumAddress as f, validateAndParseAddress as h } from "starknet";
import { z as t } from "zod";
import { decodeBase58 as A } from "../../utils/base58.js";
const g = t.string().refine((s) => {
  if (s.toLowerCase() === s)
    return !0;
  try {
    return f(s) && v(s);
  } catch {
  }
  return !1;
}, { message: "Invalid address (checksum error)" });
t.string().refine((s) => {
  try {
    return h(s);
  } catch {
  }
  return !1;
}, { message: "Invalid address (validation error)" });
const n = t.string().regex(/^0x[0-9a-fA-F]+$/, "Invalid address"), $ = n.min(50, "Address must at least be 50 characters long").max(66, "Address must at most be 66 characters long");
n.length(66, "Address must be 66 characters long");
const l = $.pipe(g).transform((s) => `0x${(s.startsWith("0x") ? s.slice(2) : s).padStart(64, "0")}`);
l.or(t.literal("")).transform((s) => s === "" ? void 0 : s).optional();
n.transform((s) => `0x${s.replace(/^0x/, "").toLowerCase().padStart(64, "0")}`);
const p = (s) => l.safeParse(s).success, x = p, m = (s) => u(s), L = (s) => {
  if (!s)
    return !1;
  try {
    const r = A(s);
    return x(r);
  } catch {
    return !1;
  }
}, k = (s) => {
  const r = m(s), e = r.slice(0, 2), a = r.slice(2, 6), d = r.slice(-4);
  return `${e}${a}…${d}`;
}, B = (s) => {
  const r = m(s), e = r.slice(0, 2), a = r.slice(2).match(/.{1,4}/g) || [];
  return `${e} ${a.join(" ")}`;
}, v = (s) => !/^0x[0-9a-f]{63,64}$/.test(s), c = (s) => s.toLowerCase().replace(/^[0x]+/, ""), o = (s) => {
  try {
    return /^(0x)?[0-9a-f]+$/i.test(s);
  } catch {
  }
  return !1;
}, b = (s, r) => {
  try {
    return !s || !r || !o(s) || !o(r) ? !1 : c(s) === c(r);
  } catch {
  }
  return !1;
}, w = i((s) => {
  const r = s.slice(0, 6), e = s.slice(-4);
  return `${r}…${e}`;
});
i((s, r) => {
  if (s.length < r)
    return s;
  const e = Math.floor((r - 1) / 2), a = s.slice(0, e), d = s.slice(-e);
  return `${a}…${d}`;
});
export {
  l as addressSchema,
  n as addressSchemaBase,
  $ as addressSchemaLooseLength,
  B as formatFullAddress,
  k as formatTruncatedAddress,
  w as formatTruncatedSignerKey,
  p as isAddress,
  L as isBase58Address,
  b as isEqualAddress,
  x as isValidAddress,
  o as isValidHexString,
  m as normalizeAddress,
  c as normalizeAddressForCompare,
  g as validChecksumAddressSchema
};
