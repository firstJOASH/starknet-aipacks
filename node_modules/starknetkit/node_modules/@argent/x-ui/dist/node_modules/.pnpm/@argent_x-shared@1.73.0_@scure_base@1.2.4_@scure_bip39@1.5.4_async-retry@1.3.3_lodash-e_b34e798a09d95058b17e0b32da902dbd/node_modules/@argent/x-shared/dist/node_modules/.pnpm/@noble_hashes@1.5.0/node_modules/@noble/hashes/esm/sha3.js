import { number as d, exists as k, bytes as m, output as A } from "./_assert.js";
import { rotlSH as F, rotlSL as X, rotlBH as $, rotlBL as E, split as S } from "./_u64.js";
import { wrapConstructor as U, Hash as H, u32 as M, isLE as w, byteSwap32 as b, toBytes as C } from "./utils.js";
const I = [], L = [], O = [], _ = /* @__PURE__ */ BigInt(0), u = /* @__PURE__ */ BigInt(1), j = /* @__PURE__ */ BigInt(2), q = /* @__PURE__ */ BigInt(7), v = /* @__PURE__ */ BigInt(256), z = /* @__PURE__ */ BigInt(113);
for (let o = 0, t = u, s = 1, e = 0; o < 24; o++) {
  [s, e] = [e, (2 * s + 3 * e) % 5], I.push(2 * (5 * e + s)), L.push((o + 1) * (o + 2) / 2 % 64);
  let n = _;
  for (let r = 0; r < 7; r++)
    t = (t << u ^ (t >> q) * z) % v, t & j && (n ^= u << (u << /* @__PURE__ */ BigInt(r)) - u);
  O.push(n);
}
const [D, G] = /* @__PURE__ */ S(O, !0), y = (o, t, s) => s > 32 ? $(o, t, s) : F(o, t, s), g = (o, t, s) => s > 32 ? E(o, t, s) : X(o, t, s);
function K(o, t = 24) {
  const s = new Uint32Array(10);
  for (let e = 24 - t; e < 24; e++) {
    for (let i = 0; i < 10; i++)
      s[i] = o[i] ^ o[i + 10] ^ o[i + 20] ^ o[i + 30] ^ o[i + 40];
    for (let i = 0; i < 10; i += 2) {
      const h = (i + 8) % 10, f = (i + 2) % 10, l = s[f], a = s[f + 1], x = y(l, a, 1) ^ s[h], B = g(l, a, 1) ^ s[h + 1];
      for (let c = 0; c < 50; c += 10)
        o[i + c] ^= x, o[i + c + 1] ^= B;
    }
    let n = o[2], r = o[3];
    for (let i = 0; i < 24; i++) {
      const h = L[i], f = y(n, r, h), l = g(n, r, h), a = I[i];
      n = o[a], r = o[a + 1], o[a] = f, o[a + 1] = l;
    }
    for (let i = 0; i < 50; i += 10) {
      for (let h = 0; h < 10; h++)
        s[h] = o[i + h];
      for (let h = 0; h < 10; h++)
        o[i + h] ^= ~s[(h + 2) % 10] & s[(h + 4) % 10];
    }
    o[0] ^= D[e], o[1] ^= G[e];
  }
  s.fill(0);
}
class p extends H {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, s, e, n = !1, r = 24) {
    if (super(), this.blockLen = t, this.suffix = s, this.outputLen = e, this.enableXOF = n, this.rounds = r, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, d(e), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = M(this.state);
  }
  keccak() {
    w || b(this.state32), K(this.state32, this.rounds), w || b(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    k(this);
    const { blockLen: s, state: e } = this;
    t = C(t);
    const n = t.length;
    for (let r = 0; r < n; ) {
      const i = Math.min(s - this.pos, n - r);
      for (let h = 0; h < i; h++)
        e[this.pos++] ^= t[r++];
      this.pos === s && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: s, pos: e, blockLen: n } = this;
    t[e] ^= s, s & 128 && e === n - 1 && this.keccak(), t[n - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    k(this, !1), m(t), this.finish();
    const s = this.state, { blockLen: e } = this;
    for (let n = 0, r = t.length; n < r; ) {
      this.posOut >= e && this.keccak();
      const i = Math.min(e - this.posOut, r - n);
      t.set(s.subarray(this.posOut, this.posOut + i), n), this.posOut += i, n += i;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return d(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (A(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: s, suffix: e, outputLen: n, rounds: r, enableXOF: i } = this;
    return t || (t = new p(s, e, n, i, r)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = r, t.suffix = e, t.outputLen = n, t.enableXOF = i, t.destroyed = this.destroyed, t;
  }
}
const P = (o, t, s) => U(() => new p(t, o, s)), N = /* @__PURE__ */ P(1, 136, 256 / 8);
export {
  p as Keccak,
  K as keccakP,
  N as keccak_256
};
