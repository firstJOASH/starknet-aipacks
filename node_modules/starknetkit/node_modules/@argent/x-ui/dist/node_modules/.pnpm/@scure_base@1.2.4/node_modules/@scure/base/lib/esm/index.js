/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function $(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function A(r, e) {
  return Array.isArray(e) ? e.length === 0 ? !0 : r ? e.every((n) => typeof n == "string") : e.every((n) => Number.isSafeInteger(n)) : !1;
}
function S(r) {
  if (typeof r != "function")
    throw new Error("function expected");
  return !0;
}
function g(r, e) {
  if (typeof e != "string")
    throw new Error(`${r}: string expected`);
  return !0;
}
function p(r) {
  if (!Number.isSafeInteger(r))
    throw new Error(`invalid integer: ${r}`);
}
function h(r) {
  if (!Array.isArray(r))
    throw new Error("array expected");
}
function b(r, e) {
  if (!A(!0, e))
    throw new Error(`${r}: array of strings expected`);
}
function R(r, e) {
  if (!A(!1, e))
    throw new Error(`${r}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function m(...r) {
  const e = (o) => o, n = (o, d) => (i) => o(d(i)), c = r.map((o) => o.encode).reduceRight(n, e), t = r.map((o) => o.decode).reduce(n, e);
  return { encode: c, decode: t };
}
// @__NO_SIDE_EFFECTS__
function U(r) {
  const e = typeof r == "string" ? r.split("") : r, n = e.length;
  b("alphabet", e);
  const c = new Map(e.map((t, o) => [t, o]));
  return {
    encode: (t) => (h(t), t.map((o) => {
      if (!Number.isSafeInteger(o) || o < 0 || o >= n)
        throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${r}`);
      return e[o];
    })),
    decode: (t) => (h(t), t.map((o) => {
      g("alphabet.decode", o);
      const d = c.get(o);
      if (d === void 0)
        throw new Error(`Unknown letter: "${o}". Allowed: ${r}`);
      return d;
    }))
  };
}
// @__NO_SIDE_EFFECTS__
function N(r = "") {
  return g("join", r), {
    encode: (e) => (b("join.decode", e), e.join(r)),
    decode: (e) => (g("join.decode", e), e.split(r))
  };
}
// @__NO_SIDE_EFFECTS__
function I(r) {
  return S(r), { encode: (e) => e, decode: (e) => r(e) };
}
function E(r, e, n) {
  if (e < 2)
    throw new Error(`convertRadix: invalid from=${e}, base cannot be less than 2`);
  if (n < 2)
    throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);
  if (h(r), !r.length)
    return [];
  let c = 0;
  const t = [], o = Array.from(r, (i) => {
    if (p(i), i < 0 || i >= e)
      throw new Error(`invalid integer: ${i}`);
    return i;
  }), d = o.length;
  for (; ; ) {
    let i = 0, f = !0;
    for (let a = c; a < d; a++) {
      const u = o[a], y = e * i, s = y + u;
      if (!Number.isSafeInteger(s) || y / e !== i || s - u !== y)
        throw new Error("convertRadix: carry overflow");
      const B = s / n;
      i = s % n;
      const w = Math.floor(B);
      if (o[a] = w, !Number.isSafeInteger(w) || w * n + i !== s)
        throw new Error("convertRadix: carry overflow");
      if (f)
        w ? f = !1 : c = a;
      else continue;
    }
    if (t.push(i), f)
      break;
  }
  for (let i = 0; i < r.length - 1 && r[i] === 0; i++)
    t.push(0);
  return t.reverse();
}
const j = (r, e) => e === 0 ? r : j(e, r % e), l = /* @__NO_SIDE_EFFECTS__ */ (r, e) => r + (e - j(r, e)), x = /* @__PURE__ */ (() => {
  let r = [];
  for (let e = 0; e < 40; e++)
    r.push(2 ** e);
  return r;
})();
function v(r, e, n, c) {
  if (h(r), e <= 0 || e > 32)
    throw new Error(`convertRadix2: wrong from=${e}`);
  if (n <= 0 || n > 32)
    throw new Error(`convertRadix2: wrong to=${n}`);
  if (/* @__PURE__ */ l(e, n) > 32)
    throw new Error(`convertRadix2: carry overflow from=${e} to=${n} carryBits=${/* @__PURE__ */ l(e, n)}`);
  let t = 0, o = 0;
  const d = x[e], i = x[n] - 1, f = [];
  for (const a of r) {
    if (p(a), a >= d)
      throw new Error(`convertRadix2: invalid data word=${a} from=${e}`);
    if (t = t << e | a, o + e > 32)
      throw new Error(`convertRadix2: carry overflow pos=${o} from=${e}`);
    for (o += e; o >= n; o -= n)
      f.push((t >> o - n & i) >>> 0);
    const u = x[o];
    if (u === void 0)
      throw new Error("invalid carry");
    t &= u - 1;
  }
  if (t = t << n - o & i, !c && o >= e)
    throw new Error("Excess padding");
  if (!c && t > 0)
    throw new Error(`Non-zero padding: ${t}`);
  return c && o > 0 && f.push(t >>> 0), f;
}
// @__NO_SIDE_EFFECTS__
function k(r) {
  p(r);
  const e = 2 ** 8;
  return {
    encode: (n) => {
      if (!$(n))
        throw new Error("radix.encode input should be Uint8Array");
      return E(Array.from(n), e, r);
    },
    decode: (n) => (R("radix.decode", n), Uint8Array.from(E(n, r, e)))
  };
}
// @__NO_SIDE_EFFECTS__
function z(r, e = !1) {
  if (p(r), r <= 0 || r > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ l(8, r) > 32 || /* @__PURE__ */ l(r, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (n) => {
      if (!$(n))
        throw new Error("radix2.encode input should be Uint8Array");
      return v(Array.from(n), 8, r, !e);
    },
    decode: (n) => (R("radix2.decode", n), Uint8Array.from(v(n, r, 8, e)))
  };
}
const C = /* @__NO_SIDE_EFFECTS__ */ (r) => /* @__PURE__ */ m(/* @__PURE__ */ k(58), /* @__PURE__ */ U(r), /* @__PURE__ */ N("")), M = /* @__PURE__ */ C("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), L = /* @__PURE__ */ m(/* @__PURE__ */ z(4), /* @__PURE__ */ U("0123456789abcdef"), /* @__PURE__ */ N(""), /* @__PURE__ */ I((r) => {
  if (typeof r != "string" || r.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof r} with length ${r.length}`);
  return r.toLowerCase();
}));
export {
  M as base58,
  L as hex
};
