"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const l=require("./_assert.cjs"),f=require("./_u64.cjs"),u=require("./utils.cjs"),g=[],L=[],O=[],S=BigInt(0),a=BigInt(1),m=BigInt(2),E=BigInt(7),F=BigInt(256),X=BigInt(113);for(let e=0,t=a,s=1,o=0;e<24;e++){[s,o]=[o,(2*s+3*o)%5],g.push(2*(5*o+s)),L.push((e+1)*(e+2)/2%64);let n=S;for(let r=0;r<7;r++)t=(t<<a^(t>>E)*X)%F,t&m&&(n^=a<<(a<<BigInt(r))-a);O.push(n)}const[q,A]=f.split(O,!0),w=(e,t,s)=>s>32?f.rotlBH(e,t,s):f.rotlSH(e,t,s),y=(e,t,s)=>s>32?f.rotlBL(e,t,s):f.rotlSL(e,t,s);function I(e,t=24){const s=new Uint32Array(10);for(let o=24-t;o<24;o++){for(let i=0;i<10;i++)s[i]=e[i]^e[i+10]^e[i+20]^e[i+30]^e[i+40];for(let i=0;i<10;i+=2){const h=(i+8)%10,p=(i+2)%10,d=s[p],c=s[p+1],x=w(d,c,1)^s[h],B=y(d,c,1)^s[h+1];for(let k=0;k<50;k+=10)e[i+k]^=x,e[i+k+1]^=B}let n=e[2],r=e[3];for(let i=0;i<24;i++){const h=L[i],p=w(n,r,h),d=y(n,r,h),c=g[i];n=e[c],r=e[c+1],e[c]=p,e[c+1]=d}for(let i=0;i<50;i+=10){for(let h=0;h<10;h++)s[h]=e[i+h];for(let h=0;h<10;h++)e[i+h]^=~s[(h+2)%10]&s[(h+4)%10]}e[0]^=q[o],e[1]^=A[o]}s.fill(0)}class b extends u.Hash{constructor(t,s,o,n=!1,r=24){if(super(),this.blockLen=t,this.suffix=s,this.outputLen=o,this.enableXOF=n,this.rounds=r,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,l.number(o),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=u.u32(this.state)}keccak(){u.isLE||u.byteSwap32(this.state32),I(this.state32,this.rounds),u.isLE||u.byteSwap32(this.state32),this.posOut=0,this.pos=0}update(t){l.exists(this);const{blockLen:s,state:o}=this;t=u.toBytes(t);const n=t.length;for(let r=0;r<n;){const i=Math.min(s-this.pos,n-r);for(let h=0;h<i;h++)o[this.pos++]^=t[r++];this.pos===s&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:s,pos:o,blockLen:n}=this;t[o]^=s,s&128&&o===n-1&&this.keccak(),t[n-1]^=128,this.keccak()}writeInto(t){l.exists(this,!1),l.bytes(t),this.finish();const s=this.state,{blockLen:o}=this;for(let n=0,r=t.length;n<r;){this.posOut>=o&&this.keccak();const i=Math.min(o-this.posOut,r-n);t.set(s.subarray(this.posOut,this.posOut+i),n),this.posOut+=i,n+=i}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return l.number(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(l.output(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:s,suffix:o,outputLen:n,rounds:r,enableXOF:i}=this;return t||(t=new b(s,o,n,i,r)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=r,t.suffix=o,t.outputLen=n,t.enableXOF=i,t.destroyed=this.destroyed,t}}const M=(e,t,s)=>u.wrapConstructor(()=>new b(t,e,s)),U=M(1,136,256/8);exports.Keccak=b;exports.keccakP=I;exports.keccak_256=U;
