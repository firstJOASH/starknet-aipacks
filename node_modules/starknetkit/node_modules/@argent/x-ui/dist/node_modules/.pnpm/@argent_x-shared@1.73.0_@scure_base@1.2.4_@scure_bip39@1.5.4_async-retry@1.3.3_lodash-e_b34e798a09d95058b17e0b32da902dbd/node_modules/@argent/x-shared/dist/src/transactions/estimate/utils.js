import "lodash-es";
import { num as g } from "starknet";
import { calculateCubeRootAdjustment as d } from "./adjustment.js";
import { argentMaxFee as f } from "./argentMaxFee.js";
import { isEqualAddress as C } from "../../chains/starknet/address.js";
const v = (s) => {
  const { type: r, deployment: e, transactions: a } = s;
  if (r === "paymaster")
    return a.maxFee + ((e == null ? void 0 : e.maxFee) ?? 0n);
  if (e && !C(e.feeTokenAddress, a.feeTokenAddress))
    throw Error("Cannot calculate estimated fees for different tokens");
  const o = !a.overallFee && !(e != null && e.overallFee), t = (i) => o ? P(i) : l(i), m = e ? t(e) : 0n, c = t(a);
  return m + c;
}, l = (s) => {
  const { l1Gas: r, l2Gas: e, l1DataGas: a } = s;
  return r.gasConsumed * r.gasPrice + e.gasConsumed * e.gasPrice + a.gasConsumed * a.gasPrice;
}, P = (s) => l(F(s)), F = (s, r = d) => {
  const e = 10000n, { l1Gas: a, l2Gas: o, l1DataGas: t } = s, m = a.gasConsumed * a.gasPrice + o.gasConsumed * o.gasPrice + t.gasConsumed * t.gasPrice;
  if (m < 0)
    throw Error("Cannot calculate max fee for negative fee");
  const c = g.toBigInt(f({ estimatedFee: m })), i = Number(c) / Number(m), u = r(i), n = BigInt(Math.trunc(u * Number(e)));
  return {
    ...s,
    l1Gas: {
      gasConsumed: a.gasConsumed * n / e,
      gasPrice: a.gasPrice * n / e
    },
    l2Gas: {
      gasConsumed: o.gasConsumed * n / e,
      gasPrice: o.gasPrice * n / e
    },
    l1DataGas: {
      gasConsumed: t.gasConsumed * n / e,
      gasPrice: t.gasPrice * n / e
    }
  };
};
export {
  P as estimatedFeeToMaxFeeTotal,
  l as estimatedFeeToTotal,
  v as estimatedFeesToMaxFeeTotalV2
};
