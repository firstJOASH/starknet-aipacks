import { isEqualAddress as d } from "../../../node_modules/.pnpm/@argent_x-shared@1.73.0_@scure_base@1.2.4_@scure_bip39@1.5.4_async-retry@1.3.3_lodash-e_b34e798a09d95058b17e0b32da902dbd/node_modules/@argent/x-shared/dist/src/chains/starknet/address.js";
import { getTokenBalance as R } from "../../../node_modules/.pnpm/@argent_x-shared@1.73.0_@scure_base@1.2.4_@scure_bip39@1.5.4_async-retry@1.3.3_lodash-e_b34e798a09d95058b17e0b32da902dbd/node_modules/@argent/x-shared/dist/src/tokens/balances.js";
import { estimatedFeesToMaxFeeTotalV2 as S } from "../../../node_modules/.pnpm/@argent_x-shared@1.73.0_@scure_base@1.2.4_@scure_bip39@1.5.4_async-retry@1.3.3_lodash-e_b34e798a09d95058b17e0b32da902dbd/node_modules/@argent/x-shared/dist/src/transactions/estimate/utils.js";
import { ensureArray as H } from "../../../node_modules/.pnpm/@argent_x-shared@1.73.0_@scure_base@1.2.4_@scure_bip39@1.5.4_async-retry@1.3.3_lodash-e_b34e798a09d95058b17e0b32da902dbd/node_modules/@argent/x-shared/dist/src/utils/arrays.js";
import { hexSchema as B } from "../../../node_modules/.pnpm/@argent_x-shared@1.73.0_@scure_base@1.2.4_@scure_bip39@1.5.4_async-retry@1.3.3_lodash-e_b34e798a09d95058b17e0b32da902dbd/node_modules/@argent/x-shared/dist/src/utils/hex.js";
import { useCallback as I } from "react";
const b = async ({ feeTokenAddress: t, calls: o, selectedAccount: r, transactionReviewService: i, appDomain: e, accountDeployTransaction: a, isDelayedTransaction: u }) => {
  const l = {
    type: "INVOKE",
    calls: H(o)
  };
  if (!r || !t)
    return;
  const s = a ? [a, l] : [l];
  return { result: await i.simulateAndReview(r, s, t, e, a, u) };
}, M = async (t, o, r, i) => {
  var v, p, y, F, f, w;
  let e = !1;
  const a = (v = o.transactions) == null ? void 0 : v.find((n) => {
    var T, A;
    return (A = (T = n == null ? void 0 : n.simulation) == null ? void 0 : T.summary) == null ? void 0 : A.find((N) => N.sent);
  });
  if (!a || !((p = a.simulation) != null && p.summary))
    return e;
  const u = await R(r, t, i) ?? 0n, l = a.simulation.summary.filter((n) => n.sent).map((n) => n.token.address), s = (y = o.enrichedFeeEstimation) == null ? void 0 : y.find((n) => d(n.transactions.feeTokenAddress, r)), c = (s == null ? void 0 : s.transactions.feeTokenAddress) && l.includes(s.transactions.feeTokenAddress), m = (s == null ? void 0 : s.type) === "native" && !(s != null && s.transactions.l1Gas.gasConsumed || s != null && s.transactions.l2Gas.gasConsumed || s != null && s.transactions.l1DataGas.gasConsumed), G = (s == null ? void 0 : s.type) === "paymaster" && !((F = s.transactions) != null && F.maxFee);
  if (!c || m && G)
    return e;
  const h = S(s), g = (f = a.simulation.summary.find((n) => n.sent && d(n.token.address, r))) == null ? void 0 : f.value, k = (w = a.simulation.summary.find((n) => !n.sent && d(n.token.address, r))) == null ? void 0 : w.value;
  if (!h || !g)
    return e;
  const C = BigInt(g) - BigInt(k || 0);
  if (!u)
    return e;
  const x = h + C;
  return u >= x || (e = !0), e;
}, P = () => I(async ({ feeTokenAddress: o, calls: r, selectedAccount: i, transactionReviewService: e, appDomain: a, accountDeployPayload: u, provider: l, isDelayedTransaction: s }) => {
  if (!i)
    return;
  const c = await b({
    feeTokenAddress: o,
    calls: r,
    selectedAccount: i,
    transactionReviewService: e,
    appDomain: a,
    accountDeployTransaction: O(u),
    isDelayedTransaction: s
  });
  if (!c || !c.result || !o)
    return;
  const m = await M(i.address, c.result, o, l);
  return { ...c.result, isSendingMoreThanBalanceAndGas: m };
}, []), O = (t) => t ? {
  type: "DEPLOY_ACCOUNT",
  calldata: t.calldata,
  classHash: B.parse(t.class_hash),
  salt: B.parse(t.salt),
  signature: []
} : void 0;
export {
  O as buildAccountDeployTransaction,
  M as checkGasFeeBalance,
  b as getReviewForTransactions,
  P as useTransactionReviewV2webFetcher
};
