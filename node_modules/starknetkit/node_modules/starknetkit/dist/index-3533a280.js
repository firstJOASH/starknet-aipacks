var $h = Object.defineProperty;
var Oh = (t, e, i) => e in t ? $h(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i;
var V = (t, e, i) => (Oh(t, typeof e != "symbol" ? e + "" : e, i), i);
import { d as Jc, g as xh, c as li } from "./connector-d58f0dd8.js";
import { d as Ah, a as Ph, L as kt, M as Ch, g as Rh } from "./Modal-f68d2590.js";
import { constants as Kt, RpcProvider as Zc, Account as Th } from "starknet";
import { a as Nh, r as Fh } from "./index-ae60a5dd.js";
var Hn = { exports: {} }, _i = typeof Reflect == "object" ? Reflect : null, Oo = _i && typeof _i.apply == "function" ? _i.apply : function(e, i, r) {
  return Function.prototype.apply.call(e, i, r);
}, Ur;
_i && typeof _i.ownKeys == "function" ? Ur = _i.ownKeys : Object.getOwnPropertySymbols ? Ur = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : Ur = function(e) {
  return Object.getOwnPropertyNames(e);
};
function Lh(t) {
  console && console.warn && console.warn(t);
}
var Qc = Number.isNaN || function(e) {
  return e !== e;
};
function te() {
  te.init.call(this);
}
Hn.exports = te;
Hn.exports.once = Mh;
te.EventEmitter = te;
te.prototype._events = void 0;
te.prototype._eventsCount = 0;
te.prototype._maxListeners = void 0;
var xo = 10;
function ns(t) {
  if (typeof t != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
}
Object.defineProperty(te, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return xo;
  },
  set: function(t) {
    if (typeof t != "number" || t < 0 || Qc(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    xo = t;
  }
});
te.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
te.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || Qc(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function Xc(t) {
  return t._maxListeners === void 0 ? te.defaultMaxListeners : t._maxListeners;
}
te.prototype.getMaxListeners = function() {
  return Xc(this);
};
te.prototype.emit = function(e) {
  for (var i = [], r = 1; r < arguments.length; r++)
    i.push(arguments[r]);
  var s = e === "error", n = this._events;
  if (n !== void 0)
    s = s && n.error === void 0;
  else if (!s)
    return !1;
  if (s) {
    var o;
    if (i.length > 0 && (o = i[0]), o instanceof Error)
      throw o;
    var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw a.context = o, a;
  }
  var c = n[e];
  if (c === void 0)
    return !1;
  if (typeof c == "function")
    Oo(c, this, i);
  else
    for (var u = c.length, l = su(c, u), r = 0; r < u; ++r)
      Oo(l[r], this, i);
  return !0;
};
function eu(t, e, i, r) {
  var s, n, o;
  if (ns(i), n = t._events, n === void 0 ? (n = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (n.newListener !== void 0 && (t.emit(
    "newListener",
    e,
    i.listener ? i.listener : i
  ), n = t._events), o = n[e]), o === void 0)
    o = n[e] = i, ++t._eventsCount;
  else if (typeof o == "function" ? o = n[e] = r ? [i, o] : [o, i] : r ? o.unshift(i) : o.push(i), s = Xc(t), s > 0 && o.length > s && !o.warned) {
    o.warned = !0;
    var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a.name = "MaxListenersExceededWarning", a.emitter = t, a.type = e, a.count = o.length, Lh(a);
  }
  return t;
}
te.prototype.addListener = function(e, i) {
  return eu(this, e, i, !1);
};
te.prototype.on = te.prototype.addListener;
te.prototype.prependListener = function(e, i) {
  return eu(this, e, i, !0);
};
function Bh() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function tu(t, e, i) {
  var r = { fired: !1, wrapFn: void 0, target: t, type: e, listener: i }, s = Bh.bind(r);
  return s.listener = i, r.wrapFn = s, s;
}
te.prototype.once = function(e, i) {
  return ns(i), this.on(e, tu(this, e, i)), this;
};
te.prototype.prependOnceListener = function(e, i) {
  return ns(i), this.prependListener(e, tu(this, e, i)), this;
};
te.prototype.removeListener = function(e, i) {
  var r, s, n, o, a;
  if (ns(i), s = this._events, s === void 0)
    return this;
  if (r = s[e], r === void 0)
    return this;
  if (r === i || r.listener === i)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete s[e], s.removeListener && this.emit("removeListener", e, r.listener || i));
  else if (typeof r != "function") {
    for (n = -1, o = r.length - 1; o >= 0; o--)
      if (r[o] === i || r[o].listener === i) {
        a = r[o].listener, n = o;
        break;
      }
    if (n < 0)
      return this;
    n === 0 ? r.shift() : Uh(r, n), r.length === 1 && (s[e] = r[0]), s.removeListener !== void 0 && this.emit("removeListener", e, a || i);
  }
  return this;
};
te.prototype.off = te.prototype.removeListener;
te.prototype.removeAllListeners = function(e) {
  var i, r, s;
  if (r = this._events, r === void 0)
    return this;
  if (r.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r[e]), this;
  if (arguments.length === 0) {
    var n = Object.keys(r), o;
    for (s = 0; s < n.length; ++s)
      o = n[s], o !== "removeListener" && this.removeAllListeners(o);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (i = r[e], typeof i == "function")
    this.removeListener(e, i);
  else if (i !== void 0)
    for (s = i.length - 1; s >= 0; s--)
      this.removeListener(e, i[s]);
  return this;
};
function iu(t, e, i) {
  var r = t._events;
  if (r === void 0)
    return [];
  var s = r[e];
  return s === void 0 ? [] : typeof s == "function" ? i ? [s.listener || s] : [s] : i ? kh(s) : su(s, s.length);
}
te.prototype.listeners = function(e) {
  return iu(this, e, !0);
};
te.prototype.rawListeners = function(e) {
  return iu(this, e, !1);
};
te.listenerCount = function(t, e) {
  return typeof t.listenerCount == "function" ? t.listenerCount(e) : ru.call(t, e);
};
te.prototype.listenerCount = ru;
function ru(t) {
  var e = this._events;
  if (e !== void 0) {
    var i = e[t];
    if (typeof i == "function")
      return 1;
    if (i !== void 0)
      return i.length;
  }
  return 0;
}
te.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Ur(this._events) : [];
};
function su(t, e) {
  for (var i = new Array(e), r = 0; r < e; ++r)
    i[r] = t[r];
  return i;
}
function Uh(t, e) {
  for (; e + 1 < t.length; e++)
    t[e] = t[e + 1];
  t.pop();
}
function kh(t) {
  for (var e = new Array(t.length), i = 0; i < e.length; ++i)
    e[i] = t[i].listener || t[i];
  return e;
}
function Mh(t, e) {
  return new Promise(function(i, r) {
    function s(o) {
      t.removeListener(e, n), r(o);
    }
    function n() {
      typeof t.removeListener == "function" && t.removeListener("error", s), i([].slice.call(arguments));
    }
    nu(t, e, n, { once: !0 }), e !== "error" && qh(t, s, { once: !0 });
  });
}
function qh(t, e, i) {
  typeof t.on == "function" && nu(t, "error", e, i);
}
function nu(t, e, i, r) {
  if (typeof t.on == "function")
    r.once ? t.once(e, i) : t.on(e, i);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function s(n) {
      r.once && t.removeEventListener(e, s), i(n);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
}
var Ge = Hn.exports;
const ou = /* @__PURE__ */ Jc(Ge);
var T = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ln = function(t, e) {
  return ln = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
    i.__proto__ = r;
  } || function(i, r) {
    for (var s in r)
      r.hasOwnProperty(s) && (i[s] = r[s]);
  }, ln(t, e);
};
function jh(t, e) {
  ln(t, e);
  function i() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
}
var hn = function() {
  return hn = Object.assign || function(e) {
    for (var i, r = 1, s = arguments.length; r < s; r++) {
      i = arguments[r];
      for (var n in i)
        Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n]);
    }
    return e;
  }, hn.apply(this, arguments);
};
function zh(t, e) {
  var i = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (i[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, r = Object.getOwnPropertySymbols(t); s < r.length; s++)
      e.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[s]) && (i[r[s]] = t[r[s]]);
  return i;
}
function Vh(t, e, i, r) {
  var s = arguments.length, n = s < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, i) : r, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(t, e, i, r);
  else
    for (var a = t.length - 1; a >= 0; a--)
      (o = t[a]) && (n = (s < 3 ? o(n) : s > 3 ? o(e, i, n) : o(e, i)) || n);
  return s > 3 && n && Object.defineProperty(e, i, n), n;
}
function Kh(t, e) {
  return function(i, r) {
    e(i, r, t);
  };
}
function Hh(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(t, e);
}
function Wh(t, e, i, r) {
  function s(n) {
    return n instanceof i ? n : new i(function(o) {
      o(n);
    });
  }
  return new (i || (i = Promise))(function(n, o) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (h) {
        o(h);
      }
    }
    function c(l) {
      try {
        u(r.throw(l));
      } catch (h) {
        o(h);
      }
    }
    function u(l) {
      l.done ? n(l.value) : s(l.value).then(a, c);
    }
    u((r = r.apply(t, e || [])).next());
  });
}
function Gh(t, e) {
  var i = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, r, s, n, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(u) {
    return function(l) {
      return c([u, l]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; i; )
      try {
        if (r = 1, s && (n = u[0] & 2 ? s.return : u[0] ? s.throw || ((n = s.return) && n.call(s), 0) : s.next) && !(n = n.call(s, u[1])).done)
          return n;
        switch (s = 0, n && (u = [u[0] & 2, n.value]), u[0]) {
          case 0:
          case 1:
            n = u;
            break;
          case 4:
            return i.label++, { value: u[1], done: !1 };
          case 5:
            i.label++, s = u[1], u = [0];
            continue;
          case 7:
            u = i.ops.pop(), i.trys.pop();
            continue;
          default:
            if (n = i.trys, !(n = n.length > 0 && n[n.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              i = 0;
              continue;
            }
            if (u[0] === 3 && (!n || u[1] > n[0] && u[1] < n[3])) {
              i.label = u[1];
              break;
            }
            if (u[0] === 6 && i.label < n[1]) {
              i.label = n[1], n = u;
              break;
            }
            if (n && i.label < n[2]) {
              i.label = n[2], i.ops.push(u);
              break;
            }
            n[2] && i.ops.pop(), i.trys.pop();
            continue;
        }
        u = e.call(t, i);
      } catch (l) {
        u = [6, l], s = 0;
      } finally {
        r = n = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function Yh(t, e, i, r) {
  r === void 0 && (r = i), t[r] = e[i];
}
function Jh(t, e) {
  for (var i in t)
    i !== "default" && !e.hasOwnProperty(i) && (e[i] = t[i]);
}
function dn(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, i = e && t[e], r = 0;
  if (i)
    return i.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function au(t, e) {
  var i = typeof Symbol == "function" && t[Symbol.iterator];
  if (!i)
    return t;
  var r = i.call(t), s, n = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(s = r.next()).done; )
      n.push(s.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      s && !s.done && (i = r.return) && i.call(r);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return n;
}
function Zh() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(au(arguments[e]));
  return t;
}
function Qh() {
  for (var t = 0, e = 0, i = arguments.length; e < i; e++)
    t += arguments[e].length;
  for (var r = Array(t), s = 0, e = 0; e < i; e++)
    for (var n = arguments[e], o = 0, a = n.length; o < a; o++, s++)
      r[s] = n[o];
  return r;
}
function ir(t) {
  return this instanceof ir ? (this.v = t, this) : new ir(t);
}
function Xh(t, e, i) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = i.apply(t, e || []), s, n = [];
  return s = {}, o("next"), o("throw"), o("return"), s[Symbol.asyncIterator] = function() {
    return this;
  }, s;
  function o(d) {
    r[d] && (s[d] = function(f) {
      return new Promise(function(p, g) {
        n.push([d, f, p, g]) > 1 || a(d, f);
      });
    });
  }
  function a(d, f) {
    try {
      c(r[d](f));
    } catch (p) {
      h(n[0][3], p);
    }
  }
  function c(d) {
    d.value instanceof ir ? Promise.resolve(d.value.v).then(u, l) : h(n[0][2], d);
  }
  function u(d) {
    a("next", d);
  }
  function l(d) {
    a("throw", d);
  }
  function h(d, f) {
    d(f), n.shift(), n.length && a(n[0][0], n[0][1]);
  }
}
function ed(t) {
  var e, i;
  return e = {}, r("next"), r("throw", function(s) {
    throw s;
  }), r("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function r(s, n) {
    e[s] = t[s] ? function(o) {
      return (i = !i) ? { value: ir(t[s](o)), done: s === "return" } : n ? n(o) : o;
    } : n;
  }
}
function td(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], i;
  return e ? e.call(t) : (t = typeof dn == "function" ? dn(t) : t[Symbol.iterator](), i = {}, r("next"), r("throw"), r("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function r(n) {
    i[n] = t[n] && function(o) {
      return new Promise(function(a, c) {
        o = t[n](o), s(a, c, o.done, o.value);
      });
    };
  }
  function s(n, o, a, c) {
    Promise.resolve(c).then(function(u) {
      n({ value: u, done: a });
    }, o);
  }
}
function id(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function rd(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var i in t)
      Object.hasOwnProperty.call(t, i) && (e[i] = t[i]);
  return e.default = t, e;
}
function sd(t) {
  return t && t.__esModule ? t : { default: t };
}
function nd(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function od(t, e, i) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, i), i;
}
const ad = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return hn;
  },
  __asyncDelegator: ed,
  __asyncGenerator: Xh,
  __asyncValues: td,
  __await: ir,
  __awaiter: Wh,
  __classPrivateFieldGet: nd,
  __classPrivateFieldSet: od,
  __createBinding: Yh,
  __decorate: Vh,
  __exportStar: Jh,
  __extends: jh,
  __generator: Gh,
  __importDefault: sd,
  __importStar: rd,
  __makeTemplateObject: id,
  __metadata: Hh,
  __param: Kh,
  __read: au,
  __rest: zh,
  __spread: Zh,
  __spreadArrays: Qh,
  __values: dn
}, Symbol.toStringTag, { value: "Module" })), hr = /* @__PURE__ */ xh(ad);
var Ss = {}, ki = {}, Ao;
function cd() {
  if (Ao)
    return ki;
  Ao = 1, Object.defineProperty(ki, "__esModule", { value: !0 }), ki.delay = void 0;
  function t(e) {
    return new Promise((i) => {
      setTimeout(() => {
        i(!0);
      }, e);
    });
  }
  return ki.delay = t, ki;
}
var Mt = {}, $s = {}, qt = {}, Po;
function ud() {
  return Po || (Po = 1, Object.defineProperty(qt, "__esModule", { value: !0 }), qt.ONE_THOUSAND = qt.ONE_HUNDRED = void 0, qt.ONE_HUNDRED = 100, qt.ONE_THOUSAND = 1e3), qt;
}
var Os = {}, Co;
function ld() {
  return Co || (Co = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ONE_YEAR = t.FOUR_WEEKS = t.THREE_WEEKS = t.TWO_WEEKS = t.ONE_WEEK = t.THIRTY_DAYS = t.SEVEN_DAYS = t.FIVE_DAYS = t.THREE_DAYS = t.ONE_DAY = t.TWENTY_FOUR_HOURS = t.TWELVE_HOURS = t.SIX_HOURS = t.THREE_HOURS = t.ONE_HOUR = t.SIXTY_MINUTES = t.THIRTY_MINUTES = t.TEN_MINUTES = t.FIVE_MINUTES = t.ONE_MINUTE = t.SIXTY_SECONDS = t.THIRTY_SECONDS = t.TEN_SECONDS = t.FIVE_SECONDS = t.ONE_SECOND = void 0, t.ONE_SECOND = 1, t.FIVE_SECONDS = 5, t.TEN_SECONDS = 10, t.THIRTY_SECONDS = 30, t.SIXTY_SECONDS = 60, t.ONE_MINUTE = t.SIXTY_SECONDS, t.FIVE_MINUTES = t.ONE_MINUTE * 5, t.TEN_MINUTES = t.ONE_MINUTE * 10, t.THIRTY_MINUTES = t.ONE_MINUTE * 30, t.SIXTY_MINUTES = t.ONE_MINUTE * 60, t.ONE_HOUR = t.SIXTY_MINUTES, t.THREE_HOURS = t.ONE_HOUR * 3, t.SIX_HOURS = t.ONE_HOUR * 6, t.TWELVE_HOURS = t.ONE_HOUR * 12, t.TWENTY_FOUR_HOURS = t.ONE_HOUR * 24, t.ONE_DAY = t.TWENTY_FOUR_HOURS, t.THREE_DAYS = t.ONE_DAY * 3, t.FIVE_DAYS = t.ONE_DAY * 5, t.SEVEN_DAYS = t.ONE_DAY * 7, t.THIRTY_DAYS = t.ONE_DAY * 30, t.ONE_WEEK = t.SEVEN_DAYS, t.TWO_WEEKS = t.ONE_WEEK * 2, t.THREE_WEEKS = t.ONE_WEEK * 3, t.FOUR_WEEKS = t.ONE_WEEK * 4, t.ONE_YEAR = t.ONE_DAY * 365;
  }(Os)), Os;
}
var Ro;
function cu() {
  return Ro || (Ro = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = hr;
    e.__exportStar(ud(), t), e.__exportStar(ld(), t);
  }($s)), $s;
}
var To;
function hd() {
  if (To)
    return Mt;
  To = 1, Object.defineProperty(Mt, "__esModule", { value: !0 }), Mt.fromMiliseconds = Mt.toMiliseconds = void 0;
  const t = cu();
  function e(r) {
    return r * t.ONE_THOUSAND;
  }
  Mt.toMiliseconds = e;
  function i(r) {
    return Math.floor(r / t.ONE_THOUSAND);
  }
  return Mt.fromMiliseconds = i, Mt;
}
var No;
function dd() {
  return No || (No = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = hr;
    e.__exportStar(cd(), t), e.__exportStar(hd(), t);
  }(Ss)), Ss;
}
var hi = {}, Fo;
function pd() {
  if (Fo)
    return hi;
  Fo = 1, Object.defineProperty(hi, "__esModule", { value: !0 }), hi.Watch = void 0;
  class t {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(i) {
      if (this.timestamps.has(i))
        throw new Error(`Watch already started for label: ${i}`);
      this.timestamps.set(i, { started: Date.now() });
    }
    stop(i) {
      const r = this.get(i);
      if (typeof r.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${i}`);
      const s = Date.now() - r.started;
      this.timestamps.set(i, { started: r.started, elapsed: s });
    }
    get(i) {
      const r = this.timestamps.get(i);
      if (typeof r > "u")
        throw new Error(`No timestamp found for label: ${i}`);
      return r;
    }
    elapsed(i) {
      const r = this.get(i);
      return r.elapsed || Date.now() - r.started;
    }
  }
  return hi.Watch = t, hi.default = t, hi;
}
var xs = {}, Mi = {}, Lo;
function fd() {
  if (Lo)
    return Mi;
  Lo = 1, Object.defineProperty(Mi, "__esModule", { value: !0 }), Mi.IWatch = void 0;
  class t {
  }
  return Mi.IWatch = t, Mi;
}
var Bo;
function gd() {
  return Bo || (Bo = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), hr.__exportStar(fd(), t);
  }(xs)), xs;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = hr;
  e.__exportStar(dd(), t), e.__exportStar(pd(), t), e.__exportStar(gd(), t), e.__exportStar(cu(), t);
})(T);
class ni {
}
let yd = class extends ni {
  constructor(e) {
    super();
  }
};
const Uo = T.FIVE_SECONDS, Ci = { pulse: "heartbeat_pulse" };
let wd = class uu extends yd {
  constructor(e) {
    super(e), this.events = new Ge.EventEmitter(), this.interval = Uo, this.interval = e?.interval || Uo;
  }
  static async init(e) {
    const i = new uu(e);
    return await i.init(), i;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e, i) {
    this.events.on(e, i);
  }
  once(e, i) {
    this.events.once(e, i);
  }
  off(e, i) {
    this.events.off(e, i);
  }
  removeListener(e, i) {
    this.events.removeListener(e, i);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), T.toMiliseconds(this.interval));
  }
  pulse() {
    this.events.emit(Ci.pulse);
  }
};
const md = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, bd = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, vd = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function Ed(t, e) {
  if (t === "__proto__" || t === "constructor" && e && typeof e == "object" && "prototype" in e) {
    _d(t);
    return;
  }
  return e;
}
function _d(t) {
  console.warn(`[destr] Dropping "${t}" key to prevent prototype pollution.`);
}
function $r(t, e = {}) {
  if (typeof t != "string")
    return t;
  if (t[0] === '"' && t[t.length - 1] === '"' && t.indexOf("\\") === -1)
    return t.slice(1, -1);
  const i = t.trim();
  if (i.length <= 9)
    switch (i.toLowerCase()) {
      case "true":
        return !0;
      case "false":
        return !1;
      case "undefined":
        return;
      case "null":
        return null;
      case "nan":
        return Number.NaN;
      case "infinity":
        return Number.POSITIVE_INFINITY;
      case "-infinity":
        return Number.NEGATIVE_INFINITY;
    }
  if (!vd.test(t)) {
    if (e.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return t;
  }
  try {
    if (md.test(t) || bd.test(t)) {
      if (e.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(t, Ed);
    }
    return JSON.parse(t);
  } catch (r) {
    if (e.strict)
      throw r;
    return t;
  }
}
function Id(t) {
  return !t || typeof t.then != "function" ? Promise.resolve(t) : t;
}
function we(t, ...e) {
  try {
    return Id(t(...e));
  } catch (i) {
    return Promise.reject(i);
  }
}
function Dd(t) {
  const e = typeof t;
  return t === null || e !== "object" && e !== "function";
}
function Sd(t) {
  const e = Object.getPrototypeOf(t);
  return !e || e.isPrototypeOf(Object);
}
function kr(t) {
  if (Dd(t))
    return String(t);
  if (Sd(t) || Array.isArray(t))
    return JSON.stringify(t);
  if (typeof t.toJSON == "function")
    return kr(t.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
const pn = "base64:";
function $d(t) {
  return typeof t == "string" ? t : pn + Ad(t);
}
function Od(t) {
  return typeof t != "string" || !t.startsWith(pn) ? t : xd(t.slice(pn.length));
}
function xd(t) {
  return globalThis.Buffer ? Buffer.from(t, "base64") : Uint8Array.from(
    globalThis.atob(t),
    (e) => e.codePointAt(0)
  );
}
function Ad(t) {
  return globalThis.Buffer ? Buffer.from(t).toString("base64") : globalThis.btoa(String.fromCodePoint(...t));
}
function Ue(t) {
  return t && t.split("?")[0]?.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") || "";
}
function Pd(...t) {
  return Ue(t.join(":"));
}
function Or(t) {
  return t = Ue(t), t ? t + ":" : "";
}
function Cd(t, e) {
  if (e === void 0)
    return !0;
  let i = 0, r = t.indexOf(":");
  for (; r > -1; )
    i++, r = t.indexOf(":", r + 1);
  return i <= e;
}
function Rd(t, e) {
  return e ? t.startsWith(e) && t[t.length - 1] !== "$" : t[t.length - 1] !== "$";
}
const Td = "memory", Nd = () => {
  const t = /* @__PURE__ */ new Map();
  return {
    name: Td,
    getInstance: () => t,
    hasItem(e) {
      return t.has(e);
    },
    getItem(e) {
      return t.get(e) ?? null;
    },
    getItemRaw(e) {
      return t.get(e) ?? null;
    },
    setItem(e, i) {
      t.set(e, i);
    },
    setItemRaw(e, i) {
      t.set(e, i);
    },
    removeItem(e) {
      t.delete(e);
    },
    getKeys() {
      return [...t.keys()];
    },
    clear() {
      t.clear();
    },
    dispose() {
      t.clear();
    }
  };
};
function Fd(t = {}) {
  const e = {
    mounts: { "": t.driver || Nd() },
    mountpoints: [""],
    watching: !1,
    watchListeners: [],
    unwatch: {}
  }, i = (u) => {
    for (const l of e.mountpoints)
      if (u.startsWith(l))
        return {
          base: l,
          relativeKey: u.slice(l.length),
          driver: e.mounts[l]
        };
    return {
      base: "",
      relativeKey: u,
      driver: e.mounts[""]
    };
  }, r = (u, l) => e.mountpoints.filter(
    (h) => h.startsWith(u) || l && u.startsWith(h)
  ).map((h) => ({
    relativeBase: u.length > h.length ? u.slice(h.length) : void 0,
    mountpoint: h,
    driver: e.mounts[h]
  })), s = (u, l) => {
    if (e.watching) {
      l = Ue(l);
      for (const h of e.watchListeners)
        h(u, l);
    }
  }, n = async () => {
    if (!e.watching) {
      e.watching = !0;
      for (const u in e.mounts)
        e.unwatch[u] = await ko(
          e.mounts[u],
          s,
          u
        );
    }
  }, o = async () => {
    if (e.watching) {
      for (const u in e.unwatch)
        await e.unwatch[u]();
      e.unwatch = {}, e.watching = !1;
    }
  }, a = (u, l, h) => {
    const d = /* @__PURE__ */ new Map(), f = (p) => {
      let g = d.get(p.base);
      return g || (g = {
        driver: p.driver,
        base: p.base,
        items: []
      }, d.set(p.base, g)), g;
    };
    for (const p of u) {
      const g = typeof p == "string", y = Ue(g ? p : p.key), m = g ? void 0 : p.value, w = g || !p.options ? l : { ...l, ...p.options }, b = i(y);
      f(b).items.push({
        key: y,
        value: m,
        relativeKey: b.relativeKey,
        options: w
      });
    }
    return Promise.all([...d.values()].map((p) => h(p))).then(
      (p) => p.flat()
    );
  }, c = {
    // Item
    hasItem(u, l = {}) {
      u = Ue(u);
      const { relativeKey: h, driver: d } = i(u);
      return we(d.hasItem, h, l);
    },
    getItem(u, l = {}) {
      u = Ue(u);
      const { relativeKey: h, driver: d } = i(u);
      return we(d.getItem, h, l).then(
        (f) => $r(f)
      );
    },
    getItems(u, l = {}) {
      return a(u, l, (h) => h.driver.getItems ? we(
        h.driver.getItems,
        h.items.map((d) => ({
          key: d.relativeKey,
          options: d.options
        })),
        l
      ).then(
        (d) => d.map((f) => ({
          key: Pd(h.base, f.key),
          value: $r(f.value)
        }))
      ) : Promise.all(
        h.items.map((d) => we(
          h.driver.getItem,
          d.relativeKey,
          d.options
        ).then((f) => ({
          key: d.key,
          value: $r(f)
        })))
      ));
    },
    getItemRaw(u, l = {}) {
      u = Ue(u);
      const { relativeKey: h, driver: d } = i(u);
      return d.getItemRaw ? we(d.getItemRaw, h, l) : we(d.getItem, h, l).then(
        (f) => Od(f)
      );
    },
    async setItem(u, l, h = {}) {
      if (l === void 0)
        return c.removeItem(u);
      u = Ue(u);
      const { relativeKey: d, driver: f } = i(u);
      f.setItem && (await we(f.setItem, d, kr(l), h), f.watch || s("update", u));
    },
    async setItems(u, l) {
      await a(u, l, async (h) => {
        if (h.driver.setItems)
          return we(
            h.driver.setItems,
            h.items.map((d) => ({
              key: d.relativeKey,
              value: kr(d.value),
              options: d.options
            })),
            l
          );
        h.driver.setItem && await Promise.all(
          h.items.map((d) => we(
            h.driver.setItem,
            d.relativeKey,
            kr(d.value),
            d.options
          ))
        );
      });
    },
    async setItemRaw(u, l, h = {}) {
      if (l === void 0)
        return c.removeItem(u, h);
      u = Ue(u);
      const { relativeKey: d, driver: f } = i(u);
      if (f.setItemRaw)
        await we(f.setItemRaw, d, l, h);
      else if (f.setItem)
        await we(f.setItem, d, $d(l), h);
      else
        return;
      f.watch || s("update", u);
    },
    async removeItem(u, l = {}) {
      typeof l == "boolean" && (l = { removeMeta: l }), u = Ue(u);
      const { relativeKey: h, driver: d } = i(u);
      d.removeItem && (await we(d.removeItem, h, l), (l.removeMeta || l.removeMata) && await we(d.removeItem, h + "$", l), d.watch || s("remove", u));
    },
    // Meta
    async getMeta(u, l = {}) {
      typeof l == "boolean" && (l = { nativeOnly: l }), u = Ue(u);
      const { relativeKey: h, driver: d } = i(u), f = /* @__PURE__ */ Object.create(null);
      if (d.getMeta && Object.assign(f, await we(d.getMeta, h, l)), !l.nativeOnly) {
        const p = await we(
          d.getItem,
          h + "$",
          l
        ).then((g) => $r(g));
        p && typeof p == "object" && (typeof p.atime == "string" && (p.atime = new Date(p.atime)), typeof p.mtime == "string" && (p.mtime = new Date(p.mtime)), Object.assign(f, p));
      }
      return f;
    },
    setMeta(u, l, h = {}) {
      return this.setItem(u + "$", l, h);
    },
    removeMeta(u, l = {}) {
      return this.removeItem(u + "$", l);
    },
    // Keys
    async getKeys(u, l = {}) {
      u = Or(u);
      const h = r(u, !0);
      let d = [];
      const f = [];
      let p = !0;
      for (const y of h) {
        y.driver.flags?.maxDepth || (p = !1);
        const m = await we(
          y.driver.getKeys,
          y.relativeBase,
          l
        );
        for (const w of m) {
          const b = y.mountpoint + Ue(w);
          d.some((E) => b.startsWith(E)) || f.push(b);
        }
        d = [
          y.mountpoint,
          ...d.filter((w) => !w.startsWith(y.mountpoint))
        ];
      }
      const g = l.maxDepth !== void 0 && !p;
      return f.filter(
        (y) => (!g || Cd(y, l.maxDepth)) && Rd(y, u)
      );
    },
    // Utils
    async clear(u, l = {}) {
      u = Or(u), await Promise.all(
        r(u, !1).map(async (h) => {
          if (h.driver.clear)
            return we(h.driver.clear, h.relativeBase, l);
          if (h.driver.removeItem) {
            const d = await h.driver.getKeys(h.relativeBase || "", l);
            return Promise.all(
              d.map((f) => h.driver.removeItem(f, l))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(e.mounts).map((u) => Mo(u))
      );
    },
    async watch(u) {
      return await n(), e.watchListeners.push(u), async () => {
        e.watchListeners = e.watchListeners.filter(
          (l) => l !== u
        ), e.watchListeners.length === 0 && await o();
      };
    },
    async unwatch() {
      e.watchListeners = [], await o();
    },
    // Mount
    mount(u, l) {
      if (u = Or(u), u && e.mounts[u])
        throw new Error(`already mounted at ${u}`);
      return u && (e.mountpoints.push(u), e.mountpoints.sort((h, d) => d.length - h.length)), e.mounts[u] = l, e.watching && Promise.resolve(ko(l, s, u)).then((h) => {
        e.unwatch[u] = h;
      }).catch(console.error), c;
    },
    async unmount(u, l = !0) {
      u = Or(u), !(!u || !e.mounts[u]) && (e.watching && u in e.unwatch && (e.unwatch[u]?.(), delete e.unwatch[u]), l && await Mo(e.mounts[u]), e.mountpoints = e.mountpoints.filter((h) => h !== u), delete e.mounts[u]);
    },
    getMount(u = "") {
      u = Ue(u) + ":";
      const l = i(u);
      return {
        driver: l.driver,
        base: l.base
      };
    },
    getMounts(u = "", l = {}) {
      return u = Ue(u), r(u, l.parents).map((d) => ({
        driver: d.driver,
        base: d.mountpoint
      }));
    },
    // Aliases
    keys: (u, l = {}) => c.getKeys(u, l),
    get: (u, l = {}) => c.getItem(u, l),
    set: (u, l, h = {}) => c.setItem(u, l, h),
    has: (u, l = {}) => c.hasItem(u, l),
    del: (u, l = {}) => c.removeItem(u, l),
    remove: (u, l = {}) => c.removeItem(u, l)
  };
  return c;
}
function ko(t, e, i) {
  return t.watch ? t.watch((r, s) => e(r, i + s)) : () => {
  };
}
async function Mo(t) {
  typeof t.dispose == "function" && await we(t.dispose);
}
function oi(t) {
  return new Promise((e, i) => {
    t.oncomplete = t.onsuccess = () => e(t.result), t.onabort = t.onerror = () => i(t.error);
  });
}
function lu(t, e) {
  let i;
  const r = () => {
    if (i)
      return i;
    const s = indexedDB.open(t);
    return s.onupgradeneeded = () => s.result.createObjectStore(e), i = oi(s), i.then((n) => {
      n.onclose = () => i = void 0;
    }, () => {
    }), i;
  };
  return (s, n) => r().then((o) => n(o.transaction(e, s).objectStore(e)));
}
let As;
function dr() {
  return As || (As = lu("keyval-store", "keyval")), As;
}
function qo(t, e = dr()) {
  return e("readonly", (i) => oi(i.get(t)));
}
function Ld(t, e, i = dr()) {
  return i("readwrite", (r) => (r.put(e, t), oi(r.transaction)));
}
function Bd(t, e = dr()) {
  return e("readwrite", (i) => (i.delete(t), oi(i.transaction)));
}
function Ud(t = dr()) {
  return t("readwrite", (e) => (e.clear(), oi(e.transaction)));
}
function kd(t, e) {
  return t.openCursor().onsuccess = function() {
    this.result && (e(this.result), this.result.continue());
  }, oi(t.transaction);
}
function Md(t = dr()) {
  return t("readonly", (e) => {
    if (e.getAllKeys)
      return oi(e.getAllKeys());
    const i = [];
    return kd(e, (r) => i.push(r.key)).then(() => i);
  });
}
const qd = (t) => JSON.stringify(t, (e, i) => typeof i == "bigint" ? i.toString() + "n" : i), jd = (t) => {
  const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, i = t.replace(e, '$1"$2n"$3');
  return JSON.parse(i, (r, s) => typeof s == "string" && s.match(/^\d+n$/) ? BigInt(s.substring(0, s.length - 1)) : s);
};
function Ii(t) {
  if (typeof t != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof t}`);
  try {
    return jd(t);
  } catch {
    return t;
  }
}
function ei(t) {
  return typeof t == "string" ? t : qd(t) || "";
}
const zd = "idb-keyval";
var Vd = (t = {}) => {
  const e = t.base && t.base.length > 0 ? `${t.base}:` : "", i = (s) => e + s;
  let r;
  return t.dbName && t.storeName && (r = lu(t.dbName, t.storeName)), { name: zd, options: t, async hasItem(s) {
    return !(typeof await qo(i(s), r) > "u");
  }, async getItem(s) {
    return await qo(i(s), r) ?? null;
  }, setItem(s, n) {
    return Ld(i(s), n, r);
  }, removeItem(s) {
    return Bd(i(s), r);
  }, getKeys() {
    return Md(r);
  }, clear() {
    return Ud(r);
  } };
};
const Kd = "WALLET_CONNECT_V2_INDEXED_DB", Hd = "keyvaluestorage";
let Wd = class {
  constructor() {
    this.indexedDb = Fd({ driver: Vd({ dbName: Kd, storeName: Hd }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e) => [e.key, e.value]);
  }
  async getItem(e) {
    const i = await this.indexedDb.getItem(e);
    if (i !== null)
      return i;
  }
  async setItem(e, i) {
    await this.indexedDb.setItem(e, ei(i));
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e);
  }
};
var Ps = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Mr = { exports: {} };
(function() {
  let t;
  function e() {
  }
  t = e, t.prototype.getItem = function(i) {
    return this.hasOwnProperty(i) ? String(this[i]) : null;
  }, t.prototype.setItem = function(i, r) {
    this[i] = String(r);
  }, t.prototype.removeItem = function(i) {
    delete this[i];
  }, t.prototype.clear = function() {
    const i = this;
    Object.keys(i).forEach(function(r) {
      i[r] = void 0, delete i[r];
    });
  }, t.prototype.key = function(i) {
    return i = i || 0, Object.keys(this)[i];
  }, t.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof Ps < "u" && Ps.localStorage ? Mr.exports = Ps.localStorage : typeof window < "u" && window.localStorage ? Mr.exports = window.localStorage : Mr.exports = new e();
})();
function Gd(t) {
  var e;
  return [t[0], Ii((e = t[1]) != null ? e : "")];
}
let Yd = class {
  constructor() {
    this.localStorage = Mr.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(Gd);
  }
  async getItem(e) {
    const i = this.localStorage.getItem(e);
    if (i !== null)
      return Ii(i);
  }
  async setItem(e, i) {
    this.localStorage.setItem(e, ei(i));
  }
  async removeItem(e) {
    this.localStorage.removeItem(e);
  }
};
const Jd = "wc_storage_version", jo = 1, Zd = async (t, e, i) => {
  const r = Jd, s = await e.getItem(r);
  if (s && s >= jo) {
    i(e);
    return;
  }
  const n = await t.getKeys();
  if (!n.length) {
    i(e);
    return;
  }
  const o = [];
  for (; n.length; ) {
    const a = n.shift();
    if (!a)
      continue;
    const c = a.toLowerCase();
    if (c.includes("wc@") || c.includes("walletconnect") || c.includes("wc_") || c.includes("wallet_connect")) {
      const u = await t.getItem(a);
      await e.setItem(a, u), o.push(a);
    }
  }
  await e.setItem(r, jo), i(e), Qd(t, o);
}, Qd = async (t, e) => {
  e.length && e.forEach(async (i) => {
    await t.removeItem(i);
  });
};
let Xd = class {
  constructor() {
    this.initialized = !1, this.setInitialized = (i) => {
      this.storage = i, this.initialized = !0;
    };
    const e = new Yd();
    this.storage = e;
    try {
      const i = new Wd();
      Zd(e, i, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e);
  }
  async setItem(e, i) {
    return await this.initialize(), this.storage.setItem(e, i);
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e);
  }
  async initialize() {
    this.initialized || await new Promise((e) => {
      const i = setInterval(() => {
        this.initialized && (clearInterval(i), e());
      }, 20);
    });
  }
};
function ep(t) {
  try {
    return JSON.stringify(t);
  } catch {
    return '"[Circular]"';
  }
}
var tp = ip;
function ip(t, e, i) {
  var r = i && i.stringify || ep, s = 1;
  if (typeof t == "object" && t !== null) {
    var n = e.length + s;
    if (n === 1)
      return t;
    var o = new Array(n);
    o[0] = r(t);
    for (var a = 1; a < n; a++)
      o[a] = r(e[a]);
    return o.join(" ");
  }
  if (typeof t != "string")
    return t;
  var c = e.length;
  if (c === 0)
    return t;
  for (var u = "", l = 1 - s, h = -1, d = t && t.length || 0, f = 0; f < d; ) {
    if (t.charCodeAt(f) === 37 && f + 1 < d) {
      switch (h = h > -1 ? h : 0, t.charCodeAt(f + 1)) {
        case 100:
        case 102:
          if (l >= c || e[l] == null)
            break;
          h < f && (u += t.slice(h, f)), u += Number(e[l]), h = f + 2, f++;
          break;
        case 105:
          if (l >= c || e[l] == null)
            break;
          h < f && (u += t.slice(h, f)), u += Math.floor(Number(e[l])), h = f + 2, f++;
          break;
        case 79:
        case 111:
        case 106:
          if (l >= c || e[l] === void 0)
            break;
          h < f && (u += t.slice(h, f));
          var p = typeof e[l];
          if (p === "string") {
            u += "'" + e[l] + "'", h = f + 2, f++;
            break;
          }
          if (p === "function") {
            u += e[l].name || "<anonymous>", h = f + 2, f++;
            break;
          }
          u += r(e[l]), h = f + 2, f++;
          break;
        case 115:
          if (l >= c)
            break;
          h < f && (u += t.slice(h, f)), u += String(e[l]), h = f + 2, f++;
          break;
        case 37:
          h < f && (u += t.slice(h, f)), u += "%", h = f + 2, f++, l--;
          break;
      }
      ++l;
    }
    ++f;
  }
  return h === -1 ? t : (h < d && (u += t.slice(h)), u);
}
const zo = tp;
var vi = yt;
const rr = dp().console || {}, rp = {
  mapHttpRequest: xr,
  mapHttpResponse: xr,
  wrapRequestSerializer: Cs,
  wrapResponseSerializer: Cs,
  wrapErrorSerializer: Cs,
  req: xr,
  res: xr,
  err: cp
};
function sp(t, e) {
  return Array.isArray(t) ? t.filter(function(r) {
    return r !== "!stdSerializers.err";
  }) : t === !0 ? Object.keys(e) : !1;
}
function yt(t) {
  t = t || {}, t.browser = t.browser || {};
  const e = t.browser.transmit;
  if (e && typeof e.send != "function")
    throw Error("pino: transmit option must have a send function");
  const i = t.browser.write || rr;
  t.browser.write && (t.browser.asObject = !0);
  const r = t.serializers || {}, s = sp(t.browser.serialize, r);
  let n = t.browser.serialize;
  Array.isArray(t.browser.serialize) && t.browser.serialize.indexOf("!stdSerializers.err") > -1 && (n = !1);
  const o = ["error", "fatal", "warn", "info", "debug", "trace"];
  typeof i == "function" && (i.error = i.fatal = i.warn = i.info = i.debug = i.trace = i), t.enabled === !1 && (t.level = "silent");
  const a = t.level || "info", c = Object.create(i);
  c.log || (c.log = sr), Object.defineProperty(c, "levelVal", {
    get: l
  }), Object.defineProperty(c, "level", {
    get: h,
    set: d
  });
  const u = {
    transmit: e,
    serialize: s,
    asObject: t.browser.asObject,
    levels: o,
    timestamp: up(t)
  };
  c.levels = yt.levels, c.level = a, c.setMaxListeners = c.getMaxListeners = c.emit = c.addListener = c.on = c.prependListener = c.once = c.prependOnceListener = c.removeListener = c.removeAllListeners = c.listeners = c.listenerCount = c.eventNames = c.write = c.flush = sr, c.serializers = r, c._serialize = s, c._stdErrSerialize = n, c.child = f, e && (c._logEvent = fn());
  function l() {
    return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
  }
  function h() {
    return this._level;
  }
  function d(p) {
    if (p !== "silent" && !this.levels.values[p])
      throw Error("unknown level " + p);
    this._level = p, di(u, c, "error", "log"), di(u, c, "fatal", "error"), di(u, c, "warn", "error"), di(u, c, "info", "log"), di(u, c, "debug", "log"), di(u, c, "trace", "log");
  }
  function f(p, g) {
    if (!p)
      throw new Error("missing bindings for child Pino");
    g = g || {}, s && p.serializers && (g.serializers = p.serializers);
    const y = g.serializers;
    if (s && y) {
      var m = Object.assign({}, r, y), w = t.browser.serialize === !0 ? Object.keys(m) : s;
      delete p.serializers, os([p], w, m, this._stdErrSerialize);
    }
    function b(E) {
      this._childLevel = (E._childLevel | 0) + 1, this.error = pi(E, p, "error"), this.fatal = pi(E, p, "fatal"), this.warn = pi(E, p, "warn"), this.info = pi(E, p, "info"), this.debug = pi(E, p, "debug"), this.trace = pi(E, p, "trace"), m && (this.serializers = m, this._serialize = w), e && (this._logEvent = fn(
        [].concat(E._logEvent.bindings, p)
      ));
    }
    return b.prototype = this, new b(this);
  }
  return c;
}
yt.levels = {
  values: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },
  labels: {
    10: "trace",
    20: "debug",
    30: "info",
    40: "warn",
    50: "error",
    60: "fatal"
  }
};
yt.stdSerializers = rp;
yt.stdTimeFunctions = Object.assign({}, { nullTime: hu, epochTime: du, unixTime: lp, isoTime: hp });
function di(t, e, i, r) {
  const s = Object.getPrototypeOf(e);
  e[i] = e.levelVal > e.levels.values[i] ? sr : s[i] ? s[i] : rr[i] || rr[r] || sr, np(t, e, i);
}
function np(t, e, i) {
  !t.transmit && e[i] === sr || (e[i] = function(r) {
    return function() {
      const n = t.timestamp(), o = new Array(arguments.length), a = Object.getPrototypeOf && Object.getPrototypeOf(this) === rr ? rr : this;
      for (var c = 0; c < o.length; c++)
        o[c] = arguments[c];
      if (t.serialize && !t.asObject && os(o, this._serialize, this.serializers, this._stdErrSerialize), t.asObject ? r.call(a, op(this, i, o, n)) : r.apply(a, o), t.transmit) {
        const u = t.transmit.level || e.level, l = yt.levels.values[u], h = yt.levels.values[i];
        if (h < l)
          return;
        ap(this, {
          ts: n,
          methodLevel: i,
          methodValue: h,
          transmitLevel: u,
          transmitValue: yt.levels.values[t.transmit.level || e.level],
          send: t.transmit.send,
          val: e.levelVal
        }, o);
      }
    };
  }(e[i]));
}
function op(t, e, i, r) {
  t._serialize && os(i, t._serialize, t.serializers, t._stdErrSerialize);
  const s = i.slice();
  let n = s[0];
  const o = {};
  r && (o.time = r), o.level = yt.levels.values[e];
  let a = (t._childLevel | 0) + 1;
  if (a < 1 && (a = 1), n !== null && typeof n == "object") {
    for (; a-- && typeof s[0] == "object"; )
      Object.assign(o, s.shift());
    n = s.length ? zo(s.shift(), s) : void 0;
  } else
    typeof n == "string" && (n = zo(s.shift(), s));
  return n !== void 0 && (o.msg = n), o;
}
function os(t, e, i, r) {
  for (const s in t)
    if (r && t[s] instanceof Error)
      t[s] = yt.stdSerializers.err(t[s]);
    else if (typeof t[s] == "object" && !Array.isArray(t[s]))
      for (const n in t[s])
        e && e.indexOf(n) > -1 && n in i && (t[s][n] = i[n](t[s][n]));
}
function pi(t, e, i) {
  return function() {
    const r = new Array(1 + arguments.length);
    r[0] = e;
    for (var s = 1; s < r.length; s++)
      r[s] = arguments[s - 1];
    return t[i].apply(this, r);
  };
}
function ap(t, e, i) {
  const r = e.send, s = e.ts, n = e.methodLevel, o = e.methodValue, a = e.val, c = t._logEvent.bindings;
  os(
    i,
    t._serialize || Object.keys(t.serializers),
    t.serializers,
    t._stdErrSerialize === void 0 ? !0 : t._stdErrSerialize
  ), t._logEvent.ts = s, t._logEvent.messages = i.filter(function(u) {
    return c.indexOf(u) === -1;
  }), t._logEvent.level.label = n, t._logEvent.level.value = o, r(n, t._logEvent, a), t._logEvent = fn(c);
}
function fn(t) {
  return {
    ts: 0,
    messages: [],
    bindings: t || [],
    level: { label: "", value: 0 }
  };
}
function cp(t) {
  const e = {
    type: t.constructor.name,
    msg: t.message,
    stack: t.stack
  };
  for (const i in t)
    e[i] === void 0 && (e[i] = t[i]);
  return e;
}
function up(t) {
  return typeof t.timestamp == "function" ? t.timestamp : t.timestamp === !1 ? hu : du;
}
function xr() {
  return {};
}
function Cs(t) {
  return t;
}
function sr() {
}
function hu() {
  return !1;
}
function du() {
  return Date.now();
}
function lp() {
  return Math.round(Date.now() / 1e3);
}
function hp() {
  return new Date(Date.now()).toISOString();
}
function dp() {
  function t(e) {
    return typeof e < "u" && e;
  }
  try {
    return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
      get: function() {
        return delete Object.prototype.globalThis, this.globalThis = this;
      },
      configurable: !0
    }), globalThis;
  } catch {
    return t(self) || t(window) || t(this) || {};
  }
}
const as = /* @__PURE__ */ Jc(vi), pp = { level: "info" }, pr = "custom_context", Wn = 1e3 * 1024;
let fp = class {
  constructor(e) {
    this.nodeValue = e, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
}, Vo = class {
  constructor(e) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e, this.sizeInBytes = 0;
  }
  append(e) {
    const i = new fp(e);
    if (i.size > this.maxSizeInBytes)
      throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${i.size}`);
    for (; this.size + i.size > this.maxSizeInBytes; )
      this.shift();
    this.head ? (this.tail && (this.tail.next = i), this.tail = i) : (this.head = i, this.tail = i), this.lengthInNodes++, this.sizeInBytes += i.size;
  }
  shift() {
    if (!this.head)
      return;
    const e = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e.size;
  }
  toArray() {
    const e = [];
    let i = this.head;
    for (; i !== null; )
      e.push(i.value), i = i.next;
    return e;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e = this.head;
    return { next: () => {
      if (!e)
        return { done: !0, value: null };
      const i = e.value;
      return e = e.next, { done: !1, value: i };
    } };
  }
}, pu = class {
  constructor(e, i = Wn) {
    this.level = e ?? "error", this.levelValue = vi.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = i, this.logs = new Vo(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(e, i) {
    i === vi.levels.values.error ? console.error(e) : i === vi.levels.values.warn ? console.warn(e) : i === vi.levels.values.debug ? console.debug(e) : i === vi.levels.values.trace ? console.trace(e) : console.log(e);
  }
  appendToLogs(e) {
    this.logs.append(ei({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e }));
    const i = typeof e == "string" ? JSON.parse(e).level : e.level;
    i >= this.levelValue && this.forwardToConsole(e, i);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new Vo(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(e) {
    const i = this.getLogArray();
    return i.push(ei({ extraMetadata: e })), new Blob(i, { type: "application/json" });
  }
}, gp = class {
  constructor(e, i = Wn) {
    this.baseChunkLogger = new pu(e, i);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
  downloadLogsBlobInBrowser(e) {
    const i = URL.createObjectURL(this.logsToBlob(e)), r = document.createElement("a");
    r.href = i, r.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(r), r.click(), document.body.removeChild(r), URL.revokeObjectURL(i);
  }
}, yp = class {
  constructor(e, i = Wn) {
    this.baseChunkLogger = new pu(e, i);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
};
var wp = Object.defineProperty, mp = Object.defineProperties, bp = Object.getOwnPropertyDescriptors, Ko = Object.getOwnPropertySymbols, vp = Object.prototype.hasOwnProperty, Ep = Object.prototype.propertyIsEnumerable, Ho = (t, e, i) => e in t ? wp(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Wr = (t, e) => {
  for (var i in e || (e = {}))
    vp.call(e, i) && Ho(t, i, e[i]);
  if (Ko)
    for (var i of Ko(e))
      Ep.call(e, i) && Ho(t, i, e[i]);
  return t;
}, Gr = (t, e) => mp(t, bp(e));
function Gn(t) {
  return Gr(Wr({}, t), { level: t?.level || pp.level });
}
function _p(t, e = pr) {
  return t[e] || "";
}
function Ip(t, e, i = pr) {
  return t[i] = e, t;
}
function je(t, e = pr) {
  let i = "";
  return typeof t.bindings > "u" ? i = _p(t, e) : i = t.bindings().context || "", i;
}
function Dp(t, e, i = pr) {
  const r = je(t, i);
  return r.trim() ? `${r}/${e}` : e;
}
function Fe(t, e, i = pr) {
  const r = Dp(t, e, i), s = t.child({ context: r });
  return Ip(s, r, i);
}
function Sp(t) {
  var e, i;
  const r = new gp((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes);
  return { logger: as(Gr(Wr({}, t.opts), { level: "trace", browser: Gr(Wr({}, (i = t.opts) == null ? void 0 : i.browser), { write: (s) => r.write(s) }) })), chunkLoggerController: r };
}
function $p(t) {
  var e;
  const i = new yp((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes);
  return { logger: as(Gr(Wr({}, t.opts), { level: "trace" }), i), chunkLoggerController: i };
}
function Op(t) {
  return typeof t.loggerOverride < "u" && typeof t.loggerOverride != "string" ? { logger: t.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? Sp(t) : $p(t);
}
var xp = Object.defineProperty, Ap = (t, e, i) => e in t ? xp(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Wo = (t, e, i) => Ap(t, typeof e != "symbol" ? e + "" : e, i);
let Pp = class extends ni {
  constructor(e) {
    super(), this.opts = e, Wo(this, "protocol", "wc"), Wo(this, "version", 2);
  }
};
var Cp = Object.defineProperty, Rp = (t, e, i) => e in t ? Cp(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Tp = (t, e, i) => Rp(t, typeof e != "symbol" ? e + "" : e, i);
class Np extends ni {
  constructor(e, i) {
    super(), this.core = e, this.logger = i, Tp(this, "records", /* @__PURE__ */ new Map());
  }
}
let Fp = class {
  constructor(e, i) {
    this.logger = e, this.core = i;
  }
};
class Lp extends ni {
  constructor(e, i) {
    super(), this.relayer = e, this.logger = i;
  }
}
let Bp = class extends ni {
  constructor(e) {
    super();
  }
}, Up = class {
  constructor(e, i, r, s) {
    this.core = e, this.logger = i, this.name = r;
  }
}, kp = class extends ni {
  constructor(e, i) {
    super(), this.relayer = e, this.logger = i;
  }
}, Mp = class extends ni {
  constructor(e, i) {
    super(), this.core = e, this.logger = i;
  }
}, qp = class {
  constructor(e, i, r) {
    this.core = e, this.logger = i, this.store = r;
  }
};
class jp {
  constructor(e, i) {
    this.projectId = e, this.logger = i;
  }
}
let zp = class {
  constructor(e, i, r) {
    this.core = e, this.logger = i, this.telemetryEnabled = r;
  }
};
var Vp = Object.defineProperty, Kp = (t, e, i) => e in t ? Vp(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Go = (t, e, i) => Kp(t, typeof e != "symbol" ? e + "" : e, i);
let Hp = class {
  constructor(e) {
    this.opts = e, Go(this, "protocol", "wc"), Go(this, "version", 2);
  }
}, Wp = class {
  constructor(e) {
    this.client = e;
  }
};
function Gp(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function fu(t, ...e) {
  if (!Gp(t))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function Yo(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function Yp(t, e) {
  fu(t);
  const i = e.outputLen;
  if (t.length < i)
    throw new Error("digestInto() expects output buffer of length at least " + i);
}
const fi = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Rs = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength);
function Jp(t) {
  if (typeof t != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof t);
  return new Uint8Array(new TextEncoder().encode(t));
}
function gu(t) {
  return typeof t == "string" && (t = Jp(t)), fu(t), t;
}
let Zp = class {
  clone() {
    return this._cloneInto();
  }
};
function Qp(t) {
  const e = (r) => t().update(gu(r)).digest(), i = t();
  return e.outputLen = i.outputLen, e.blockLen = i.blockLen, e.create = () => t(), e;
}
function yu(t = 32) {
  if (fi && typeof fi.getRandomValues == "function")
    return fi.getRandomValues(new Uint8Array(t));
  if (fi && typeof fi.randomBytes == "function")
    return fi.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
function Xp(t, e, i, r) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, i, r);
  const s = BigInt(32), n = BigInt(4294967295), o = Number(i >> s & n), a = Number(i & n), c = r ? 4 : 0, u = r ? 0 : 4;
  t.setUint32(e + c, o, r), t.setUint32(e + u, a, r);
}
let ef = class extends Zp {
  constructor(e, i, r, s) {
    super(), this.blockLen = e, this.outputLen = i, this.padOffset = r, this.isLE = s, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Rs(this.buffer);
  }
  update(e) {
    Yo(this);
    const { view: i, buffer: r, blockLen: s } = this;
    e = gu(e);
    const n = e.length;
    for (let o = 0; o < n; ) {
      const a = Math.min(s - this.pos, n - o);
      if (a === s) {
        const c = Rs(e);
        for (; s <= n - o; o += s)
          this.process(c, o);
        continue;
      }
      r.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === s && (this.process(i, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Yo(this), Yp(e, this), this.finished = !0;
    const { buffer: i, view: r, blockLen: s, isLE: n } = this;
    let { pos: o } = this;
    i[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > s - o && (this.process(r, 0), o = 0);
    for (let h = o; h < s; h++)
      i[h] = 0;
    Xp(r, s - 8, BigInt(this.length * 8), n), this.process(r, 0);
    const a = Rs(e), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let h = 0; h < u; h++)
      a.setUint32(4 * h, l[h], n);
  }
  digest() {
    const { buffer: e, outputLen: i } = this;
    this.digestInto(e);
    const r = e.slice(0, i);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: i, buffer: r, length: s, finished: n, destroyed: o, pos: a } = this;
    return e.length = s, e.pos = a, e.finished = n, e.destroyed = o, s % i && e.buffer.set(r), e;
  }
};
const Ar = BigInt(2 ** 32 - 1), gn = BigInt(32);
function wu(t, e = !1) {
  return e ? { h: Number(t & Ar), l: Number(t >> gn & Ar) } : { h: Number(t >> gn & Ar) | 0, l: Number(t & Ar) | 0 };
}
function tf(t, e = !1) {
  let i = new Uint32Array(t.length), r = new Uint32Array(t.length);
  for (let s = 0; s < t.length; s++) {
    const { h: n, l: o } = wu(t[s], e);
    [i[s], r[s]] = [n, o];
  }
  return [i, r];
}
const rf = (t, e) => BigInt(t >>> 0) << gn | BigInt(e >>> 0), sf = (t, e, i) => t >>> i, nf = (t, e, i) => t << 32 - i | e >>> i, of = (t, e, i) => t >>> i | e << 32 - i, af = (t, e, i) => t << 32 - i | e >>> i, cf = (t, e, i) => t << 64 - i | e >>> i - 32, uf = (t, e, i) => t >>> i - 32 | e << 64 - i, lf = (t, e) => e, hf = (t, e) => t, df = (t, e, i) => t << i | e >>> 32 - i, pf = (t, e, i) => e << i | t >>> 32 - i, ff = (t, e, i) => e << i - 32 | t >>> 64 - i, gf = (t, e, i) => t << i - 32 | e >>> 64 - i;
function yf(t, e, i, r) {
  const s = (e >>> 0) + (r >>> 0);
  return { h: t + i + (s / 2 ** 32 | 0) | 0, l: s | 0 };
}
const wf = (t, e, i) => (t >>> 0) + (e >>> 0) + (i >>> 0), mf = (t, e, i, r) => e + i + r + (t / 2 ** 32 | 0) | 0, bf = (t, e, i, r) => (t >>> 0) + (e >>> 0) + (i >>> 0) + (r >>> 0), vf = (t, e, i, r, s) => e + i + r + s + (t / 2 ** 32 | 0) | 0, Ef = (t, e, i, r, s) => (t >>> 0) + (e >>> 0) + (i >>> 0) + (r >>> 0) + (s >>> 0), _f = (t, e, i, r, s, n) => e + i + r + s + n + (t / 2 ** 32 | 0) | 0, K = { fromBig: wu, split: tf, toBig: rf, shrSH: sf, shrSL: nf, rotrSH: of, rotrSL: af, rotrBH: cf, rotrBL: uf, rotr32H: lf, rotr32L: hf, rotlSH: df, rotlSL: pf, rotlBH: ff, rotlBL: gf, add: yf, add3L: wf, add3H: mf, add4L: bf, add4H: vf, add5H: _f, add5L: Ef }, [If, Df] = (() => K.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t) => BigInt(t))))(), Pt = new Uint32Array(80), Ct = new Uint32Array(80);
let Sf = class extends ef {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: e, Al: i, Bh: r, Bl: s, Ch: n, Cl: o, Dh: a, Dl: c, Eh: u, El: l, Fh: h, Fl: d, Gh: f, Gl: p, Hh: g, Hl: y } = this;
    return [e, i, r, s, n, o, a, c, u, l, h, d, f, p, g, y];
  }
  set(e, i, r, s, n, o, a, c, u, l, h, d, f, p, g, y) {
    this.Ah = e | 0, this.Al = i | 0, this.Bh = r | 0, this.Bl = s | 0, this.Ch = n | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = u | 0, this.El = l | 0, this.Fh = h | 0, this.Fl = d | 0, this.Gh = f | 0, this.Gl = p | 0, this.Hh = g | 0, this.Hl = y | 0;
  }
  process(e, i) {
    for (let b = 0; b < 16; b++, i += 4)
      Pt[b] = e.getUint32(i), Ct[b] = e.getUint32(i += 4);
    for (let b = 16; b < 80; b++) {
      const E = Pt[b - 15] | 0, O = Ct[b - 15] | 0, S = K.rotrSH(E, O, 1) ^ K.rotrSH(E, O, 8) ^ K.shrSH(E, O, 7), $ = K.rotrSL(E, O, 1) ^ K.rotrSL(E, O, 8) ^ K.shrSL(E, O, 7), A = Pt[b - 2] | 0, I = Ct[b - 2] | 0, M = K.rotrSH(A, I, 19) ^ K.rotrBH(A, I, 61) ^ K.shrSH(A, I, 6), L = K.rotrSL(A, I, 19) ^ K.rotrBL(A, I, 61) ^ K.shrSL(A, I, 6), U = K.add4L($, L, Ct[b - 7], Ct[b - 16]), q = K.add4H(U, S, M, Pt[b - 7], Pt[b - 16]);
      Pt[b] = q | 0, Ct[b] = U | 0;
    }
    let { Ah: r, Al: s, Bh: n, Bl: o, Ch: a, Cl: c, Dh: u, Dl: l, Eh: h, El: d, Fh: f, Fl: p, Gh: g, Gl: y, Hh: m, Hl: w } = this;
    for (let b = 0; b < 80; b++) {
      const E = K.rotrSH(h, d, 14) ^ K.rotrSH(h, d, 18) ^ K.rotrBH(h, d, 41), O = K.rotrSL(h, d, 14) ^ K.rotrSL(h, d, 18) ^ K.rotrBL(h, d, 41), S = h & f ^ ~h & g, $ = d & p ^ ~d & y, A = K.add5L(w, O, $, Df[b], Ct[b]), I = K.add5H(A, m, E, S, If[b], Pt[b]), M = A | 0, L = K.rotrSH(r, s, 28) ^ K.rotrBH(r, s, 34) ^ K.rotrBH(r, s, 39), U = K.rotrSL(r, s, 28) ^ K.rotrBL(r, s, 34) ^ K.rotrBL(r, s, 39), q = r & n ^ r & a ^ n & a, C = s & o ^ s & c ^ o & c;
      m = g | 0, w = y | 0, g = f | 0, y = p | 0, f = h | 0, p = d | 0, { h, l: d } = K.add(u | 0, l | 0, I | 0, M | 0), u = a | 0, l = c | 0, a = n | 0, c = o | 0, n = r | 0, o = s | 0;
      const _ = K.add3L(M, U, C);
      r = K.add3H(_, I, L, q), s = _ | 0;
    }
    ({ h: r, l: s } = K.add(this.Ah | 0, this.Al | 0, r | 0, s | 0)), { h: n, l: o } = K.add(this.Bh | 0, this.Bl | 0, n | 0, o | 0), { h: a, l: c } = K.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: u, l } = K.add(this.Dh | 0, this.Dl | 0, u | 0, l | 0), { h, l: d } = K.add(this.Eh | 0, this.El | 0, h | 0, d | 0), { h: f, l: p } = K.add(this.Fh | 0, this.Fl | 0, f | 0, p | 0), { h: g, l: y } = K.add(this.Gh | 0, this.Gl | 0, g | 0, y | 0), { h: m, l: w } = K.add(this.Hh | 0, this.Hl | 0, m | 0, w | 0), this.set(r, s, n, o, a, c, u, l, h, d, f, p, g, y, m, w);
  }
  roundClean() {
    Pt.fill(0), Ct.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
const $f = Qp(() => new Sf());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Yn = BigInt(0), mu = BigInt(1), Of = BigInt(2);
function Jn(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Zn(t) {
  if (!Jn(t))
    throw new Error("Uint8Array expected");
}
function Ts(t, e) {
  if (typeof e != "boolean")
    throw new Error(t + " boolean expected, got " + e);
}
const xf = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Qn(t) {
  Zn(t);
  let e = "";
  for (let i = 0; i < t.length; i++)
    e += xf[t[i]];
  return e;
}
function bu(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  return t === "" ? Yn : BigInt("0x" + t);
}
const bt = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Jo(t) {
  if (t >= bt._0 && t <= bt._9)
    return t - bt._0;
  if (t >= bt.A && t <= bt.F)
    return t - (bt.A - 10);
  if (t >= bt.a && t <= bt.f)
    return t - (bt.a - 10);
}
function vu(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  const e = t.length, i = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const r = new Uint8Array(i);
  for (let s = 0, n = 0; s < i; s++, n += 2) {
    const o = Jo(t.charCodeAt(n)), a = Jo(t.charCodeAt(n + 1));
    if (o === void 0 || a === void 0) {
      const c = t[n] + t[n + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + n);
    }
    r[s] = o * 16 + a;
  }
  return r;
}
function Af(t) {
  return bu(Qn(t));
}
function qr(t) {
  return Zn(t), bu(Qn(Uint8Array.from(t).reverse()));
}
function Eu(t, e) {
  return vu(t.toString(16).padStart(e * 2, "0"));
}
function yn(t, e) {
  return Eu(t, e).reverse();
}
function vt(t, e, i) {
  let r;
  if (typeof e == "string")
    try {
      r = vu(e);
    } catch (n) {
      throw new Error(t + " must be hex string or Uint8Array, cause: " + n);
    }
  else if (Jn(e))
    r = Uint8Array.from(e);
  else
    throw new Error(t + " must be hex string or Uint8Array");
  const s = r.length;
  if (typeof i == "number" && s !== i)
    throw new Error(t + " of length " + i + " expected, got " + s);
  return r;
}
function Zo(...t) {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    Zn(s), e += s.length;
  }
  const i = new Uint8Array(e);
  for (let r = 0, s = 0; r < t.length; r++) {
    const n = t[r];
    i.set(n, s), s += n.length;
  }
  return i;
}
const Ns = (t) => typeof t == "bigint" && Yn <= t;
function Pf(t, e, i) {
  return Ns(t) && Ns(e) && Ns(i) && e <= t && t < i;
}
function qi(t, e, i, r) {
  if (!Pf(e, i, r))
    throw new Error("expected valid " + t + ": " + i + " <= n < " + r + ", got " + e);
}
function Cf(t) {
  let e;
  for (e = 0; t > Yn; t >>= mu, e += 1)
    ;
  return e;
}
const Rf = (t) => (Of << BigInt(t - 1)) - mu, Tf = { bigint: (t) => typeof t == "bigint", function: (t) => typeof t == "function", boolean: (t) => typeof t == "boolean", string: (t) => typeof t == "string", stringOrUint8Array: (t) => typeof t == "string" || Jn(t), isSafeInteger: (t) => Number.isSafeInteger(t), array: (t) => Array.isArray(t), field: (t, e) => e.Fp.isValid(t), hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen) };
function Xn(t, e, i = {}) {
  const r = (s, n, o) => {
    const a = Tf[n];
    if (typeof a != "function")
      throw new Error("invalid validator function");
    const c = t[s];
    if (!(o && c === void 0) && !a(c, t))
      throw new Error("param " + String(s) + " is invalid. Expected " + n + ", got " + c);
  };
  for (const [s, n] of Object.entries(e))
    r(s, n, !1);
  for (const [s, n] of Object.entries(i))
    r(s, n, !0);
  return t;
}
function Qo(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return (i, ...r) => {
    const s = e.get(i);
    if (s !== void 0)
      return s;
    const n = t(i, ...r);
    return e.set(i, n), n;
  };
}
const ve = BigInt(0), ue = BigInt(1), Wt = BigInt(2), Nf = BigInt(3), wn = BigInt(4), Xo = BigInt(5), ea = BigInt(8);
function fe(t, e) {
  const i = t % e;
  return i >= ve ? i : e + i;
}
function Ff(t, e, i) {
  if (e < ve)
    throw new Error("invalid exponent, negatives unsupported");
  if (i <= ve)
    throw new Error("invalid modulus");
  if (i === ue)
    return ve;
  let r = ue;
  for (; e > ve; )
    e & ue && (r = r * t % i), t = t * t % i, e >>= ue;
  return r;
}
function at(t, e, i) {
  let r = t;
  for (; e-- > ve; )
    r *= r, r %= i;
  return r;
}
function ta(t, e) {
  if (t === ve)
    throw new Error("invert: expected non-zero number");
  if (e <= ve)
    throw new Error("invert: expected positive modulus, got " + e);
  let i = fe(t, e), r = e, s = ve, n = ue;
  for (; i !== ve; ) {
    const o = r / i, a = r % i, c = s - n * o;
    r = i, i = a, s = n, n = c;
  }
  if (r !== ue)
    throw new Error("invert: does not exist");
  return fe(s, e);
}
function Lf(t) {
  const e = (t - ue) / Wt;
  let i, r, s;
  for (i = t - ue, r = 0; i % Wt === ve; i /= Wt, r++)
    ;
  for (s = Wt; s < t && Ff(s, e, t) !== t - ue; s++)
    if (s > 1e3)
      throw new Error("Cannot find square root: likely non-prime P");
  if (r === 1) {
    const o = (t + ue) / wn;
    return function(a, c) {
      const u = a.pow(c, o);
      if (!a.eql(a.sqr(u), c))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  const n = (i + ue) / Wt;
  return function(o, a) {
    if (o.pow(a, e) === o.neg(o.ONE))
      throw new Error("Cannot find square root");
    let c = r, u = o.pow(o.mul(o.ONE, s), i), l = o.pow(a, n), h = o.pow(a, i);
    for (; !o.eql(h, o.ONE); ) {
      if (o.eql(h, o.ZERO))
        return o.ZERO;
      let d = 1;
      for (let p = o.sqr(h); d < c && !o.eql(p, o.ONE); d++)
        p = o.sqr(p);
      const f = o.pow(u, ue << BigInt(c - d - 1));
      u = o.sqr(f), l = o.mul(l, f), h = o.mul(h, u), c = d;
    }
    return l;
  };
}
function Bf(t) {
  if (t % wn === Nf) {
    const e = (t + ue) / wn;
    return function(i, r) {
      const s = i.pow(r, e);
      if (!i.eql(i.sqr(s), r))
        throw new Error("Cannot find square root");
      return s;
    };
  }
  if (t % ea === Xo) {
    const e = (t - Xo) / ea;
    return function(i, r) {
      const s = i.mul(r, Wt), n = i.pow(s, e), o = i.mul(r, n), a = i.mul(i.mul(o, Wt), n), c = i.mul(o, i.sub(a, i.ONE));
      if (!i.eql(i.sqr(c), r))
        throw new Error("Cannot find square root");
      return c;
    };
  }
  return Lf(t);
}
const Uf = (t, e) => (fe(t, e) & ue) === ue, kf = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function Mf(t) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, i = kf.reduce((r, s) => (r[s] = "function", r), e);
  return Xn(t, i);
}
function qf(t, e, i) {
  if (i < ve)
    throw new Error("invalid exponent, negatives unsupported");
  if (i === ve)
    return t.ONE;
  if (i === ue)
    return e;
  let r = t.ONE, s = e;
  for (; i > ve; )
    i & ue && (r = t.mul(r, s)), s = t.sqr(s), i >>= ue;
  return r;
}
function jf(t, e) {
  const i = new Array(e.length), r = e.reduce((n, o, a) => t.is0(o) ? n : (i[a] = n, t.mul(n, o)), t.ONE), s = t.inv(r);
  return e.reduceRight((n, o, a) => t.is0(o) ? n : (i[a] = t.mul(n, i[a]), t.mul(n, o)), s), i;
}
function _u(t, e) {
  const i = e !== void 0 ? e : t.toString(2).length, r = Math.ceil(i / 8);
  return { nBitLength: i, nByteLength: r };
}
function Iu(t, e, i = !1, r = {}) {
  if (t <= ve)
    throw new Error("invalid field: expected ORDER > 0, got " + t);
  const { nBitLength: s, nByteLength: n } = _u(t, e);
  if (n > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let o;
  const a = Object.freeze({ ORDER: t, isLE: i, BITS: s, BYTES: n, MASK: Rf(s), ZERO: ve, ONE: ue, create: (c) => fe(c, t), isValid: (c) => {
    if (typeof c != "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof c);
    return ve <= c && c < t;
  }, is0: (c) => c === ve, isOdd: (c) => (c & ue) === ue, neg: (c) => fe(-c, t), eql: (c, u) => c === u, sqr: (c) => fe(c * c, t), add: (c, u) => fe(c + u, t), sub: (c, u) => fe(c - u, t), mul: (c, u) => fe(c * u, t), pow: (c, u) => qf(a, c, u), div: (c, u) => fe(c * ta(u, t), t), sqrN: (c) => c * c, addN: (c, u) => c + u, subN: (c, u) => c - u, mulN: (c, u) => c * u, inv: (c) => ta(c, t), sqrt: r.sqrt || ((c) => (o || (o = Bf(t)), o(a, c))), invertBatch: (c) => jf(a, c), cmov: (c, u, l) => l ? u : c, toBytes: (c) => i ? yn(c, n) : Eu(c, n), fromBytes: (c) => {
    if (c.length !== n)
      throw new Error("Field.fromBytes: expected " + n + " bytes, got " + c.length);
    return i ? qr(c) : Af(c);
  } });
  return Object.freeze(a);
}
const ia = BigInt(0), Pr = BigInt(1);
function Fs(t, e) {
  const i = e.negate();
  return t ? i : e;
}
function Du(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e)
    throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function Ls(t, e) {
  Du(t, e);
  const i = Math.ceil(e / t) + 1, r = 2 ** (t - 1);
  return { windows: i, windowSize: r };
}
function zf(t, e) {
  if (!Array.isArray(t))
    throw new Error("array expected");
  t.forEach((i, r) => {
    if (!(i instanceof e))
      throw new Error("invalid point at index " + r);
  });
}
function Vf(t, e) {
  if (!Array.isArray(t))
    throw new Error("array of scalars expected");
  t.forEach((i, r) => {
    if (!e.isValid(i))
      throw new Error("invalid scalar at index " + r);
  });
}
const Bs = /* @__PURE__ */ new WeakMap(), Su = /* @__PURE__ */ new WeakMap();
function Us(t) {
  return Su.get(t) || 1;
}
function Kf(t, e) {
  return { constTimeNegate: Fs, hasPrecomputes(i) {
    return Us(i) !== 1;
  }, unsafeLadder(i, r, s = t.ZERO) {
    let n = i;
    for (; r > ia; )
      r & Pr && (s = s.add(n)), n = n.double(), r >>= Pr;
    return s;
  }, precomputeWindow(i, r) {
    const { windows: s, windowSize: n } = Ls(r, e), o = [];
    let a = i, c = a;
    for (let u = 0; u < s; u++) {
      c = a, o.push(c);
      for (let l = 1; l < n; l++)
        c = c.add(a), o.push(c);
      a = c.double();
    }
    return o;
  }, wNAF(i, r, s) {
    const { windows: n, windowSize: o } = Ls(i, e);
    let a = t.ZERO, c = t.BASE;
    const u = BigInt(2 ** i - 1), l = 2 ** i, h = BigInt(i);
    for (let d = 0; d < n; d++) {
      const f = d * o;
      let p = Number(s & u);
      s >>= h, p > o && (p -= l, s += Pr);
      const g = f, y = f + Math.abs(p) - 1, m = d % 2 !== 0, w = p < 0;
      p === 0 ? c = c.add(Fs(m, r[g])) : a = a.add(Fs(w, r[y]));
    }
    return { p: a, f: c };
  }, wNAFUnsafe(i, r, s, n = t.ZERO) {
    const { windows: o, windowSize: a } = Ls(i, e), c = BigInt(2 ** i - 1), u = 2 ** i, l = BigInt(i);
    for (let h = 0; h < o; h++) {
      const d = h * a;
      if (s === ia)
        break;
      let f = Number(s & c);
      if (s >>= l, f > a && (f -= u, s += Pr), f === 0)
        continue;
      let p = r[d + Math.abs(f) - 1];
      f < 0 && (p = p.negate()), n = n.add(p);
    }
    return n;
  }, getPrecomputes(i, r, s) {
    let n = Bs.get(r);
    return n || (n = this.precomputeWindow(r, i), i !== 1 && Bs.set(r, s(n))), n;
  }, wNAFCached(i, r, s) {
    const n = Us(i);
    return this.wNAF(n, this.getPrecomputes(n, i, s), r);
  }, wNAFCachedUnsafe(i, r, s, n) {
    const o = Us(i);
    return o === 1 ? this.unsafeLadder(i, r, n) : this.wNAFUnsafe(o, this.getPrecomputes(o, i, s), r, n);
  }, setWindowSize(i, r) {
    Du(r, e), Su.set(i, r), Bs.delete(i);
  } };
}
function Hf(t, e, i, r) {
  if (zf(i, t), Vf(r, e), i.length !== r.length)
    throw new Error("arrays of points and scalars must have equal length");
  const s = t.ZERO, n = Cf(BigInt(i.length)), o = n > 12 ? n - 3 : n > 4 ? n - 2 : n ? 2 : 1, a = (1 << o) - 1, c = new Array(a + 1).fill(s), u = Math.floor((e.BITS - 1) / o) * o;
  let l = s;
  for (let h = u; h >= 0; h -= o) {
    c.fill(s);
    for (let f = 0; f < r.length; f++) {
      const p = r[f], g = Number(p >> BigInt(h) & BigInt(a));
      c[g] = c[g].add(i[f]);
    }
    let d = s;
    for (let f = c.length - 1, p = s; f > 0; f--)
      p = p.add(c[f]), d = d.add(p);
    if (l = l.add(d), h !== 0)
      for (let f = 0; f < o; f++)
        l = l.double();
  }
  return l;
}
function Wf(t) {
  return Mf(t.Fp), Xn(t, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ..._u(t.n, t.nBitLength), ...t, p: t.Fp.ORDER });
}
const et = BigInt(0), Le = BigInt(1), Cr = BigInt(2), Gf = BigInt(8), Yf = { zip215: !0 };
function Jf(t) {
  const e = Wf(t);
  return Xn(t, { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" }, { adjustScalarBytes: "function", domain: "function", uvRatio: "function", mapToCurve: "function" }), Object.freeze({ ...e });
}
function Zf(t) {
  const e = Jf(t), { Fp: i, n: r, prehash: s, hash: n, randomBytes: o, nByteLength: a, h: c } = e, u = Cr << BigInt(a * 8) - Le, l = i.create, h = Iu(e.n, e.nBitLength), d = e.uvRatio || ((_, v) => {
    try {
      return { isValid: !0, value: i.sqrt(_ * i.inv(v)) };
    } catch {
      return { isValid: !1, value: et };
    }
  }), f = e.adjustScalarBytes || ((_) => _), p = e.domain || ((_, v, x) => {
    if (Ts("phflag", x), v.length || x)
      throw new Error("Contexts/pre-hash are not supported");
    return _;
  });
  function g(_, v) {
    qi("coordinate " + _, v, et, u);
  }
  function y(_) {
    if (!(_ instanceof b))
      throw new Error("ExtendedPoint expected");
  }
  const m = Qo((_, v) => {
    const { ex: x, ey: P, ez: D } = _, N = _.is0();
    v == null && (v = N ? Gf : i.inv(D));
    const B = l(x * v), k = l(P * v), j = l(D * v);
    if (N)
      return { x: et, y: Le };
    if (j !== Le)
      throw new Error("invZ was invalid");
    return { x: B, y: k };
  }), w = Qo((_) => {
    const { a: v, d: x } = e;
    if (_.is0())
      throw new Error("bad point: ZERO");
    const { ex: P, ey: D, ez: N, et: B } = _, k = l(P * P), j = l(D * D), z = l(N * N), H = l(z * z), Y = l(k * v), ne = l(z * l(Y + j)), ee = l(H + l(x * l(k * j)));
    if (ne !== ee)
      throw new Error("bad point: equation left != right (1)");
    const J = l(P * D), Pe = l(N * B);
    if (J !== Pe)
      throw new Error("bad point: equation left != right (2)");
    return !0;
  });
  class b {
    constructor(v, x, P, D) {
      this.ex = v, this.ey = x, this.ez = P, this.et = D, g("x", v), g("y", x), g("z", P), g("t", D), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(v) {
      if (v instanceof b)
        throw new Error("extended point not allowed");
      const { x, y: P } = v || {};
      return g("x", x), g("y", P), new b(x, P, Le, l(x * P));
    }
    static normalizeZ(v) {
      const x = i.invertBatch(v.map((P) => P.ez));
      return v.map((P, D) => P.toAffine(x[D])).map(b.fromAffine);
    }
    static msm(v, x) {
      return Hf(b, h, v, x);
    }
    _setWindowSize(v) {
      S.setWindowSize(this, v);
    }
    assertValidity() {
      w(this);
    }
    equals(v) {
      y(v);
      const { ex: x, ey: P, ez: D } = this, { ex: N, ey: B, ez: k } = v, j = l(x * k), z = l(N * D), H = l(P * k), Y = l(B * D);
      return j === z && H === Y;
    }
    is0() {
      return this.equals(b.ZERO);
    }
    negate() {
      return new b(l(-this.ex), this.ey, this.ez, l(-this.et));
    }
    double() {
      const { a: v } = e, { ex: x, ey: P, ez: D } = this, N = l(x * x), B = l(P * P), k = l(Cr * l(D * D)), j = l(v * N), z = x + P, H = l(l(z * z) - N - B), Y = j + B, ne = Y - k, ee = j - B, J = l(H * ne), Pe = l(Y * ee), _e = l(H * ee), Re = l(ne * Y);
      return new b(J, Pe, Re, _e);
    }
    add(v) {
      y(v);
      const { a: x, d: P } = e, { ex: D, ey: N, ez: B, et: k } = this, { ex: j, ey: z, ez: H, et: Y } = v;
      if (x === BigInt(-1)) {
        const vo = l((N - D) * (z + j)), Eo = l((N + D) * (z - j)), Ds = l(Eo - vo);
        if (Ds === et)
          return this.double();
        const _o = l(B * Cr * Y), Io = l(k * Cr * H), Do = Io + _o, So = Eo + vo, $o = Io - _o, _h = l(Do * Ds), Ih = l(So * $o), Dh = l(Do * $o), Sh = l(Ds * So);
        return new b(_h, Ih, Sh, Dh);
      }
      const ne = l(D * j), ee = l(N * z), J = l(k * P * Y), Pe = l(B * H), _e = l((D + N) * (j + z) - ne - ee), Re = Pe - J, Ye = Pe + J, mt = l(ee - x * ne), ui = l(_e * Re), bh = l(Ye * mt), vh = l(_e * mt), Eh = l(Re * Ye);
      return new b(ui, bh, Eh, vh);
    }
    subtract(v) {
      return this.add(v.negate());
    }
    wNAF(v) {
      return S.wNAFCached(this, v, b.normalizeZ);
    }
    multiply(v) {
      const x = v;
      qi("scalar", x, Le, r);
      const { p: P, f: D } = this.wNAF(x);
      return b.normalizeZ([P, D])[0];
    }
    multiplyUnsafe(v, x = b.ZERO) {
      const P = v;
      return qi("scalar", P, et, r), P === et ? O : this.is0() || P === Le ? this : S.wNAFCachedUnsafe(this, P, b.normalizeZ, x);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(c).is0();
    }
    isTorsionFree() {
      return S.unsafeLadder(this, r).is0();
    }
    toAffine(v) {
      return m(this, v);
    }
    clearCofactor() {
      const { h: v } = e;
      return v === Le ? this : this.multiplyUnsafe(v);
    }
    static fromHex(v, x = !1) {
      const { d: P, a: D } = e, N = i.BYTES;
      v = vt("pointHex", v, N), Ts("zip215", x);
      const B = v.slice(), k = v[N - 1];
      B[N - 1] = k & -129;
      const j = qr(B), z = x ? u : i.ORDER;
      qi("pointHex.y", j, et, z);
      const H = l(j * j), Y = l(H - Le), ne = l(P * H - D);
      let { isValid: ee, value: J } = d(Y, ne);
      if (!ee)
        throw new Error("Point.fromHex: invalid y coordinate");
      const Pe = (J & Le) === Le, _e = (k & 128) !== 0;
      if (!x && J === et && _e)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      return _e !== Pe && (J = l(-J)), b.fromAffine({ x: J, y: j });
    }
    static fromPrivateKey(v) {
      return I(v).point;
    }
    toRawBytes() {
      const { x: v, y: x } = this.toAffine(), P = yn(x, i.BYTES);
      return P[P.length - 1] |= v & Le ? 128 : 0, P;
    }
    toHex() {
      return Qn(this.toRawBytes());
    }
  }
  b.BASE = new b(e.Gx, e.Gy, Le, l(e.Gx * e.Gy)), b.ZERO = new b(et, Le, Le, et);
  const { BASE: E, ZERO: O } = b, S = Kf(b, a * 8);
  function $(_) {
    return fe(_, r);
  }
  function A(_) {
    return $(qr(_));
  }
  function I(_) {
    const v = i.BYTES;
    _ = vt("private key", _, v);
    const x = vt("hashed private key", n(_), 2 * v), P = f(x.slice(0, v)), D = x.slice(v, 2 * v), N = A(P), B = E.multiply(N), k = B.toRawBytes();
    return { head: P, prefix: D, scalar: N, point: B, pointBytes: k };
  }
  function M(_) {
    return I(_).pointBytes;
  }
  function L(_ = new Uint8Array(), ...v) {
    const x = Zo(...v);
    return A(n(p(x, vt("context", _), !!s)));
  }
  function U(_, v, x = {}) {
    _ = vt("message", _), s && (_ = s(_));
    const { prefix: P, scalar: D, pointBytes: N } = I(v), B = L(x.context, P, _), k = E.multiply(B).toRawBytes(), j = L(x.context, k, N, _), z = $(B + j * D);
    qi("signature.s", z, et, r);
    const H = Zo(k, yn(z, i.BYTES));
    return vt("result", H, i.BYTES * 2);
  }
  const q = Yf;
  function C(_, v, x, P = q) {
    const { context: D, zip215: N } = P, B = i.BYTES;
    _ = vt("signature", _, 2 * B), v = vt("message", v), x = vt("publicKey", x, B), N !== void 0 && Ts("zip215", N), s && (v = s(v));
    const k = qr(_.slice(B, 2 * B));
    let j, z, H;
    try {
      j = b.fromHex(x, N), z = b.fromHex(_.slice(0, B), N), H = E.multiplyUnsafe(k);
    } catch {
      return !1;
    }
    if (!N && j.isSmallOrder())
      return !1;
    const Y = L(D, z.toRawBytes(), j.toRawBytes(), v);
    return z.add(j.multiplyUnsafe(Y)).subtract(H).clearCofactor().equals(b.ZERO);
  }
  return E._setWindowSize(8), { CURVE: e, getPublicKey: M, sign: U, verify: C, ExtendedPoint: b, utils: { getExtendedPublicKey: I, randomPrivateKey: () => o(i.BYTES), precompute(_ = 8, v = b.BASE) {
    return v._setWindowSize(_), v.multiply(BigInt(3)), v;
  } } };
}
BigInt(0), BigInt(1);
const eo = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), ra = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const Qf = BigInt(1), sa = BigInt(2);
BigInt(3);
const Xf = BigInt(5), eg = BigInt(8);
function tg(t) {
  const e = BigInt(10), i = BigInt(20), r = BigInt(40), s = BigInt(80), n = eo, o = t * t % n * t % n, a = at(o, sa, n) * o % n, c = at(a, Qf, n) * t % n, u = at(c, Xf, n) * c % n, l = at(u, e, n) * u % n, h = at(l, i, n) * l % n, d = at(h, r, n) * h % n, f = at(d, s, n) * d % n, p = at(f, s, n) * d % n, g = at(p, e, n) * u % n;
  return { pow_p_5_8: at(g, sa, n) * t % n, b2: o };
}
function ig(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
function rg(t, e) {
  const i = eo, r = fe(e * e * e, i), s = fe(r * r * e, i), n = tg(t * s).pow_p_5_8;
  let o = fe(t * r * n, i);
  const a = fe(e * o * o, i), c = o, u = fe(o * ra, i), l = a === t, h = a === fe(-t, i), d = a === fe(-t * ra, i);
  return l && (o = c), (h || d) && (o = u), Uf(o, i) && (o = fe(-o, i)), { isValid: l || h, value: o };
}
const sg = (() => Iu(eo, void 0, !0))(), ng = (() => ({ a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), Fp: sg, n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), h: eg, Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"), hash: $f, randomBytes: yu, adjustScalarBytes: ig, uvRatio: rg }))(), $u = (() => Zf(ng))(), og = "EdDSA", ag = "JWT", Yr = ".", cs = "base64url", Ou = "utf8", xu = "utf8", cg = ":", ug = "did", lg = "key", na = "base58btc", hg = "z", dg = "K36", pg = 32;
function to(t) {
  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t;
}
function Au(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? to(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t);
}
function Pu(t, e) {
  e || (e = t.reduce((s, n) => s + n.length, 0));
  const i = Au(e);
  let r = 0;
  for (const s of t)
    i.set(s, r), r += s.length;
  return to(i);
}
function fg(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var i = new Uint8Array(256), r = 0; r < i.length; r++)
    i[r] = 255;
  for (var s = 0; s < t.length; s++) {
    var n = t.charAt(s), o = n.charCodeAt(0);
    if (i[o] !== 255)
      throw new TypeError(n + " is ambiguous");
    i[o] = s;
  }
  var a = t.length, c = t.charAt(0), u = Math.log(a) / Math.log(256), l = Math.log(256) / Math.log(a);
  function h(p) {
    if (p instanceof Uint8Array || (ArrayBuffer.isView(p) ? p = new Uint8Array(p.buffer, p.byteOffset, p.byteLength) : Array.isArray(p) && (p = Uint8Array.from(p))), !(p instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (p.length === 0)
      return "";
    for (var g = 0, y = 0, m = 0, w = p.length; m !== w && p[m] === 0; )
      m++, g++;
    for (var b = (w - m) * l + 1 >>> 0, E = new Uint8Array(b); m !== w; ) {
      for (var O = p[m], S = 0, $ = b - 1; (O !== 0 || S < y) && $ !== -1; $--, S++)
        O += 256 * E[$] >>> 0, E[$] = O % a >>> 0, O = O / a >>> 0;
      if (O !== 0)
        throw new Error("Non-zero carry");
      y = S, m++;
    }
    for (var A = b - y; A !== b && E[A] === 0; )
      A++;
    for (var I = c.repeat(g); A < b; ++A)
      I += t.charAt(E[A]);
    return I;
  }
  function d(p) {
    if (typeof p != "string")
      throw new TypeError("Expected String");
    if (p.length === 0)
      return new Uint8Array();
    var g = 0;
    if (p[g] !== " ") {
      for (var y = 0, m = 0; p[g] === c; )
        y++, g++;
      for (var w = (p.length - g) * u + 1 >>> 0, b = new Uint8Array(w); p[g]; ) {
        var E = i[p.charCodeAt(g)];
        if (E === 255)
          return;
        for (var O = 0, S = w - 1; (E !== 0 || O < m) && S !== -1; S--, O++)
          E += a * b[S] >>> 0, b[S] = E % 256 >>> 0, E = E / 256 >>> 0;
        if (E !== 0)
          throw new Error("Non-zero carry");
        m = O, g++;
      }
      if (p[g] !== " ") {
        for (var $ = w - m; $ !== w && b[$] === 0; )
          $++;
        for (var A = new Uint8Array(y + (w - $)), I = y; $ !== w; )
          A[I++] = b[$++];
        return A;
      }
    }
  }
  function f(p) {
    var g = d(p);
    if (g)
      return g;
    throw new Error(`Non-${e} character`);
  }
  return { encode: h, decodeUnsafe: d, decode: f };
}
var gg = fg, yg = gg;
const Cu = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, wg = (t) => new TextEncoder().encode(t), mg = (t) => new TextDecoder().decode(t);
let bg = class {
  constructor(e, i, r) {
    this.name = e, this.prefix = i, this.baseEncode = r;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}, vg = class {
  constructor(e, i, r) {
    if (this.name = e, this.prefix = i, i.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = i.codePointAt(0), this.baseDecode = r;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Ru(this, e);
  }
}, Eg = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Ru(this, e);
  }
  decode(e) {
    const i = e[0], r = this.decoders[i];
    if (r)
      return r.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
const Ru = (t, e) => new Eg({ ...t.decoders || { [t.prefix]: t }, ...e.decoders || { [e.prefix]: e } });
let _g = class {
  constructor(e, i, r, s) {
    this.name = e, this.prefix = i, this.baseEncode = r, this.baseDecode = s, this.encoder = new bg(e, i, r), this.decoder = new vg(e, i, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
const us = ({ name: t, prefix: e, encode: i, decode: r }) => new _g(t, e, i, r), fr = ({ prefix: t, name: e, alphabet: i }) => {
  const { encode: r, decode: s } = yg(i, e);
  return us({ prefix: t, name: e, encode: r, decode: (n) => Cu(s(n)) });
}, Ig = (t, e, i, r) => {
  const s = {};
  for (let l = 0; l < e.length; ++l)
    s[e[l]] = l;
  let n = t.length;
  for (; t[n - 1] === "="; )
    --n;
  const o = new Uint8Array(n * i / 8 | 0);
  let a = 0, c = 0, u = 0;
  for (let l = 0; l < n; ++l) {
    const h = s[t[l]];
    if (h === void 0)
      throw new SyntaxError(`Non-${r} character`);
    c = c << i | h, a += i, a >= 8 && (a -= 8, o[u++] = 255 & c >> a);
  }
  if (a >= i || 255 & c << 8 - a)
    throw new SyntaxError("Unexpected end of data");
  return o;
}, Dg = (t, e, i) => {
  const r = e[e.length - 1] === "=", s = (1 << i) - 1;
  let n = "", o = 0, a = 0;
  for (let c = 0; c < t.length; ++c)
    for (a = a << 8 | t[c], o += 8; o > i; )
      o -= i, n += e[s & a >> o];
  if (o && (n += e[s & a << i - o]), r)
    for (; n.length * i & 7; )
      n += "=";
  return n;
}, Oe = ({ name: t, prefix: e, bitsPerChar: i, alphabet: r }) => us({ prefix: e, name: t, encode(s) {
  return Dg(s, r, i);
}, decode(s) {
  return Ig(s, r, i, t);
} }), Sg = us({ prefix: "\0", name: "identity", encode: (t) => mg(t), decode: (t) => wg(t) });
var $g = Object.freeze({ __proto__: null, identity: Sg });
const Og = Oe({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var xg = Object.freeze({ __proto__: null, base2: Og });
const Ag = Oe({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Pg = Object.freeze({ __proto__: null, base8: Ag });
const Cg = fr({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Rg = Object.freeze({ __proto__: null, base10: Cg });
const Tg = Oe({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), Ng = Oe({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Fg = Object.freeze({ __proto__: null, base16: Tg, base16upper: Ng });
const Lg = Oe({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), Bg = Oe({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), Ug = Oe({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), kg = Oe({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), Mg = Oe({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), qg = Oe({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), jg = Oe({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), zg = Oe({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), Vg = Oe({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Kg = Object.freeze({ __proto__: null, base32: Lg, base32upper: Bg, base32pad: Ug, base32padupper: kg, base32hex: Mg, base32hexupper: qg, base32hexpad: jg, base32hexpadupper: zg, base32z: Vg });
const Hg = fr({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), Wg = fr({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Gg = Object.freeze({ __proto__: null, base36: Hg, base36upper: Wg });
const Yg = fr({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), Jg = fr({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Zg = Object.freeze({ __proto__: null, base58btc: Yg, base58flickr: Jg });
const Qg = Oe({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), Xg = Oe({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), ey = Oe({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), ty = Oe({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var iy = Object.freeze({ __proto__: null, base64: Qg, base64pad: Xg, base64url: ey, base64urlpad: ty });
const Tu = Array.from(""), ry = Tu.reduce((t, e, i) => (t[i] = e, t), []), sy = Tu.reduce((t, e, i) => (t[e.codePointAt(0)] = i, t), []);
function ny(t) {
  return t.reduce((e, i) => (e += ry[i], e), "");
}
function oy(t) {
  const e = [];
  for (const i of t) {
    const r = sy[i.codePointAt(0)];
    if (r === void 0)
      throw new Error(`Non-base256emoji character: ${i}`);
    e.push(r);
  }
  return new Uint8Array(e);
}
const ay = us({ prefix: "", name: "base256emoji", encode: ny, decode: oy });
var cy = Object.freeze({ __proto__: null, base256emoji: ay }), uy = Nu, oa = 128, ly = 127, hy = ~ly, dy = Math.pow(2, 31);
function Nu(t, e, i) {
  e = e || [], i = i || 0;
  for (var r = i; t >= dy; )
    e[i++] = t & 255 | oa, t /= 128;
  for (; t & hy; )
    e[i++] = t & 255 | oa, t >>>= 7;
  return e[i] = t | 0, Nu.bytes = i - r + 1, e;
}
var py = mn, fy = 128, aa = 127;
function mn(t, r) {
  var i = 0, r = r || 0, s = 0, n = r, o, a = t.length;
  do {
    if (n >= a)
      throw mn.bytes = 0, new RangeError("Could not decode varint");
    o = t[n++], i += s < 28 ? (o & aa) << s : (o & aa) * Math.pow(2, s), s += 7;
  } while (o >= fy);
  return mn.bytes = n - r, i;
}
var gy = Math.pow(2, 7), yy = Math.pow(2, 14), wy = Math.pow(2, 21), my = Math.pow(2, 28), by = Math.pow(2, 35), vy = Math.pow(2, 42), Ey = Math.pow(2, 49), _y = Math.pow(2, 56), Iy = Math.pow(2, 63), Dy = function(t) {
  return t < gy ? 1 : t < yy ? 2 : t < wy ? 3 : t < my ? 4 : t < by ? 5 : t < vy ? 6 : t < Ey ? 7 : t < _y ? 8 : t < Iy ? 9 : 10;
}, Sy = { encode: uy, decode: py, encodingLength: Dy }, Fu = Sy;
const ca = (t, e, i = 0) => (Fu.encode(t, e, i), e), ua = (t) => Fu.encodingLength(t), bn = (t, e) => {
  const i = e.byteLength, r = ua(t), s = r + ua(i), n = new Uint8Array(s + i);
  return ca(t, n, 0), ca(i, n, r), n.set(e, s), new $y(t, i, e, n);
};
let $y = class {
  constructor(e, i, r, s) {
    this.code = e, this.size = i, this.digest = r, this.bytes = s;
  }
};
const Lu = ({ name: t, code: e, encode: i }) => new Oy(t, e, i);
let Oy = class {
  constructor(e, i, r) {
    this.name = e, this.code = i, this.encode = r;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const i = this.encode(e);
      return i instanceof Uint8Array ? bn(this.code, i) : i.then((r) => bn(this.code, r));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
const Bu = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)), xy = Lu({ name: "sha2-256", code: 18, encode: Bu("SHA-256") }), Ay = Lu({ name: "sha2-512", code: 19, encode: Bu("SHA-512") });
var Py = Object.freeze({ __proto__: null, sha256: xy, sha512: Ay });
const Uu = 0, Cy = "identity", ku = Cu, Ry = (t) => bn(Uu, ku(t)), Ty = { code: Uu, name: Cy, encode: ku, digest: Ry };
var Ny = Object.freeze({ __proto__: null, identity: Ty });
new TextEncoder(), new TextDecoder();
const la = { ...$g, ...xg, ...Pg, ...Rg, ...Fg, ...Kg, ...Gg, ...Zg, ...iy, ...cy };
({ ...Py, ...Ny });
function Mu(t, e, i, r) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: i }, decoder: { decode: r } };
}
const ha = Mu("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), ks = Mu("ascii", "a", (t) => {
  let e = "a";
  for (let i = 0; i < t.length; i++)
    e += String.fromCharCode(t[i]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = Au(t.length);
  for (let i = 0; i < t.length; i++)
    e[i] = t.charCodeAt(i);
  return e;
}), qu = { utf8: ha, "utf-8": ha, hex: la.base16, latin1: ks, ascii: ks, binary: ks, ...la };
function ls(t, e = "utf8") {
  const i = qu[e];
  if (!i)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : i.encoder.encode(t).substring(1);
}
function Ri(t, e = "utf8") {
  const i = qu[e];
  if (!i)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? to(globalThis.Buffer.from(t, "utf-8")) : i.decoder.decode(`${i.prefix}${t}`);
}
function da(t) {
  return Ii(ls(Ri(t, cs), Ou));
}
function Jr(t) {
  return ls(Ri(ei(t), Ou), cs);
}
function ju(t) {
  const e = Ri(dg, na), i = hg + ls(Pu([e, t]), na);
  return [ug, lg, i].join(cg);
}
function Fy(t) {
  return ls(t, cs);
}
function Ly(t) {
  return Ri(t, cs);
}
function By(t) {
  return Ri([Jr(t.header), Jr(t.payload)].join(Yr), xu);
}
function Uy(t) {
  return [Jr(t.header), Jr(t.payload), Fy(t.signature)].join(Yr);
}
function vn(t) {
  const e = t.split(Yr), i = da(e[0]), r = da(e[1]), s = Ly(e[2]), n = Ri(e.slice(0, 2).join(Yr), xu);
  return { header: i, payload: r, signature: s, data: n };
}
function pa(t = yu(pg)) {
  const e = $u.getPublicKey(t);
  return { secretKey: Pu([t, e]), publicKey: e };
}
async function ky(t, e, i, r, s = T.fromMiliseconds(Date.now())) {
  const n = { alg: og, typ: ag }, o = ju(r.publicKey), a = s + i, c = { iss: o, sub: t, aud: e, iat: s, exp: a }, u = By({ header: n, payload: c }), l = $u.sign(u, r.secretKey.slice(0, 32));
  return Uy({ header: n, payload: c, signature: l });
}
var ae = {};
Object.defineProperty(ae, "__esModule", { value: !0 });
ae.getLocalStorage = ae.getLocalStorageOrThrow = ae.getCrypto = ae.getCryptoOrThrow = zu = ae.getLocation = ae.getLocationOrThrow = io = ae.getNavigator = ae.getNavigatorOrThrow = gr = ae.getDocument = ae.getDocumentOrThrow = ae.getFromWindowOrThrow = ae.getFromWindow = void 0;
function ai(t) {
  let e;
  return typeof window < "u" && typeof window[t] < "u" && (e = window[t]), e;
}
ae.getFromWindow = ai;
function Ti(t) {
  const e = ai(t);
  if (!e)
    throw new Error(`${t} is not defined in Window`);
  return e;
}
ae.getFromWindowOrThrow = Ti;
function My() {
  return Ti("document");
}
ae.getDocumentOrThrow = My;
function qy() {
  return ai("document");
}
var gr = ae.getDocument = qy;
function jy() {
  return Ti("navigator");
}
ae.getNavigatorOrThrow = jy;
function zy() {
  return ai("navigator");
}
var io = ae.getNavigator = zy;
function Vy() {
  return Ti("location");
}
ae.getLocationOrThrow = Vy;
function Ky() {
  return ai("location");
}
var zu = ae.getLocation = Ky;
function Hy() {
  return Ti("crypto");
}
ae.getCryptoOrThrow = Hy;
function Wy() {
  return ai("crypto");
}
ae.getCrypto = Wy;
function Gy() {
  return Ti("localStorage");
}
ae.getLocalStorageOrThrow = Gy;
function Yy() {
  return ai("localStorage");
}
ae.getLocalStorage = Yy;
var ro = {};
Object.defineProperty(ro, "__esModule", { value: !0 });
var Vu = ro.getWindowMetadata = void 0;
const fa = ae;
function Jy() {
  let t, e;
  try {
    t = fa.getDocumentOrThrow(), e = fa.getLocationOrThrow();
  } catch {
    return null;
  }
  function i() {
    const h = t.getElementsByTagName("link"), d = [];
    for (let f = 0; f < h.length; f++) {
      const p = h[f], g = p.getAttribute("rel");
      if (g && g.toLowerCase().indexOf("icon") > -1) {
        const y = p.getAttribute("href");
        if (y)
          if (y.toLowerCase().indexOf("https:") === -1 && y.toLowerCase().indexOf("http:") === -1 && y.indexOf("//") !== 0) {
            let m = e.protocol + "//" + e.host;
            if (y.indexOf("/") === 0)
              m += y;
            else {
              const w = e.pathname.split("/");
              w.pop();
              const b = w.join("/");
              m += b + "/" + y;
            }
            d.push(m);
          } else if (y.indexOf("//") === 0) {
            const m = e.protocol + y;
            d.push(m);
          } else
            d.push(y);
      }
    }
    return d;
  }
  function r(...h) {
    const d = t.getElementsByTagName("meta");
    for (let f = 0; f < d.length; f++) {
      const p = d[f], g = ["itemprop", "property", "name"].map((y) => p.getAttribute(y)).filter((y) => y ? h.includes(y) : !1);
      if (g.length && g) {
        const y = p.getAttribute("content");
        if (y)
          return y;
      }
    }
    return "";
  }
  function s() {
    let h = r("name", "og:site_name", "og:title", "twitter:title");
    return h || (h = t.title), h;
  }
  function n() {
    return r("description", "og:description", "twitter:description", "keywords");
  }
  const o = s(), a = n(), c = e.origin, u = i();
  return {
    description: a,
    url: c,
    icons: u,
    name: o
  };
}
Vu = ro.getWindowMetadata = Jy;
function nr(t, { strict: e = !0 } = {}) {
  return !t || typeof t != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(t) : t.startsWith("0x");
}
function ga(t) {
  return nr(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length;
}
const Ku = "2.23.2";
let Ms = {
  getDocsUrl: ({ docsBaseUrl: t, docsPath: e = "", docsSlug: i }) => e ? `${t ?? "https://viem.sh"}${e}${i ? `#${i}` : ""}` : void 0,
  version: `viem@${Ku}`
};
class ti extends Error {
  constructor(e, i = {}) {
    const r = (() => i.cause instanceof ti ? i.cause.details : i.cause?.message ? i.cause.message : i.details)(), s = (() => i.cause instanceof ti && i.cause.docsPath || i.docsPath)(), n = Ms.getDocsUrl?.({ ...i, docsPath: s }), o = [
      e || "An error occurred.",
      "",
      ...i.metaMessages ? [...i.metaMessages, ""] : [],
      ...n ? [`Docs: ${n}`] : [],
      ...r ? [`Details: ${r}`] : [],
      ...Ms.version ? [`Version: ${Ms.version}`] : []
    ].join(`
`);
    super(o, i.cause ? { cause: i.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = r, this.docsPath = s, this.metaMessages = i.metaMessages, this.name = i.name ?? this.name, this.shortMessage = e, this.version = Ku;
  }
  walk(e) {
    return Hu(this, e);
  }
}
function Hu(t, e) {
  return e?.(t) ? t : t && typeof t == "object" && "cause" in t && t.cause !== void 0 ? Hu(t.cause, e) : e ? null : t;
}
class Wu extends ti {
  constructor({ size: e, targetSize: i, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${e}) exceeds padding size (${i}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
function Ni(t, { dir: e, size: i = 32 } = {}) {
  return typeof t == "string" ? Zy(t, { dir: e, size: i }) : Qy(t, { dir: e, size: i });
}
function Zy(t, { dir: e, size: i = 32 } = {}) {
  if (i === null)
    return t;
  const r = t.replace("0x", "");
  if (r.length > i * 2)
    throw new Wu({
      size: Math.ceil(r.length / 2),
      targetSize: i,
      type: "hex"
    });
  return `0x${r[e === "right" ? "padEnd" : "padStart"](i * 2, "0")}`;
}
function Qy(t, { dir: e, size: i = 32 } = {}) {
  if (i === null)
    return t;
  if (t.length > i)
    throw new Wu({
      size: t.length,
      targetSize: i,
      type: "bytes"
    });
  const r = new Uint8Array(i);
  for (let s = 0; s < i; s++) {
    const n = e === "right";
    r[n ? s : i - s - 1] = t[n ? s : t.length - s - 1];
  }
  return r;
}
class Xy extends ti {
  constructor({ max: e, min: i, signed: r, size: s, value: n }) {
    super(`Number "${n}" is not in safe ${s ? `${s * 8}-bit ${r ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${i} to ${e})` : `(above ${i})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class ew extends ti {
  constructor({ givenSize: e, maxSize: i }) {
    super(`Size cannot exceed ${i} bytes. Given size: ${e} bytes.`, { name: "SizeOverflowError" });
  }
}
function Fi(t, { size: e }) {
  if (ga(t) > e)
    throw new ew({
      givenSize: ga(t),
      maxSize: e
    });
}
function En(t, e = {}) {
  const { signed: i } = e;
  e.size && Fi(t, { size: e.size });
  const r = BigInt(t);
  if (!i)
    return r;
  const s = (t.length - 2) / 2, n = (1n << BigInt(s) * 8n - 1n) - 1n;
  return r <= n ? r : r - BigInt(`0x${"f".padStart(s * 2, "f")}`) - 1n;
}
function tw(t, e = {}) {
  return Number(En(t, e));
}
const iw = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function _n(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? Yu(t, e) : typeof t == "string" ? nw(t, e) : typeof t == "boolean" ? rw(t, e) : Gu(t, e);
}
function rw(t, e = {}) {
  const i = `0x${Number(t)}`;
  return typeof e.size == "number" ? (Fi(i, { size: e.size }), Ni(i, { size: e.size })) : i;
}
function Gu(t, e = {}) {
  let i = "";
  for (let s = 0; s < t.length; s++)
    i += iw[t[s]];
  const r = `0x${i}`;
  return typeof e.size == "number" ? (Fi(r, { size: e.size }), Ni(r, { dir: "right", size: e.size })) : r;
}
function Yu(t, e = {}) {
  const { signed: i, size: r } = e, s = BigInt(t);
  let n;
  r ? i ? n = (1n << BigInt(r) * 8n - 1n) - 1n : n = 2n ** (BigInt(r) * 8n) - 1n : typeof t == "number" && (n = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof n == "bigint" && i ? -n - 1n : 0;
  if (n && s > n || s < o) {
    const c = typeof t == "bigint" ? "n" : "";
    throw new Xy({
      max: n ? `${n}${c}` : void 0,
      min: `${o}${c}`,
      signed: i,
      size: r,
      value: `${t}${c}`
    });
  }
  const a = `0x${(i && s < 0 ? (1n << BigInt(r * 8)) + BigInt(s) : s).toString(16)}`;
  return r ? Ni(a, { size: r }) : a;
}
const sw = /* @__PURE__ */ new TextEncoder();
function nw(t, e = {}) {
  const i = sw.encode(t);
  return Gu(i, e);
}
const ow = /* @__PURE__ */ new TextEncoder();
function aw(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? uw(t, e) : typeof t == "boolean" ? cw(t, e) : nr(t) ? Ju(t, e) : Zu(t, e);
}
function cw(t, e = {}) {
  const i = new Uint8Array(1);
  return i[0] = Number(t), typeof e.size == "number" ? (Fi(i, { size: e.size }), Ni(i, { size: e.size })) : i;
}
const Et = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function ya(t) {
  if (t >= Et.zero && t <= Et.nine)
    return t - Et.zero;
  if (t >= Et.A && t <= Et.F)
    return t - (Et.A - 10);
  if (t >= Et.a && t <= Et.f)
    return t - (Et.a - 10);
}
function Ju(t, e = {}) {
  let i = t;
  e.size && (Fi(i, { size: e.size }), i = Ni(i, { dir: "right", size: e.size }));
  let r = i.slice(2);
  r.length % 2 && (r = `0${r}`);
  const s = r.length / 2, n = new Uint8Array(s);
  for (let o = 0, a = 0; o < s; o++) {
    const c = ya(r.charCodeAt(a++)), u = ya(r.charCodeAt(a++));
    if (c === void 0 || u === void 0)
      throw new ti(`Invalid byte sequence ("${r[a - 2]}${r[a - 1]}" in "${r}").`);
    n[o] = c * 16 + u;
  }
  return n;
}
function uw(t, e) {
  const i = Yu(t, e);
  return Ju(i);
}
function Zu(t, e = {}) {
  const i = ow.encode(t);
  return typeof e.size == "number" ? (Fi(i, { size: e.size }), Ni(i, { dir: "right", size: e.size })) : i;
}
function Zr(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error("positive integer expected, got " + t);
}
function lw(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function hs(t, ...e) {
  if (!lw(t))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function GD(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Zr(t.outputLen), Zr(t.blockLen);
}
function wa(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function hw(t, e) {
  hs(t);
  const i = e.outputLen;
  if (t.length < i)
    throw new Error("digestInto() expects output buffer of length at least " + i);
}
const Rr = /* @__PURE__ */ BigInt(2 ** 32 - 1), ma = /* @__PURE__ */ BigInt(32);
function dw(t, e = !1) {
  return e ? { h: Number(t & Rr), l: Number(t >> ma & Rr) } : { h: Number(t >> ma & Rr) | 0, l: Number(t & Rr) | 0 };
}
function pw(t, e = !1) {
  let i = new Uint32Array(t.length), r = new Uint32Array(t.length);
  for (let s = 0; s < t.length; s++) {
    const { h: n, l: o } = dw(t[s], e);
    [i[s], r[s]] = [n, o];
  }
  return [i, r];
}
const fw = (t, e, i) => t << i | e >>> 32 - i, gw = (t, e, i) => e << i | t >>> 32 - i, yw = (t, e, i) => e << i - 32 | t >>> 64 - i, ww = (t, e, i) => t << i - 32 | e >>> 64 - i, gi = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function mw(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function YD(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function JD(t, e) {
  return t << 32 - e | t >>> e;
}
const ba = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function bw(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function va(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = bw(t[e]);
}
function vw(t) {
  if (typeof t != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof t);
  return new Uint8Array(new TextEncoder().encode(t));
}
function Qu(t) {
  return typeof t == "string" && (t = vw(t)), hs(t), t;
}
function ZD(...t) {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    hs(s), e += s.length;
  }
  const i = new Uint8Array(e);
  for (let r = 0, s = 0; r < t.length; r++) {
    const n = t[r];
    i.set(n, s), s += n.length;
  }
  return i;
}
class Ew {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function _w(t) {
  const e = (r) => t().update(Qu(r)).digest(), i = t();
  return e.outputLen = i.outputLen, e.blockLen = i.blockLen, e.create = () => t(), e;
}
function QD(t = 32) {
  if (gi && typeof gi.getRandomValues == "function")
    return gi.getRandomValues(new Uint8Array(t));
  if (gi && typeof gi.randomBytes == "function")
    return gi.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
const Xu = [], el = [], tl = [], Iw = /* @__PURE__ */ BigInt(0), ji = /* @__PURE__ */ BigInt(1), Dw = /* @__PURE__ */ BigInt(2), Sw = /* @__PURE__ */ BigInt(7), $w = /* @__PURE__ */ BigInt(256), Ow = /* @__PURE__ */ BigInt(113);
for (let t = 0, e = ji, i = 1, r = 0; t < 24; t++) {
  [i, r] = [r, (2 * i + 3 * r) % 5], Xu.push(2 * (5 * r + i)), el.push((t + 1) * (t + 2) / 2 % 64);
  let s = Iw;
  for (let n = 0; n < 7; n++)
    e = (e << ji ^ (e >> Sw) * Ow) % $w, e & Dw && (s ^= ji << (ji << /* @__PURE__ */ BigInt(n)) - ji);
  tl.push(s);
}
const [xw, Aw] = /* @__PURE__ */ pw(tl, !0), Ea = (t, e, i) => i > 32 ? yw(t, e, i) : fw(t, e, i), _a = (t, e, i) => i > 32 ? ww(t, e, i) : gw(t, e, i);
function Pw(t, e = 24) {
  const i = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let o = 0; o < 10; o++)
      i[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10, c = (o + 2) % 10, u = i[c], l = i[c + 1], h = Ea(u, l, 1) ^ i[a], d = _a(u, l, 1) ^ i[a + 1];
      for (let f = 0; f < 50; f += 10)
        t[o + f] ^= h, t[o + f + 1] ^= d;
    }
    let s = t[2], n = t[3];
    for (let o = 0; o < 24; o++) {
      const a = el[o], c = Ea(s, n, a), u = _a(s, n, a), l = Xu[o];
      s = t[l], n = t[l + 1], t[l] = c, t[l + 1] = u;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++)
        i[a] = t[o + a];
      for (let a = 0; a < 10; a++)
        t[o + a] ^= ~i[(a + 2) % 10] & i[(a + 4) % 10];
    }
    t[0] ^= xw[r], t[1] ^= Aw[r];
  }
  i.fill(0);
}
class so extends Ew {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, i, r, s = !1, n = 24) {
    if (super(), this.blockLen = e, this.suffix = i, this.outputLen = r, this.enableXOF = s, this.rounds = n, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Zr(r), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = mw(this.state);
  }
  keccak() {
    ba || va(this.state32), Pw(this.state32, this.rounds), ba || va(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    wa(this);
    const { blockLen: i, state: r } = this;
    e = Qu(e);
    const s = e.length;
    for (let n = 0; n < s; ) {
      const o = Math.min(i - this.pos, s - n);
      for (let a = 0; a < o; a++)
        r[this.pos++] ^= e[n++];
      this.pos === i && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: i, pos: r, blockLen: s } = this;
    e[r] ^= i, i & 128 && r === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    wa(this, !1), hs(e), this.finish();
    const i = this.state, { blockLen: r } = this;
    for (let s = 0, n = e.length; s < n; ) {
      this.posOut >= r && this.keccak();
      const o = Math.min(r - this.posOut, n - s);
      e.set(i.subarray(this.posOut, this.posOut + o), s), this.posOut += o, s += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Zr(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (hw(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: i, suffix: r, outputLen: s, rounds: n, enableXOF: o } = this;
    return e || (e = new so(i, r, s, o, n)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = n, e.suffix = r, e.outputLen = s, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
}
const Cw = (t, e, i) => _w(() => new so(e, t, i)), Rw = /* @__PURE__ */ Cw(1, 136, 256 / 8);
function il(t, e) {
  const i = e || "hex", r = Rw(nr(t, { strict: !1 }) ? aw(t) : t);
  return i === "bytes" ? r : _n(r);
}
class Tw extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const i = super.get(e);
    return super.has(e) && i !== void 0 && (this.delete(e), super.set(e, i)), i;
  }
  set(e, i) {
    if (super.set(e, i), this.maxSize && this.size > this.maxSize) {
      const r = this.keys().next().value;
      r && this.delete(r);
    }
    return this;
  }
}
const qs = /* @__PURE__ */ new Tw(8192);
function Nw(t, e) {
  if (qs.has(`${t}.${e}`))
    return qs.get(`${t}.${e}`);
  const i = e ? `${e}${t.toLowerCase()}` : t.substring(2).toLowerCase(), r = il(Zu(i), "bytes"), s = (e ? i.substring(`${e}0x`.length) : i).split("");
  for (let o = 0; o < 40; o += 2)
    r[o >> 1] >> 4 >= 8 && s[o] && (s[o] = s[o].toUpperCase()), (r[o >> 1] & 15) >= 8 && s[o + 1] && (s[o + 1] = s[o + 1].toUpperCase());
  const n = `0x${s.join("")}`;
  return qs.set(`${t}.${e}`, n), n;
}
function Fw(t) {
  const e = il(`0x${t.substring(4)}`).substring(26);
  return Nw(`0x${e}`);
}
async function Lw({ hash: t, signature: e }) {
  const i = nr(t) ? t : _n(t), { secp256k1: r } = await import("./secp256k1-bf520fb8.js");
  return `0x${(() => {
    if (typeof e == "object" && "r" in e && "s" in e) {
      const { r: u, s: l, v: h, yParity: d } = e, f = Number(d ?? h), p = Ia(f);
      return new r.Signature(En(u), En(l)).addRecoveryBit(p);
    }
    const o = nr(e) ? e : _n(e), a = tw(`0x${o.slice(130)}`), c = Ia(a);
    return r.Signature.fromCompact(o.substring(2, 130)).addRecoveryBit(c);
  })().recoverPublicKey(i.substring(2)).toHex(!1)}`;
}
function Ia(t) {
  if (t === 0 || t === 1)
    return t;
  if (t === 27)
    return 0;
  if (t === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
async function Bw({ hash: t, signature: e }) {
  return Fw(await Lw({ hash: t, signature: e }));
}
function Uw(t) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  const e = new Uint8Array(256);
  for (let u = 0; u < e.length; u++)
    e[u] = 255;
  for (let u = 0; u < t.length; u++) {
    const l = t.charAt(u), h = l.charCodeAt(0);
    if (e[h] !== 255)
      throw new TypeError(l + " is ambiguous");
    e[h] = u;
  }
  const i = t.length, r = t.charAt(0), s = Math.log(i) / Math.log(256), n = Math.log(256) / Math.log(i);
  function o(u) {
    if (u instanceof Uint8Array || (ArrayBuffer.isView(u) ? u = new Uint8Array(u.buffer, u.byteOffset, u.byteLength) : Array.isArray(u) && (u = Uint8Array.from(u))), !(u instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (u.length === 0)
      return "";
    let l = 0, h = 0, d = 0;
    const f = u.length;
    for (; d !== f && u[d] === 0; )
      d++, l++;
    const p = (f - d) * n + 1 >>> 0, g = new Uint8Array(p);
    for (; d !== f; ) {
      let w = u[d], b = 0;
      for (let E = p - 1; (w !== 0 || b < h) && E !== -1; E--, b++)
        w += 256 * g[E] >>> 0, g[E] = w % i >>> 0, w = w / i >>> 0;
      if (w !== 0)
        throw new Error("Non-zero carry");
      h = b, d++;
    }
    let y = p - h;
    for (; y !== p && g[y] === 0; )
      y++;
    let m = r.repeat(l);
    for (; y < p; ++y)
      m += t.charAt(g[y]);
    return m;
  }
  function a(u) {
    if (typeof u != "string")
      throw new TypeError("Expected String");
    if (u.length === 0)
      return new Uint8Array();
    let l = 0, h = 0, d = 0;
    for (; u[l] === r; )
      h++, l++;
    const f = (u.length - l) * s + 1 >>> 0, p = new Uint8Array(f);
    for (; l < u.length; ) {
      const w = u.charCodeAt(l);
      if (w > 255)
        return;
      let b = e[w];
      if (b === 255)
        return;
      let E = 0;
      for (let O = f - 1; (b !== 0 || E < d) && O !== -1; O--, E++)
        b += i * p[O] >>> 0, p[O] = b % 256 >>> 0, b = b / 256 >>> 0;
      if (b !== 0)
        throw new Error("Non-zero carry");
      d = E, l++;
    }
    let g = f - d;
    for (; g !== f && p[g] === 0; )
      g++;
    const y = new Uint8Array(h + (f - g));
    let m = h;
    for (; g !== f; )
      y[m++] = p[g++];
    return y;
  }
  function c(u) {
    const l = a(u);
    if (l)
      return l;
    throw new Error("Non-base" + i + " character");
  }
  return {
    encode: o,
    decodeUnsafe: a,
    decode: c
  };
}
var kw = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const Mw = Uw(kw);
function rl(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(t) : new Uint8Array(t);
}
function Zi(t, e) {
  e || (e = t.reduce((s, n) => s + n.length, 0));
  const i = rl(e);
  let r = 0;
  for (const s of t)
    i.set(s, r), r += s.length;
  return i;
}
function qw(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var i = new Uint8Array(256), r = 0; r < i.length; r++)
    i[r] = 255;
  for (var s = 0; s < t.length; s++) {
    var n = t.charAt(s), o = n.charCodeAt(0);
    if (i[o] !== 255)
      throw new TypeError(n + " is ambiguous");
    i[o] = s;
  }
  var a = t.length, c = t.charAt(0), u = Math.log(a) / Math.log(256), l = Math.log(256) / Math.log(a);
  function h(p) {
    if (p instanceof Uint8Array || (ArrayBuffer.isView(p) ? p = new Uint8Array(p.buffer, p.byteOffset, p.byteLength) : Array.isArray(p) && (p = Uint8Array.from(p))), !(p instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (p.length === 0)
      return "";
    for (var g = 0, y = 0, m = 0, w = p.length; m !== w && p[m] === 0; )
      m++, g++;
    for (var b = (w - m) * l + 1 >>> 0, E = new Uint8Array(b); m !== w; ) {
      for (var O = p[m], S = 0, $ = b - 1; (O !== 0 || S < y) && $ !== -1; $--, S++)
        O += 256 * E[$] >>> 0, E[$] = O % a >>> 0, O = O / a >>> 0;
      if (O !== 0)
        throw new Error("Non-zero carry");
      y = S, m++;
    }
    for (var A = b - y; A !== b && E[A] === 0; )
      A++;
    for (var I = c.repeat(g); A < b; ++A)
      I += t.charAt(E[A]);
    return I;
  }
  function d(p) {
    if (typeof p != "string")
      throw new TypeError("Expected String");
    if (p.length === 0)
      return new Uint8Array();
    var g = 0;
    if (p[g] !== " ") {
      for (var y = 0, m = 0; p[g] === c; )
        y++, g++;
      for (var w = (p.length - g) * u + 1 >>> 0, b = new Uint8Array(w); p[g]; ) {
        var E = i[p.charCodeAt(g)];
        if (E === 255)
          return;
        for (var O = 0, S = w - 1; (E !== 0 || O < m) && S !== -1; S--, O++)
          E += a * b[S] >>> 0, b[S] = E % 256 >>> 0, E = E / 256 >>> 0;
        if (E !== 0)
          throw new Error("Non-zero carry");
        m = O, g++;
      }
      if (p[g] !== " ") {
        for (var $ = w - m; $ !== w && b[$] === 0; )
          $++;
        for (var A = new Uint8Array(y + (w - $)), I = y; $ !== w; )
          A[I++] = b[$++];
        return A;
      }
    }
  }
  function f(p) {
    var g = d(p);
    if (g)
      return g;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: h,
    decodeUnsafe: d,
    decode: f
  };
}
var jw = qw, zw = jw;
const Vw = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, Kw = (t) => new TextEncoder().encode(t), Hw = (t) => new TextDecoder().decode(t);
class Ww {
  constructor(e, i, r) {
    this.name = e, this.prefix = i, this.baseEncode = r;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Gw {
  constructor(e, i, r) {
    if (this.name = e, this.prefix = i, i.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = i.codePointAt(0), this.baseDecode = r;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return sl(this, e);
  }
}
class Yw {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return sl(this, e);
  }
  decode(e) {
    const i = e[0], r = this.decoders[i];
    if (r)
      return r.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const sl = (t, e) => new Yw({
  ...t.decoders || { [t.prefix]: t },
  ...e.decoders || { [e.prefix]: e }
});
class Jw {
  constructor(e, i, r, s) {
    this.name = e, this.prefix = i, this.baseEncode = r, this.baseDecode = s, this.encoder = new Ww(e, i, r), this.decoder = new Gw(e, i, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const ds = ({ name: t, prefix: e, encode: i, decode: r }) => new Jw(t, e, i, r), yr = ({ prefix: t, name: e, alphabet: i }) => {
  const { encode: r, decode: s } = zw(i, e);
  return ds({
    prefix: t,
    name: e,
    encode: r,
    decode: (n) => Vw(s(n))
  });
}, Zw = (t, e, i, r) => {
  const s = {};
  for (let l = 0; l < e.length; ++l)
    s[e[l]] = l;
  let n = t.length;
  for (; t[n - 1] === "="; )
    --n;
  const o = new Uint8Array(n * i / 8 | 0);
  let a = 0, c = 0, u = 0;
  for (let l = 0; l < n; ++l) {
    const h = s[t[l]];
    if (h === void 0)
      throw new SyntaxError(`Non-${r} character`);
    c = c << i | h, a += i, a >= 8 && (a -= 8, o[u++] = 255 & c >> a);
  }
  if (a >= i || 255 & c << 8 - a)
    throw new SyntaxError("Unexpected end of data");
  return o;
}, Qw = (t, e, i) => {
  const r = e[e.length - 1] === "=", s = (1 << i) - 1;
  let n = "", o = 0, a = 0;
  for (let c = 0; c < t.length; ++c)
    for (a = a << 8 | t[c], o += 8; o > i; )
      o -= i, n += e[s & a >> o];
  if (o && (n += e[s & a << i - o]), r)
    for (; n.length * i & 7; )
      n += "=";
  return n;
}, xe = ({ name: t, prefix: e, bitsPerChar: i, alphabet: r }) => ds({
  prefix: e,
  name: t,
  encode(s) {
    return Qw(s, r, i);
  },
  decode(s) {
    return Zw(s, r, i, t);
  }
}), Xw = ds({
  prefix: "\0",
  name: "identity",
  encode: (t) => Hw(t),
  decode: (t) => Kw(t)
}), em = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: Xw
}, Symbol.toStringTag, { value: "Module" })), tm = xe({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), im = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: tm
}, Symbol.toStringTag, { value: "Module" })), rm = xe({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), sm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: rm
}, Symbol.toStringTag, { value: "Module" })), nm = yr({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), om = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: nm
}, Symbol.toStringTag, { value: "Module" })), am = xe({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), cm = xe({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), um = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: am,
  base16upper: cm
}, Symbol.toStringTag, { value: "Module" })), lm = xe({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), hm = xe({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), dm = xe({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), pm = xe({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), fm = xe({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), gm = xe({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), ym = xe({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), wm = xe({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), mm = xe({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), bm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: lm,
  base32hex: fm,
  base32hexpad: ym,
  base32hexpadupper: wm,
  base32hexupper: gm,
  base32pad: dm,
  base32padupper: pm,
  base32upper: hm,
  base32z: mm
}, Symbol.toStringTag, { value: "Module" })), vm = yr({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), Em = yr({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), _m = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: vm,
  base36upper: Em
}, Symbol.toStringTag, { value: "Module" })), Im = yr({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), Dm = yr({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), Sm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: Im,
  base58flickr: Dm
}, Symbol.toStringTag, { value: "Module" })), $m = xe({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), Om = xe({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), xm = xe({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), Am = xe({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), Pm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: $m,
  base64pad: Om,
  base64url: xm,
  base64urlpad: Am
}, Symbol.toStringTag, { value: "Module" })), nl = Array.from(""), Cm = nl.reduce((t, e, i) => (t[i] = e, t), []), Rm = nl.reduce((t, e, i) => (t[e.codePointAt(0)] = i, t), []);
function Tm(t) {
  return t.reduce((e, i) => (e += Cm[i], e), "");
}
function Nm(t) {
  const e = [];
  for (const i of t) {
    const r = Rm[i.codePointAt(0)];
    if (r === void 0)
      throw new Error(`Non-base256emoji character: ${i}`);
    e.push(r);
  }
  return new Uint8Array(e);
}
const Fm = ds({
  prefix: "",
  name: "base256emoji",
  encode: Tm,
  decode: Nm
}), Lm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: Fm
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const Da = {
  ...em,
  ...im,
  ...sm,
  ...om,
  ...um,
  ...bm,
  ..._m,
  ...Sm,
  ...Pm,
  ...Lm
};
function ol(t, e, i, r) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: i
    },
    decoder: { decode: r }
  };
}
const Sa = ol("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), js = ol("ascii", "a", (t) => {
  let e = "a";
  for (let i = 0; i < t.length; i++)
    e += String.fromCharCode(t[i]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = rl(t.length);
  for (let i = 0; i < t.length; i++)
    e[i] = t.charCodeAt(i);
  return e;
}), al = {
  utf8: Sa,
  "utf-8": Sa,
  hex: Da.base16,
  latin1: js,
  ascii: js,
  binary: js,
  ...Da
};
function Xe(t, e = "utf8") {
  const i = al[e];
  if (!i)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t, "utf8") : i.decoder.decode(`${i.prefix}${t}`);
}
function qe(t, e = "utf8") {
  const i = al[e];
  if (!i)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : i.encoder.encode(t).substring(1);
}
const Bm = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } }, no = ":";
function jr(t) {
  const [e, i] = t.split(no);
  return { namespace: e, reference: i };
}
function Um(t) {
  const { namespace: e, reference: i } = t;
  return [e, i].join(no);
}
function km(t) {
  const [e, i, r] = t.split(no);
  return { namespace: e, reference: i, address: r };
}
function Mm(t, e) {
  const i = [];
  return t.forEach((r) => {
    const s = e(r);
    i.includes(s) || i.push(s);
  }), i;
}
function qm(t) {
  const { namespace: e, reference: i } = km(t);
  return Um({ namespace: e, reference: i });
}
function jm(t) {
  return Mm(t, qm);
}
function cl(t, e = []) {
  const i = [];
  return Object.keys(t).forEach((r) => {
    if (e.length && !e.includes(r))
      return;
    const s = t[r];
    i.push(...s.accounts);
  }), i;
}
function ul(t, e = []) {
  const i = [];
  return Object.keys(t).forEach((r) => {
    if (e.length && !e.includes(r))
      return;
    const s = t[r];
    i.push(...jm(s.accounts));
  }), i;
}
function zm(t, e = []) {
  const i = [];
  return Object.keys(t).forEach((r) => {
    if (e.length && !e.includes(r))
      return;
    const s = t[r];
    i.push(...oo(r, s));
  }), i;
}
function oo(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
var Vm = Object.defineProperty, Km = Object.defineProperties, Hm = Object.getOwnPropertyDescriptors, $a = Object.getOwnPropertySymbols, Wm = Object.prototype.hasOwnProperty, Gm = Object.prototype.propertyIsEnumerable, Oa = (t, e, i) => e in t ? Vm(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, xa = (t, e) => {
  for (var i in e || (e = {}))
    Wm.call(e, i) && Oa(t, i, e[i]);
  if ($a)
    for (var i of $a(e))
      Gm.call(e, i) && Oa(t, i, e[i]);
  return t;
}, Ym = (t, e) => Km(t, Hm(e));
const Jm = "ReactNative", We = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, Zm = "js";
function Qr() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function Ut() {
  return !gr() && !!io() && navigator.product === Jm;
}
function Qm() {
  return Ut() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function Xm() {
  return Ut() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function wr() {
  return !Qr() && !!io() && !!gr();
}
function mr() {
  return Ut() ? We.reactNative : Qr() ? We.node : wr() ? We.browser : We.unknown;
}
function Aa() {
  var t;
  try {
    return Ut() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t = global.Application) == null ? void 0 : t.applicationId : void 0;
  } catch {
    return;
  }
}
function eb(t, e) {
  const i = new URLSearchParams(t);
  for (const r of Object.keys(e).sort())
    if (e.hasOwnProperty(r)) {
      const s = e[r];
      s !== void 0 && i.set(r, s);
    }
  return i.toString();
}
function tb(t) {
  var e, i;
  const r = ll();
  try {
    return t != null && t.url && r.url && t.url !== r.url && (console.warn(`The configured WalletConnect 'metadata.url':${t.url} differs from the actual page url:${r.url}. This is probably unintended and can lead to issues.`), t.url = r.url), (e = t?.icons) != null && e.length && t.icons.length > 0 && (t.icons = t.icons.filter((s) => s !== "")), Ym(xa(xa({}, r), t), { url: t?.url || r.url, name: t?.name || r.name, description: t?.description || r.description, icons: (i = t?.icons) != null && i.length && t.icons.length > 0 ? t.icons : r.icons });
  } catch (s) {
    return console.warn("Error populating app metadata", s), t || r;
  }
}
function ll() {
  return Vu() || { name: "", description: "", url: "", icons: [""] };
}
function ib() {
  if (mr() === We.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: i, Version: r } = global.Platform;
    return [i, r].join("-");
  }
  const t = Ah();
  if (t === null)
    return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-");
}
function rb() {
  var t;
  const e = mr();
  return e === We.browser ? [e, ((t = zu()) == null ? void 0 : t.host) || "unknown"].join(":") : e;
}
function hl(t, e, i) {
  const r = ib(), s = rb();
  return [[t, e].join("-"), [Zm, i].join("-"), r, s].join("/");
}
function sb({ protocol: t, version: e, relayUrl: i, sdkVersion: r, auth: s, projectId: n, useOnCloseEvent: o, bundleId: a, packageName: c }) {
  const u = i.split("?"), l = hl(t, e, r), h = { auth: s, ua: l, projectId: n, useOnCloseEvent: o || void 0, packageName: c || void 0, bundleId: a || void 0 }, d = eb(u[1] || "", h);
  return u[0] + "?" + d;
}
function Jt(t, e) {
  return t.filter((i) => e.includes(i)).length === t.length;
}
function In(t) {
  return Object.fromEntries(t.entries());
}
function Dn(t) {
  return new Map(Object.entries(t));
}
function Ht(t = T.FIVE_MINUTES, e) {
  const i = T.toMiliseconds(t || T.FIVE_MINUTES);
  let r, s, n, o;
  return { resolve: (a) => {
    n && r && (clearTimeout(n), r(a), o = Promise.resolve(a));
  }, reject: (a) => {
    n && s && (clearTimeout(n), s(a));
  }, done: () => new Promise((a, c) => {
    if (o)
      return a(o);
    n = setTimeout(() => {
      const u = new Error(e);
      o = Promise.reject(u), c(u);
    }, i), r = a, s = c;
  }) };
}
function Lt(t, e, i) {
  return new Promise(async (r, s) => {
    const n = setTimeout(() => s(new Error(i)), e);
    try {
      const o = await t;
      r(o);
    } catch (o) {
      s(o);
    }
    clearTimeout(n);
  });
}
function dl(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`))
    return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function nb(t) {
  return dl("topic", t);
}
function ob(t) {
  return dl("id", t);
}
function pl(t) {
  const [e, i] = t.split(":"), r = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof i == "string")
    r.topic = i;
  else if (e === "id" && Number.isInteger(Number(i)))
    r.id = Number(i);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${i}`);
  return r;
}
function pe(t, e) {
  return T.fromMiliseconds((e || Date.now()) + T.toMiliseconds(t));
}
function Nt(t) {
  return Date.now() >= T.toMiliseconds(t);
}
function X(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
function ab(t = [], e = []) {
  return [.../* @__PURE__ */ new Set([...t, ...e])];
}
async function cb({ id: t, topic: e, wcDeepLink: i }) {
  var r;
  try {
    if (!i)
      return;
    const s = typeof i == "string" ? JSON.parse(i) : i, n = s?.href;
    if (typeof n != "string")
      return;
    const o = ub(n, t, e), a = mr();
    if (a === We.browser) {
      if (!((r = gr()) != null && r.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      lb(o);
    } else
      a === We.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(o);
  } catch (s) {
    console.error(s);
  }
}
function ub(t, e, i) {
  const r = `requestId=${e}&sessionTopic=${i}`;
  t.endsWith("/") && (t = t.slice(0, -1));
  let s = `${t}`;
  if (t.startsWith("https://t.me")) {
    const n = t.includes("?") ? "&startapp=" : "?startapp=";
    s = `${s}${n}${fb(r, !0)}`;
  } else
    s = `${s}/wc?${r}`;
  return s;
}
function lb(t) {
  let e = "_self";
  pb() ? e = "_top" : (db() || t.startsWith("https://") || t.startsWith("http://")) && (e = "_blank"), window.open(t, e, "noreferrer noopener");
}
async function hb(t, e) {
  let i = "";
  try {
    if (wr() && (i = localStorage.getItem(e), i))
      return i;
    i = await t.getItem(e);
  } catch (r) {
    console.error(r);
  }
  return i;
}
function Pa(t, e) {
  if (!t.includes(e))
    return null;
  const i = t.split(/([&,?,=])/), r = i.indexOf(e);
  return i[r + 2];
}
function Ca() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
    const e = Math.random() * 16 | 0;
    return (t === "x" ? e : e & 3 | 8).toString(16);
  });
}
function ao() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function db() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function pb() {
  try {
    return window.self !== window.top;
  } catch {
    return !1;
  }
}
function fb(t, e = !1) {
  const i = Buffer.from(t).toString("base64");
  return e ? i.replace(/[=]/g, "") : i;
}
function fl(t) {
  return Buffer.from(t, "base64").toString("utf-8");
}
function gb(t) {
  return new Promise((e) => setTimeout(e, t));
}
function or(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error("positive integer expected, got " + t);
}
function yb(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function br(t, ...e) {
  if (!yb(t))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function co(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  or(t.outputLen), or(t.blockLen);
}
function Di(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function gl(t, e) {
  br(t);
  const i = e.outputLen;
  if (t.length < i)
    throw new Error("digestInto() expects output buffer of length at least " + i);
}
const Tr = BigInt(2 ** 32 - 1), Ra = BigInt(32);
function wb(t, e = !1) {
  return e ? { h: Number(t & Tr), l: Number(t >> Ra & Tr) } : { h: Number(t >> Ra & Tr) | 0, l: Number(t & Tr) | 0 };
}
function mb(t, e = !1) {
  let i = new Uint32Array(t.length), r = new Uint32Array(t.length);
  for (let s = 0; s < t.length; s++) {
    const { h: n, l: o } = wb(t[s], e);
    [i[s], r[s]] = [n, o];
  }
  return [i, r];
}
const bb = (t, e, i) => t << i | e >>> 32 - i, vb = (t, e, i) => e << i | t >>> 32 - i, Eb = (t, e, i) => e << i - 32 | t >>> 64 - i, _b = (t, e, i) => t << i - 32 | e >>> 64 - i, yi = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function Ib(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function zs(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function ct(t, e) {
  return t << 32 - e | t >>> e;
}
const Ta = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Db(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function Na(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = Db(t[e]);
}
function Sb(t) {
  if (typeof t != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof t);
  return new Uint8Array(new TextEncoder().encode(t));
}
function Si(t) {
  return typeof t == "string" && (t = Sb(t)), br(t), t;
}
function $b(...t) {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    br(s), e += s.length;
  }
  const i = new Uint8Array(e);
  for (let r = 0, s = 0; r < t.length; r++) {
    const n = t[r];
    i.set(n, s), s += n.length;
  }
  return i;
}
class uo {
  clone() {
    return this._cloneInto();
  }
}
function yl(t) {
  const e = (r) => t().update(Si(r)).digest(), i = t();
  return e.outputLen = i.outputLen, e.blockLen = i.blockLen, e.create = () => t(), e;
}
function Li(t = 32) {
  if (yi && typeof yi.getRandomValues == "function")
    return yi.getRandomValues(new Uint8Array(t));
  if (yi && typeof yi.randomBytes == "function")
    return yi.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
const wl = [], ml = [], bl = [], Ob = BigInt(0), zi = BigInt(1), xb = BigInt(2), Ab = BigInt(7), Pb = BigInt(256), Cb = BigInt(113);
for (let t = 0, e = zi, i = 1, r = 0; t < 24; t++) {
  [i, r] = [r, (2 * i + 3 * r) % 5], wl.push(2 * (5 * r + i)), ml.push((t + 1) * (t + 2) / 2 % 64);
  let s = Ob;
  for (let n = 0; n < 7; n++)
    e = (e << zi ^ (e >> Ab) * Cb) % Pb, e & xb && (s ^= zi << (zi << BigInt(n)) - zi);
  bl.push(s);
}
const [Rb, Tb] = mb(bl, !0), Fa = (t, e, i) => i > 32 ? Eb(t, e, i) : bb(t, e, i), La = (t, e, i) => i > 32 ? _b(t, e, i) : vb(t, e, i);
function Nb(t, e = 24) {
  const i = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let o = 0; o < 10; o++)
      i[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10, c = (o + 2) % 10, u = i[c], l = i[c + 1], h = Fa(u, l, 1) ^ i[a], d = La(u, l, 1) ^ i[a + 1];
      for (let f = 0; f < 50; f += 10)
        t[o + f] ^= h, t[o + f + 1] ^= d;
    }
    let s = t[2], n = t[3];
    for (let o = 0; o < 24; o++) {
      const a = ml[o], c = Fa(s, n, a), u = La(s, n, a), l = wl[o];
      s = t[l], n = t[l + 1], t[l] = c, t[l + 1] = u;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++)
        i[a] = t[o + a];
      for (let a = 0; a < 10; a++)
        t[o + a] ^= ~i[(a + 2) % 10] & i[(a + 4) % 10];
    }
    t[0] ^= Rb[r], t[1] ^= Tb[r];
  }
  i.fill(0);
}
let Fb = class vl extends uo {
  constructor(e, i, r, s = !1, n = 24) {
    if (super(), this.blockLen = e, this.suffix = i, this.outputLen = r, this.enableXOF = s, this.rounds = n, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, or(r), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = Ib(this.state);
  }
  keccak() {
    Ta || Na(this.state32), Nb(this.state32, this.rounds), Ta || Na(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Di(this);
    const { blockLen: i, state: r } = this;
    e = Si(e);
    const s = e.length;
    for (let n = 0; n < s; ) {
      const o = Math.min(i - this.pos, s - n);
      for (let a = 0; a < o; a++)
        r[this.pos++] ^= e[n++];
      this.pos === i && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: i, pos: r, blockLen: s } = this;
    e[r] ^= i, i & 128 && r === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Di(this, !1), br(e), this.finish();
    const i = this.state, { blockLen: r } = this;
    for (let s = 0, n = e.length; s < n; ) {
      this.posOut >= r && this.keccak();
      const o = Math.min(r - this.posOut, n - s);
      e.set(i.subarray(this.posOut, this.posOut + o), s), this.posOut += o, s += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return or(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (gl(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: i, suffix: r, outputLen: s, rounds: n, enableXOF: o } = this;
    return e || (e = new vl(i, r, s, o, n)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = n, e.suffix = r, e.outputLen = s, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
};
const Lb = (t, e, i) => yl(() => new Fb(e, t, i)), Bb = Lb(1, 136, 256 / 8), Ub = "https://rpc.walletconnect.org/v1";
function El(t) {
  const e = `Ethereum Signed Message:
${t.length}`, i = new TextEncoder().encode(e + t);
  return "0x" + Buffer.from(Bb(i)).toString("hex");
}
async function kb(t, e, i, r, s, n) {
  switch (i.t) {
    case "eip191":
      return await Mb(t, e, i.s);
    case "eip1271":
      return await qb(t, e, i.s, r, s, n);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${i.t}`);
  }
}
async function Mb(t, e, i) {
  return (await Bw({ hash: El(e), signature: i })).toLowerCase() === t.toLowerCase();
}
async function qb(t, e, i, r, s, n) {
  const o = jr(r);
  if (!o.namespace || !o.reference)
    throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r}`);
  try {
    const a = "0x1626ba7e", c = "0000000000000000000000000000000000000000000000000000000000000040", u = "0000000000000000000000000000000000000000000000000000000000000041", l = i.substring(2), h = El(e).substring(2), d = a + h + c + u + l, f = await fetch(`${n || Ub}/?chainId=${r}&projectId=${s}`, { method: "POST", body: JSON.stringify({ id: jb(), jsonrpc: "2.0", method: "eth_call", params: [{ to: t, data: d }, "latest"] }) }), { result: p } = await f.json();
    return p ? p.slice(0, a.length).toLowerCase() === a.toLowerCase() : !1;
  } catch (a) {
    return console.error("isValidEip1271Signature: ", a), !1;
  }
}
function jb() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function zb(t) {
  const e = atob(t), i = new Uint8Array(e.length);
  for (let o = 0; o < e.length; o++)
    i[o] = e.charCodeAt(o);
  const r = i[0];
  if (r === 0)
    throw new Error("No signatures found");
  const s = 1 + r * 64;
  if (i.length < s)
    throw new Error("Transaction data too short for claimed signature count");
  if (i.length < 100)
    throw new Error("Transaction too short");
  const n = Buffer.from(t, "base64").slice(1, 65);
  return Mw.encode(n);
}
var Vb = Object.defineProperty, Kb = Object.defineProperties, Hb = Object.getOwnPropertyDescriptors, Ba = Object.getOwnPropertySymbols, Wb = Object.prototype.hasOwnProperty, Gb = Object.prototype.propertyIsEnumerable, Ua = (t, e, i) => e in t ? Vb(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Yb = (t, e) => {
  for (var i in e || (e = {}))
    Wb.call(e, i) && Ua(t, i, e[i]);
  if (Ba)
    for (var i of Ba(e))
      Gb.call(e, i) && Ua(t, i, e[i]);
  return t;
}, Jb = (t, e) => Kb(t, Hb(e));
const Zb = "did:pkh:", lo = (t) => t?.split(":"), Qb = (t) => {
  const e = t && lo(t);
  if (e)
    return t.includes(Zb) ? e[3] : e[1];
}, Sn = (t) => {
  const e = t && lo(t);
  if (e)
    return e[2] + ":" + e[3];
}, Xr = (t) => {
  const e = t && lo(t);
  if (e)
    return e.pop();
};
async function ka(t) {
  const { cacao: e, projectId: i } = t, { s: r, p: s } = e, n = _l(s, s.iss), o = Xr(s.iss);
  return await kb(o, n, r, Sn(s.iss), i);
}
const _l = (t, e) => {
  const i = `${t.domain} wants you to sign in with your Ethereum account:`, r = Xr(e);
  if (!t.aud && !t.uri)
    throw new Error("Either `aud` or `uri` is required to construct the message");
  let s = t.statement || void 0;
  const n = `URI: ${t.aud || t.uri}`, o = `Version: ${t.version}`, a = `Chain ID: ${Qb(e)}`, c = `Nonce: ${t.nonce}`, u = `Issued At: ${t.iat}`, l = t.exp ? `Expiration Time: ${t.exp}` : void 0, h = t.nbf ? `Not Before: ${t.nbf}` : void 0, d = t.requestId ? `Request ID: ${t.requestId}` : void 0, f = t.resources ? `Resources:${t.resources.map((g) => `
- ${g}`).join("")}` : void 0, p = zr(t.resources);
  if (p) {
    const g = ar(p);
    s = a1(s, g);
  }
  return [i, r, "", s, "", n, o, a, c, u, l, h, d, f].filter((g) => g != null).join(`
`);
};
function Xb(t) {
  return Buffer.from(JSON.stringify(t)).toString("base64");
}
function e1(t) {
  return JSON.parse(Buffer.from(t, "base64").toString("utf-8"));
}
function ii(t) {
  if (!t)
    throw new Error("No recap provided, value is undefined");
  if (!t.att)
    throw new Error("No `att` property found");
  const e = Object.keys(t.att);
  if (!(e != null && e.length))
    throw new Error("No resources found in `att` property");
  e.forEach((i) => {
    const r = t.att[i];
    if (Array.isArray(r))
      throw new Error(`Resource must be an object: ${i}`);
    if (typeof r != "object")
      throw new Error(`Resource must be an object: ${i}`);
    if (!Object.keys(r).length)
      throw new Error(`Resource object is empty: ${i}`);
    Object.keys(r).forEach((s) => {
      const n = r[s];
      if (!Array.isArray(n))
        throw new Error(`Ability limits ${s} must be an array of objects, found: ${n}`);
      if (!n.length)
        throw new Error(`Value of ${s} is empty array, must be an array with objects`);
      n.forEach((o) => {
        if (typeof o != "object")
          throw new Error(`Ability limits (${s}) must be an array of objects, found: ${o}`);
      });
    });
  });
}
function t1(t, e, i, r = {}) {
  return i?.sort((s, n) => s.localeCompare(n)), { att: { [t]: i1(e, i, r) } };
}
function i1(t, e, i = {}) {
  e = e?.sort((s, n) => s.localeCompare(n));
  const r = e.map((s) => ({ [`${t}/${s}`]: [i] }));
  return Object.assign({}, ...r);
}
function Il(t) {
  return ii(t), `urn:recap:${Xb(t).replace(/=/g, "")}`;
}
function ar(t) {
  const e = e1(t.replace("urn:recap:", ""));
  return ii(e), e;
}
function r1(t, e, i) {
  const r = t1(t, e, i);
  return Il(r);
}
function s1(t) {
  return t && t.includes("urn:recap:");
}
function n1(t, e) {
  const i = ar(t), r = ar(e), s = o1(i, r);
  return Il(s);
}
function o1(t, e) {
  ii(t), ii(e);
  const i = Object.keys(t.att).concat(Object.keys(e.att)).sort((s, n) => s.localeCompare(n)), r = { att: {} };
  return i.forEach((s) => {
    var n, o;
    Object.keys(((n = t.att) == null ? void 0 : n[s]) || {}).concat(Object.keys(((o = e.att) == null ? void 0 : o[s]) || {})).sort((a, c) => a.localeCompare(c)).forEach((a) => {
      var c, u;
      r.att[s] = Jb(Yb({}, r.att[s]), { [a]: ((c = t.att[s]) == null ? void 0 : c[a]) || ((u = e.att[s]) == null ? void 0 : u[a]) });
    });
  }), r;
}
function a1(t = "", e) {
  ii(e);
  const i = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (t.includes(i))
    return t;
  const r = [];
  let s = 0;
  Object.keys(e.att).forEach((a) => {
    const c = Object.keys(e.att[a]).map((h) => ({ ability: h.split("/")[0], action: h.split("/")[1] }));
    c.sort((h, d) => h.action.localeCompare(d.action));
    const u = {};
    c.forEach((h) => {
      u[h.ability] || (u[h.ability] = []), u[h.ability].push(h.action);
    });
    const l = Object.keys(u).map((h) => (s++, `(${s}) '${h}': '${u[h].join("', '")}' for '${a}'.`));
    r.push(l.join(", ").replace(".,", "."));
  });
  const n = r.join(" "), o = `${i}${n}`;
  return `${t ? t + " " : ""}${o}`;
}
function Ma(t) {
  var e;
  const i = ar(t);
  ii(i);
  const r = (e = i.att) == null ? void 0 : e.eip155;
  return r ? Object.keys(r).map((s) => s.split("/")[1]) : [];
}
function qa(t) {
  const e = ar(t);
  ii(e);
  const i = [];
  return Object.values(e.att).forEach((r) => {
    Object.values(r).forEach((s) => {
      var n;
      (n = s?.[0]) != null && n.chains && i.push(s[0].chains);
    });
  }), [...new Set(i.flat())];
}
function zr(t) {
  if (!t)
    return;
  const e = t?.[t.length - 1];
  return s1(e) ? e : void 0;
}
function Vs(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error("positive integer expected, got " + t);
}
function Dl(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function He(t, ...e) {
  if (!Dl(t))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function ja(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function c1(t, e) {
  He(t);
  const i = e.outputLen;
  if (t.length < i)
    throw new Error("digestInto() expects output buffer of length at least " + i);
}
function za(t) {
  if (typeof t != "boolean")
    throw new Error(`boolean expected, not ${t}`);
}
const Bt = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)), u1 = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), l1 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!l1)
  throw new Error("Non little-endian hardware is not supported");
function h1(t) {
  if (typeof t != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function $n(t) {
  if (typeof t == "string")
    t = h1(t);
  else if (Dl(t))
    t = On(t);
  else
    throw new Error("Uint8Array expected, got " + typeof t);
  return t;
}
function d1(t, e) {
  if (e == null || typeof e != "object")
    throw new Error("options must be defined");
  return Object.assign(t, e);
}
function p1(t, e) {
  if (t.length !== e.length)
    return !1;
  let i = 0;
  for (let r = 0; r < t.length; r++)
    i |= t[r] ^ e[r];
  return i === 0;
}
const f1 = (t, e) => {
  function i(r, ...s) {
    if (He(r), t.nonceLength !== void 0) {
      const u = s[0];
      if (!u)
        throw new Error("nonce / iv required");
      t.varSizeNonce ? He(u) : He(u, t.nonceLength);
    }
    const n = t.tagLength;
    n && s[1] !== void 0 && He(s[1]);
    const o = e(r, ...s), a = (u, l) => {
      if (l !== void 0) {
        if (u !== 2)
          throw new Error("cipher output not supported");
        He(l);
      }
    };
    let c = !1;
    return { encrypt(u, l) {
      if (c)
        throw new Error("cannot encrypt() twice with same key + nonce");
      return c = !0, He(u), a(o.encrypt.length, l), o.encrypt(u, l);
    }, decrypt(u, l) {
      if (He(u), n && u.length < n)
        throw new Error("invalid ciphertext length: smaller than tagLength=" + n);
      return a(o.decrypt.length, l), o.decrypt(u, l);
    } };
  }
  return Object.assign(i, t), i;
};
function Va(t, e, i = !0) {
  if (e === void 0)
    return new Uint8Array(t);
  if (e.length !== t)
    throw new Error("invalid output length, expected " + t + ", got: " + e.length);
  if (i && !g1(e))
    throw new Error("invalid output, must be aligned");
  return e;
}
function Ka(t, e, i, r) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, i, r);
  const s = BigInt(32), n = BigInt(4294967295), o = Number(i >> s & n), a = Number(i & n), c = r ? 4 : 0, u = r ? 0 : 4;
  t.setUint32(e + c, o, r), t.setUint32(e + u, a, r);
}
function g1(t) {
  return t.byteOffset % 4 === 0;
}
function On(t) {
  return Uint8Array.from(t);
}
function $i(...t) {
  for (let e = 0; e < t.length; e++)
    t[e].fill(0);
}
const Sl = (t) => Uint8Array.from(t.split("").map((e) => e.charCodeAt(0))), y1 = Sl("expand 16-byte k"), w1 = Sl("expand 32-byte k"), m1 = Bt(y1), b1 = Bt(w1);
function Z(t, e) {
  return t << e | t >>> 32 - e;
}
function xn(t) {
  return t.byteOffset % 4 === 0;
}
const Nr = 64, v1 = 16, $l = 2 ** 32 - 1, Ha = new Uint32Array();
function E1(t, e, i, r, s, n, o, a) {
  const c = s.length, u = new Uint8Array(Nr), l = Bt(u), h = xn(s) && xn(n), d = h ? Bt(s) : Ha, f = h ? Bt(n) : Ha;
  for (let p = 0; p < c; o++) {
    if (t(e, i, r, l, o, a), o >= $l)
      throw new Error("arx: counter overflow");
    const g = Math.min(Nr, c - p);
    if (h && g === Nr) {
      const y = p / 4;
      if (p % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let m = 0, w; m < v1; m++)
        w = y + m, f[w] = d[w] ^ l[m];
      p += Nr;
      continue;
    }
    for (let y = 0, m; y < g; y++)
      m = p + y, n[m] = s[m] ^ u[y];
    p += g;
  }
}
function _1(t, e) {
  const { allowShortKeys: i, extendNonceFn: r, counterLength: s, counterRight: n, rounds: o } = d1({ allowShortKeys: !1, counterLength: 8, counterRight: !1, rounds: 20 }, e);
  if (typeof t != "function")
    throw new Error("core must be a function");
  return Vs(s), Vs(o), za(n), za(i), (a, c, u, l, h = 0) => {
    He(a), He(c), He(u);
    const d = u.length;
    if (l === void 0 && (l = new Uint8Array(d)), He(l), Vs(h), h < 0 || h >= $l)
      throw new Error("arx: counter overflow");
    if (l.length < d)
      throw new Error(`arx: output (${l.length}) is shorter than data (${d})`);
    const f = [];
    let p = a.length, g, y;
    if (p === 32)
      f.push(g = On(a)), y = b1;
    else if (p === 16 && i)
      g = new Uint8Array(32), g.set(a), g.set(a, 16), y = m1, f.push(g);
    else
      throw new Error(`arx: invalid 32-byte key, got length=${p}`);
    xn(c) || f.push(c = On(c));
    const m = Bt(g);
    if (r) {
      if (c.length !== 24)
        throw new Error("arx: extended nonce must be 24 bytes");
      r(y, m, Bt(c.subarray(0, 16)), m), c = c.subarray(16);
    }
    const w = 16 - s;
    if (w !== c.length)
      throw new Error(`arx: nonce must be ${w} or 16 bytes`);
    if (w !== 12) {
      const E = new Uint8Array(12);
      E.set(c, n ? 0 : 12 - c.length), c = E, f.push(c);
    }
    const b = Bt(c);
    return E1(t, y, m, b, u, l, h, o), $i(...f), l;
  };
}
const Ie = (t, e) => t[e++] & 255 | (t[e++] & 255) << 8;
class I1 {
  constructor(e) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, e = $n(e), He(e, 32);
    const i = Ie(e, 0), r = Ie(e, 2), s = Ie(e, 4), n = Ie(e, 6), o = Ie(e, 8), a = Ie(e, 10), c = Ie(e, 12), u = Ie(e, 14);
    this.r[0] = i & 8191, this.r[1] = (i >>> 13 | r << 3) & 8191, this.r[2] = (r >>> 10 | s << 6) & 7939, this.r[3] = (s >>> 7 | n << 9) & 8191, this.r[4] = (n >>> 4 | o << 12) & 255, this.r[5] = o >>> 1 & 8190, this.r[6] = (o >>> 14 | a << 2) & 8191, this.r[7] = (a >>> 11 | c << 5) & 8065, this.r[8] = (c >>> 8 | u << 8) & 8191, this.r[9] = u >>> 5 & 127;
    for (let l = 0; l < 8; l++)
      this.pad[l] = Ie(e, 16 + 2 * l);
  }
  process(e, i, r = !1) {
    const s = r ? 0 : 2048, { h: n, r: o } = this, a = o[0], c = o[1], u = o[2], l = o[3], h = o[4], d = o[5], f = o[6], p = o[7], g = o[8], y = o[9], m = Ie(e, i + 0), w = Ie(e, i + 2), b = Ie(e, i + 4), E = Ie(e, i + 6), O = Ie(e, i + 8), S = Ie(e, i + 10), $ = Ie(e, i + 12), A = Ie(e, i + 14);
    let I = n[0] + (m & 8191), M = n[1] + ((m >>> 13 | w << 3) & 8191), L = n[2] + ((w >>> 10 | b << 6) & 8191), U = n[3] + ((b >>> 7 | E << 9) & 8191), q = n[4] + ((E >>> 4 | O << 12) & 8191), C = n[5] + (O >>> 1 & 8191), _ = n[6] + ((O >>> 14 | S << 2) & 8191), v = n[7] + ((S >>> 11 | $ << 5) & 8191), x = n[8] + (($ >>> 8 | A << 8) & 8191), P = n[9] + (A >>> 5 | s), D = 0, N = D + I * a + M * (5 * y) + L * (5 * g) + U * (5 * p) + q * (5 * f);
    D = N >>> 13, N &= 8191, N += C * (5 * d) + _ * (5 * h) + v * (5 * l) + x * (5 * u) + P * (5 * c), D += N >>> 13, N &= 8191;
    let B = D + I * c + M * a + L * (5 * y) + U * (5 * g) + q * (5 * p);
    D = B >>> 13, B &= 8191, B += C * (5 * f) + _ * (5 * d) + v * (5 * h) + x * (5 * l) + P * (5 * u), D += B >>> 13, B &= 8191;
    let k = D + I * u + M * c + L * a + U * (5 * y) + q * (5 * g);
    D = k >>> 13, k &= 8191, k += C * (5 * p) + _ * (5 * f) + v * (5 * d) + x * (5 * h) + P * (5 * l), D += k >>> 13, k &= 8191;
    let j = D + I * l + M * u + L * c + U * a + q * (5 * y);
    D = j >>> 13, j &= 8191, j += C * (5 * g) + _ * (5 * p) + v * (5 * f) + x * (5 * d) + P * (5 * h), D += j >>> 13, j &= 8191;
    let z = D + I * h + M * l + L * u + U * c + q * a;
    D = z >>> 13, z &= 8191, z += C * (5 * y) + _ * (5 * g) + v * (5 * p) + x * (5 * f) + P * (5 * d), D += z >>> 13, z &= 8191;
    let H = D + I * d + M * h + L * l + U * u + q * c;
    D = H >>> 13, H &= 8191, H += C * a + _ * (5 * y) + v * (5 * g) + x * (5 * p) + P * (5 * f), D += H >>> 13, H &= 8191;
    let Y = D + I * f + M * d + L * h + U * l + q * u;
    D = Y >>> 13, Y &= 8191, Y += C * c + _ * a + v * (5 * y) + x * (5 * g) + P * (5 * p), D += Y >>> 13, Y &= 8191;
    let ne = D + I * p + M * f + L * d + U * h + q * l;
    D = ne >>> 13, ne &= 8191, ne += C * u + _ * c + v * a + x * (5 * y) + P * (5 * g), D += ne >>> 13, ne &= 8191;
    let ee = D + I * g + M * p + L * f + U * d + q * h;
    D = ee >>> 13, ee &= 8191, ee += C * l + _ * u + v * c + x * a + P * (5 * y), D += ee >>> 13, ee &= 8191;
    let J = D + I * y + M * g + L * p + U * f + q * d;
    D = J >>> 13, J &= 8191, J += C * h + _ * l + v * u + x * c + P * a, D += J >>> 13, J &= 8191, D = (D << 2) + D | 0, D = D + N | 0, N = D & 8191, D = D >>> 13, B += D, n[0] = N, n[1] = B, n[2] = k, n[3] = j, n[4] = z, n[5] = H, n[6] = Y, n[7] = ne, n[8] = ee, n[9] = J;
  }
  finalize() {
    const { h: e, pad: i } = this, r = new Uint16Array(10);
    let s = e[1] >>> 13;
    e[1] &= 8191;
    for (let a = 2; a < 10; a++)
      e[a] += s, s = e[a] >>> 13, e[a] &= 8191;
    e[0] += s * 5, s = e[0] >>> 13, e[0] &= 8191, e[1] += s, s = e[1] >>> 13, e[1] &= 8191, e[2] += s, r[0] = e[0] + 5, s = r[0] >>> 13, r[0] &= 8191;
    for (let a = 1; a < 10; a++)
      r[a] = e[a] + s, s = r[a] >>> 13, r[a] &= 8191;
    r[9] -= 8192;
    let n = (s ^ 1) - 1;
    for (let a = 0; a < 10; a++)
      r[a] &= n;
    n = ~n;
    for (let a = 0; a < 10; a++)
      e[a] = e[a] & n | r[a];
    e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
    let o = e[0] + i[0];
    e[0] = o & 65535;
    for (let a = 1; a < 8; a++)
      o = (e[a] + i[a] | 0) + (o >>> 16) | 0, e[a] = o & 65535;
    $i(r);
  }
  update(e) {
    ja(this);
    const { buffer: i, blockLen: r } = this;
    e = $n(e);
    const s = e.length;
    for (let n = 0; n < s; ) {
      const o = Math.min(r - this.pos, s - n);
      if (o === r) {
        for (; r <= s - n; n += r)
          this.process(e, n);
        continue;
      }
      i.set(e.subarray(n, n + o), this.pos), this.pos += o, n += o, this.pos === r && (this.process(i, 0, !1), this.pos = 0);
    }
    return this;
  }
  destroy() {
    $i(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e) {
    ja(this), c1(e, this), this.finished = !0;
    const { buffer: i, h: r } = this;
    let { pos: s } = this;
    if (s) {
      for (i[s++] = 1; s < 16; s++)
        i[s] = 0;
      this.process(i, 0, !0);
    }
    this.finalize();
    let n = 0;
    for (let o = 0; o < 8; o++)
      e[n++] = r[o] >>> 0, e[n++] = r[o] >>> 8;
    return e;
  }
  digest() {
    const { buffer: e, outputLen: i } = this;
    this.digestInto(e);
    const r = e.slice(0, i);
    return this.destroy(), r;
  }
}
function D1(t) {
  const e = (r, s) => t(s).update($n(r)).digest(), i = t(new Uint8Array(32));
  return e.outputLen = i.outputLen, e.blockLen = i.blockLen, e.create = (r) => t(r), e;
}
const S1 = D1((t) => new I1(t));
function $1(t, e, i, r, s, n = 20) {
  let o = t[0], a = t[1], c = t[2], u = t[3], l = e[0], h = e[1], d = e[2], f = e[3], p = e[4], g = e[5], y = e[6], m = e[7], w = s, b = i[0], E = i[1], O = i[2], S = o, $ = a, A = c, I = u, M = l, L = h, U = d, q = f, C = p, _ = g, v = y, x = m, P = w, D = b, N = E, B = O;
  for (let j = 0; j < n; j += 2)
    S = S + M | 0, P = Z(P ^ S, 16), C = C + P | 0, M = Z(M ^ C, 12), S = S + M | 0, P = Z(P ^ S, 8), C = C + P | 0, M = Z(M ^ C, 7), $ = $ + L | 0, D = Z(D ^ $, 16), _ = _ + D | 0, L = Z(L ^ _, 12), $ = $ + L | 0, D = Z(D ^ $, 8), _ = _ + D | 0, L = Z(L ^ _, 7), A = A + U | 0, N = Z(N ^ A, 16), v = v + N | 0, U = Z(U ^ v, 12), A = A + U | 0, N = Z(N ^ A, 8), v = v + N | 0, U = Z(U ^ v, 7), I = I + q | 0, B = Z(B ^ I, 16), x = x + B | 0, q = Z(q ^ x, 12), I = I + q | 0, B = Z(B ^ I, 8), x = x + B | 0, q = Z(q ^ x, 7), S = S + L | 0, B = Z(B ^ S, 16), v = v + B | 0, L = Z(L ^ v, 12), S = S + L | 0, B = Z(B ^ S, 8), v = v + B | 0, L = Z(L ^ v, 7), $ = $ + U | 0, P = Z(P ^ $, 16), x = x + P | 0, U = Z(U ^ x, 12), $ = $ + U | 0, P = Z(P ^ $, 8), x = x + P | 0, U = Z(U ^ x, 7), A = A + q | 0, D = Z(D ^ A, 16), C = C + D | 0, q = Z(q ^ C, 12), A = A + q | 0, D = Z(D ^ A, 8), C = C + D | 0, q = Z(q ^ C, 7), I = I + M | 0, N = Z(N ^ I, 16), _ = _ + N | 0, M = Z(M ^ _, 12), I = I + M | 0, N = Z(N ^ I, 8), _ = _ + N | 0, M = Z(M ^ _, 7);
  let k = 0;
  r[k++] = o + S | 0, r[k++] = a + $ | 0, r[k++] = c + A | 0, r[k++] = u + I | 0, r[k++] = l + M | 0, r[k++] = h + L | 0, r[k++] = d + U | 0, r[k++] = f + q | 0, r[k++] = p + C | 0, r[k++] = g + _ | 0, r[k++] = y + v | 0, r[k++] = m + x | 0, r[k++] = w + P | 0, r[k++] = b + D | 0, r[k++] = E + N | 0, r[k++] = O + B | 0;
}
const O1 = _1($1, { counterRight: !1, counterLength: 4, allowShortKeys: !1 }), x1 = new Uint8Array(16), Wa = (t, e) => {
  t.update(e);
  const i = e.length % 16;
  i && t.update(x1.subarray(i));
}, A1 = new Uint8Array(32);
function Ga(t, e, i, r, s) {
  const n = t(e, i, A1), o = S1.create(n);
  s && Wa(o, s), Wa(o, r);
  const a = new Uint8Array(16), c = u1(a);
  Ka(c, 0, BigInt(s ? s.length : 0), !0), Ka(c, 8, BigInt(r.length), !0), o.update(a);
  const u = o.digest();
  return $i(n, a), u;
}
const P1 = (t) => (e, i, r) => ({ encrypt(s, n) {
  const o = s.length;
  n = Va(o + 16, n, !1), n.set(s);
  const a = n.subarray(0, -16);
  t(e, i, a, a, 1);
  const c = Ga(t, e, i, a, r);
  return n.set(c, o), $i(c), n;
}, decrypt(s, n) {
  n = Va(s.length - 16, n, !1);
  const o = s.subarray(0, -16), a = s.subarray(-16), c = Ga(t, e, i, o, r);
  if (!p1(a, c))
    throw new Error("invalid tag");
  return n.set(s.subarray(0, -16)), t(e, i, n, n, 1), $i(c), n;
} }), Ol = f1({ blockSize: 64, nonceLength: 12, tagLength: 16 }, P1(O1));
let xl = class extends uo {
  constructor(e, i) {
    super(), this.finished = !1, this.destroyed = !1, co(e);
    const r = Si(i);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, n = new Uint8Array(s);
    n.set(r.length > s ? e.create().update(r).digest() : r);
    for (let o = 0; o < n.length; o++)
      n[o] ^= 54;
    this.iHash.update(n), this.oHash = e.create();
    for (let o = 0; o < n.length; o++)
      n[o] ^= 106;
    this.oHash.update(n), n.fill(0);
  }
  update(e) {
    return Di(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Di(this), br(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: i, iHash: r, finished: s, destroyed: n, blockLen: o, outputLen: a } = this;
    return e = e, e.finished = s, e.destroyed = n, e.blockLen = o, e.outputLen = a, e.oHash = i._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
};
const ps = (t, e, i) => new xl(t, e).update(i).digest();
ps.create = (t, e) => new xl(t, e);
function C1(t, e, i) {
  return co(t), i === void 0 && (i = new Uint8Array(t.outputLen)), ps(t, Si(i), Si(e));
}
const Ks = new Uint8Array([0]), Ya = new Uint8Array();
function R1(t, e, i, r = 32) {
  if (co(t), or(r), r > 255 * t.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const s = Math.ceil(r / t.outputLen);
  i === void 0 && (i = Ya);
  const n = new Uint8Array(s * t.outputLen), o = ps.create(t, e), a = o._cloneInto(), c = new Uint8Array(o.outputLen);
  for (let u = 0; u < s; u++)
    Ks[0] = u + 1, a.update(u === 0 ? Ya : c).update(i).update(Ks).digestInto(c), n.set(c, t.outputLen * u), o._cloneInto(a);
  return o.destroy(), a.destroy(), c.fill(0), Ks.fill(0), n.slice(0, r);
}
const T1 = (t, e, i, r, s) => R1(t, C1(t, e, i), r, s);
function N1(t, e, i, r) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, i, r);
  const s = BigInt(32), n = BigInt(4294967295), o = Number(i >> s & n), a = Number(i & n), c = r ? 4 : 0, u = r ? 0 : 4;
  t.setUint32(e + c, o, r), t.setUint32(e + u, a, r);
}
function F1(t, e, i) {
  return t & e ^ ~t & i;
}
function L1(t, e, i) {
  return t & e ^ t & i ^ e & i;
}
let B1 = class extends uo {
  constructor(e, i, r, s) {
    super(), this.blockLen = e, this.outputLen = i, this.padOffset = r, this.isLE = s, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = zs(this.buffer);
  }
  update(e) {
    Di(this);
    const { view: i, buffer: r, blockLen: s } = this;
    e = Si(e);
    const n = e.length;
    for (let o = 0; o < n; ) {
      const a = Math.min(s - this.pos, n - o);
      if (a === s) {
        const c = zs(e);
        for (; s <= n - o; o += s)
          this.process(c, o);
        continue;
      }
      r.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === s && (this.process(i, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Di(this), gl(e, this), this.finished = !0;
    const { buffer: i, view: r, blockLen: s, isLE: n } = this;
    let { pos: o } = this;
    i[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > s - o && (this.process(r, 0), o = 0);
    for (let h = o; h < s; h++)
      i[h] = 0;
    N1(r, s - 8, BigInt(this.length * 8), n), this.process(r, 0);
    const a = zs(e), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let h = 0; h < u; h++)
      a.setUint32(4 * h, l[h], n);
  }
  digest() {
    const { buffer: e, outputLen: i } = this;
    this.digestInto(e);
    const r = e.slice(0, i);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: i, buffer: r, length: s, finished: n, destroyed: o, pos: a } = this;
    return e.length = s, e.pos = a, e.finished = n, e.destroyed = o, s % i && e.buffer.set(r), e;
  }
};
const U1 = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]), Rt = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), Tt = new Uint32Array(64);
class k1 extends B1 {
  constructor() {
    super(64, 32, 8, !1), this.A = Rt[0] | 0, this.B = Rt[1] | 0, this.C = Rt[2] | 0, this.D = Rt[3] | 0, this.E = Rt[4] | 0, this.F = Rt[5] | 0, this.G = Rt[6] | 0, this.H = Rt[7] | 0;
  }
  get() {
    const { A: e, B: i, C: r, D: s, E: n, F: o, G: a, H: c } = this;
    return [e, i, r, s, n, o, a, c];
  }
  set(e, i, r, s, n, o, a, c) {
    this.A = e | 0, this.B = i | 0, this.C = r | 0, this.D = s | 0, this.E = n | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;
  }
  process(e, i) {
    for (let h = 0; h < 16; h++, i += 4)
      Tt[h] = e.getUint32(i, !1);
    for (let h = 16; h < 64; h++) {
      const d = Tt[h - 15], f = Tt[h - 2], p = ct(d, 7) ^ ct(d, 18) ^ d >>> 3, g = ct(f, 17) ^ ct(f, 19) ^ f >>> 10;
      Tt[h] = g + Tt[h - 7] + p + Tt[h - 16] | 0;
    }
    let { A: r, B: s, C: n, D: o, E: a, F: c, G: u, H: l } = this;
    for (let h = 0; h < 64; h++) {
      const d = ct(a, 6) ^ ct(a, 11) ^ ct(a, 25), f = l + d + F1(a, c, u) + U1[h] + Tt[h] | 0, p = (ct(r, 2) ^ ct(r, 13) ^ ct(r, 22)) + L1(r, s, n) | 0;
      l = u, u = c, c = a, a = o + f | 0, o = n, n = s, s = r, r = f + p | 0;
    }
    r = r + this.A | 0, s = s + this.B | 0, n = n + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(r, s, n, o, a, c, u, l);
  }
  roundClean() {
    Tt.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const vr = yl(() => new k1());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const fs = BigInt(0), gs = BigInt(1), M1 = BigInt(2);
function ri(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Er(t) {
  if (!ri(t))
    throw new Error("Uint8Array expected");
}
function Oi(t, e) {
  if (typeof e != "boolean")
    throw new Error(t + " boolean expected, got " + e);
}
const q1 = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function xi(t) {
  Er(t);
  let e = "";
  for (let i = 0; i < t.length; i++)
    e += q1[t[i]];
  return e;
}
function Ei(t) {
  const e = t.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function ho(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  return t === "" ? fs : BigInt("0x" + t);
}
const _t = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Ja(t) {
  if (t >= _t._0 && t <= _t._9)
    return t - _t._0;
  if (t >= _t.A && t <= _t.F)
    return t - (_t.A - 10);
  if (t >= _t.a && t <= _t.f)
    return t - (_t.a - 10);
}
function Ai(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  const e = t.length, i = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const r = new Uint8Array(i);
  for (let s = 0, n = 0; s < i; s++, n += 2) {
    const o = Ja(t.charCodeAt(n)), a = Ja(t.charCodeAt(n + 1));
    if (o === void 0 || a === void 0) {
      const c = t[n] + t[n + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + n);
    }
    r[s] = o * 16 + a;
  }
  return r;
}
function Xt(t) {
  return ho(xi(t));
}
function cr(t) {
  return Er(t), ho(xi(Uint8Array.from(t).reverse()));
}
function Pi(t, e) {
  return Ai(t.toString(16).padStart(e * 2, "0"));
}
function ys(t, e) {
  return Pi(t, e).reverse();
}
function j1(t) {
  return Ai(Ei(t));
}
function Ke(t, e, i) {
  let r;
  if (typeof e == "string")
    try {
      r = Ai(e);
    } catch (n) {
      throw new Error(t + " must be hex string or Uint8Array, cause: " + n);
    }
  else if (ri(e))
    r = Uint8Array.from(e);
  else
    throw new Error(t + " must be hex string or Uint8Array");
  const s = r.length;
  if (typeof i == "number" && s !== i)
    throw new Error(t + " of length " + i + " expected, got " + s);
  return r;
}
function ur(...t) {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    Er(s), e += s.length;
  }
  const i = new Uint8Array(e);
  for (let r = 0, s = 0; r < t.length; r++) {
    const n = t[r];
    i.set(n, s), s += n.length;
  }
  return i;
}
function z1(t, e) {
  if (t.length !== e.length)
    return !1;
  let i = 0;
  for (let r = 0; r < t.length; r++)
    i |= t[r] ^ e[r];
  return i === 0;
}
function V1(t) {
  if (typeof t != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
const Hs = (t) => typeof t == "bigint" && fs <= t;
function ws(t, e, i) {
  return Hs(t) && Hs(e) && Hs(i) && e <= t && t < i;
}
function xt(t, e, i, r) {
  if (!ws(e, i, r))
    throw new Error("expected valid " + t + ": " + i + " <= n < " + r + ", got " + e);
}
function Al(t) {
  let e;
  for (e = 0; t > fs; t >>= gs, e += 1)
    ;
  return e;
}
function K1(t, e) {
  return t >> BigInt(e) & gs;
}
function H1(t, e, i) {
  return t | (i ? gs : fs) << BigInt(e);
}
const po = (t) => (M1 << BigInt(t - 1)) - gs, Ws = (t) => new Uint8Array(t), Za = (t) => Uint8Array.from(t);
function Pl(t, e, i) {
  if (typeof t != "number" || t < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof i != "function")
    throw new Error("hmacFn must be a function");
  let r = Ws(t), s = Ws(t), n = 0;
  const o = () => {
    r.fill(1), s.fill(0), n = 0;
  }, a = (...l) => i(s, r, ...l), c = (l = Ws()) => {
    s = a(Za([0]), l), r = a(), l.length !== 0 && (s = a(Za([1]), l), r = a());
  }, u = () => {
    if (n++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let l = 0;
    const h = [];
    for (; l < e; ) {
      r = a();
      const d = r.slice();
      h.push(d), l += r.length;
    }
    return ur(...h);
  };
  return (l, h) => {
    o(), c(l);
    let d;
    for (; !(d = h(u())); )
      c();
    return o(), d;
  };
}
const W1 = { bigint: (t) => typeof t == "bigint", function: (t) => typeof t == "function", boolean: (t) => typeof t == "boolean", string: (t) => typeof t == "string", stringOrUint8Array: (t) => typeof t == "string" || ri(t), isSafeInteger: (t) => Number.isSafeInteger(t), array: (t) => Array.isArray(t), field: (t, e) => e.Fp.isValid(t), hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen) };
function Bi(t, e, i = {}) {
  const r = (s, n, o) => {
    const a = W1[n];
    if (typeof a != "function")
      throw new Error("invalid validator function");
    const c = t[s];
    if (!(o && c === void 0) && !a(c, t))
      throw new Error("param " + String(s) + " is invalid. Expected " + n + ", got " + c);
  };
  for (const [s, n] of Object.entries(e))
    r(s, n, !1);
  for (const [s, n] of Object.entries(i))
    r(s, n, !0);
  return t;
}
const G1 = () => {
  throw new Error("not implemented");
};
function An(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return (i, ...r) => {
    const s = e.get(i);
    if (s !== void 0)
      return s;
    const n = t(i, ...r);
    return e.set(i, n), n;
  };
}
var Y1 = Object.freeze({ __proto__: null, isBytes: ri, abytes: Er, abool: Oi, bytesToHex: xi, numberToHexUnpadded: Ei, hexToNumber: ho, hexToBytes: Ai, bytesToNumberBE: Xt, bytesToNumberLE: cr, numberToBytesBE: Pi, numberToBytesLE: ys, numberToVarBytesBE: j1, ensureBytes: Ke, concatBytes: ur, equalBytes: z1, utf8ToBytes: V1, inRange: ws, aInRange: xt, bitLen: Al, bitGet: K1, bitSet: H1, bitMask: po, createHmacDrbg: Pl, validateObject: Bi, notImplemented: G1, memoized: An });
const Ee = BigInt(0), le = BigInt(1), Gt = BigInt(2), J1 = BigInt(3), Pn = BigInt(4), Qa = BigInt(5), Xa = BigInt(8);
function Me(t, e) {
  const i = t % e;
  return i >= Ee ? i : e + i;
}
function Cl(t, e, i) {
  if (e < Ee)
    throw new Error("invalid exponent, negatives unsupported");
  if (i <= Ee)
    throw new Error("invalid modulus");
  if (i === le)
    return Ee;
  let r = le;
  for (; e > Ee; )
    e & le && (r = r * t % i), t = t * t % i, e >>= le;
  return r;
}
function st(t, e, i) {
  let r = t;
  for (; e-- > Ee; )
    r *= r, r %= i;
  return r;
}
function Cn(t, e) {
  if (t === Ee)
    throw new Error("invert: expected non-zero number");
  if (e <= Ee)
    throw new Error("invert: expected positive modulus, got " + e);
  let i = Me(t, e), r = e, s = Ee, n = le;
  for (; i !== Ee; ) {
    const o = r / i, a = r % i, c = s - n * o;
    r = i, i = a, s = n, n = c;
  }
  if (r !== le)
    throw new Error("invert: does not exist");
  return Me(s, e);
}
function Z1(t) {
  const e = (t - le) / Gt;
  let i, r, s;
  for (i = t - le, r = 0; i % Gt === Ee; i /= Gt, r++)
    ;
  for (s = Gt; s < t && Cl(s, e, t) !== t - le; s++)
    if (s > 1e3)
      throw new Error("Cannot find square root: likely non-prime P");
  if (r === 1) {
    const o = (t + le) / Pn;
    return function(a, c) {
      const u = a.pow(c, o);
      if (!a.eql(a.sqr(u), c))
        throw new Error("Cannot find square root");
      return u;
    };
  }
  const n = (i + le) / Gt;
  return function(o, a) {
    if (o.pow(a, e) === o.neg(o.ONE))
      throw new Error("Cannot find square root");
    let c = r, u = o.pow(o.mul(o.ONE, s), i), l = o.pow(a, n), h = o.pow(a, i);
    for (; !o.eql(h, o.ONE); ) {
      if (o.eql(h, o.ZERO))
        return o.ZERO;
      let d = 1;
      for (let p = o.sqr(h); d < c && !o.eql(p, o.ONE); d++)
        p = o.sqr(p);
      const f = o.pow(u, le << BigInt(c - d - 1));
      u = o.sqr(f), l = o.mul(l, f), h = o.mul(h, u), c = d;
    }
    return l;
  };
}
function Q1(t) {
  if (t % Pn === J1) {
    const e = (t + le) / Pn;
    return function(i, r) {
      const s = i.pow(r, e);
      if (!i.eql(i.sqr(s), r))
        throw new Error("Cannot find square root");
      return s;
    };
  }
  if (t % Xa === Qa) {
    const e = (t - Qa) / Xa;
    return function(i, r) {
      const s = i.mul(r, Gt), n = i.pow(s, e), o = i.mul(r, n), a = i.mul(i.mul(o, Gt), n), c = i.mul(o, i.sub(a, i.ONE));
      if (!i.eql(i.sqr(c), r))
        throw new Error("Cannot find square root");
      return c;
    };
  }
  return Z1(t);
}
const X1 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function e0(t) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, i = X1.reduce((r, s) => (r[s] = "function", r), e);
  return Bi(t, i);
}
function t0(t, e, i) {
  if (i < Ee)
    throw new Error("invalid exponent, negatives unsupported");
  if (i === Ee)
    return t.ONE;
  if (i === le)
    return e;
  let r = t.ONE, s = e;
  for (; i > Ee; )
    i & le && (r = t.mul(r, s)), s = t.sqr(s), i >>= le;
  return r;
}
function i0(t, e) {
  const i = new Array(e.length), r = e.reduce((n, o, a) => t.is0(o) ? n : (i[a] = n, t.mul(n, o)), t.ONE), s = t.inv(r);
  return e.reduceRight((n, o, a) => t.is0(o) ? n : (i[a] = t.mul(n, i[a]), t.mul(n, o)), s), i;
}
function Rl(t, e) {
  const i = e !== void 0 ? e : t.toString(2).length, r = Math.ceil(i / 8);
  return { nBitLength: i, nByteLength: r };
}
function Tl(t, e, i = !1, r = {}) {
  if (t <= Ee)
    throw new Error("invalid field: expected ORDER > 0, got " + t);
  const { nBitLength: s, nByteLength: n } = Rl(t, e);
  if (n > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let o;
  const a = Object.freeze({ ORDER: t, isLE: i, BITS: s, BYTES: n, MASK: po(s), ZERO: Ee, ONE: le, create: (c) => Me(c, t), isValid: (c) => {
    if (typeof c != "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof c);
    return Ee <= c && c < t;
  }, is0: (c) => c === Ee, isOdd: (c) => (c & le) === le, neg: (c) => Me(-c, t), eql: (c, u) => c === u, sqr: (c) => Me(c * c, t), add: (c, u) => Me(c + u, t), sub: (c, u) => Me(c - u, t), mul: (c, u) => Me(c * u, t), pow: (c, u) => t0(a, c, u), div: (c, u) => Me(c * Cn(u, t), t), sqrN: (c) => c * c, addN: (c, u) => c + u, subN: (c, u) => c - u, mulN: (c, u) => c * u, inv: (c) => Cn(c, t), sqrt: r.sqrt || ((c) => (o || (o = Q1(t)), o(a, c))), invertBatch: (c) => i0(a, c), cmov: (c, u, l) => l ? u : c, toBytes: (c) => i ? ys(c, n) : Pi(c, n), fromBytes: (c) => {
    if (c.length !== n)
      throw new Error("Field.fromBytes: expected " + n + " bytes, got " + c.length);
    return i ? cr(c) : Xt(c);
  } });
  return Object.freeze(a);
}
function Nl(t) {
  if (typeof t != "bigint")
    throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function Fl(t) {
  const e = Nl(t);
  return e + Math.ceil(e / 2);
}
function r0(t, e, i = !1) {
  const r = t.length, s = Nl(e), n = Fl(e);
  if (r < 16 || r < n || r > 1024)
    throw new Error("expected " + n + "-1024 bytes of input, got " + r);
  const o = i ? cr(t) : Xt(t), a = Me(o, e - le) + le;
  return i ? ys(a, s) : Pi(a, s);
}
const ec = BigInt(0), Fr = BigInt(1);
function Gs(t, e) {
  const i = e.negate();
  return t ? i : e;
}
function Ll(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e)
    throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function Ys(t, e) {
  Ll(t, e);
  const i = Math.ceil(e / t) + 1, r = 2 ** (t - 1);
  return { windows: i, windowSize: r };
}
function s0(t, e) {
  if (!Array.isArray(t))
    throw new Error("array expected");
  t.forEach((i, r) => {
    if (!(i instanceof e))
      throw new Error("invalid point at index " + r);
  });
}
function n0(t, e) {
  if (!Array.isArray(t))
    throw new Error("array of scalars expected");
  t.forEach((i, r) => {
    if (!e.isValid(i))
      throw new Error("invalid scalar at index " + r);
  });
}
const Js = /* @__PURE__ */ new WeakMap(), Bl = /* @__PURE__ */ new WeakMap();
function Zs(t) {
  return Bl.get(t) || 1;
}
function o0(t, e) {
  return { constTimeNegate: Gs, hasPrecomputes(i) {
    return Zs(i) !== 1;
  }, unsafeLadder(i, r, s = t.ZERO) {
    let n = i;
    for (; r > ec; )
      r & Fr && (s = s.add(n)), n = n.double(), r >>= Fr;
    return s;
  }, precomputeWindow(i, r) {
    const { windows: s, windowSize: n } = Ys(r, e), o = [];
    let a = i, c = a;
    for (let u = 0; u < s; u++) {
      c = a, o.push(c);
      for (let l = 1; l < n; l++)
        c = c.add(a), o.push(c);
      a = c.double();
    }
    return o;
  }, wNAF(i, r, s) {
    const { windows: n, windowSize: o } = Ys(i, e);
    let a = t.ZERO, c = t.BASE;
    const u = BigInt(2 ** i - 1), l = 2 ** i, h = BigInt(i);
    for (let d = 0; d < n; d++) {
      const f = d * o;
      let p = Number(s & u);
      s >>= h, p > o && (p -= l, s += Fr);
      const g = f, y = f + Math.abs(p) - 1, m = d % 2 !== 0, w = p < 0;
      p === 0 ? c = c.add(Gs(m, r[g])) : a = a.add(Gs(w, r[y]));
    }
    return { p: a, f: c };
  }, wNAFUnsafe(i, r, s, n = t.ZERO) {
    const { windows: o, windowSize: a } = Ys(i, e), c = BigInt(2 ** i - 1), u = 2 ** i, l = BigInt(i);
    for (let h = 0; h < o; h++) {
      const d = h * a;
      if (s === ec)
        break;
      let f = Number(s & c);
      if (s >>= l, f > a && (f -= u, s += Fr), f === 0)
        continue;
      let p = r[d + Math.abs(f) - 1];
      f < 0 && (p = p.negate()), n = n.add(p);
    }
    return n;
  }, getPrecomputes(i, r, s) {
    let n = Js.get(r);
    return n || (n = this.precomputeWindow(r, i), i !== 1 && Js.set(r, s(n))), n;
  }, wNAFCached(i, r, s) {
    const n = Zs(i);
    return this.wNAF(n, this.getPrecomputes(n, i, s), r);
  }, wNAFCachedUnsafe(i, r, s, n) {
    const o = Zs(i);
    return o === 1 ? this.unsafeLadder(i, r, n) : this.wNAFUnsafe(o, this.getPrecomputes(o, i, s), r, n);
  }, setWindowSize(i, r) {
    Ll(r, e), Bl.set(i, r), Js.delete(i);
  } };
}
function a0(t, e, i, r) {
  if (s0(i, t), n0(r, e), i.length !== r.length)
    throw new Error("arrays of points and scalars must have equal length");
  const s = t.ZERO, n = Al(BigInt(i.length)), o = n > 12 ? n - 3 : n > 4 ? n - 2 : n ? 2 : 1, a = (1 << o) - 1, c = new Array(a + 1).fill(s), u = Math.floor((e.BITS - 1) / o) * o;
  let l = s;
  for (let h = u; h >= 0; h -= o) {
    c.fill(s);
    for (let f = 0; f < r.length; f++) {
      const p = r[f], g = Number(p >> BigInt(h) & BigInt(a));
      c[g] = c[g].add(i[f]);
    }
    let d = s;
    for (let f = c.length - 1, p = s; f > 0; f--)
      p = p.add(c[f]), d = d.add(p);
    if (l = l.add(d), h !== 0)
      for (let f = 0; f < o; f++)
        l = l.double();
  }
  return l;
}
function Ul(t) {
  return e0(t.Fp), Bi(t, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...Rl(t.n, t.nBitLength), ...t, p: t.Fp.ORDER });
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
const wi = BigInt(0), Qs = BigInt(1);
function c0(t) {
  return Bi(t, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...t });
}
function u0(t) {
  const e = c0(t), { P: i } = e, r = (w) => Me(w, i), s = e.montgomeryBits, n = Math.ceil(s / 8), o = e.nByteLength, a = e.adjustScalarBytes || ((w) => w), c = e.powPminus2 || ((w) => Cl(w, i - BigInt(2), i));
  function u(w, b, E) {
    const O = r(w * (b - E));
    return b = r(b - O), E = r(E + O), [b, E];
  }
  const l = (e.a - BigInt(2)) / BigInt(4);
  function h(w, b) {
    xt("u", w, wi, i), xt("scalar", b, wi, i);
    const E = b, O = w;
    let S = Qs, $ = wi, A = w, I = Qs, M = wi, L;
    for (let q = BigInt(s - 1); q >= wi; q--) {
      const C = E >> q & Qs;
      M ^= C, L = u(M, S, A), S = L[0], A = L[1], L = u(M, $, I), $ = L[0], I = L[1], M = C;
      const _ = S + $, v = r(_ * _), x = S - $, P = r(x * x), D = v - P, N = A + I, B = A - I, k = r(B * _), j = r(N * x), z = k + j, H = k - j;
      A = r(z * z), I = r(O * r(H * H)), S = r(v * P), $ = r(D * (v + r(l * D)));
    }
    L = u(M, S, A), S = L[0], A = L[1], L = u(M, $, I), $ = L[0], I = L[1];
    const U = c($);
    return r(S * U);
  }
  function d(w) {
    return ys(r(w), n);
  }
  function f(w) {
    const b = Ke("u coordinate", w, n);
    return o === 32 && (b[31] &= 127), cr(b);
  }
  function p(w) {
    const b = Ke("scalar", w), E = b.length;
    if (E !== n && E !== o) {
      let O = "" + n + " or " + o;
      throw new Error("invalid scalar, expected " + O + " bytes, got " + E);
    }
    return cr(a(b));
  }
  function g(w, b) {
    const E = f(b), O = p(w), S = h(E, O);
    if (S === wi)
      throw new Error("invalid private or public key received");
    return d(S);
  }
  const y = d(e.Gu);
  function m(w) {
    return g(w, y);
  }
  return { scalarMult: g, scalarMultBase: m, getSharedSecret: (w, b) => g(w, b), getPublicKey: (w) => m(w), utils: { randomPrivateKey: () => e.randomBytes(e.nByteLength) }, GuBytes: y };
}
const Rn = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
BigInt(0);
const l0 = BigInt(1), tc = BigInt(2), h0 = BigInt(3), d0 = BigInt(5);
BigInt(8);
function p0(t) {
  const e = BigInt(10), i = BigInt(20), r = BigInt(40), s = BigInt(80), n = Rn, o = t * t % n * t % n, a = st(o, tc, n) * o % n, c = st(a, l0, n) * t % n, u = st(c, d0, n) * c % n, l = st(u, e, n) * u % n, h = st(l, i, n) * l % n, d = st(h, r, n) * h % n, f = st(d, s, n) * d % n, p = st(f, s, n) * d % n, g = st(p, e, n) * u % n;
  return { pow_p_5_8: st(g, tc, n) * t % n, b2: o };
}
function f0(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
const Tn = u0({ P: Rn, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (t) => {
  const e = Rn, { pow_p_5_8: i, b2: r } = p0(t);
  return Me(st(i, h0, e) * r, e);
}, adjustScalarBytes: f0, randomBytes: Li });
function ic(t) {
  t.lowS !== void 0 && Oi("lowS", t.lowS), t.prehash !== void 0 && Oi("prehash", t.prehash);
}
function g0(t) {
  const e = Ul(t);
  Bi(e, { a: "field", b: "field" }, { allowedPrivateKeyLengths: "array", wrapPrivateKey: "boolean", isTorsionFree: "function", clearCofactor: "function", allowInfinityPoint: "boolean", fromBytes: "function", toBytes: "function" });
  const { endo: i, Fp: r, a: s } = e;
  if (i) {
    if (!r.eql(s, r.ZERO))
      throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    if (typeof i != "object" || typeof i.beta != "bigint" || typeof i.splitScalar != "function")
      throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
const { bytesToNumberBE: y0, hexToBytes: w0 } = Y1;
class m0 extends Error {
  constructor(e = "") {
    super(e);
  }
}
const $t = { Err: m0, _tlv: { encode: (t, e) => {
  const { Err: i } = $t;
  if (t < 0 || t > 256)
    throw new i("tlv.encode: wrong tag");
  if (e.length & 1)
    throw new i("tlv.encode: unpadded data");
  const r = e.length / 2, s = Ei(r);
  if (s.length / 2 & 128)
    throw new i("tlv.encode: long form length too big");
  const n = r > 127 ? Ei(s.length / 2 | 128) : "";
  return Ei(t) + n + s + e;
}, decode(t, e) {
  const { Err: i } = $t;
  let r = 0;
  if (t < 0 || t > 256)
    throw new i("tlv.encode: wrong tag");
  if (e.length < 2 || e[r++] !== t)
    throw new i("tlv.decode: wrong tlv");
  const s = e[r++], n = !!(s & 128);
  let o = 0;
  if (!n)
    o = s;
  else {
    const c = s & 127;
    if (!c)
      throw new i("tlv.decode(long): indefinite length not supported");
    if (c > 4)
      throw new i("tlv.decode(long): byte length is too big");
    const u = e.subarray(r, r + c);
    if (u.length !== c)
      throw new i("tlv.decode: length bytes not complete");
    if (u[0] === 0)
      throw new i("tlv.decode(long): zero leftmost byte");
    for (const l of u)
      o = o << 8 | l;
    if (r += c, o < 128)
      throw new i("tlv.decode(long): not minimal encoding");
  }
  const a = e.subarray(r, r + o);
  if (a.length !== o)
    throw new i("tlv.decode: wrong value length");
  return { v: a, l: e.subarray(r + o) };
} }, _int: { encode(t) {
  const { Err: e } = $t;
  if (t < Ot)
    throw new e("integer: negative integers are not allowed");
  let i = Ei(t);
  if (Number.parseInt(i[0], 16) & 8 && (i = "00" + i), i.length & 1)
    throw new e("unexpected DER parsing assertion: unpadded hex");
  return i;
}, decode(t) {
  const { Err: e } = $t;
  if (t[0] & 128)
    throw new e("invalid signature integer: negative");
  if (t[0] === 0 && !(t[1] & 128))
    throw new e("invalid signature integer: unnecessary leading zero");
  return y0(t);
} }, toSig(t) {
  const { Err: e, _int: i, _tlv: r } = $t, s = typeof t == "string" ? w0(t) : t;
  Er(s);
  const { v: n, l: o } = r.decode(48, s);
  if (o.length)
    throw new e("invalid signature: left bytes after parsing");
  const { v: a, l: c } = r.decode(2, n), { v: u, l } = r.decode(2, c);
  if (l.length)
    throw new e("invalid signature: left bytes after parsing");
  return { r: i.decode(a), s: i.decode(u) };
}, hexFromSig(t) {
  const { _tlv: e, _int: i } = $t, r = e.encode(2, i.encode(t.r)), s = e.encode(2, i.encode(t.s)), n = r + s;
  return e.encode(48, n);
} }, Ot = BigInt(0), me = BigInt(1);
BigInt(2);
const rc = BigInt(3);
BigInt(4);
function b0(t) {
  const e = g0(t), { Fp: i } = e, r = Tl(e.n, e.nBitLength), s = e.toBytes || ((g, y, m) => {
    const w = y.toAffine();
    return ur(Uint8Array.from([4]), i.toBytes(w.x), i.toBytes(w.y));
  }), n = e.fromBytes || ((g) => {
    const y = g.subarray(1), m = i.fromBytes(y.subarray(0, i.BYTES)), w = i.fromBytes(y.subarray(i.BYTES, 2 * i.BYTES));
    return { x: m, y: w };
  });
  function o(g) {
    const { a: y, b: m } = e, w = i.sqr(g), b = i.mul(w, g);
    return i.add(i.add(b, i.mul(g, y)), m);
  }
  if (!i.eql(i.sqr(e.Gy), o(e.Gx)))
    throw new Error("bad generator point: equation left != right");
  function a(g) {
    return ws(g, me, e.n);
  }
  function c(g) {
    const { allowedPrivateKeyLengths: y, nByteLength: m, wrapPrivateKey: w, n: b } = e;
    if (y && typeof g != "bigint") {
      if (ri(g) && (g = xi(g)), typeof g != "string" || !y.includes(g.length))
        throw new Error("invalid private key");
      g = g.padStart(m * 2, "0");
    }
    let E;
    try {
      E = typeof g == "bigint" ? g : Xt(Ke("private key", g, m));
    } catch {
      throw new Error("invalid private key, expected hex or " + m + " bytes, got " + typeof g);
    }
    return w && (E = Me(E, b)), xt("private key", E, me, b), E;
  }
  function u(g) {
    if (!(g instanceof d))
      throw new Error("ProjectivePoint expected");
  }
  const l = An((g, y) => {
    const { px: m, py: w, pz: b } = g;
    if (i.eql(b, i.ONE))
      return { x: m, y: w };
    const E = g.is0();
    y == null && (y = E ? i.ONE : i.inv(b));
    const O = i.mul(m, y), S = i.mul(w, y), $ = i.mul(b, y);
    if (E)
      return { x: i.ZERO, y: i.ZERO };
    if (!i.eql($, i.ONE))
      throw new Error("invZ was invalid");
    return { x: O, y: S };
  }), h = An((g) => {
    if (g.is0()) {
      if (e.allowInfinityPoint && !i.is0(g.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: y, y: m } = g.toAffine();
    if (!i.isValid(y) || !i.isValid(m))
      throw new Error("bad point: x or y not FE");
    const w = i.sqr(m), b = o(y);
    if (!i.eql(w, b))
      throw new Error("bad point: equation left != right");
    if (!g.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  class d {
    constructor(y, m, w) {
      if (this.px = y, this.py = m, this.pz = w, y == null || !i.isValid(y))
        throw new Error("x required");
      if (m == null || !i.isValid(m))
        throw new Error("y required");
      if (w == null || !i.isValid(w))
        throw new Error("z required");
      Object.freeze(this);
    }
    static fromAffine(y) {
      const { x: m, y: w } = y || {};
      if (!y || !i.isValid(m) || !i.isValid(w))
        throw new Error("invalid affine point");
      if (y instanceof d)
        throw new Error("projective point not allowed");
      const b = (E) => i.eql(E, i.ZERO);
      return b(m) && b(w) ? d.ZERO : new d(m, w, i.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(y) {
      const m = i.invertBatch(y.map((w) => w.pz));
      return y.map((w, b) => w.toAffine(m[b])).map(d.fromAffine);
    }
    static fromHex(y) {
      const m = d.fromAffine(n(Ke("pointHex", y)));
      return m.assertValidity(), m;
    }
    static fromPrivateKey(y) {
      return d.BASE.multiply(c(y));
    }
    static msm(y, m) {
      return a0(d, r, y, m);
    }
    _setWindowSize(y) {
      p.setWindowSize(this, y);
    }
    assertValidity() {
      h(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (i.isOdd)
        return !i.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    equals(y) {
      u(y);
      const { px: m, py: w, pz: b } = this, { px: E, py: O, pz: S } = y, $ = i.eql(i.mul(m, S), i.mul(E, b)), A = i.eql(i.mul(w, S), i.mul(O, b));
      return $ && A;
    }
    negate() {
      return new d(this.px, i.neg(this.py), this.pz);
    }
    double() {
      const { a: y, b: m } = e, w = i.mul(m, rc), { px: b, py: E, pz: O } = this;
      let S = i.ZERO, $ = i.ZERO, A = i.ZERO, I = i.mul(b, b), M = i.mul(E, E), L = i.mul(O, O), U = i.mul(b, E);
      return U = i.add(U, U), A = i.mul(b, O), A = i.add(A, A), S = i.mul(y, A), $ = i.mul(w, L), $ = i.add(S, $), S = i.sub(M, $), $ = i.add(M, $), $ = i.mul(S, $), S = i.mul(U, S), A = i.mul(w, A), L = i.mul(y, L), U = i.sub(I, L), U = i.mul(y, U), U = i.add(U, A), A = i.add(I, I), I = i.add(A, I), I = i.add(I, L), I = i.mul(I, U), $ = i.add($, I), L = i.mul(E, O), L = i.add(L, L), I = i.mul(L, U), S = i.sub(S, I), A = i.mul(L, M), A = i.add(A, A), A = i.add(A, A), new d(S, $, A);
    }
    add(y) {
      u(y);
      const { px: m, py: w, pz: b } = this, { px: E, py: O, pz: S } = y;
      let $ = i.ZERO, A = i.ZERO, I = i.ZERO;
      const M = e.a, L = i.mul(e.b, rc);
      let U = i.mul(m, E), q = i.mul(w, O), C = i.mul(b, S), _ = i.add(m, w), v = i.add(E, O);
      _ = i.mul(_, v), v = i.add(U, q), _ = i.sub(_, v), v = i.add(m, b);
      let x = i.add(E, S);
      return v = i.mul(v, x), x = i.add(U, C), v = i.sub(v, x), x = i.add(w, b), $ = i.add(O, S), x = i.mul(x, $), $ = i.add(q, C), x = i.sub(x, $), I = i.mul(M, v), $ = i.mul(L, C), I = i.add($, I), $ = i.sub(q, I), I = i.add(q, I), A = i.mul($, I), q = i.add(U, U), q = i.add(q, U), C = i.mul(M, C), v = i.mul(L, v), q = i.add(q, C), C = i.sub(U, C), C = i.mul(M, C), v = i.add(v, C), U = i.mul(q, v), A = i.add(A, U), U = i.mul(x, v), $ = i.mul(_, $), $ = i.sub($, U), U = i.mul(_, q), I = i.mul(x, I), I = i.add(I, U), new d($, A, I);
    }
    subtract(y) {
      return this.add(y.negate());
    }
    is0() {
      return this.equals(d.ZERO);
    }
    wNAF(y) {
      return p.wNAFCached(this, y, d.normalizeZ);
    }
    multiplyUnsafe(y) {
      const { endo: m, n: w } = e;
      xt("scalar", y, Ot, w);
      const b = d.ZERO;
      if (y === Ot)
        return b;
      if (this.is0() || y === me)
        return this;
      if (!m || p.hasPrecomputes(this))
        return p.wNAFCachedUnsafe(this, y, d.normalizeZ);
      let { k1neg: E, k1: O, k2neg: S, k2: $ } = m.splitScalar(y), A = b, I = b, M = this;
      for (; O > Ot || $ > Ot; )
        O & me && (A = A.add(M)), $ & me && (I = I.add(M)), M = M.double(), O >>= me, $ >>= me;
      return E && (A = A.negate()), S && (I = I.negate()), I = new d(i.mul(I.px, m.beta), I.py, I.pz), A.add(I);
    }
    multiply(y) {
      const { endo: m, n: w } = e;
      xt("scalar", y, me, w);
      let b, E;
      if (m) {
        const { k1neg: O, k1: S, k2neg: $, k2: A } = m.splitScalar(y);
        let { p: I, f: M } = this.wNAF(S), { p: L, f: U } = this.wNAF(A);
        I = p.constTimeNegate(O, I), L = p.constTimeNegate($, L), L = new d(i.mul(L.px, m.beta), L.py, L.pz), b = I.add(L), E = M.add(U);
      } else {
        const { p: O, f: S } = this.wNAF(y);
        b = O, E = S;
      }
      return d.normalizeZ([b, E])[0];
    }
    multiplyAndAddUnsafe(y, m, w) {
      const b = d.BASE, E = (S, $) => $ === Ot || $ === me || !S.equals(b) ? S.multiplyUnsafe($) : S.multiply($), O = E(this, m).add(E(y, w));
      return O.is0() ? void 0 : O;
    }
    toAffine(y) {
      return l(this, y);
    }
    isTorsionFree() {
      const { h: y, isTorsionFree: m } = e;
      if (y === me)
        return !0;
      if (m)
        return m(d, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: y, clearCofactor: m } = e;
      return y === me ? this : m ? m(d, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(y = !0) {
      return Oi("isCompressed", y), this.assertValidity(), s(d, this, y);
    }
    toHex(y = !0) {
      return Oi("isCompressed", y), xi(this.toRawBytes(y));
    }
  }
  d.BASE = new d(e.Gx, e.Gy, i.ONE), d.ZERO = new d(i.ZERO, i.ONE, i.ZERO);
  const f = e.nBitLength, p = o0(d, e.endo ? Math.ceil(f / 2) : f);
  return { CURVE: e, ProjectivePoint: d, normPrivateKeyToScalar: c, weierstrassEquation: o, isWithinCurveOrder: a };
}
function v0(t) {
  const e = Ul(t);
  return Bi(e, { hash: "hash", hmac: "function", randomBytes: "function" }, { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }), Object.freeze({ lowS: !0, ...e });
}
function E0(t) {
  const e = v0(t), { Fp: i, n: r } = e, s = i.BYTES + 1, n = 2 * i.BYTES + 1;
  function o(C) {
    return Me(C, r);
  }
  function a(C) {
    return Cn(C, r);
  }
  const { ProjectivePoint: c, normPrivateKeyToScalar: u, weierstrassEquation: l, isWithinCurveOrder: h } = b0({ ...e, toBytes(C, _, v) {
    const x = _.toAffine(), P = i.toBytes(x.x), D = ur;
    return Oi("isCompressed", v), v ? D(Uint8Array.from([_.hasEvenY() ? 2 : 3]), P) : D(Uint8Array.from([4]), P, i.toBytes(x.y));
  }, fromBytes(C) {
    const _ = C.length, v = C[0], x = C.subarray(1);
    if (_ === s && (v === 2 || v === 3)) {
      const P = Xt(x);
      if (!ws(P, me, i.ORDER))
        throw new Error("Point is not on curve");
      const D = l(P);
      let N;
      try {
        N = i.sqrt(D);
      } catch (k) {
        const j = k instanceof Error ? ": " + k.message : "";
        throw new Error("Point is not on curve" + j);
      }
      const B = (N & me) === me;
      return (v & 1) === 1 !== B && (N = i.neg(N)), { x: P, y: N };
    } else if (_ === n && v === 4) {
      const P = i.fromBytes(x.subarray(0, i.BYTES)), D = i.fromBytes(x.subarray(i.BYTES, 2 * i.BYTES));
      return { x: P, y: D };
    } else {
      const P = s, D = n;
      throw new Error("invalid Point, expected length of " + P + ", or uncompressed " + D + ", got " + _);
    }
  } }), d = (C) => xi(Pi(C, e.nByteLength));
  function f(C) {
    const _ = r >> me;
    return C > _;
  }
  function p(C) {
    return f(C) ? o(-C) : C;
  }
  const g = (C, _, v) => Xt(C.slice(_, v));
  class y {
    constructor(_, v, x) {
      this.r = _, this.s = v, this.recovery = x, this.assertValidity();
    }
    static fromCompact(_) {
      const v = e.nByteLength;
      return _ = Ke("compactSignature", _, v * 2), new y(g(_, 0, v), g(_, v, 2 * v));
    }
    static fromDER(_) {
      const { r: v, s: x } = $t.toSig(Ke("DER", _));
      return new y(v, x);
    }
    assertValidity() {
      xt("r", this.r, me, r), xt("s", this.s, me, r);
    }
    addRecoveryBit(_) {
      return new y(this.r, this.s, _);
    }
    recoverPublicKey(_) {
      const { r: v, s: x, recovery: P } = this, D = S(Ke("msgHash", _));
      if (P == null || ![0, 1, 2, 3].includes(P))
        throw new Error("recovery id invalid");
      const N = P === 2 || P === 3 ? v + e.n : v;
      if (N >= i.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const B = P & 1 ? "03" : "02", k = c.fromHex(B + d(N)), j = a(N), z = o(-D * j), H = o(x * j), Y = c.BASE.multiplyAndAddUnsafe(k, z, H);
      if (!Y)
        throw new Error("point at infinify");
      return Y.assertValidity(), Y;
    }
    hasHighS() {
      return f(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new y(this.r, o(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return Ai(this.toDERHex());
    }
    toDERHex() {
      return $t.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return Ai(this.toCompactHex());
    }
    toCompactHex() {
      return d(this.r) + d(this.s);
    }
  }
  const m = { isValidPrivateKey(C) {
    try {
      return u(C), !0;
    } catch {
      return !1;
    }
  }, normPrivateKeyToScalar: u, randomPrivateKey: () => {
    const C = Fl(e.n);
    return r0(e.randomBytes(C), e.n);
  }, precompute(C = 8, _ = c.BASE) {
    return _._setWindowSize(C), _.multiply(BigInt(3)), _;
  } };
  function w(C, _ = !0) {
    return c.fromPrivateKey(C).toRawBytes(_);
  }
  function b(C) {
    const _ = ri(C), v = typeof C == "string", x = (_ || v) && C.length;
    return _ ? x === s || x === n : v ? x === 2 * s || x === 2 * n : C instanceof c;
  }
  function E(C, _, v = !0) {
    if (b(C))
      throw new Error("first arg must be private key");
    if (!b(_))
      throw new Error("second arg must be public key");
    return c.fromHex(_).multiply(u(C)).toRawBytes(v);
  }
  const O = e.bits2int || function(C) {
    if (C.length > 8192)
      throw new Error("input is too large");
    const _ = Xt(C), v = C.length * 8 - e.nBitLength;
    return v > 0 ? _ >> BigInt(v) : _;
  }, S = e.bits2int_modN || function(C) {
    return o(O(C));
  }, $ = po(e.nBitLength);
  function A(C) {
    return xt("num < 2^" + e.nBitLength, C, Ot, $), Pi(C, e.nByteLength);
  }
  function I(C, _, v = M) {
    if (["recovered", "canonical"].some((ee) => ee in v))
      throw new Error("sign() legacy options not supported");
    const { hash: x, randomBytes: P } = e;
    let { lowS: D, prehash: N, extraEntropy: B } = v;
    D == null && (D = !0), C = Ke("msgHash", C), ic(v), N && (C = Ke("prehashed msgHash", x(C)));
    const k = S(C), j = u(_), z = [A(j), A(k)];
    if (B != null && B !== !1) {
      const ee = B === !0 ? P(i.BYTES) : B;
      z.push(Ke("extraEntropy", ee));
    }
    const H = ur(...z), Y = k;
    function ne(ee) {
      const J = O(ee);
      if (!h(J))
        return;
      const Pe = a(J), _e = c.BASE.multiply(J).toAffine(), Re = o(_e.x);
      if (Re === Ot)
        return;
      const Ye = o(Pe * o(Y + Re * j));
      if (Ye === Ot)
        return;
      let mt = (_e.x === Re ? 0 : 2) | Number(_e.y & me), ui = Ye;
      return D && f(Ye) && (ui = p(Ye), mt ^= 1), new y(Re, ui, mt);
    }
    return { seed: H, k2sig: ne };
  }
  const M = { lowS: e.lowS, prehash: !1 }, L = { lowS: e.lowS, prehash: !1 };
  function U(C, _, v = M) {
    const { seed: x, k2sig: P } = I(C, _, v), D = e;
    return Pl(D.hash.outputLen, D.nByteLength, D.hmac)(x, P);
  }
  c.BASE._setWindowSize(8);
  function q(C, _, v, x = L) {
    const P = C;
    _ = Ke("msgHash", _), v = Ke("publicKey", v);
    const { lowS: D, prehash: N, format: B } = x;
    if (ic(x), "strict" in x)
      throw new Error("options.strict was renamed to lowS");
    if (B !== void 0 && B !== "compact" && B !== "der")
      throw new Error("format must be compact or der");
    const k = typeof P == "string" || ri(P), j = !k && !B && typeof P == "object" && P !== null && typeof P.r == "bigint" && typeof P.s == "bigint";
    if (!k && !j)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let z, H;
    try {
      if (j && (z = new y(P.r, P.s)), k) {
        try {
          B !== "compact" && (z = y.fromDER(P));
        } catch (Ye) {
          if (!(Ye instanceof $t.Err))
            throw Ye;
        }
        !z && B !== "der" && (z = y.fromCompact(P));
      }
      H = c.fromHex(v);
    } catch {
      return !1;
    }
    if (!z || D && z.hasHighS())
      return !1;
    N && (_ = e.hash(_));
    const { r: Y, s: ne } = z, ee = S(_), J = a(ne), Pe = o(ee * J), _e = o(Y * J), Re = c.BASE.multiplyAndAddUnsafe(H, Pe, _e)?.toAffine();
    return Re ? o(Re.x) === Y : !1;
  }
  return { CURVE: e, getPublicKey: w, getSharedSecret: E, sign: U, verify: q, ProjectivePoint: c, Signature: y, utils: m };
}
function _0(t) {
  return { hash: t, hmac: (e, ...i) => ps(t, e, $b(...i)), randomBytes: Li };
}
function I0(t, e) {
  const i = (r) => E0({ ...t, ..._0(r) });
  return { ...i(e), create: i };
}
const kl = Tl(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")), D0 = kl.create(BigInt("-3")), S0 = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), $0 = I0({ a: D0, b: S0, Fp: kl, n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"), h: BigInt(1), lowS: !1 }, vr), Ml = "base10", Ne = "base16", ot = "base64pad", Ft = "base64url", _r = "utf8", ql = 0, At = 1, Ir = 2, O0 = 0, sc = 1, Qi = 12, fo = 32;
function x0() {
  const t = Tn.utils.randomPrivateKey(), e = Tn.getPublicKey(t);
  return { privateKey: qe(t, Ne), publicKey: qe(e, Ne) };
}
function Nn() {
  const t = Li(fo);
  return qe(t, Ne);
}
function A0(t, e) {
  const i = Tn.getSharedSecret(Xe(t, Ne), Xe(e, Ne)), r = T1(vr, i, void 0, void 0, fo);
  return qe(r, Ne);
}
function Vr(t) {
  const e = vr(Xe(t, Ne));
  return qe(e, Ne);
}
function gt(t) {
  const e = vr(Xe(t, _r));
  return qe(e, Ne);
}
function jl(t) {
  return Xe(`${t}`, Ml);
}
function si(t) {
  return Number(qe(t, Ml));
}
function zl(t) {
  return t.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function Vl(t) {
  const e = t.replace(/-/g, "+").replace(/_/g, "/"), i = (4 - e.length % 4) % 4;
  return e + "=".repeat(i);
}
function P0(t) {
  const e = jl(typeof t.type < "u" ? t.type : ql);
  if (si(e) === At && typeof t.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const i = typeof t.senderPublicKey < "u" ? Xe(t.senderPublicKey, Ne) : void 0, r = typeof t.iv < "u" ? Xe(t.iv, Ne) : Li(Qi), s = Xe(t.symKey, Ne), n = Ol(s, r).encrypt(Xe(t.message, _r)), o = Kl({ type: e, sealed: n, iv: r, senderPublicKey: i });
  return t.encoding === Ft ? zl(o) : o;
}
function C0(t) {
  const e = Xe(t.symKey, Ne), { sealed: i, iv: r } = lr({ encoded: t.encoded, encoding: t.encoding }), s = Ol(e, r).decrypt(i);
  if (s === null)
    throw new Error("Failed to decrypt");
  return qe(s, _r);
}
function R0(t, e) {
  const i = jl(Ir), r = Li(Qi), s = Xe(t, _r), n = Kl({ type: i, sealed: s, iv: r });
  return e === Ft ? zl(n) : n;
}
function T0(t, e) {
  const { sealed: i } = lr({ encoded: t, encoding: e });
  return qe(i, _r);
}
function Kl(t) {
  if (si(t.type) === Ir)
    return qe(Zi([t.type, t.sealed]), ot);
  if (si(t.type) === At) {
    if (typeof t.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return qe(Zi([t.type, t.senderPublicKey, t.iv, t.sealed]), ot);
  }
  return qe(Zi([t.type, t.iv, t.sealed]), ot);
}
function lr(t) {
  const e = (t.encoding || ot) === Ft ? Vl(t.encoded) : t.encoded, i = Xe(e, ot), r = i.slice(O0, sc), s = sc;
  if (si(r) === At) {
    const c = s + fo, u = c + Qi, l = i.slice(s, c), h = i.slice(c, u), d = i.slice(u);
    return { type: r, sealed: d, iv: h, senderPublicKey: l };
  }
  if (si(r) === Ir) {
    const c = i.slice(s), u = Li(Qi);
    return { type: r, sealed: c, iv: u };
  }
  const n = s + Qi, o = i.slice(s, n), a = i.slice(n);
  return { type: r, sealed: a, iv: o };
}
function N0(t, e) {
  const i = lr({ encoded: t, encoding: e?.encoding });
  return Hl({ type: si(i.type), senderPublicKey: typeof i.senderPublicKey < "u" ? qe(i.senderPublicKey, Ne) : void 0, receiverPublicKey: e?.receiverPublicKey });
}
function Hl(t) {
  const e = t?.type || ql;
  if (e === At) {
    if (typeof t?.senderPublicKey > "u")
      throw new Error("missing sender public key");
    if (typeof t?.receiverPublicKey > "u")
      throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: t?.senderPublicKey, receiverPublicKey: t?.receiverPublicKey };
}
function nc(t) {
  return t.type === At && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
function oc(t) {
  return t.type === Ir;
}
function F0(t) {
  const e = Buffer.from(t.x, "base64"), i = Buffer.from(t.y, "base64");
  return Zi([new Uint8Array([4]), e, i]);
}
function L0(t, e) {
  const [i, r, s] = t.split("."), n = Buffer.from(Vl(s), "base64");
  if (n.length !== 64)
    throw new Error("Invalid signature length");
  const o = n.slice(0, 32), a = n.slice(32, 64), c = `${i}.${r}`, u = vr(c), l = F0(e);
  if (!$0.verify(Zi([o, a]), u, l))
    throw new Error("Invalid signature");
  return vn(t).payload;
}
const B0 = "irn";
function es(t) {
  return t?.relay || { protocol: B0 };
}
function Yi(t) {
  const e = Bm[t];
  if (typeof e > "u")
    throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
function U0(t, e = "-") {
  const i = {}, r = "relay" + e;
  return Object.keys(t).forEach((s) => {
    if (s.startsWith(r)) {
      const n = s.replace(r, ""), o = t[s];
      i[n] = o;
    }
  }), i;
}
function ac(t) {
  if (!t.includes("wc:")) {
    const u = fl(t);
    u != null && u.includes("wc:") && (t = u);
  }
  t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
  const e = t.indexOf(":"), i = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, r = t.substring(0, e), s = t.substring(e + 1, i).split("@"), n = typeof i < "u" ? t.substring(i) : "", o = new URLSearchParams(n), a = {};
  o.forEach((u, l) => {
    a[l] = u;
  });
  const c = typeof a.methods == "string" ? a.methods.split(",") : void 0;
  return { protocol: r, topic: k0(s[0]), version: parseInt(s[1], 10), symKey: a.symKey, relay: U0(a), methods: c, expiryTimestamp: a.expiryTimestamp ? parseInt(a.expiryTimestamp, 10) : void 0 };
}
function k0(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function M0(t, e = "-") {
  const i = "relay", r = {};
  return Object.keys(t).forEach((s) => {
    const n = s, o = i + e + n;
    t[n] && (r[o] = t[n]);
  }), r;
}
function cc(t) {
  const e = new URLSearchParams(), i = M0(t.relay);
  Object.keys(i).sort().forEach((s) => {
    e.set(s, i[s]);
  }), e.set("symKey", t.symKey), t.expiryTimestamp && e.set("expiryTimestamp", t.expiryTimestamp.toString()), t.methods && e.set("methods", t.methods.join(","));
  const r = e.toString();
  return `${t.protocol}:${t.topic}@${t.version}?${r}`;
}
function Lr(t, e, i) {
  return `${t}?wc_ev=${i}&topic=${e}`;
}
function Ui(t) {
  const e = [];
  return t.forEach((i) => {
    const [r, s] = i.split(":");
    e.push(`${r}:${s}`);
  }), e;
}
function q0(t) {
  const e = [];
  return Object.values(t).forEach((i) => {
    e.push(...Ui(i.accounts));
  }), e;
}
function j0(t, e) {
  const i = [];
  return Object.values(t).forEach((r) => {
    Ui(r.accounts).includes(e) && i.push(...r.methods);
  }), i;
}
function z0(t, e) {
  const i = [];
  return Object.values(t).forEach((r) => {
    Ui(r.accounts).includes(e) && i.push(...r.events);
  }), i;
}
function V0(t) {
  const e = {};
  return t?.forEach((i) => {
    var r;
    const [s, n] = i.split(":");
    e[s] || (e[s] = { accounts: [], chains: [], events: [], methods: [] }), e[s].accounts.push(i), (r = e[s].chains) == null || r.push(`${s}:${n}`);
  }), e;
}
function uc(t, e) {
  e = e.map((r) => r.replace("did:pkh:", ""));
  const i = V0(e);
  for (const [r, s] of Object.entries(i))
    s.methods ? s.methods = ab(s.methods, t) : s.methods = t, s.events = ["chainChanged", "accountsChanged"];
  return i;
}
const K0 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, H0 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function F(t, e) {
  const { message: i, code: r } = H0[t];
  return { message: e ? `${i} ${e}` : i, code: r };
}
function se(t, e) {
  const { message: i, code: r } = K0[t];
  return { message: e ? `${i} ${e}` : i, code: r };
}
function Dr(t, e) {
  return Array.isArray(t) ? typeof e < "u" && t.length ? t.every(e) : !0 : !1;
}
function ts(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function $e(t) {
  return typeof t > "u";
}
function de(t, e) {
  return e && $e(t) ? !0 : typeof t == "string" && !!t.trim().length;
}
function go(t, e) {
  return e && $e(t) ? !0 : typeof t == "number" && !isNaN(t);
}
function W0(t, e) {
  const { requiredNamespaces: i } = e, r = Object.keys(t.namespaces), s = Object.keys(i);
  let n = !0;
  return Jt(s, r) ? (r.forEach((o) => {
    const { accounts: a, methods: c, events: u } = t.namespaces[o], l = Ui(a), h = i[o];
    (!Jt(oo(o, h), l) || !Jt(h.methods, c) || !Jt(h.events, u)) && (n = !1);
  }), n) : !1;
}
function is(t) {
  return de(t, !1) && t.includes(":") ? t.split(":").length === 2 : !1;
}
function G0(t) {
  if (de(t, !1) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const i = e[0] + ":" + e[1];
      return !!e[2] && is(i);
    }
  }
  return !1;
}
function Y0(t) {
  function e(i) {
    try {
      return typeof new URL(i) < "u";
    } catch {
      return !1;
    }
  }
  try {
    if (de(t, !1)) {
      if (e(t))
        return !0;
      const i = fl(t);
      return e(i);
    }
  } catch {
  }
  return !1;
}
function J0(t) {
  var e;
  return (e = t?.proposer) == null ? void 0 : e.publicKey;
}
function Z0(t) {
  return t?.topic;
}
function Q0(t, e) {
  let i = null;
  return de(t?.publicKey, !1) || (i = F("MISSING_OR_INVALID", `${e} controller public key should be a string`)), i;
}
function lc(t) {
  let e = !0;
  return Dr(t) ? t.length && (e = t.every((i) => de(i, !1))) : e = !1, e;
}
function X0(t, e, i) {
  let r = null;
  return Dr(e) && e.length ? e.forEach((s) => {
    r || is(s) || (r = se("UNSUPPORTED_CHAINS", `${i}, chain ${s} should be a string and conform to "namespace:chainId" format`));
  }) : is(t) || (r = se("UNSUPPORTED_CHAINS", `${i}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r;
}
function ev(t, e, i) {
  let r = null;
  return Object.entries(t).forEach(([s, n]) => {
    if (r)
      return;
    const o = X0(s, oo(s, n), `${e} ${i}`);
    o && (r = o);
  }), r;
}
function tv(t, e) {
  let i = null;
  return Dr(t) ? t.forEach((r) => {
    i || G0(r) || (i = se("UNSUPPORTED_ACCOUNTS", `${e}, account ${r} should be a string and conform to "namespace:chainId:address" format`));
  }) : i = se("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), i;
}
function iv(t, e) {
  let i = null;
  return Object.values(t).forEach((r) => {
    if (i)
      return;
    const s = tv(r?.accounts, `${e} namespace`);
    s && (i = s);
  }), i;
}
function rv(t, e) {
  let i = null;
  return lc(t?.methods) ? lc(t?.events) || (i = se("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : i = se("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), i;
}
function Wl(t, e) {
  let i = null;
  return Object.values(t).forEach((r) => {
    if (i)
      return;
    const s = rv(r, `${e}, namespace`);
    s && (i = s);
  }), i;
}
function sv(t, e, i) {
  let r = null;
  if (t && ts(t)) {
    const s = Wl(t, e);
    s && (r = s);
    const n = ev(t, e, i);
    n && (r = n);
  } else
    r = F("MISSING_OR_INVALID", `${e}, ${i} should be an object with data`);
  return r;
}
function Xs(t, e) {
  let i = null;
  if (t && ts(t)) {
    const r = Wl(t, e);
    r && (i = r);
    const s = iv(t, e);
    s && (i = s);
  } else
    i = F("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return i;
}
function Gl(t) {
  return de(t.protocol, !0);
}
function nv(t, e) {
  let i = !1;
  return e && !t ? i = !0 : t && Dr(t) && t.length && t.forEach((r) => {
    i = Gl(r);
  }), i;
}
function ov(t) {
  return typeof t == "number";
}
function ke(t) {
  return typeof t < "u" && typeof t !== null;
}
function av(t) {
  return !(!t || typeof t != "object" || !t.code || !go(t.code, !1) || !t.message || !de(t.message, !1));
}
function cv(t) {
  return !($e(t) || !de(t.method, !1));
}
function uv(t) {
  return !($e(t) || $e(t.result) && $e(t.error) || !go(t.id, !1) || !de(t.jsonrpc, !1));
}
function lv(t) {
  return !($e(t) || !de(t.name, !1));
}
function hc(t, e) {
  return !(!is(e) || !q0(t).includes(e));
}
function hv(t, e, i) {
  return de(i, !1) ? j0(t, e).includes(i) : !1;
}
function dv(t, e, i) {
  return de(i, !1) ? z0(t, e).includes(i) : !1;
}
function dc(t, e, i) {
  let r = null;
  const s = pv(t), n = fv(e), o = Object.keys(s), a = Object.keys(n), c = pc(Object.keys(t)), u = pc(Object.keys(e)), l = c.filter((h) => !u.includes(h));
  return l.length && (r = F("NON_CONFORMING_NAMESPACES", `${i} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l.toString()}
      Received: ${Object.keys(e).toString()}`)), Jt(o, a) || (r = F("NON_CONFORMING_NAMESPACES", `${i} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`)), Object.keys(e).forEach((h) => {
    if (!h.includes(":") || r)
      return;
    const d = Ui(e[h].accounts);
    d.includes(h) || (r = F("NON_CONFORMING_NAMESPACES", `${i} namespaces accounts don't satisfy namespace accounts for ${h}
        Required: ${h}
        Approved: ${d.toString()}`));
  }), o.forEach((h) => {
    r || (Jt(s[h].methods, n[h].methods) ? Jt(s[h].events, n[h].events) || (r = F("NON_CONFORMING_NAMESPACES", `${i} namespaces events don't satisfy namespace events for ${h}`)) : r = F("NON_CONFORMING_NAMESPACES", `${i} namespaces methods don't satisfy namespace methods for ${h}`));
  }), r;
}
function pv(t) {
  const e = {};
  return Object.keys(t).forEach((i) => {
    var r;
    i.includes(":") ? e[i] = t[i] : (r = t[i].chains) == null || r.forEach((s) => {
      e[s] = { methods: t[i].methods, events: t[i].events };
    });
  }), e;
}
function pc(t) {
  return [...new Set(t.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function fv(t) {
  const e = {};
  return Object.keys(t).forEach((i) => {
    i.includes(":") ? e[i] = t[i] : Ui(t[i].accounts)?.forEach((s) => {
      e[s] = { accounts: t[i].accounts.filter((n) => n.includes(`${s}:`)), methods: t[i].methods, events: t[i].events };
    });
  }), e;
}
function gv(t, e) {
  return go(t, !1) && t <= e.max && t >= e.min;
}
function fc() {
  const t = mr();
  return new Promise((e) => {
    switch (t) {
      case We.browser:
        e(yv());
        break;
      case We.reactNative:
        e(wv());
        break;
      case We.node:
        e(mv());
        break;
      default:
        e(!0);
    }
  });
}
function yv() {
  return wr() && navigator?.onLine;
}
async function wv() {
  return Ut() && typeof global < "u" && global != null && global.NetInfo ? (await (global == null ? void 0 : global.NetInfo.fetch()))?.isConnected : !0;
}
function mv() {
  return !0;
}
function bv(t) {
  switch (mr()) {
    case We.browser:
      vv(t);
      break;
    case We.reactNative:
      Ev(t);
      break;
  }
}
function vv(t) {
  !Ut() && wr() && (window.addEventListener("online", () => t(!0)), window.addEventListener("offline", () => t(!1)));
}
function Ev(t) {
  Ut() && typeof global < "u" && global != null && global.NetInfo && global?.NetInfo.addEventListener((e) => t(e?.isConnected));
}
const en = {};
class Vi {
  static get(e) {
    return en[e];
  }
  static set(e, i) {
    en[e] = i;
  }
  static delete(e) {
    delete en[e];
  }
}
const _v = "PARSE_ERROR", Iv = "INVALID_REQUEST", Dv = "METHOD_NOT_FOUND", Sv = "INVALID_PARAMS", Yl = "INTERNAL_ERROR", yo = "SERVER_ERROR", $v = [-32700, -32600, -32601, -32602, -32603], Xi = {
  [_v]: { code: -32700, message: "Parse error" },
  [Iv]: { code: -32600, message: "Invalid Request" },
  [Dv]: { code: -32601, message: "Method not found" },
  [Sv]: { code: -32602, message: "Invalid params" },
  [Yl]: { code: -32603, message: "Internal error" },
  [yo]: { code: -32e3, message: "Server error" }
}, Jl = yo;
function Ov(t) {
  return $v.includes(t);
}
function gc(t) {
  return Object.keys(Xi).includes(t) ? Xi[t] : Xi[Jl];
}
function xv(t) {
  const e = Object.values(Xi).find((i) => i.code === t);
  return e || Xi[Jl];
}
function Av(t, e, i) {
  return t.message.includes("getaddrinfo ENOTFOUND") || t.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${i} RPC url at ${e}`) : t;
}
var Zl = {}, It = {}, yc;
function Pv() {
  if (yc)
    return It;
  yc = 1, Object.defineProperty(It, "__esModule", { value: !0 }), It.isBrowserCryptoAvailable = It.getSubtleCrypto = It.getBrowerCrypto = void 0;
  function t() {
    return (li === null || li === void 0 ? void 0 : li.crypto) || (li === null || li === void 0 ? void 0 : li.msCrypto) || {};
  }
  It.getBrowerCrypto = t;
  function e() {
    const r = t();
    return r.subtle || r.webkitSubtle;
  }
  It.getSubtleCrypto = e;
  function i() {
    return !!t() && !!e();
  }
  return It.isBrowserCryptoAvailable = i, It;
}
var Dt = {}, wc;
function Cv() {
  if (wc)
    return Dt;
  wc = 1, Object.defineProperty(Dt, "__esModule", { value: !0 }), Dt.isBrowser = Dt.isNode = Dt.isReactNative = void 0;
  function t() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  Dt.isReactNative = t;
  function e() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  Dt.isNode = e;
  function i() {
    return !t() && !e();
  }
  return Dt.isBrowser = i, Dt;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = hr;
  e.__exportStar(Pv(), t), e.__exportStar(Cv(), t);
})(Zl);
function dt(t = 3) {
  const e = Date.now() * Math.pow(10, t), i = Math.floor(Math.random() * Math.pow(10, t));
  return e + i;
}
function Zt(t = 6) {
  return BigInt(dt(t));
}
function Qt(t, e, i) {
  return {
    id: i || dt(),
    jsonrpc: "2.0",
    method: t,
    params: e
  };
}
function ms(t, e) {
  return {
    id: t,
    jsonrpc: "2.0",
    result: e
  };
}
function bs(t, e, i) {
  return {
    id: t,
    jsonrpc: "2.0",
    error: Rv(e, i)
  };
}
function Rv(t, e) {
  return typeof t > "u" ? gc(Yl) : (typeof t == "string" && (t = Object.assign(Object.assign({}, gc(yo)), { message: t })), typeof e < "u" && (t.data = e), Ov(t.code) && (t = xv(t.code)), t);
}
class Ql {
}
let Tv = class extends Ql {
  constructor(e) {
    super();
  }
}, Nv = class extends Ql {
  constructor() {
    super();
  }
};
class Fv extends Nv {
  constructor(e) {
    super();
  }
}
const Lv = "^wss?:";
function Bv(t) {
  const e = t.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length))
    return e[0];
}
function Uv(t, e) {
  const i = Bv(t);
  return typeof i > "u" ? !1 : new RegExp(e).test(i);
}
function mc(t) {
  return Uv(t, Lv);
}
function kv(t) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(t);
}
function Xl(t) {
  return typeof t == "object" && "id" in t && "jsonrpc" in t && t.jsonrpc === "2.0";
}
function wo(t) {
  return Xl(t) && "method" in t;
}
function vs(t) {
  return Xl(t) && (pt(t) || Qe(t));
}
function pt(t) {
  return "result" in t;
}
function Qe(t) {
  return "error" in t;
}
let eh = class extends Fv {
  constructor(e) {
    super(e), this.events = new Ge.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, i) {
    this.events.on(e, i);
  }
  once(e, i) {
    this.events.once(e, i);
  }
  off(e, i) {
    this.events.off(e, i);
  }
  removeListener(e, i) {
    this.events.removeListener(e, i);
  }
  async request(e, i) {
    return this.requestStrict(Qt(e.method, e.params || [], e.id || Zt().toString()), i);
  }
  async requestStrict(e, i) {
    return new Promise(async (r, s) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (n) {
          s(n);
        }
      this.events.on(`${e.id}`, (n) => {
        Qe(n) ? s(n.error) : r(n.result);
      });
      try {
        await this.connection.send(e, i);
      } catch (n) {
        s(n);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e), vs(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", { type: e.method, data: e.params });
  }
  onClose(e) {
    e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (e) => this.onPayload(e)), this.connection.on("close", (e) => this.onClose(e)), this.connection.on("error", (e) => this.events.emit("error", e)), this.connection.on("register_error", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
};
const Mv = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), qv = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", bc = (t) => t.split("?")[0], vc = 10, jv = Mv();
let zv = class {
  constructor(e) {
    if (this.url = e, this.events = new Ge.EventEmitter(), this.registering = !1, !mc(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, i) {
    this.events.on(e, i);
  }
  once(e, i) {
    this.events.once(e, i);
  }
  off(e, i) {
    this.events.off(e, i);
  }
  removeListener(e, i) {
    this.events.removeListener(e, i);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, i) => {
      if (typeof this.socket > "u") {
        i(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (r) => {
        this.onClose(r), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(ei(e));
    } catch (i) {
      this.onError(e.id, i);
    }
  }
  register(e = this.url) {
    if (!mc(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const i = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= i || this.events.listenerCount("open") >= i) && this.events.setMaxListeners(i + 1), new Promise((r, s) => {
        this.events.once("register_error", (n) => {
          this.resetMaxListeners(), s(n);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u")
            return s(new Error("WebSocket connection is missing or invalid"));
          r(this.socket);
        });
      });
    }
    return this.url = e, this.registering = !0, new Promise((i, r) => {
      const s = Zl.isReactNative() ? void 0 : { rejectUnauthorized: !kv(e) }, n = new jv(e, [], s);
      qv() ? n.onerror = (o) => {
        const a = o;
        r(this.emitError(a.error));
      } : n.on("error", (o) => {
        r(this.emitError(o));
      }), n.onopen = () => {
        this.onOpen(n), i(n);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (i) => this.onPayload(i), e.onclose = (i) => this.onClose(i), this.socket = e, this.registering = !1, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u")
      return;
    const i = typeof e.data == "string" ? Ii(e.data) : e.data;
    this.events.emit("payload", i);
  }
  onError(e, i) {
    const r = this.parseError(i), s = r.message || r.toString(), n = bs(e, s);
    this.events.emit("payload", n);
  }
  parseError(e, i = this.url) {
    return Av(e, bc(i), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > vc && this.events.setMaxListeners(vc);
  }
  emitError(e) {
    const i = this.parseError(new Error(e?.message || `WebSocket connection failed for host: ${bc(this.url)}`));
    return this.events.emit("register_error", i), i;
  }
};
const th = "wc", ih = 2, rs = "core", wt = `${th}@2:${rs}:`, Vv = { name: rs, logger: "error" }, Kv = { database: ":memory:" }, Hv = "crypto", Ec = "client_ed25519_seed", Wv = T.ONE_DAY, Gv = "keychain", Yv = "0.3", Jv = "messages", Zv = "0.3", _c = T.SIX_HOURS, Qv = "publisher", rh = "irn", Xv = "error", sh = "wss://relay.walletconnect.org", eE = "relayer", be = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, tE = "_subscription", Je = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, iE = 0.1, Fn = "2.20.2", ce = { link_mode: "link_mode", relay: "relay" }, Kr = { inbound: "inbound", outbound: "outbound" }, rE = "0.3", sE = "WALLETCONNECT_CLIENT_ID", Ic = "WALLETCONNECT_LINK_MODE_APPS", Ve = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, nE = "subscription", oE = "0.3", aE = "pairing", cE = "0.3", Ki = { wc_pairingDelete: { req: { ttl: T.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: T.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: T.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: T.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: T.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: T.ONE_DAY, prompt: !1, tag: 0 } } }, Yt = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, tt = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, uE = "history", lE = "0.3", hE = "expirer", Ze = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, dE = "0.3", pE = "verify-api", fE = "https://verify.walletconnect.com", nh = "https://verify.walletconnect.org", er = nh, gE = `${er}/v3`, yE = [fE, nh], wE = "echo", mE = "https://echo.walletconnect.com", ht = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" }, St = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" }, it = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" }, jt = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" }, zt = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" }, Hi = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" }, bE = 0.1, vE = "event-client", EE = 86400, _E = "https://pulse.walletconnect.org/batch";
function IE(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var i = new Uint8Array(256), r = 0; r < i.length; r++)
    i[r] = 255;
  for (var s = 0; s < t.length; s++) {
    var n = t.charAt(s), o = n.charCodeAt(0);
    if (i[o] !== 255)
      throw new TypeError(n + " is ambiguous");
    i[o] = s;
  }
  var a = t.length, c = t.charAt(0), u = Math.log(a) / Math.log(256), l = Math.log(256) / Math.log(a);
  function h(p) {
    if (p instanceof Uint8Array || (ArrayBuffer.isView(p) ? p = new Uint8Array(p.buffer, p.byteOffset, p.byteLength) : Array.isArray(p) && (p = Uint8Array.from(p))), !(p instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (p.length === 0)
      return "";
    for (var g = 0, y = 0, m = 0, w = p.length; m !== w && p[m] === 0; )
      m++, g++;
    for (var b = (w - m) * l + 1 >>> 0, E = new Uint8Array(b); m !== w; ) {
      for (var O = p[m], S = 0, $ = b - 1; (O !== 0 || S < y) && $ !== -1; $--, S++)
        O += 256 * E[$] >>> 0, E[$] = O % a >>> 0, O = O / a >>> 0;
      if (O !== 0)
        throw new Error("Non-zero carry");
      y = S, m++;
    }
    for (var A = b - y; A !== b && E[A] === 0; )
      A++;
    for (var I = c.repeat(g); A < b; ++A)
      I += t.charAt(E[A]);
    return I;
  }
  function d(p) {
    if (typeof p != "string")
      throw new TypeError("Expected String");
    if (p.length === 0)
      return new Uint8Array();
    var g = 0;
    if (p[g] !== " ") {
      for (var y = 0, m = 0; p[g] === c; )
        y++, g++;
      for (var w = (p.length - g) * u + 1 >>> 0, b = new Uint8Array(w); p[g]; ) {
        var E = i[p.charCodeAt(g)];
        if (E === 255)
          return;
        for (var O = 0, S = w - 1; (E !== 0 || O < m) && S !== -1; S--, O++)
          E += a * b[S] >>> 0, b[S] = E % 256 >>> 0, E = E / 256 >>> 0;
        if (E !== 0)
          throw new Error("Non-zero carry");
        m = O, g++;
      }
      if (p[g] !== " ") {
        for (var $ = w - m; $ !== w && b[$] === 0; )
          $++;
        for (var A = new Uint8Array(y + (w - $)), I = y; $ !== w; )
          A[I++] = b[$++];
        return A;
      }
    }
  }
  function f(p) {
    var g = d(p);
    if (g)
      return g;
    throw new Error(`Non-${e} character`);
  }
  return { encode: h, decodeUnsafe: d, decode: f };
}
var DE = IE, SE = DE;
const oh = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, $E = (t) => new TextEncoder().encode(t), OE = (t) => new TextDecoder().decode(t);
class xE {
  constructor(e, i, r) {
    this.name = e, this.prefix = i, this.baseEncode = r;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class AE {
  constructor(e, i, r) {
    if (this.name = e, this.prefix = i, i.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = i.codePointAt(0), this.baseDecode = r;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ah(this, e);
  }
}
class PE {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ah(this, e);
  }
  decode(e) {
    const i = e[0], r = this.decoders[i];
    if (r)
      return r.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const ah = (t, e) => new PE({ ...t.decoders || { [t.prefix]: t }, ...e.decoders || { [e.prefix]: e } });
class CE {
  constructor(e, i, r, s) {
    this.name = e, this.prefix = i, this.baseEncode = r, this.baseDecode = s, this.encoder = new xE(e, i, r), this.decoder = new AE(e, i, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const Es = ({ name: t, prefix: e, encode: i, decode: r }) => new CE(t, e, i, r), Sr = ({ prefix: t, name: e, alphabet: i }) => {
  const { encode: r, decode: s } = SE(i, e);
  return Es({ prefix: t, name: e, encode: r, decode: (n) => oh(s(n)) });
}, RE = (t, e, i, r) => {
  const s = {};
  for (let l = 0; l < e.length; ++l)
    s[e[l]] = l;
  let n = t.length;
  for (; t[n - 1] === "="; )
    --n;
  const o = new Uint8Array(n * i / 8 | 0);
  let a = 0, c = 0, u = 0;
  for (let l = 0; l < n; ++l) {
    const h = s[t[l]];
    if (h === void 0)
      throw new SyntaxError(`Non-${r} character`);
    c = c << i | h, a += i, a >= 8 && (a -= 8, o[u++] = 255 & c >> a);
  }
  if (a >= i || 255 & c << 8 - a)
    throw new SyntaxError("Unexpected end of data");
  return o;
}, TE = (t, e, i) => {
  const r = e[e.length - 1] === "=", s = (1 << i) - 1;
  let n = "", o = 0, a = 0;
  for (let c = 0; c < t.length; ++c)
    for (a = a << 8 | t[c], o += 8; o > i; )
      o -= i, n += e[s & a >> o];
  if (o && (n += e[s & a << i - o]), r)
    for (; n.length * i & 7; )
      n += "=";
  return n;
}, Ae = ({ name: t, prefix: e, bitsPerChar: i, alphabet: r }) => Es({ prefix: e, name: t, encode(s) {
  return TE(s, r, i);
}, decode(s) {
  return RE(s, r, i, t);
} }), NE = Es({ prefix: "\0", name: "identity", encode: (t) => OE(t), decode: (t) => $E(t) });
var FE = Object.freeze({ __proto__: null, identity: NE });
const LE = Ae({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var BE = Object.freeze({ __proto__: null, base2: LE });
const UE = Ae({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var kE = Object.freeze({ __proto__: null, base8: UE });
const ME = Sr({ prefix: "9", name: "base10", alphabet: "0123456789" });
var qE = Object.freeze({ __proto__: null, base10: ME });
const jE = Ae({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), zE = Ae({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var VE = Object.freeze({ __proto__: null, base16: jE, base16upper: zE });
const KE = Ae({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), HE = Ae({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), WE = Ae({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), GE = Ae({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), YE = Ae({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), JE = Ae({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), ZE = Ae({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), QE = Ae({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), XE = Ae({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var e_ = Object.freeze({ __proto__: null, base32: KE, base32upper: HE, base32pad: WE, base32padupper: GE, base32hex: YE, base32hexupper: JE, base32hexpad: ZE, base32hexpadupper: QE, base32z: XE });
const t_ = Sr({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), i_ = Sr({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var r_ = Object.freeze({ __proto__: null, base36: t_, base36upper: i_ });
const s_ = Sr({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), n_ = Sr({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var o_ = Object.freeze({ __proto__: null, base58btc: s_, base58flickr: n_ });
const a_ = Ae({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), c_ = Ae({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), u_ = Ae({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), l_ = Ae({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var h_ = Object.freeze({ __proto__: null, base64: a_, base64pad: c_, base64url: u_, base64urlpad: l_ });
const ch = Array.from(""), d_ = ch.reduce((t, e, i) => (t[i] = e, t), []), p_ = ch.reduce((t, e, i) => (t[e.codePointAt(0)] = i, t), []);
function f_(t) {
  return t.reduce((e, i) => (e += d_[i], e), "");
}
function g_(t) {
  const e = [];
  for (const i of t) {
    const r = p_[i.codePointAt(0)];
    if (r === void 0)
      throw new Error(`Non-base256emoji character: ${i}`);
    e.push(r);
  }
  return new Uint8Array(e);
}
const y_ = Es({ prefix: "", name: "base256emoji", encode: f_, decode: g_ });
var w_ = Object.freeze({ __proto__: null, base256emoji: y_ }), m_ = uh, Dc = 128, b_ = 127, v_ = ~b_, E_ = Math.pow(2, 31);
function uh(t, e, i) {
  e = e || [], i = i || 0;
  for (var r = i; t >= E_; )
    e[i++] = t & 255 | Dc, t /= 128;
  for (; t & v_; )
    e[i++] = t & 255 | Dc, t >>>= 7;
  return e[i] = t | 0, uh.bytes = i - r + 1, e;
}
var __ = Ln, I_ = 128, Sc = 127;
function Ln(t, r) {
  var i = 0, r = r || 0, s = 0, n = r, o, a = t.length;
  do {
    if (n >= a)
      throw Ln.bytes = 0, new RangeError("Could not decode varint");
    o = t[n++], i += s < 28 ? (o & Sc) << s : (o & Sc) * Math.pow(2, s), s += 7;
  } while (o >= I_);
  return Ln.bytes = n - r, i;
}
var D_ = Math.pow(2, 7), S_ = Math.pow(2, 14), $_ = Math.pow(2, 21), O_ = Math.pow(2, 28), x_ = Math.pow(2, 35), A_ = Math.pow(2, 42), P_ = Math.pow(2, 49), C_ = Math.pow(2, 56), R_ = Math.pow(2, 63), T_ = function(t) {
  return t < D_ ? 1 : t < S_ ? 2 : t < $_ ? 3 : t < O_ ? 4 : t < x_ ? 5 : t < A_ ? 6 : t < P_ ? 7 : t < C_ ? 8 : t < R_ ? 9 : 10;
}, N_ = { encode: m_, decode: __, encodingLength: T_ }, lh = N_;
const $c = (t, e, i = 0) => (lh.encode(t, e, i), e), Oc = (t) => lh.encodingLength(t), Bn = (t, e) => {
  const i = e.byteLength, r = Oc(t), s = r + Oc(i), n = new Uint8Array(s + i);
  return $c(t, n, 0), $c(i, n, r), n.set(e, s), new F_(t, i, e, n);
};
class F_ {
  constructor(e, i, r, s) {
    this.code = e, this.size = i, this.digest = r, this.bytes = s;
  }
}
const hh = ({ name: t, code: e, encode: i }) => new L_(t, e, i);
class L_ {
  constructor(e, i, r) {
    this.name = e, this.code = i, this.encode = r;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const i = this.encode(e);
      return i instanceof Uint8Array ? Bn(this.code, i) : i.then((r) => Bn(this.code, r));
    } else
      throw Error("Unknown type, must be binary type");
  }
}
const dh = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)), B_ = hh({ name: "sha2-256", code: 18, encode: dh("SHA-256") }), U_ = hh({ name: "sha2-512", code: 19, encode: dh("SHA-512") });
var k_ = Object.freeze({ __proto__: null, sha256: B_, sha512: U_ });
const ph = 0, M_ = "identity", fh = oh, q_ = (t) => Bn(ph, fh(t)), j_ = { code: ph, name: M_, encode: fh, digest: q_ };
var z_ = Object.freeze({ __proto__: null, identity: j_ });
new TextEncoder(), new TextDecoder();
const xc = { ...FE, ...BE, ...kE, ...qE, ...VE, ...e_, ...r_, ...o_, ...h_, ...w_ };
({ ...k_, ...z_ });
function V_(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(t) : new Uint8Array(t);
}
function gh(t, e, i, r) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: i }, decoder: { decode: r } };
}
const Ac = gh("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), tn = gh("ascii", "a", (t) => {
  let e = "a";
  for (let i = 0; i < t.length; i++)
    e += String.fromCharCode(t[i]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = V_(t.length);
  for (let i = 0; i < t.length; i++)
    e[i] = t.charCodeAt(i);
  return e;
}), K_ = { utf8: Ac, "utf-8": Ac, hex: xc.base16, latin1: tn, ascii: tn, binary: tn, ...xc };
function H_(t, e = "utf8") {
  const i = K_[e];
  if (!i)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t, "utf8") : i.decoder.decode(`${i.prefix}${t}`);
}
var W_ = Object.defineProperty, G_ = (t, e, i) => e in t ? W_(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, ut = (t, e, i) => G_(t, typeof e != "symbol" ? e + "" : e, i);
class Y_ {
  constructor(e, i) {
    this.core = e, this.logger = i, ut(this, "keychain", /* @__PURE__ */ new Map()), ut(this, "name", Gv), ut(this, "version", Yv), ut(this, "initialized", !1), ut(this, "storagePrefix", wt), ut(this, "init", async () => {
      if (!this.initialized) {
        const r = await this.getKeyChain();
        typeof r < "u" && (this.keychain = r), this.initialized = !0;
      }
    }), ut(this, "has", (r) => (this.isInitialized(), this.keychain.has(r))), ut(this, "set", async (r, s) => {
      this.isInitialized(), this.keychain.set(r, s), await this.persist();
    }), ut(this, "get", (r) => {
      this.isInitialized();
      const s = this.keychain.get(r);
      if (typeof s > "u") {
        const { message: n } = F("NO_MATCHING_KEY", `${this.name}: ${r}`);
        throw new Error(n);
      }
      return s;
    }), ut(this, "del", async (r) => {
      this.isInitialized(), this.keychain.delete(r), await this.persist();
    }), this.core = e, this.logger = Fe(i, this.name);
  }
  get context() {
    return je(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, In(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Dn(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var J_ = Object.defineProperty, Z_ = (t, e, i) => e in t ? J_(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, De = (t, e, i) => Z_(t, typeof e != "symbol" ? e + "" : e, i);
class Q_ {
  constructor(e, i, r) {
    this.core = e, this.logger = i, De(this, "name", Hv), De(this, "keychain"), De(this, "randomSessionIdentifier", Nn()), De(this, "initialized", !1), De(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }), De(this, "hasKeys", (s) => (this.isInitialized(), this.keychain.has(s))), De(this, "getClientId", async () => {
      this.isInitialized();
      const s = await this.getClientSeed(), n = pa(s);
      return ju(n.publicKey);
    }), De(this, "generateKeyPair", () => {
      this.isInitialized();
      const s = x0();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }), De(this, "signJWT", async (s) => {
      this.isInitialized();
      const n = await this.getClientSeed(), o = pa(n), a = this.randomSessionIdentifier;
      return await ky(a, s, Wv, o);
    }), De(this, "generateSharedKey", (s, n, o) => {
      this.isInitialized();
      const a = this.getPrivateKey(s), c = A0(a, n);
      return this.setSymKey(c, o);
    }), De(this, "setSymKey", async (s, n) => {
      this.isInitialized();
      const o = n || Vr(s);
      return await this.keychain.set(o, s), o;
    }), De(this, "deleteKeyPair", async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }), De(this, "deleteSymKey", async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }), De(this, "encode", async (s, n, o) => {
      this.isInitialized();
      const a = Hl(o), c = ei(n);
      if (oc(a))
        return R0(c, o?.encoding);
      if (nc(a)) {
        const d = a.senderPublicKey, f = a.receiverPublicKey;
        s = await this.generateSharedKey(d, f);
      }
      const u = this.getSymKey(s), { type: l, senderPublicKey: h } = a;
      return P0({ type: l, symKey: u, message: c, senderPublicKey: h, encoding: o?.encoding });
    }), De(this, "decode", async (s, n, o) => {
      this.isInitialized();
      const a = N0(n, o);
      if (oc(a)) {
        const c = T0(n, o?.encoding);
        return Ii(c);
      }
      if (nc(a)) {
        const c = a.receiverPublicKey, u = a.senderPublicKey;
        s = await this.generateSharedKey(c, u);
      }
      try {
        const c = this.getSymKey(s), u = C0({ symKey: c, encoded: n, encoding: o?.encoding });
        return Ii(u);
      } catch (c) {
        this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`), this.logger.error(c);
      }
    }), De(this, "getPayloadType", (s, n = ot) => {
      const o = lr({ encoded: s, encoding: n });
      return si(o.type);
    }), De(this, "getPayloadSenderPublicKey", (s, n = ot) => {
      const o = lr({ encoded: s, encoding: n });
      return o.senderPublicKey ? qe(o.senderPublicKey, Ne) : void 0;
    }), this.core = e, this.logger = Fe(i, this.name), this.keychain = r || new Y_(this.core, this.logger);
  }
  get context() {
    return je(this.logger);
  }
  async setPrivateKey(e, i) {
    return await this.keychain.set(e, i), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(Ec);
    } catch {
      e = Nn(), await this.keychain.set(Ec, e);
    }
    return H_(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var X_ = Object.defineProperty, e2 = Object.defineProperties, t2 = Object.getOwnPropertyDescriptors, Pc = Object.getOwnPropertySymbols, i2 = Object.prototype.hasOwnProperty, r2 = Object.prototype.propertyIsEnumerable, Un = (t, e, i) => e in t ? X_(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, s2 = (t, e) => {
  for (var i in e || (e = {}))
    i2.call(e, i) && Un(t, i, e[i]);
  if (Pc)
    for (var i of Pc(e))
      r2.call(e, i) && Un(t, i, e[i]);
  return t;
}, n2 = (t, e) => e2(t, t2(e)), ze = (t, e, i) => Un(t, typeof e != "symbol" ? e + "" : e, i);
class o2 extends Fp {
  constructor(e, i) {
    super(e, i), this.logger = e, this.core = i, ze(this, "messages", /* @__PURE__ */ new Map()), ze(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), ze(this, "name", Jv), ze(this, "version", Zv), ze(this, "initialized", !1), ze(this, "storagePrefix", wt), ze(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const r = await this.getRelayerMessages();
          typeof r < "u" && (this.messages = r);
          const s = await this.getRelayerMessagesWithoutClientAck();
          typeof s < "u" && (this.messagesWithoutClientAck = s), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (r) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(r);
        } finally {
          this.initialized = !0;
        }
      }
    }), ze(this, "set", async (r, s, n) => {
      this.isInitialized();
      const o = gt(s);
      let a = this.messages.get(r);
      if (typeof a > "u" && (a = {}), typeof a[o] < "u")
        return o;
      if (a[o] = s, this.messages.set(r, a), n === Kr.inbound) {
        const c = this.messagesWithoutClientAck.get(r) || {};
        this.messagesWithoutClientAck.set(r, n2(s2({}, c), { [o]: s }));
      }
      return await this.persist(), o;
    }), ze(this, "get", (r) => {
      this.isInitialized();
      let s = this.messages.get(r);
      return typeof s > "u" && (s = {}), s;
    }), ze(this, "getWithoutAck", (r) => {
      this.isInitialized();
      const s = {};
      for (const n of r) {
        const o = this.messagesWithoutClientAck.get(n) || {};
        s[n] = Object.values(o);
      }
      return s;
    }), ze(this, "has", (r, s) => {
      this.isInitialized();
      const n = this.get(r), o = gt(s);
      return typeof n[o] < "u";
    }), ze(this, "ack", async (r, s) => {
      this.isInitialized();
      const n = this.messagesWithoutClientAck.get(r);
      if (typeof n > "u")
        return;
      const o = gt(s);
      delete n[o], Object.keys(n).length === 0 ? this.messagesWithoutClientAck.delete(r) : this.messagesWithoutClientAck.set(r, n), await this.persist();
    }), ze(this, "del", async (r) => {
      this.isInitialized(), this.messages.delete(r), this.messagesWithoutClientAck.delete(r), await this.persist();
    }), this.logger = Fe(e, this.name), this.core = i;
  }
  get context() {
    return je(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get storageKeyWithoutClientAck() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, In(e));
  }
  async setRelayerMessagesWithoutClientAck(e) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, In(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Dn(e) : void 0;
  }
  async getRelayerMessagesWithoutClientAck() {
    const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
    return typeof e < "u" ? Dn(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var a2 = Object.defineProperty, c2 = Object.defineProperties, u2 = Object.getOwnPropertyDescriptors, Cc = Object.getOwnPropertySymbols, l2 = Object.prototype.hasOwnProperty, h2 = Object.prototype.propertyIsEnumerable, kn = (t, e, i) => e in t ? a2(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Br = (t, e) => {
  for (var i in e || (e = {}))
    l2.call(e, i) && kn(t, i, e[i]);
  if (Cc)
    for (var i of Cc(e))
      h2.call(e, i) && kn(t, i, e[i]);
  return t;
}, rn = (t, e) => c2(t, u2(e)), rt = (t, e, i) => kn(t, typeof e != "symbol" ? e + "" : e, i);
class d2 extends Lp {
  constructor(e, i) {
    super(e, i), this.relayer = e, this.logger = i, rt(this, "events", new Ge.EventEmitter()), rt(this, "name", Qv), rt(this, "queue", /* @__PURE__ */ new Map()), rt(this, "publishTimeout", T.toMiliseconds(T.ONE_MINUTE)), rt(this, "initialPublishTimeout", T.toMiliseconds(T.ONE_SECOND * 15)), rt(this, "needsTransportRestart", !1), rt(this, "publish", async (r, s, n) => {
      var o;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: r, message: s, opts: n } });
      const a = n?.ttl || _c, c = es(n), u = n?.prompt || !1, l = n?.tag || 0, h = n?.id || Zt().toString(), d = { topic: r, message: s, opts: { ttl: a, relay: c, prompt: u, tag: l, id: h, attestation: n?.attestation, tvf: n?.tvf } }, f = `Failed to publish payload, please try again. id:${h} tag:${l}`;
      try {
        const p = new Promise(async (g) => {
          const y = ({ id: w }) => {
            d.opts.id === w && (this.removeRequestFromQueue(w), this.relayer.events.removeListener(be.publish, y), g(d));
          };
          this.relayer.events.on(be.publish, y);
          const m = Lt(new Promise((w, b) => {
            this.rpcPublish({ topic: r, message: s, ttl: a, prompt: u, tag: l, id: h, attestation: n?.attestation, tvf: n?.tvf }).then(w).catch((E) => {
              this.logger.warn(E, E?.message), b(E);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${h} tag:${l}`);
          try {
            await m, this.events.removeListener(be.publish, y);
          } catch (w) {
            this.queue.set(h, rn(Br({}, d), { attempt: 1 })), this.logger.warn(w, w?.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: h, topic: r, message: s, opts: n } }), await Lt(p, this.publishTimeout, f);
      } catch (p) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(p), (o = n?.internal) != null && o.throwOnFailedPublish)
          throw p;
      } finally {
        this.queue.delete(h);
      }
    }), rt(this, "on", (r, s) => {
      this.events.on(r, s);
    }), rt(this, "once", (r, s) => {
      this.events.once(r, s);
    }), rt(this, "off", (r, s) => {
      this.events.off(r, s);
    }), rt(this, "removeListener", (r, s) => {
      this.events.removeListener(r, s);
    }), this.relayer = e, this.logger = Fe(i, this.name), this.registerEventListeners();
  }
  get context() {
    return je(this.logger);
  }
  async rpcPublish(e) {
    var i, r, s, n;
    const { topic: o, message: a, ttl: c = _c, prompt: u, tag: l, id: h, attestation: d, tvf: f } = e, p = { method: Yi(es().protocol).publish, params: Br({ topic: o, message: a, ttl: c, prompt: u, tag: l, attestation: d }, f), id: h };
    $e((i = p.params) == null ? void 0 : i.prompt) && ((r = p.params) == null || delete r.prompt), $e((s = p.params) == null ? void 0 : s.tag) && ((n = p.params) == null || delete n.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: p });
    const g = await this.relayer.request(p);
    return this.relayer.events.emit(be.publish, e), this.logger.debug("Successfully Published Payload"), g;
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e, i) => {
      const r = e.attempt + 1;
      this.queue.set(i, rn(Br({}, e), { attempt: r }));
      const { topic: s, message: n, opts: o, attestation: a } = e;
      this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${r}`), await this.rpcPublish(rn(Br({}, e), { topic: s, message: n, ttl: o.ttl, prompt: o.prompt, tag: o.tag, id: o.id, attestation: a, tvf: o.tvf })), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(Ci.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(be.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(be.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
}
var p2 = Object.defineProperty, f2 = (t, e, i) => e in t ? p2(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, mi = (t, e, i) => f2(t, typeof e != "symbol" ? e + "" : e, i);
class g2 {
  constructor() {
    mi(this, "map", /* @__PURE__ */ new Map()), mi(this, "set", (e, i) => {
      const r = this.get(e);
      this.exists(e, i) || this.map.set(e, [...r, i]);
    }), mi(this, "get", (e) => this.map.get(e) || []), mi(this, "exists", (e, i) => this.get(e).includes(i)), mi(this, "delete", (e, i) => {
      if (typeof i > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const r = this.get(e);
      if (!this.exists(e, i))
        return;
      const s = r.filter((n) => n !== i);
      if (!s.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s);
    }), mi(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var y2 = Object.defineProperty, w2 = Object.defineProperties, m2 = Object.getOwnPropertyDescriptors, Rc = Object.getOwnPropertySymbols, b2 = Object.prototype.hasOwnProperty, v2 = Object.prototype.propertyIsEnumerable, Mn = (t, e, i) => e in t ? y2(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Wi = (t, e) => {
  for (var i in e || (e = {}))
    b2.call(e, i) && Mn(t, i, e[i]);
  if (Rc)
    for (var i of Rc(e))
      v2.call(e, i) && Mn(t, i, e[i]);
  return t;
}, sn = (t, e) => w2(t, m2(e)), ie = (t, e, i) => Mn(t, typeof e != "symbol" ? e + "" : e, i);
class E2 extends kp {
  constructor(e, i) {
    super(e, i), this.relayer = e, this.logger = i, ie(this, "subscriptions", /* @__PURE__ */ new Map()), ie(this, "topicMap", new g2()), ie(this, "events", new Ge.EventEmitter()), ie(this, "name", nE), ie(this, "version", oE), ie(this, "pending", /* @__PURE__ */ new Map()), ie(this, "cached", []), ie(this, "initialized", !1), ie(this, "storagePrefix", wt), ie(this, "subscribeTimeout", T.toMiliseconds(T.ONE_MINUTE)), ie(this, "initialSubscribeTimeout", T.toMiliseconds(T.ONE_SECOND * 15)), ie(this, "clientId"), ie(this, "batchSubscribeTopicsLimit", 500), ie(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = !0;
    }), ie(this, "subscribe", async (r, s) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: r, opts: s } });
      try {
        const n = es(s), o = { topic: r, relay: n, transportType: s?.transportType };
        this.pending.set(r, o);
        const a = await this.rpcSubscribe(r, n, s);
        return typeof a == "string" && (this.onSubscribe(a, o), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: r, opts: s } })), a;
      } catch (n) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n), n;
      }
    }), ie(this, "unsubscribe", async (r, s) => {
      this.isInitialized(), typeof s?.id < "u" ? await this.unsubscribeById(r, s.id, s) : await this.unsubscribeByTopic(r, s);
    }), ie(this, "isSubscribed", (r) => new Promise((s) => {
      s(this.topicMap.topics.includes(r));
    })), ie(this, "isKnownTopic", (r) => new Promise((s) => {
      s(this.topicMap.topics.includes(r) || this.pending.has(r) || this.cached.some((n) => n.topic === r));
    })), ie(this, "on", (r, s) => {
      this.events.on(r, s);
    }), ie(this, "once", (r, s) => {
      this.events.once(r, s);
    }), ie(this, "off", (r, s) => {
      this.events.off(r, s);
    }), ie(this, "removeListener", (r, s) => {
      this.events.removeListener(r, s);
    }), ie(this, "start", async () => {
      await this.onConnect();
    }), ie(this, "stop", async () => {
      await this.onDisconnect();
    }), ie(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), ie(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected))
        return;
      const r = [];
      this.pending.forEach((s) => {
        r.push(s);
      }), await this.batchSubscribe(r);
    }), ie(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(Ci.pulse, async () => {
        await this.checkPending();
      }), this.events.on(Ve.created, async (r) => {
        const s = Ve.created;
        this.logger.info(`Emitting ${s}`), this.logger.debug({ type: "event", event: s, data: r }), await this.persist();
      }), this.events.on(Ve.deleted, async (r) => {
        const s = Ve.deleted;
        this.logger.info(`Emitting ${s}`), this.logger.debug({ type: "event", event: s, data: r }), await this.persist();
      });
    }), this.relayer = e, this.logger = Fe(i, this.name), this.clientId = "";
  }
  get context() {
    return je(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e, i) {
    let r = !1;
    try {
      r = this.getSubscription(e).topic === i;
    } catch {
    }
    return r;
  }
  reset() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.values.length > 0 && (this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, i) {
    const r = this.topicMap.get(e);
    await Promise.all(r.map(async (s) => await this.unsubscribeById(e, s, i)));
  }
  async unsubscribeById(e, i, r) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: i, opts: r } });
    try {
      const s = es(r);
      await this.restartToComplete({ topic: e, id: i, relay: s }), await this.rpcUnsubscribe(e, i, s);
      const n = se("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, i, n), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: i, opts: r } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e, i, r) {
    var s;
    (!r || r?.transportType === ce.relay) && await this.restartToComplete({ topic: e, id: e, relay: i });
    const n = { method: Yi(i.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    const o = (s = r?.internal) == null ? void 0 : s.throwOnFailedPublish;
    try {
      const a = await this.getSubscriptionId(e);
      if (r?.transportType === ce.link_mode)
        return setTimeout(() => {
          (this.relayer.connected || this.relayer.connecting) && this.relayer.request(n).catch((l) => this.logger.warn(l));
        }, T.toMiliseconds(T.ONE_SECOND)), a;
      const c = new Promise(async (l) => {
        const h = (d) => {
          d.topic === e && (this.events.removeListener(Ve.created, h), l(d.id));
        };
        this.events.on(Ve.created, h);
        try {
          const d = await Lt(new Promise((f, p) => {
            this.relayer.request(n).catch((g) => {
              this.logger.warn(g, g?.message), p(g);
            }).then(f);
          }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
          this.events.removeListener(Ve.created, h), l(d);
        } catch {
        }
      }), u = await Lt(c, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!u && o)
        throw new Error(`Subscribing to ${e} failed, please try again`);
      return u ? a : null;
    } catch (a) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(be.connection_stalled), o)
        throw a;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const i = e[0].relay, r = { method: Yi(i.protocol).batchSubscribe, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: r });
    try {
      await await Lt(new Promise((s) => {
        this.relayer.request(r).catch((n) => this.logger.warn(n)).then(s);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(be.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length)
      return;
    const i = e[0].relay, r = { method: Yi(i.protocol).batchFetchMessages, params: { topics: e.map((n) => n.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: r });
    let s;
    try {
      s = await await Lt(new Promise((n, o) => {
        this.relayer.request(r).catch((a) => {
          this.logger.warn(a), o(a);
        }).then(n);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(be.connection_stalled);
    }
    return s;
  }
  rpcUnsubscribe(e, i, r) {
    const s = { method: Yi(r.protocol).unsubscribe, params: { topic: e, id: i } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e, i) {
    this.setSubscription(e, sn(Wi({}, i), { id: e })), this.pending.delete(i.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((i) => {
      this.setSubscription(i.id, Wi({}, i)), this.pending.delete(i.topic);
    });
  }
  async onUnsubscribe(e, i, r) {
    this.events.removeAllListeners(i), this.hasSubscription(i, e) && this.deleteSubscription(i, r), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, i) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: i }), this.addSubscription(e, i);
  }
  addSubscription(e, i) {
    this.subscriptions.set(e, Wi({}, i)), this.topicMap.set(i.topic, e), this.events.emit(Ve.created, i);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const i = this.subscriptions.get(e);
    if (!i) {
      const { message: r } = F("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(r);
    }
    return i;
  }
  deleteSubscription(e, i) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: i });
    const r = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(r.topic, e), this.events.emit(Ve.deleted, sn(Wi({}, r), { reason: i }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(Ve.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached], i = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let r = 0; r < i; r++) {
        const s = e.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(s);
      }
    }
    this.events.emit(Ve.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: i } = F("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(i), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(i);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async (i) => sn(Wi({}, i), { id: await this.getSubscriptionId(i.topic) })))));
  }
  async batchFetchMessages(e) {
    if (!e.length)
      return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const i = await this.rpcBatchFetchMessages(e);
    i && i.messages && (await gb(T.toMiliseconds(T.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(i.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete(e) {
    !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e), await this.relayer.transportOpen());
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e) {
    return gt(e + await this.getClientId());
  }
}
var _2 = Object.defineProperty, Tc = Object.getOwnPropertySymbols, I2 = Object.prototype.hasOwnProperty, D2 = Object.prototype.propertyIsEnumerable, qn = (t, e, i) => e in t ? _2(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Nc = (t, e) => {
  for (var i in e || (e = {}))
    I2.call(e, i) && qn(t, i, e[i]);
  if (Tc)
    for (var i of Tc(e))
      D2.call(e, i) && qn(t, i, e[i]);
  return t;
}, Q = (t, e, i) => qn(t, typeof e != "symbol" ? e + "" : e, i);
class S2 extends Bp {
  constructor(e) {
    super(e), Q(this, "protocol", "wc"), Q(this, "version", 2), Q(this, "core"), Q(this, "logger"), Q(this, "events", new Ge.EventEmitter()), Q(this, "provider"), Q(this, "messages"), Q(this, "subscriber"), Q(this, "publisher"), Q(this, "name", eE), Q(this, "transportExplicitlyClosed", !1), Q(this, "initialized", !1), Q(this, "connectionAttemptInProgress", !1), Q(this, "relayUrl"), Q(this, "projectId"), Q(this, "packageName"), Q(this, "bundleId"), Q(this, "hasExperiencedNetworkDisruption", !1), Q(this, "pingTimeout"), Q(this, "heartBeatTimeout", T.toMiliseconds(T.THIRTY_SECONDS + T.FIVE_SECONDS)), Q(this, "reconnectTimeout"), Q(this, "connectPromise"), Q(this, "reconnectInProgress", !1), Q(this, "requestsInFlight", []), Q(this, "connectTimeout", T.toMiliseconds(T.ONE_SECOND * 15)), Q(this, "request", async (i) => {
      var r, s;
      this.logger.debug("Publishing Request Payload");
      const n = i.id || Zt().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: n, method: i.method, topic: (r = i.params) == null ? void 0 : r.topic }, "relayer.request - publishing...");
        const o = `${n}:${((s = i.params) == null ? void 0 : s.tag) || ""}`;
        this.requestsInFlight.push(o);
        const a = await this.provider.request(i);
        return this.requestsInFlight = this.requestsInFlight.filter((c) => c !== o), a;
      } catch (o) {
        throw this.logger.debug(`Failed to Publish Request: ${n}`), o;
      }
    }), Q(this, "resetPingTimeout", () => {
      Qr() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
        var i, r, s, n;
        try {
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (n = (s = (r = (i = this.provider) == null ? void 0 : i.connection) == null ? void 0 : r.socket) == null ? void 0 : s.terminate) == null || n.call(s);
        } catch (o) {
          this.logger.warn(o, o?.message);
        }
      }, this.heartBeatTimeout));
    }), Q(this, "onPayloadHandler", (i) => {
      this.onProviderPayload(i), this.resetPingTimeout();
    }), Q(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(be.connect);
    }), Q(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
    }), Q(this, "onProviderErrorHandler", (i) => {
      this.logger.fatal(`Fatal socket error: ${i.message}`), this.events.emit(be.error, i), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), Q(this, "registerProviderListeners", () => {
      this.provider.on(Je.payload, this.onPayloadHandler), this.provider.on(Je.connect, this.onConnectHandler), this.provider.on(Je.disconnect, this.onDisconnectHandler), this.provider.on(Je.error, this.onProviderErrorHandler);
    }), this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? Fe(e.logger, this.name) : as(Gn({ level: e.logger || Xv })), this.messages = new o2(this.logger, e.core), this.subscriber = new E2(this, this.logger), this.publisher = new d2(this, this.logger), this.relayUrl = e?.relayUrl || sh, this.projectId = e.projectId, Qm() ? this.packageName = Aa() : Xm() && (this.bundleId = Aa()), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = !0, this.subscriber.hasAnyTopics)
      try {
        await this.transportOpen();
      } catch (e) {
        this.logger.warn(e, e?.message);
      }
  }
  get context() {
    return je(this.logger);
  }
  get connected() {
    var e, i, r;
    return ((r = (i = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : i.socket) == null ? void 0 : r.readyState) === 1 || !1;
  }
  get connecting() {
    var e, i, r;
    return ((r = (i = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : i.socket) == null ? void 0 : r.readyState) === 0 || this.connectPromise !== void 0 || !1;
  }
  async publish(e, i, r) {
    this.isInitialized(), await this.publisher.publish(e, i, r), await this.recordMessageEvent({ topic: e, message: i, publishedAt: Date.now(), transportType: ce.relay }, Kr.outbound);
  }
  async subscribe(e, i) {
    var r, s, n;
    this.isInitialized(), (!(i != null && i.transportType) || i?.transportType === "relay") && await this.toEstablishConnection();
    const o = typeof ((r = i?.internal) == null ? void 0 : r.throwOnFailedPublish) > "u" ? !0 : (s = i?.internal) == null ? void 0 : s.throwOnFailedPublish;
    let a = ((n = this.subscriber.topicMap.get(e)) == null ? void 0 : n[0]) || "", c;
    const u = (l) => {
      l.topic === e && (this.subscriber.off(Ve.created, u), c());
    };
    return await Promise.all([new Promise((l) => {
      c = l, this.subscriber.on(Ve.created, u);
    }), new Promise(async (l, h) => {
      a = await this.subscriber.subscribe(e, Nc({ internal: { throwOnFailedPublish: o } }, i)).catch((d) => {
        o && h(d);
      }) || a, l();
    })]), a;
  }
  async unsubscribe(e, i) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, i);
  }
  on(e, i) {
    this.events.on(e, i);
  }
  once(e, i) {
    this.events.once(e, i);
  }
  off(e, i) {
    this.events.off(e, i);
  }
  removeListener(e, i) {
    this.events.removeListener(e, i);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await Lt(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, await this.transportDisconnect();
  }
  async transportOpen(e) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (i, r) => {
      await this.connect(e).then(i).catch(r).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected)
      throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await fc())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if (e?.length === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const i = e.sort((r, s) => r.publishedAt - s.publishedAt);
    this.logger.debug(`Batch of ${i.length} message events sorted`);
    for (const r of i)
      try {
        await this.onMessageEvent(r);
      } catch (s) {
        this.logger.warn(s, "Error while processing batch message event: " + s?.message);
      }
    this.logger.trace(`Batch of ${i.length} message events processed`);
  }
  async onLinkMessageEvent(e, i) {
    const { topic: r } = e;
    if (!i.sessionExists) {
      const s = pe(T.FIVE_MINUTES), n = { topic: r, expiry: s, relay: { protocol: "irn" }, active: !1 };
      await this.core.pairing.pairings.set(r, n);
    }
    this.events.emit(be.message, e), await this.recordMessageEvent(e, Kr.inbound);
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;
    let i = 1;
    for (; i < 6; ) {
      try {
        if (this.transportExplicitlyClosed)
          break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${i}...`), await this.createProvider(), await new Promise(async (r, s) => {
          const n = () => {
            s(new Error("Connection interrupted while trying to subscribe"));
          };
          this.provider.once(Je.disconnect, n), await Lt(new Promise((o, a) => {
            this.provider.connect().then(o).catch(a);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o) => {
            s(o);
          }).finally(() => {
            this.provider.off(Je.disconnect, n), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o, a) => {
            const c = () => {
              a(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(Je.disconnect, c), await this.subscriber.start().then(o).catch(a).finally(() => {
              this.provider.off(Je.disconnect, c);
            });
          }), this.hasExperiencedNetworkDisruption = !1, r();
        });
      } catch (r) {
        await this.subscriber.stop();
        const s = r;
        this.logger.warn({}, s.message), this.hasExperiencedNetworkDisruption = !0;
      } finally {
        this.connectionAttemptInProgress = !1;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${i}`);
        break;
      }
      await new Promise((r) => setTimeout(r, T.toMiliseconds(i * 1))), i++;
    }
  }
  startPingTimeout() {
    var e, i, r, s, n;
    if (Qr())
      try {
        (i = (e = this.provider) == null ? void 0 : e.connection) != null && i.socket && ((n = (s = (r = this.provider) == null ? void 0 : r.connection) == null ? void 0 : s.socket) == null || n.on("ping", () => {
          this.resetPingTimeout();
        })), this.resetPingTimeout();
      } catch (o) {
        this.logger.warn(o, o?.message);
      }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new eh(new zv(sb({ sdkVersion: Fn, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e, i) {
    const { topic: r, message: s } = e;
    await this.messages.set(r, s, i);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: i, message: r } = e;
    if (!r || r.length === 0)
      return this.logger.warn(`Ignoring invalid/empty message: ${r}`), !0;
    if (!await this.subscriber.isKnownTopic(i))
      return this.logger.warn(`Ignoring message for unknown topic ${i}`), !0;
    const s = this.messages.has(i, r);
    return s && this.logger.warn(`Ignoring duplicate message: ${r}`), s;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), wo(e)) {
      if (!e.method.endsWith(tE))
        return;
      const i = e.params, { topic: r, message: s, publishedAt: n, attestation: o } = i.data, a = { topic: r, message: s, publishedAt: n, transportType: ce.relay, attestation: o };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Nc({ type: "event", event: i.id }, a)), this.events.emit(i.id, a), await this.acknowledgePayload(e), await this.onMessageEvent(a);
    } else
      vs(e) && this.events.emit(be.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (await this.recordMessageEvent(e, Kr.inbound), this.events.emit(be.message, e));
  }
  async acknowledgePayload(e) {
    const i = ms(e.id, !0);
    await this.provider.connection.send(i);
  }
  unregisterProviderListeners() {
    this.provider.off(Je.payload, this.onPayloadHandler), this.provider.off(Je.connect, this.onConnectHandler), this.provider.off(Je.disconnect, this.onDisconnectHandler), this.provider.off(Je.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await fc();
    bv(async (i) => {
      e !== i && (e = i, i ? await this.transportOpen().catch((r) => this.logger.error(r, r?.message)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1));
    });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout), this.events.emit(be.disconnect), this.connectionAttemptInProgress = !1, !this.reconnectInProgress && (this.reconnectInProgress = !0, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e, e?.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = !1;
    }, T.toMiliseconds(iE)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectPromise) {
        await this.connectPromise;
        return;
      }
      await this.connect();
    }
  }
}
function $2() {
}
function Fc(t) {
  if (!t || typeof t != "object")
    return !1;
  const e = Object.getPrototypeOf(t);
  return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null ? Object.prototype.toString.call(t) === "[object Object]" : !1;
}
function Lc(t) {
  return Object.getOwnPropertySymbols(t).filter((e) => Object.prototype.propertyIsEnumerable.call(t, e));
}
function Bc(t) {
  return t == null ? t === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(t);
}
const O2 = "[object RegExp]", x2 = "[object String]", A2 = "[object Number]", P2 = "[object Boolean]", Uc = "[object Arguments]", C2 = "[object Symbol]", R2 = "[object Date]", T2 = "[object Map]", N2 = "[object Set]", F2 = "[object Array]", L2 = "[object Function]", B2 = "[object ArrayBuffer]", nn = "[object Object]", U2 = "[object Error]", k2 = "[object DataView]", M2 = "[object Uint8Array]", q2 = "[object Uint8ClampedArray]", j2 = "[object Uint16Array]", z2 = "[object Uint32Array]", V2 = "[object BigUint64Array]", K2 = "[object Int8Array]", H2 = "[object Int16Array]", W2 = "[object Int32Array]", G2 = "[object BigInt64Array]", Y2 = "[object Float32Array]", J2 = "[object Float64Array]";
function Z2(t, e) {
  return t === e || Number.isNaN(t) && Number.isNaN(e);
}
function Q2(t, e, i) {
  return Ji(t, e, void 0, void 0, void 0, void 0, i);
}
function Ji(t, e, i, r, s, n, o) {
  const a = o(t, e, i, r, s, n);
  if (a !== void 0)
    return a;
  if (typeof t == typeof e)
    switch (typeof t) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined":
        return t === e;
      case "number":
        return t === e || Object.is(t, e);
      case "function":
        return t === e;
      case "object":
        return tr(t, e, n, o);
    }
  return tr(t, e, n, o);
}
function tr(t, e, i, r) {
  if (Object.is(t, e))
    return !0;
  let s = Bc(t), n = Bc(e);
  if (s === Uc && (s = nn), n === Uc && (n = nn), s !== n)
    return !1;
  switch (s) {
    case x2:
      return t.toString() === e.toString();
    case A2: {
      const c = t.valueOf(), u = e.valueOf();
      return Z2(c, u);
    }
    case P2:
    case R2:
    case C2:
      return Object.is(t.valueOf(), e.valueOf());
    case O2:
      return t.source === e.source && t.flags === e.flags;
    case L2:
      return t === e;
  }
  i = i ?? /* @__PURE__ */ new Map();
  const o = i.get(t), a = i.get(e);
  if (o != null && a != null)
    return o === e;
  i.set(t, e), i.set(e, t);
  try {
    switch (s) {
      case T2: {
        if (t.size !== e.size)
          return !1;
        for (const [c, u] of t.entries())
          if (!e.has(c) || !Ji(u, e.get(c), c, t, e, i, r))
            return !1;
        return !0;
      }
      case N2: {
        if (t.size !== e.size)
          return !1;
        const c = Array.from(t.values()), u = Array.from(e.values());
        for (let l = 0; l < c.length; l++) {
          const h = c[l], d = u.findIndex((f) => Ji(h, f, void 0, t, e, i, r));
          if (d === -1)
            return !1;
          u.splice(d, 1);
        }
        return !0;
      }
      case F2:
      case M2:
      case q2:
      case j2:
      case z2:
      case V2:
      case K2:
      case H2:
      case W2:
      case G2:
      case Y2:
      case J2: {
        if (typeof Buffer < "u" && Buffer.isBuffer(t) !== Buffer.isBuffer(e) || t.length !== e.length)
          return !1;
        for (let c = 0; c < t.length; c++)
          if (!Ji(t[c], e[c], c, t, e, i, r))
            return !1;
        return !0;
      }
      case B2:
        return t.byteLength !== e.byteLength ? !1 : tr(new Uint8Array(t), new Uint8Array(e), i, r);
      case k2:
        return t.byteLength !== e.byteLength || t.byteOffset !== e.byteOffset ? !1 : tr(new Uint8Array(t), new Uint8Array(e), i, r);
      case U2:
        return t.name === e.name && t.message === e.message;
      case nn: {
        if (!(tr(t.constructor, e.constructor, i, r) || Fc(t) && Fc(e)))
          return !1;
        const c = [...Object.keys(t), ...Lc(t)], u = [...Object.keys(e), ...Lc(e)];
        if (c.length !== u.length)
          return !1;
        for (let l = 0; l < c.length; l++) {
          const h = c[l], d = t[h];
          if (!Object.hasOwn(e, h))
            return !1;
          const f = e[h];
          if (!Ji(d, f, h, t, e, i, r))
            return !1;
        }
        return !0;
      }
      default:
        return !1;
    }
  } finally {
    i.delete(t), i.delete(e);
  }
}
function X2(t, e) {
  return Q2(t, e, $2);
}
var eI = Object.defineProperty, kc = Object.getOwnPropertySymbols, tI = Object.prototype.hasOwnProperty, iI = Object.prototype.propertyIsEnumerable, jn = (t, e, i) => e in t ? eI(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Mc = (t, e) => {
  for (var i in e || (e = {}))
    tI.call(e, i) && jn(t, i, e[i]);
  if (kc)
    for (var i of kc(e))
      iI.call(e, i) && jn(t, i, e[i]);
  return t;
}, Be = (t, e, i) => jn(t, typeof e != "symbol" ? e + "" : e, i);
class ci extends Up {
  constructor(e, i, r, s = wt, n = void 0) {
    super(e, i, r, s), this.core = e, this.logger = i, this.name = r, Be(this, "map", /* @__PURE__ */ new Map()), Be(this, "version", rE), Be(this, "cached", []), Be(this, "initialized", !1), Be(this, "getKey"), Be(this, "storagePrefix", wt), Be(this, "recentlyDeleted", []), Be(this, "recentlyDeletedLimit", 200), Be(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o) => {
        this.getKey && o !== null && !$e(o) ? this.map.set(this.getKey(o), o) : J0(o) ? this.map.set(o.id, o) : Z0(o) && this.map.set(o.topic, o);
      }), this.cached = [], this.initialized = !0);
    }), Be(this, "set", async (o, a) => {
      this.isInitialized(), this.map.has(o) ? await this.update(o, a) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o, value: a }), this.map.set(o, a), await this.persist());
    }), Be(this, "get", (o) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o }), this.getData(o))), Be(this, "getAll", (o) => (this.isInitialized(), o ? this.values.filter((a) => Object.keys(o).every((c) => X2(a[c], o[c]))) : this.values)), Be(this, "update", async (o, a) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o, update: a });
      const c = Mc(Mc({}, this.getData(o)), a);
      this.map.set(o, c), await this.persist();
    }), Be(this, "delete", async (o, a) => {
      this.isInitialized(), this.map.has(o) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o, reason: a }), this.map.delete(o), this.addToRecentlyDeleted(o), await this.persist());
    }), this.logger = Fe(i, this.name), this.storagePrefix = s, this.getKey = n;
  }
  get context() {
    return je(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const i = this.map.get(e);
    if (!i) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: s } = F("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(s), new Error(s);
      }
      const { message: r } = F("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(r), new Error(r);
    }
    return i;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: i } = F("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(i), new Error(i);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var rI = Object.defineProperty, sI = (t, e, i) => e in t ? rI(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, W = (t, e, i) => sI(t, typeof e != "symbol" ? e + "" : e, i);
class nI {
  constructor(e, i) {
    this.core = e, this.logger = i, W(this, "name", aE), W(this, "version", cE), W(this, "events", new ou()), W(this, "pairings"), W(this, "initialized", !1), W(this, "storagePrefix", wt), W(this, "ignoredPayloadTypes", [At]), W(this, "registeredMethods", []), W(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }), W(this, "register", ({ methods: r }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...r])];
    }), W(this, "create", async (r) => {
      this.isInitialized();
      const s = Nn(), n = await this.core.crypto.setSymKey(s), o = pe(T.FIVE_MINUTES), a = { protocol: rh }, c = { topic: n, expiry: o, relay: a, active: !1, methods: r?.methods }, u = cc({ protocol: this.core.protocol, version: this.core.version, topic: n, symKey: s, relay: a, expiryTimestamp: o, methods: r?.methods });
      return this.events.emit(Yt.create, c), this.core.expirer.set(n, o), await this.pairings.set(n, c), await this.core.relayer.subscribe(n, { transportType: r?.transportType }), { topic: n, uri: u };
    }), W(this, "pair", async (r) => {
      this.isInitialized();
      const s = this.core.eventClient.createEvent({ properties: { topic: r?.uri, trace: [ht.pairing_started] } });
      this.isValidPair(r, s);
      const { topic: n, symKey: o, relay: a, expiryTimestamp: c, methods: u } = ac(r.uri);
      s.props.properties.topic = n, s.addTrace(ht.pairing_uri_validation_success), s.addTrace(ht.pairing_uri_not_expired);
      let l;
      if (this.pairings.keys.includes(n)) {
        if (l = this.pairings.get(n), s.addTrace(ht.existing_pairing), l.active)
          throw s.setError(St.active_pairing_already_exists), new Error(`Pairing already exists: ${n}. Please try again with a new connection URI.`);
        s.addTrace(ht.pairing_not_expired);
      }
      const h = c || pe(T.FIVE_MINUTES), d = { topic: n, relay: a, expiry: h, active: !1, methods: u };
      this.core.expirer.set(n, h), await this.pairings.set(n, d), s.addTrace(ht.store_new_pairing), r.activatePairing && await this.activate({ topic: n }), this.events.emit(Yt.create, d), s.addTrace(ht.emit_inactive_pairing), this.core.crypto.keychain.has(n) || await this.core.crypto.setSymKey(o, n), s.addTrace(ht.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        s.setError(St.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(n, { relay: a });
      } catch (f) {
        throw s.setError(St.subscribe_pairing_topic_failure), f;
      }
      return s.addTrace(ht.subscribe_pairing_topic_success), d;
    }), W(this, "activate", async ({ topic: r }) => {
      this.isInitialized();
      const s = pe(T.FIVE_MINUTES);
      this.core.expirer.set(r, s), await this.pairings.update(r, { active: !0, expiry: s });
    }), W(this, "ping", async (r) => {
      this.isInitialized(), await this.isValidPing(r), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: s } = r;
      if (this.pairings.keys.includes(s)) {
        const n = await this.sendRequest(s, "wc_pairingPing", {}), { done: o, resolve: a, reject: c } = Ht();
        this.events.once(X("pairing_ping", n), ({ error: u }) => {
          u ? c(u) : a();
        }), await o();
      }
    }), W(this, "updateExpiry", async ({ topic: r, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(r, { expiry: s });
    }), W(this, "updateMetadata", async ({ topic: r, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(r, { peerMetadata: s });
    }), W(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), W(this, "disconnect", async (r) => {
      this.isInitialized(), await this.isValidDisconnect(r);
      const { topic: s } = r;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", se("USER_DISCONNECTED")), await this.deletePairing(s));
    }), W(this, "formatUriFromPairing", (r) => {
      this.isInitialized();
      const { topic: s, relay: n, expiry: o, methods: a } = r, c = this.core.crypto.keychain.get(s);
      return cc({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: c, relay: n, expiryTimestamp: o, methods: a });
    }), W(this, "sendRequest", async (r, s, n) => {
      const o = Qt(s, n), a = await this.core.crypto.encode(r, o), c = Ki[s].req;
      return this.core.history.set(r, o), this.core.relayer.publish(r, a, c), o.id;
    }), W(this, "sendResult", async (r, s, n) => {
      const o = ms(r, n), a = await this.core.crypto.encode(s, o), c = (await this.core.history.get(s, r)).request.method, u = Ki[c].res;
      await this.core.relayer.publish(s, a, u), await this.core.history.resolve(o);
    }), W(this, "sendError", async (r, s, n) => {
      const o = bs(r, n), a = await this.core.crypto.encode(s, o), c = (await this.core.history.get(s, r)).request.method, u = Ki[c] ? Ki[c].res : Ki.unregistered_method.res;
      await this.core.relayer.publish(s, a, u), await this.core.history.resolve(o);
    }), W(this, "deletePairing", async (r, s) => {
      await this.core.relayer.unsubscribe(r), await Promise.all([this.pairings.delete(r, se("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(r), s ? Promise.resolve() : this.core.expirer.del(r)]);
    }), W(this, "cleanup", async () => {
      const r = this.pairings.getAll().filter((s) => Nt(s.expiry));
      await Promise.all(r.map((s) => this.deletePairing(s.topic)));
    }), W(this, "onRelayEventRequest", async (r) => {
      const { topic: s, payload: n } = r;
      switch (n.method) {
        case "wc_pairingPing":
          return await this.onPairingPingRequest(s, n);
        case "wc_pairingDelete":
          return await this.onPairingDeleteRequest(s, n);
        default:
          return await this.onUnknownRpcMethodRequest(s, n);
      }
    }), W(this, "onRelayEventResponse", async (r) => {
      const { topic: s, payload: n } = r, o = (await this.core.history.get(s, n.id)).request.method;
      switch (o) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s, n);
        default:
          return this.onUnknownRpcMethodResponse(o);
      }
    }), W(this, "onPairingPingRequest", async (r, s) => {
      const { id: n } = s;
      try {
        this.isValidPing({ topic: r }), await this.sendResult(n, r, !0), this.events.emit(Yt.ping, { id: n, topic: r });
      } catch (o) {
        await this.sendError(n, r, o), this.logger.error(o);
      }
    }), W(this, "onPairingPingResponse", (r, s) => {
      const { id: n } = s;
      setTimeout(() => {
        pt(s) ? this.events.emit(X("pairing_ping", n), {}) : Qe(s) && this.events.emit(X("pairing_ping", n), { error: s.error });
      }, 500);
    }), W(this, "onPairingDeleteRequest", async (r, s) => {
      const { id: n } = s;
      try {
        this.isValidDisconnect({ topic: r }), await this.deletePairing(r), this.events.emit(Yt.delete, { id: n, topic: r });
      } catch (o) {
        await this.sendError(n, r, o), this.logger.error(o);
      }
    }), W(this, "onUnknownRpcMethodRequest", async (r, s) => {
      const { id: n, method: o } = s;
      try {
        if (this.registeredMethods.includes(o))
          return;
        const a = se("WC_METHOD_UNSUPPORTED", o);
        await this.sendError(n, r, a), this.logger.error(a);
      } catch (a) {
        await this.sendError(n, r, a), this.logger.error(a);
      }
    }), W(this, "onUnknownRpcMethodResponse", (r) => {
      this.registeredMethods.includes(r) || this.logger.error(se("WC_METHOD_UNSUPPORTED", r));
    }), W(this, "isValidPair", (r, s) => {
      var n;
      if (!ke(r)) {
        const { message: a } = F("MISSING_OR_INVALID", `pair() params: ${r}`);
        throw s.setError(St.malformed_pairing_uri), new Error(a);
      }
      if (!Y0(r.uri)) {
        const { message: a } = F("MISSING_OR_INVALID", `pair() uri: ${r.uri}`);
        throw s.setError(St.malformed_pairing_uri), new Error(a);
      }
      const o = ac(r?.uri);
      if (!((n = o?.relay) != null && n.protocol)) {
        const { message: a } = F("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw s.setError(St.malformed_pairing_uri), new Error(a);
      }
      if (!(o != null && o.symKey)) {
        const { message: a } = F("MISSING_OR_INVALID", "pair() uri#symKey");
        throw s.setError(St.malformed_pairing_uri), new Error(a);
      }
      if (o != null && o.expiryTimestamp && T.toMiliseconds(o?.expiryTimestamp) < Date.now()) {
        s.setError(St.pairing_expired);
        const { message: a } = F("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a);
      }
    }), W(this, "isValidPing", async (r) => {
      if (!ke(r)) {
        const { message: n } = F("MISSING_OR_INVALID", `ping() params: ${r}`);
        throw new Error(n);
      }
      const { topic: s } = r;
      await this.isValidPairingTopic(s);
    }), W(this, "isValidDisconnect", async (r) => {
      if (!ke(r)) {
        const { message: n } = F("MISSING_OR_INVALID", `disconnect() params: ${r}`);
        throw new Error(n);
      }
      const { topic: s } = r;
      await this.isValidPairingTopic(s);
    }), W(this, "isValidPairingTopic", async (r) => {
      if (!de(r, !1)) {
        const { message: s } = F("MISSING_OR_INVALID", `pairing topic should be a string: ${r}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(r)) {
        const { message: s } = F("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r}`);
        throw new Error(s);
      }
      if (Nt(this.pairings.get(r).expiry)) {
        await this.deletePairing(r);
        const { message: s } = F("EXPIRED", `pairing topic: ${r}`);
        throw new Error(s);
      }
    }), this.core = e, this.logger = Fe(i, this.name), this.pairings = new ci(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return je(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(be.message, async (e) => {
      const { topic: i, message: r, transportType: s } = e;
      if (this.pairings.keys.includes(i) && s !== ce.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(r)))
        try {
          const n = await this.core.crypto.decode(i, r);
          wo(n) ? (this.core.history.set(i, n), await this.onRelayEventRequest({ topic: i, payload: n })) : vs(n) && (await this.core.history.resolve(n), await this.onRelayEventResponse({ topic: i, payload: n }), this.core.history.delete(i, n.id)), await this.core.relayer.messages.ack(i, r);
        } catch (n) {
          this.logger.error(n);
        }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(Ze.expired, async (e) => {
      const { topic: i } = pl(e.target);
      i && this.pairings.keys.includes(i) && (await this.deletePairing(i, !0), this.events.emit(Yt.expire, { topic: i }));
    });
  }
}
var oI = Object.defineProperty, aI = (t, e, i) => e in t ? oI(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Se = (t, e, i) => aI(t, typeof e != "symbol" ? e + "" : e, i);
class cI extends Np {
  constructor(e, i) {
    super(e, i), this.core = e, this.logger = i, Se(this, "records", /* @__PURE__ */ new Map()), Se(this, "events", new Ge.EventEmitter()), Se(this, "name", uE), Se(this, "version", lE), Se(this, "cached", []), Se(this, "initialized", !1), Se(this, "storagePrefix", wt), Se(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((r) => this.records.set(r.id, r)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }), Se(this, "set", (r, s, n) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: r, request: s, chainId: n }), this.records.has(s.id))
        return;
      const o = { id: s.id, topic: r, request: { method: s.method, params: s.params || null }, chainId: n, expiry: pe(T.THIRTY_DAYS) };
      this.records.set(o.id, o), this.persist(), this.events.emit(tt.created, o);
    }), Se(this, "resolve", async (r) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: r }), !this.records.has(r.id))
        return;
      const s = await this.getRecord(r.id);
      typeof s.response > "u" && (s.response = Qe(r) ? { error: r.error } : { result: r.result }, this.records.set(s.id, s), this.persist(), this.events.emit(tt.updated, s));
    }), Se(this, "get", async (r, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: r, id: s }), await this.getRecord(s))), Se(this, "delete", (r, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((n) => {
        if (n.topic === r) {
          if (typeof s < "u" && n.id !== s)
            return;
          this.records.delete(n.id), this.events.emit(tt.deleted, n);
        }
      }), this.persist();
    }), Se(this, "exists", async (r, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === r : !1)), Se(this, "on", (r, s) => {
      this.events.on(r, s);
    }), Se(this, "once", (r, s) => {
      this.events.once(r, s);
    }), Se(this, "off", (r, s) => {
      this.events.off(r, s);
    }), Se(this, "removeListener", (r, s) => {
      this.events.removeListener(r, s);
    }), this.logger = Fe(i, this.name);
  }
  get context() {
    return je(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((i) => {
      if (typeof i.response < "u")
        return;
      const r = { topic: i.topic, request: Qt(i.request.method, i.request.params, i.id), chainId: i.chainId };
      return e.push(r);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const i = this.records.get(e);
    if (!i) {
      const { message: r } = F("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(r);
    }
    return i;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(tt.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: i } = F("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(i), new Error(i);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(tt.created, (e) => {
      const i = tt.created;
      this.logger.info(`Emitting ${i}`), this.logger.debug({ type: "event", event: i, record: e });
    }), this.events.on(tt.updated, (e) => {
      const i = tt.updated;
      this.logger.info(`Emitting ${i}`), this.logger.debug({ type: "event", event: i, record: e });
    }), this.events.on(tt.deleted, (e) => {
      const i = tt.deleted;
      this.logger.info(`Emitting ${i}`), this.logger.debug({ type: "event", event: i, record: e });
    }), this.core.heartbeat.on(Ci.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = !1;
      this.records.forEach((i) => {
        T.toMiliseconds(i.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${i.id}`), this.records.delete(i.id), this.events.emit(tt.deleted, i, !1), e = !0);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var uI = Object.defineProperty, lI = (t, e, i) => e in t ? uI(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Ce = (t, e, i) => lI(t, typeof e != "symbol" ? e + "" : e, i);
class hI extends Mp {
  constructor(e, i) {
    super(e, i), this.core = e, this.logger = i, Ce(this, "expirations", /* @__PURE__ */ new Map()), Ce(this, "events", new Ge.EventEmitter()), Ce(this, "name", hE), Ce(this, "version", dE), Ce(this, "cached", []), Ce(this, "initialized", !1), Ce(this, "storagePrefix", wt), Ce(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((r) => this.expirations.set(r.target, r)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }), Ce(this, "has", (r) => {
      try {
        const s = this.formatTarget(r);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return !1;
      }
    }), Ce(this, "set", (r, s) => {
      this.isInitialized();
      const n = this.formatTarget(r), o = { target: n, expiry: s };
      this.expirations.set(n, o), this.checkExpiry(n, o), this.events.emit(Ze.created, { target: n, expiration: o });
    }), Ce(this, "get", (r) => {
      this.isInitialized();
      const s = this.formatTarget(r);
      return this.getExpiration(s);
    }), Ce(this, "del", (r) => {
      if (this.isInitialized(), this.has(r)) {
        const s = this.formatTarget(r), n = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(Ze.deleted, { target: s, expiration: n });
      }
    }), Ce(this, "on", (r, s) => {
      this.events.on(r, s);
    }), Ce(this, "once", (r, s) => {
      this.events.once(r, s);
    }), Ce(this, "off", (r, s) => {
      this.events.off(r, s);
    }), Ce(this, "removeListener", (r, s) => {
      this.events.removeListener(r, s);
    }), this.logger = Fe(i, this.name);
  }
  get context() {
    return je(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return nb(e);
    if (typeof e == "number")
      return ob(e);
    const { message: i } = F("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(i);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(Ze.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: i } = F("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(i), new Error(i);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const i = this.expirations.get(e);
    if (!i) {
      const { message: r } = F("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(r), new Error(r);
    }
    return i;
  }
  checkExpiry(e, i) {
    const { expiry: r } = i;
    T.toMiliseconds(r) - Date.now() <= 0 && this.expire(e, i);
  }
  expire(e, i) {
    this.expirations.delete(e), this.events.emit(Ze.expired, { target: e, expiration: i });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, i) => this.checkExpiry(i, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(Ci.pulse, () => this.checkExpirations()), this.events.on(Ze.created, (e) => {
      const i = Ze.created;
      this.logger.info(`Emitting ${i}`), this.logger.debug({ type: "event", event: i, data: e }), this.persist();
    }), this.events.on(Ze.expired, (e) => {
      const i = Ze.expired;
      this.logger.info(`Emitting ${i}`), this.logger.debug({ type: "event", event: i, data: e }), this.persist();
    }), this.events.on(Ze.deleted, (e) => {
      const i = Ze.deleted;
      this.logger.info(`Emitting ${i}`), this.logger.debug({ type: "event", event: i, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var dI = Object.defineProperty, pI = (t, e, i) => e in t ? dI(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, he = (t, e, i) => pI(t, typeof e != "symbol" ? e + "" : e, i);
class fI extends qp {
  constructor(e, i, r) {
    super(e, i, r), this.core = e, this.logger = i, this.store = r, he(this, "name", pE), he(this, "abortController"), he(this, "isDevEnv"), he(this, "verifyUrlV3", gE), he(this, "storagePrefix", wt), he(this, "version", ih), he(this, "publicKey"), he(this, "fetchPromise"), he(this, "init", async () => {
      var s;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && T.toMiliseconds((s = this.publicKey) == null ? void 0 : s.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), he(this, "register", async (s) => {
      if (!wr() || this.isDevEnv)
        return;
      const n = window.location.origin, { id: o, decryptedId: a } = s, c = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n}&id=${o}&decryptedId=${a}`;
      try {
        const u = gr(), l = this.startAbortTimer(T.ONE_SECOND * 5), h = await new Promise((d, f) => {
          const p = () => {
            window.removeEventListener("message", y), u.body.removeChild(g), f("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", p);
          const g = u.createElement("iframe");
          g.src = c, g.style.display = "none", g.addEventListener("error", p, { signal: this.abortController.signal });
          const y = (m) => {
            if (m.data && typeof m.data == "string")
              try {
                const w = JSON.parse(m.data);
                if (w.type === "verify_attestation") {
                  if (vn(w.attestation).payload.id !== o)
                    return;
                  clearInterval(l), u.body.removeChild(g), this.abortController.signal.removeEventListener("abort", p), window.removeEventListener("message", y), d(w.attestation === null ? "" : w.attestation);
                }
              } catch (w) {
                this.logger.warn(w);
              }
          };
          u.body.appendChild(g), window.addEventListener("message", y, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", h), h;
      } catch (u) {
        this.logger.warn(u);
      }
      return "";
    }), he(this, "resolve", async (s) => {
      if (this.isDevEnv)
        return "";
      const { attestationId: n, hash: o, encryptedId: a } = s;
      if (n === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (n) {
        if (vn(n).payload.id !== a)
          return;
        const u = await this.isValidJwtAttestation(n);
        if (u) {
          if (!u.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return u;
        }
      }
      if (!o)
        return;
      const c = this.getVerifyUrl(s?.verifyUrl);
      return this.fetchAttestation(o, c);
    }), he(this, "fetchAttestation", async (s, n) => {
      this.logger.debug(`resolving attestation: ${s} from url: ${n}`);
      const o = this.startAbortTimer(T.ONE_SECOND * 5), a = await fetch(`${n}/attestation/${s}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o), a.status === 200 ? await a.json() : void 0;
    }), he(this, "getVerifyUrl", (s) => {
      let n = s || er;
      return yE.includes(n) || (this.logger.info(`verify url: ${n}, not included in trusted list, assigning default: ${er}`), n = er), n;
    }), he(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const s = this.startAbortTimer(T.FIVE_SECONDS), n = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(s), await n.json();
      } catch (s) {
        this.logger.warn(s);
      }
    }), he(this, "persistPublicKey", async (s) => {
      this.logger.debug("persisting public key to local storage", s), await this.store.setItem(this.storeKey, s), this.publicKey = s;
    }), he(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), he(this, "isValidJwtAttestation", async (s) => {
      const n = await this.getPublicKey();
      try {
        if (n)
          return this.validateAttestation(s, n);
      } catch (a) {
        this.logger.error(a), this.logger.warn("error validating attestation");
      }
      const o = await this.fetchAndPersistPublicKey();
      try {
        if (o)
          return this.validateAttestation(s, o);
      } catch (a) {
        this.logger.error(a), this.logger.warn("error validating attestation");
      }
    }), he(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), he(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise)
        return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (n) => {
        const o = await this.fetchPublicKey();
        o && (await this.persistPublicKey(o), n(o));
      });
      const s = await this.fetchPromise;
      return this.fetchPromise = void 0, s;
    }), he(this, "validateAttestation", (s, n) => {
      const o = L0(s, n.publicKey), a = { hasExpired: T.toMiliseconds(o.exp) < Date.now(), payload: o };
      if (a.hasExpired)
        throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a.payload.origin, isScam: a.payload.isScam, isVerified: a.payload.isVerified };
    }), this.logger = Fe(i, this.name), this.abortController = new AbortController(), this.isDevEnv = ao(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return je(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), T.toMiliseconds(e));
  }
}
var gI = Object.defineProperty, yI = (t, e, i) => e in t ? gI(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, qc = (t, e, i) => yI(t, typeof e != "symbol" ? e + "" : e, i);
class wI extends jp {
  constructor(e, i) {
    super(e, i), this.projectId = e, this.logger = i, qc(this, "context", wE), qc(this, "registerDeviceToken", async (r) => {
      const { clientId: s, token: n, notificationType: o, enableEncrypted: a = !1 } = r, c = `${mE}/${this.projectId}/clients`;
      await fetch(c, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s, type: o, token: n, always_raw: a }) });
    }), this.logger = Fe(i, this.context);
  }
}
var mI = Object.defineProperty, jc = Object.getOwnPropertySymbols, bI = Object.prototype.hasOwnProperty, vI = Object.prototype.propertyIsEnumerable, zn = (t, e, i) => e in t ? mI(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Gi = (t, e) => {
  for (var i in e || (e = {}))
    bI.call(e, i) && zn(t, i, e[i]);
  if (jc)
    for (var i of jc(e))
      vI.call(e, i) && zn(t, i, e[i]);
  return t;
}, ge = (t, e, i) => zn(t, typeof e != "symbol" ? e + "" : e, i);
class EI extends zp {
  constructor(e, i, r = !0) {
    super(e, i, r), this.core = e, this.logger = i, ge(this, "context", vE), ge(this, "storagePrefix", wt), ge(this, "storageVersion", bE), ge(this, "events", /* @__PURE__ */ new Map()), ge(this, "shouldPersist", !1), ge(this, "init", async () => {
      if (!ao())
        try {
          const s = { eventId: Ca(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: hl(this.core.relayer.protocol, this.core.relayer.version, Fn) } } };
          await this.sendEvent([s]);
        } catch (s) {
          this.logger.warn(s);
        }
    }), ge(this, "createEvent", (s) => {
      const { event: n = "ERROR", type: o = "", properties: { topic: a, trace: c } } = s, u = Ca(), l = this.core.projectId || "", h = Date.now(), d = Gi({ eventId: u, timestamp: h, props: { event: n, type: o, properties: { topic: a, trace: c } }, bundleId: l, domain: this.getAppDomain() }, this.setMethods(u));
      return this.telemetryEnabled && (this.events.set(u, d), this.shouldPersist = !0), d;
    }), ge(this, "getEvent", (s) => {
      const { eventId: n, topic: o } = s;
      if (n)
        return this.events.get(n);
      const a = Array.from(this.events.values()).find((c) => c.props.properties.topic === o);
      if (a)
        return Gi(Gi({}, a), this.setMethods(a.eventId));
    }), ge(this, "deleteEvent", (s) => {
      const { eventId: n } = s;
      this.events.delete(n), this.shouldPersist = !0;
    }), ge(this, "setEventListeners", () => {
      this.core.heartbeat.on(Ci.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((s) => {
          T.fromMiliseconds(Date.now()) - T.fromMiliseconds(s.timestamp) > EE && (this.events.delete(s.eventId), this.shouldPersist = !0);
        });
      });
    }), ge(this, "setMethods", (s) => ({ addTrace: (n) => this.addTrace(s, n), setError: (n) => this.setError(s, n) })), ge(this, "addTrace", (s, n) => {
      const o = this.events.get(s);
      o && (o.props.properties.trace.push(n), this.events.set(s, o), this.shouldPersist = !0);
    }), ge(this, "setError", (s, n) => {
      const o = this.events.get(s);
      o && (o.props.type = n, o.timestamp = Date.now(), this.events.set(s, o), this.shouldPersist = !0);
    }), ge(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1;
    }), ge(this, "restore", async () => {
      try {
        const s = await this.core.storage.getItem(this.storageKey) || [];
        if (!s.length)
          return;
        s.forEach((n) => {
          this.events.set(n.eventId, Gi(Gi({}, n), this.setMethods(n.eventId)));
        });
      } catch (s) {
        this.logger.warn(s);
      }
    }), ge(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0)
        return;
      const s = [];
      for (const [n, o] of this.events)
        o.props.type && s.push(o);
      if (s.length !== 0)
        try {
          if ((await this.sendEvent(s)).ok)
            for (const n of s)
              this.events.delete(n.eventId), this.shouldPersist = !0;
        } catch (n) {
          this.logger.warn(n);
        }
    }), ge(this, "sendEvent", async (s) => {
      const n = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${_E}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${Fn}${n}`, { method: "POST", body: JSON.stringify(s) });
    }), ge(this, "getAppDomain", () => ll().url), this.logger = Fe(i, this.context), this.telemetryEnabled = r, r ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
}
var _I = Object.defineProperty, zc = Object.getOwnPropertySymbols, II = Object.prototype.hasOwnProperty, DI = Object.prototype.propertyIsEnumerable, Vn = (t, e, i) => e in t ? _I(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Vc = (t, e) => {
  for (var i in e || (e = {}))
    II.call(e, i) && Vn(t, i, e[i]);
  if (zc)
    for (var i of zc(e))
      DI.call(e, i) && Vn(t, i, e[i]);
  return t;
}, oe = (t, e, i) => Vn(t, typeof e != "symbol" ? e + "" : e, i);
class mo extends Pp {
  constructor(e) {
    var i;
    super(e), oe(this, "protocol", th), oe(this, "version", ih), oe(this, "name", rs), oe(this, "relayUrl"), oe(this, "projectId"), oe(this, "customStoragePrefix"), oe(this, "events", new Ge.EventEmitter()), oe(this, "logger"), oe(this, "heartbeat"), oe(this, "relayer"), oe(this, "crypto"), oe(this, "storage"), oe(this, "history"), oe(this, "expirer"), oe(this, "pairing"), oe(this, "verify"), oe(this, "echoClient"), oe(this, "linkModeSupportedApps"), oe(this, "eventClient"), oe(this, "initialized", !1), oe(this, "logChunkController"), oe(this, "on", (a, c) => this.events.on(a, c)), oe(this, "once", (a, c) => this.events.once(a, c)), oe(this, "off", (a, c) => this.events.off(a, c)), oe(this, "removeListener", (a, c) => this.events.removeListener(a, c)), oe(this, "dispatchEnvelope", ({ topic: a, message: c, sessionExists: u }) => {
      if (!a || !c)
        return;
      const l = { topic: a, message: c, publishedAt: Date.now(), transportType: ce.link_mode };
      this.relayer.onLinkMessageEvent(l, { sessionExists: u });
    });
    const r = this.getGlobalCore(e?.customStoragePrefix);
    if (r)
      try {
        return this.customStoragePrefix = r.customStoragePrefix, this.logger = r.logger, this.heartbeat = r.heartbeat, this.crypto = r.crypto, this.history = r.history, this.expirer = r.expirer, this.storage = r.storage, this.relayer = r.relayer, this.pairing = r.pairing, this.verify = r.verify, this.echoClient = r.echoClient, this.linkModeSupportedApps = r.linkModeSupportedApps, this.eventClient = r.eventClient, this.initialized = r.initialized, this.logChunkController = r.logChunkController, r;
      } catch (a) {
        console.warn("Failed to copy global core", a);
      }
    this.projectId = e?.projectId, this.relayUrl = e?.relayUrl || sh, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s = Gn({ level: typeof e?.logger == "string" && e.logger ? e.logger : Vv.logger, name: rs }), { logger: n, chunkLoggerController: o } = Op({ opts: s, maxSizeInBytes: e?.maxLogBlobSizeInBytes, loggerOverride: e?.logger });
    this.logChunkController = o, (i = this.logChunkController) != null && i.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var a, c;
      (a = this.logChunkController) != null && a.downloadLogsBlobInBrowser && ((c = this.logChunkController) == null || c.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = Fe(n, this.name), this.heartbeat = new wd(), this.crypto = new Q_(this, this.logger, e?.keychain), this.history = new cI(this, this.logger), this.expirer = new hI(this, this.logger), this.storage = e != null && e.storage ? e.storage : new Xd(Vc(Vc({}, Kv), e?.storageOptions)), this.relayer = new S2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new nI(this, this.logger), this.verify = new fI(this, this.logger, this.storage), this.echoClient = new wI(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new EI(this, this.logger, e?.telemetryEnabled), this.setGlobalCore(this);
  }
  static async init(e) {
    const i = new mo(e);
    await i.initialize();
    const r = await i.crypto.getClientId();
    return await i.storage.setItem(sE, r), i;
  }
  get context() {
    return je(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(Ic, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Ic) || [], this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
  getGlobalCore(e = "") {
    try {
      if (this.isGlobalCoreDisabled())
        return;
      const i = `_walletConnectCore_${e}`, r = `${i}_count`;
      return globalThis[r] = (globalThis[r] || 0) + 1, globalThis[r] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[r]} times.`), globalThis[i];
    } catch (i) {
      console.warn("Failed to get global WalletConnect core", i);
      return;
    }
  }
  setGlobalCore(e) {
    var i;
    try {
      if (this.isGlobalCoreDisabled())
        return;
      const r = `_walletConnectCore_${((i = e.opts) == null ? void 0 : i.customStoragePrefix) || ""}`;
      globalThis[r] = e;
    } catch (r) {
      console.warn("Failed to set global WalletConnect core", r);
    }
  }
  isGlobalCoreDisabled() {
    try {
      return typeof process < "u" && process.env.DISABLE_GLOBAL_CORE === "true";
    } catch {
      return !0;
    }
  }
}
const SI = mo, yh = "wc", wh = 2, mh = "client", bo = `${yh}@${wh}:${mh}:`, on = { name: mh, logger: "error", controller: !1, relayUrl: "wss://relay.walletconnect.org" }, Kc = "WALLETCONNECT_DEEPLINK_CHOICE", $I = "proposal", Hc = "Proposal expired", OI = "session", bi = T.SEVEN_DAYS, xI = "engine", ye = { wc_sessionPropose: { req: { ttl: T.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: T.FIVE_MINUTES, prompt: !1, tag: 1101 }, reject: { ttl: T.FIVE_MINUTES, prompt: !1, tag: 1120 }, autoReject: { ttl: T.FIVE_MINUTES, prompt: !1, tag: 1121 } }, wc_sessionSettle: { req: { ttl: T.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: T.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: T.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: T.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: T.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: T.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: T.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: T.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: T.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: T.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: T.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: T.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: T.ONE_DAY, prompt: !1, tag: 1114 }, res: { ttl: T.ONE_DAY, prompt: !1, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: T.ONE_HOUR, prompt: !0, tag: 1116 }, res: { ttl: T.ONE_HOUR, prompt: !1, tag: 1117 }, reject: { ttl: T.FIVE_MINUTES, prompt: !1, tag: 1118 }, autoReject: { ttl: T.FIVE_MINUTES, prompt: !1, tag: 1119 } } }, an = { min: T.FIVE_MINUTES, max: T.SEVEN_DAYS }, lt = { idle: "IDLE", active: "ACTIVE" }, Wc = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" } }, AI = "request", PI = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"], CI = "wc", RI = "auth", TI = "authKeys", NI = "pairingTopics", FI = "requests", _s = `${CI}@${1.5}:${RI}:`, Hr = `${_s}:PUB_KEY`;
var LI = Object.defineProperty, BI = Object.defineProperties, UI = Object.getOwnPropertyDescriptors, Gc = Object.getOwnPropertySymbols, kI = Object.prototype.hasOwnProperty, MI = Object.prototype.propertyIsEnumerable, Kn = (t, e, i) => e in t ? LI(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, re = (t, e) => {
  for (var i in e || (e = {}))
    kI.call(e, i) && Kn(t, i, e[i]);
  if (Gc)
    for (var i of Gc(e))
      MI.call(e, i) && Kn(t, i, e[i]);
  return t;
}, Te = (t, e) => BI(t, UI(e)), R = (t, e, i) => Kn(t, typeof e != "symbol" ? e + "" : e, i);
class qI extends Wp {
  constructor(e) {
    super(e), R(this, "name", xI), R(this, "events", new ou()), R(this, "initialized", !1), R(this, "requestQueue", { state: lt.idle, queue: [] }), R(this, "sessionRequestQueue", { state: lt.idle, queue: [] }), R(this, "requestQueueDelay", T.ONE_SECOND), R(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), R(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), R(this, "recentlyDeletedLimit", 200), R(this, "relayMessageCache", []), R(this, "pendingSessions", /* @__PURE__ */ new Map()), R(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(ye) }), this.initialized = !0, setTimeout(async () => {
        await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, T.toMiliseconds(this.requestQueueDelay)));
    }), R(this, "connect", async (i) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const r = Te(re({}, i), { requiredNamespaces: i.requiredNamespaces || {}, optionalNamespaces: i.optionalNamespaces || {} });
      await this.isValidConnect(r);
      const { pairingTopic: s, requiredNamespaces: n, optionalNamespaces: o, sessionProperties: a, scopedProperties: c, relays: u } = r;
      let l = s, h, d = !1;
      try {
        if (l) {
          const S = this.client.core.pairing.pairings.get(l);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), d = S.active;
        }
      } catch (S) {
        throw this.client.logger.error(`connect() -> pairing.get(${l}) failed`), S;
      }
      if (!l || !d) {
        const { topic: S, uri: $ } = await this.client.core.pairing.create();
        l = S, h = $;
      }
      if (!l) {
        const { message: S } = F("NO_MATCHING_KEY", `connect() pairing topic: ${l}`);
        throw new Error(S);
      }
      const f = await this.client.core.crypto.generateKeyPair(), p = ye.wc_sessionPropose.req.ttl || T.FIVE_MINUTES, g = pe(p), y = Te(re(re({ requiredNamespaces: n, optionalNamespaces: o, relays: u ?? [{ protocol: rh }], proposer: { publicKey: f, metadata: this.client.metadata }, expiryTimestamp: g, pairingTopic: l }, a && { sessionProperties: a }), c && { scopedProperties: c }), { id: dt() }), m = X("session_connect", y.id), { reject: w, resolve: b, done: E } = Ht(p, Hc), O = ({ id: S }) => {
        S === y.id && (this.client.events.off("proposal_expire", O), this.pendingSessions.delete(y.id), this.events.emit(m, { error: { message: Hc, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", O), this.events.once(m, ({ error: S, session: $ }) => {
        this.client.events.off("proposal_expire", O), S ? w(S) : $ && b($);
      }), await this.sendRequest({ topic: l, method: "wc_sessionPropose", params: y, throwOnFailedPublish: !0, clientRpcId: y.id }), await this.setProposal(y.id, y), { uri: h, approval: E };
    }), R(this, "pair", async (i) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(i);
      } catch (r) {
        throw this.client.logger.error("pair() failed"), r;
      }
    }), R(this, "approve", async (i) => {
      var r, s, n;
      const o = this.client.core.eventClient.createEvent({ properties: { topic: (r = i?.id) == null ? void 0 : r.toString(), trace: [it.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (I) {
        throw o.setError(jt.no_internet_connection), I;
      }
      try {
        await this.isValidProposalId(i?.id);
      } catch (I) {
        throw this.client.logger.error(`approve() -> proposal.get(${i?.id}) failed`), o.setError(jt.proposal_not_found), I;
      }
      try {
        await this.isValidApprove(i);
      } catch (I) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), o.setError(jt.session_approve_namespace_validation_failure), I;
      }
      const { id: a, relayProtocol: c, namespaces: u, sessionProperties: l, scopedProperties: h, sessionConfig: d } = i, f = this.client.proposal.get(a);
      this.client.core.eventClient.deleteEvent({ eventId: o.eventId });
      const { pairingTopic: p, proposer: g, requiredNamespaces: y, optionalNamespaces: m } = f;
      let w = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({ topic: p });
      w || (w = (n = this.client.core.eventClient) == null ? void 0 : n.createEvent({ type: it.session_approve_started, properties: { topic: p, trace: [it.session_approve_started, it.session_namespaces_validation_success] } }));
      const b = await this.client.core.crypto.generateKeyPair(), E = g.publicKey, O = await this.client.core.crypto.generateSharedKey(b, E), S = re(re(re({ relay: { protocol: c ?? "irn" }, namespaces: u, controller: { publicKey: b, metadata: this.client.metadata }, expiry: pe(bi) }, l && { sessionProperties: l }), h && { scopedProperties: h }), d && { sessionConfig: d }), $ = ce.relay;
      w.addTrace(it.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(O, { transportType: $ });
      } catch (I) {
        throw w.setError(jt.subscribe_session_topic_failure), I;
      }
      w.addTrace(it.subscribe_session_topic_success);
      const A = Te(re({}, S), { topic: O, requiredNamespaces: y, optionalNamespaces: m, pairingTopic: p, acknowledged: !1, self: S.controller, peer: { publicKey: g.publicKey, metadata: g.metadata }, controller: b, transportType: ce.relay });
      await this.client.session.set(O, A), w.addTrace(it.store_session);
      try {
        w.addTrace(it.publishing_session_settle), await this.sendRequest({ topic: O, method: "wc_sessionSettle", params: S, throwOnFailedPublish: !0 }).catch((I) => {
          throw w?.setError(jt.session_settle_publish_failure), I;
        }), w.addTrace(it.session_settle_publish_success), w.addTrace(it.publishing_session_approve), await this.sendResult({ id: a, topic: p, result: { relay: { protocol: c ?? "irn" }, responderPublicKey: b }, throwOnFailedPublish: !0 }).catch((I) => {
          throw w?.setError(jt.session_approve_publish_failure), I;
        }), w.addTrace(it.session_approve_publish_success);
      } catch (I) {
        throw this.client.logger.error(I), this.client.session.delete(O, se("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(O), I;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: w.eventId }), await this.client.core.pairing.updateMetadata({ topic: p, metadata: g.metadata }), await this.client.proposal.delete(a, se("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: p }), await this.setExpiry(O, pe(bi)), { topic: O, acknowledged: () => Promise.resolve(this.client.session.get(O)) };
    }), R(this, "reject", async (i) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(i);
      } catch (o) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), o;
      }
      const { id: r, reason: s } = i;
      let n;
      try {
        n = this.client.proposal.get(r).pairingTopic;
      } catch (o) {
        throw this.client.logger.error(`reject() -> proposal.get(${r}) failed`), o;
      }
      n && (await this.sendError({ id: r, topic: n, error: s, rpcOpts: ye.wc_sessionPropose.reject }), await this.client.proposal.delete(r, se("USER_DISCONNECTED")));
    }), R(this, "update", async (i) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(i);
      } catch (h) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), h;
      }
      const { topic: r, namespaces: s } = i, { done: n, resolve: o, reject: a } = Ht(), c = dt(), u = Zt().toString(), l = this.client.session.get(r).namespaces;
      return this.events.once(X("session_update", c), ({ error: h }) => {
        h ? a(h) : o();
      }), await this.client.session.update(r, { namespaces: s }), await this.sendRequest({ topic: r, method: "wc_sessionUpdate", params: { namespaces: s }, throwOnFailedPublish: !0, clientRpcId: c, relayRpcId: u }).catch((h) => {
        this.client.logger.error(h), this.client.session.update(r, { namespaces: l }), a(h);
      }), { acknowledged: n };
    }), R(this, "extend", async (i) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(i);
      } catch (c) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), c;
      }
      const { topic: r } = i, s = dt(), { done: n, resolve: o, reject: a } = Ht();
      return this.events.once(X("session_extend", s), ({ error: c }) => {
        c ? a(c) : o();
      }), await this.setExpiry(r, pe(bi)), this.sendRequest({ topic: r, method: "wc_sessionExtend", params: {}, clientRpcId: s, throwOnFailedPublish: !0 }).catch((c) => {
        a(c);
      }), { acknowledged: n };
    }), R(this, "request", async (i) => {
      this.isInitialized();
      try {
        await this.isValidRequest(i);
      } catch (m) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), m;
      }
      const { chainId: r, request: s, topic: n, expiry: o = ye.wc_sessionRequest.req.ttl } = i, a = this.client.session.get(n);
      a?.transportType === ce.relay && await this.confirmOnlineStateOrThrow();
      const c = dt(), u = Zt().toString(), { done: l, resolve: h, reject: d } = Ht(o, "Request expired. Please try again.");
      this.events.once(X("session_request", c), ({ error: m, result: w }) => {
        m ? d(m) : h(w);
      });
      const f = "wc_sessionRequest", p = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType);
      if (p)
        return await this.sendRequest({ clientRpcId: c, relayRpcId: u, topic: n, method: f, params: { request: Te(re({}, s), { expiryTimestamp: pe(o) }), chainId: r }, expiry: o, throwOnFailedPublish: !0, appLink: p }).catch((m) => d(m)), this.client.events.emit("session_request_sent", { topic: n, request: s, chainId: r, id: c }), await l();
      const g = { request: Te(re({}, s), { expiryTimestamp: pe(o) }), chainId: r }, y = this.shouldSetTVF(f, g);
      return await Promise.all([new Promise(async (m) => {
        await this.sendRequest(re({ clientRpcId: c, relayRpcId: u, topic: n, method: f, params: g, expiry: o, throwOnFailedPublish: !0 }, y && { tvf: this.getTVFParams(c, g) })).catch((w) => d(w)), this.client.events.emit("session_request_sent", { topic: n, request: s, chainId: r, id: c }), m();
      }), new Promise(async (m) => {
        var w;
        if (!((w = a.sessionConfig) != null && w.disableDeepLink)) {
          const b = await hb(this.client.core.storage, Kc);
          await cb({ id: c, topic: n, wcDeepLink: b });
        }
        m();
      }), l()]).then((m) => m[2]);
    }), R(this, "respond", async (i) => {
      this.isInitialized(), await this.isValidRespond(i);
      const { topic: r, response: s } = i, { id: n } = s, o = this.client.session.get(r);
      o.transportType === ce.relay && await this.confirmOnlineStateOrThrow();
      const a = this.getAppLinkIfEnabled(o.peer.metadata, o.transportType);
      pt(s) ? await this.sendResult({ id: n, topic: r, result: s.result, throwOnFailedPublish: !0, appLink: a }) : Qe(s) && await this.sendError({ id: n, topic: r, error: s.error, appLink: a }), this.cleanupAfterResponse(i);
    }), R(this, "ping", async (i) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(i);
      } catch (s) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s;
      }
      const { topic: r } = i;
      if (this.client.session.keys.includes(r)) {
        const s = dt(), n = Zt().toString(), { done: o, resolve: a, reject: c } = Ht();
        this.events.once(X("session_ping", s), ({ error: u }) => {
          u ? c(u) : a();
        }), await Promise.all([this.sendRequest({ topic: r, method: "wc_sessionPing", params: {}, throwOnFailedPublish: !0, clientRpcId: s, relayRpcId: n }), o()]);
      } else
        this.client.core.pairing.pairings.keys.includes(r) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: r }));
    }), R(this, "emit", async (i) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(i);
      const { topic: r, event: s, chainId: n } = i, o = Zt().toString(), a = dt();
      await this.sendRequest({ topic: r, method: "wc_sessionEvent", params: { event: s, chainId: n }, throwOnFailedPublish: !0, relayRpcId: o, clientRpcId: a });
    }), R(this, "disconnect", async (i) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(i);
      const { topic: r } = i;
      if (this.client.session.keys.includes(r))
        await this.sendRequest({ topic: r, method: "wc_sessionDelete", params: se("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession({ topic: r, emitEvent: !1 });
      else if (this.client.core.pairing.pairings.keys.includes(r))
        await this.client.core.pairing.disconnect({ topic: r });
      else {
        const { message: s } = F("MISMATCHED_TOPIC", `Session or pairing topic not found: ${r}`);
        throw new Error(s);
      }
    }), R(this, "find", (i) => (this.isInitialized(), this.client.session.getAll().filter((r) => W0(r, i)))), R(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), R(this, "authenticate", async (i, r) => {
      var s;
      this.isInitialized(), this.isValidAuthenticate(i);
      const n = r && this.client.core.linkModeSupportedApps.includes(r) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode), o = n ? ce.link_mode : ce.relay;
      o === ce.relay && await this.confirmOnlineStateOrThrow();
      const { chains: a, statement: c = "", uri: u, domain: l, nonce: h, type: d, exp: f, nbf: p, methods: g = [], expiry: y } = i, m = [...i.resources || []], { topic: w, uri: b } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: o });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: w, uri: b } });
      const E = await this.client.core.crypto.generateKeyPair(), O = Vr(E);
      if (await Promise.all([this.client.auth.authKeys.set(Hr, { responseTopic: O, publicKey: E }), this.client.auth.pairingTopics.set(O, { topic: O, pairingTopic: w })]), await this.client.core.relayer.subscribe(O, { transportType: o }), this.client.logger.info(`sending request to new pairing topic: ${w}`), g.length > 0) {
        const { namespace: D } = jr(a[0]);
        let N = r1(D, "request", g);
        zr(m) && (N = n1(N, m.pop())), m.push(N);
      }
      const S = y && y > ye.wc_sessionAuthenticate.req.ttl ? y : ye.wc_sessionAuthenticate.req.ttl, $ = { authPayload: { type: d ?? "caip122", chains: a, statement: c, aud: u, domain: l, version: "1", nonce: h, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: f, nbf: p, resources: m }, requester: { publicKey: E, metadata: this.client.metadata }, expiryTimestamp: pe(S) }, A = { eip155: { chains: a, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...g])], events: ["chainChanged", "accountsChanged"] } }, I = { requiredNamespaces: {}, optionalNamespaces: A, relays: [{ protocol: "irn" }], pairingTopic: w, proposer: { publicKey: E, metadata: this.client.metadata }, expiryTimestamp: pe(ye.wc_sessionPropose.req.ttl), id: dt() }, { done: M, resolve: L, reject: U } = Ht(S, "Request expired"), q = dt(), C = X("session_connect", I.id), _ = X("session_request", q), v = async ({ error: D, session: N }) => {
        this.events.off(_, x), D ? U(D) : N && L({ session: N });
      }, x = async (D) => {
        var N, B, k;
        if (await this.deletePendingAuthRequest(q, { message: "fulfilled", code: 0 }), D.error) {
          const J = se("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return D.error.code === J.code ? void 0 : (this.events.off(C, v), U(D.error.message));
        }
        await this.deleteProposal(I.id), this.events.off(C, v);
        const { cacaos: j, responder: z } = D.result, H = [], Y = [];
        for (const J of j) {
          await ka({ cacao: J, projectId: this.client.core.projectId }) || (this.client.logger.error(J, "Signature verification failed"), U(se("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: Pe } = J, _e = zr(Pe.resources), Re = [Sn(Pe.iss)], Ye = Xr(Pe.iss);
          if (_e) {
            const mt = Ma(_e), ui = qa(_e);
            H.push(...mt), Re.push(...ui);
          }
          for (const mt of Re)
            Y.push(`${mt}:${Ye}`);
        }
        const ne = await this.client.core.crypto.generateSharedKey(E, z.publicKey);
        let ee;
        H.length > 0 && (ee = { topic: ne, acknowledged: !0, self: { publicKey: E, metadata: this.client.metadata }, peer: z, controller: z.publicKey, expiry: pe(bi), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: w, namespaces: uc([...new Set(H)], [...new Set(Y)]), transportType: o }, await this.client.core.relayer.subscribe(ne, { transportType: o }), await this.client.session.set(ne, ee), w && await this.client.core.pairing.updateMetadata({ topic: w, metadata: z.metadata }), ee = this.client.session.get(ne)), (N = this.client.metadata.redirect) != null && N.linkMode && (B = z.metadata.redirect) != null && B.linkMode && (k = z.metadata.redirect) != null && k.universal && r && (this.client.core.addLinkModeSupportedApp(z.metadata.redirect.universal), this.client.session.update(ne, { transportType: ce.link_mode })), L({ auths: j, session: ee });
      };
      this.events.once(C, v), this.events.once(_, x);
      let P;
      try {
        if (n) {
          const D = Qt("wc_sessionAuthenticate", $, q);
          this.client.core.history.set(w, D);
          const N = await this.client.core.crypto.encode("", D, { type: Ir, encoding: Ft });
          P = Lr(r, w, N);
        } else
          await Promise.all([this.sendRequest({ topic: w, method: "wc_sessionAuthenticate", params: $, expiry: i.expiry, throwOnFailedPublish: !0, clientRpcId: q }), this.sendRequest({ topic: w, method: "wc_sessionPropose", params: I, expiry: ye.wc_sessionPropose.req.ttl, throwOnFailedPublish: !0, clientRpcId: I.id })]);
      } catch (D) {
        throw this.events.off(C, v), this.events.off(_, x), D;
      }
      return await this.setProposal(I.id, I), await this.setAuthRequest(q, { request: Te(re({}, $), { verifyContext: {} }), pairingTopic: w, transportType: o }), { uri: P ?? b, response: M };
    }), R(this, "approveSessionAuthenticate", async (i) => {
      const { id: r, auths: s } = i, n = this.client.core.eventClient.createEvent({ properties: { topic: r.toString(), trace: [zt.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (y) {
        throw n.setError(Hi.no_internet_connection), y;
      }
      const o = this.getPendingAuthRequest(r);
      if (!o)
        throw n.setError(Hi.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${r}`);
      const a = o.transportType || ce.relay;
      a === ce.relay && await this.confirmOnlineStateOrThrow();
      const c = o.requester.publicKey, u = await this.client.core.crypto.generateKeyPair(), l = Vr(c), h = { type: At, receiverPublicKey: c, senderPublicKey: u }, d = [], f = [];
      for (const y of s) {
        if (!await ka({ cacao: y, projectId: this.client.core.projectId })) {
          n.setError(Hi.invalid_cacao);
          const O = se("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: r, topic: l, error: O, encodeOpts: h }), new Error(O.message);
        }
        n.addTrace(zt.cacaos_verified);
        const { p: m } = y, w = zr(m.resources), b = [Sn(m.iss)], E = Xr(m.iss);
        if (w) {
          const O = Ma(w), S = qa(w);
          d.push(...O), b.push(...S);
        }
        for (const O of b)
          f.push(`${O}:${E}`);
      }
      const p = await this.client.core.crypto.generateSharedKey(u, c);
      n.addTrace(zt.create_authenticated_session_topic);
      let g;
      if (d?.length > 0) {
        g = { topic: p, acknowledged: !0, self: { publicKey: u, metadata: this.client.metadata }, peer: { publicKey: c, metadata: o.requester.metadata }, controller: c, expiry: pe(bi), authentication: s, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: o.pairingTopic, namespaces: uc([...new Set(d)], [...new Set(f)]), transportType: a }, n.addTrace(zt.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(p, { transportType: a });
        } catch (y) {
          throw n.setError(Hi.subscribe_authenticated_session_topic_failure), y;
        }
        n.addTrace(zt.subscribe_authenticated_session_topic_success), await this.client.session.set(p, g), n.addTrace(zt.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: o.pairingTopic, metadata: o.requester.metadata });
      }
      n.addTrace(zt.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: l, id: r, result: { cacaos: s, responder: { publicKey: u, metadata: this.client.metadata } }, encodeOpts: h, throwOnFailedPublish: !0, appLink: this.getAppLinkIfEnabled(o.requester.metadata, a) });
      } catch (y) {
        throw n.setError(Hi.authenticated_session_approve_publish_failure), y;
      }
      return await this.client.auth.requests.delete(r, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: o.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: n.eventId }), { session: g };
    }), R(this, "rejectSessionAuthenticate", async (i) => {
      this.isInitialized();
      const { id: r, reason: s } = i, n = this.getPendingAuthRequest(r);
      if (!n)
        throw new Error(`Could not find pending auth request with id ${r}`);
      n.transportType === ce.relay && await this.confirmOnlineStateOrThrow();
      const o = n.requester.publicKey, a = await this.client.core.crypto.generateKeyPair(), c = Vr(o), u = { type: At, receiverPublicKey: o, senderPublicKey: a };
      await this.sendError({ id: r, topic: c, error: s, encodeOpts: u, rpcOpts: ye.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(n.requester.metadata, n.transportType) }), await this.client.auth.requests.delete(r, { message: "rejected", code: 0 }), await this.client.proposal.delete(r, se("USER_DISCONNECTED"));
    }), R(this, "formatAuthMessage", (i) => {
      this.isInitialized();
      const { request: r, iss: s } = i;
      return _l(r, s);
    }), R(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0)
          for (; this.relayMessageCache.length > 0; )
            try {
              const i = this.relayMessageCache.shift();
              i && await this.onRelayMessage(i);
            } catch (i) {
              this.client.logger.error(i);
            }
      }, 50);
    }), R(this, "cleanupDuplicatePairings", async (i) => {
      if (i.pairingTopic)
        try {
          const r = this.client.core.pairing.pairings.get(i.pairingTopic), s = this.client.core.pairing.pairings.getAll().filter((n) => {
            var o, a;
            return ((o = n.peerMetadata) == null ? void 0 : o.url) && ((a = n.peerMetadata) == null ? void 0 : a.url) === i.peer.metadata.url && n.topic && n.topic !== r.topic;
          });
          if (s.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map((n) => this.client.core.pairing.disconnect({ topic: n.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (r) {
          this.client.logger.error(r);
        }
    }), R(this, "deleteSession", async (i) => {
      var r;
      const { topic: s, expirerHasDeleted: n = !1, emitEvent: o = !0, id: a = 0 } = i, { self: c } = this.client.session.get(s);
      await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, se("USER_DISCONNECTED")), this.addToRecentlyDeleted(s, "session"), this.client.core.crypto.keychain.has(c.publicKey) && await this.client.core.crypto.deleteKeyPair(c.publicKey), this.client.core.crypto.keychain.has(s) && await this.client.core.crypto.deleteSymKey(s), n || this.client.core.expirer.del(s), this.client.core.storage.removeItem(Kc).catch((u) => this.client.logger.warn(u)), this.getPendingSessionRequests().forEach((u) => {
        u.topic === s && this.deletePendingSessionRequest(u.id, se("USER_DISCONNECTED"));
      }), s === ((r = this.sessionRequestQueue.queue[0]) == null ? void 0 : r.topic) && (this.sessionRequestQueue.state = lt.idle), o && this.client.events.emit("session_delete", { id: a, topic: s });
    }), R(this, "deleteProposal", async (i, r) => {
      if (r)
        try {
          const s = this.client.proposal.get(i);
          this.client.core.eventClient.getEvent({ topic: s.pairingTopic })?.setError(jt.proposal_expired);
        } catch {
        }
      await Promise.all([this.client.proposal.delete(i, se("USER_DISCONNECTED")), r ? Promise.resolve() : this.client.core.expirer.del(i)]), this.addToRecentlyDeleted(i, "proposal");
    }), R(this, "deletePendingSessionRequest", async (i, r, s = !1) => {
      await Promise.all([this.client.pendingRequest.delete(i, r), s ? Promise.resolve() : this.client.core.expirer.del(i)]), this.addToRecentlyDeleted(i, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((n) => n.id !== i), s && (this.sessionRequestQueue.state = lt.idle, this.client.events.emit("session_request_expire", { id: i }));
    }), R(this, "deletePendingAuthRequest", async (i, r, s = !1) => {
      await Promise.all([this.client.auth.requests.delete(i, r), s ? Promise.resolve() : this.client.core.expirer.del(i)]);
    }), R(this, "setExpiry", async (i, r) => {
      this.client.session.keys.includes(i) && (this.client.core.expirer.set(i, r), await this.client.session.update(i, { expiry: r }));
    }), R(this, "setProposal", async (i, r) => {
      this.client.core.expirer.set(i, pe(ye.wc_sessionPropose.req.ttl)), await this.client.proposal.set(i, r);
    }), R(this, "setAuthRequest", async (i, r) => {
      const { request: s, pairingTopic: n, transportType: o = ce.relay } = r;
      this.client.core.expirer.set(i, s.expiryTimestamp), await this.client.auth.requests.set(i, { authPayload: s.authPayload, requester: s.requester, expiryTimestamp: s.expiryTimestamp, id: i, pairingTopic: n, verifyContext: s.verifyContext, transportType: o });
    }), R(this, "setPendingSessionRequest", async (i) => {
      const { id: r, topic: s, params: n, verifyContext: o } = i, a = n.request.expiryTimestamp || pe(ye.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(r, a), await this.client.pendingRequest.set(r, { id: r, topic: s, params: n, verifyContext: o });
    }), R(this, "sendRequest", async (i) => {
      const { topic: r, method: s, params: n, expiry: o, relayRpcId: a, clientRpcId: c, throwOnFailedPublish: u, appLink: l, tvf: h } = i, d = Qt(s, n, c);
      let f;
      const p = !!l;
      try {
        const m = p ? Ft : ot;
        f = await this.client.core.crypto.encode(r, d, { encoding: m });
      } catch (m) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${r} failed`), m;
      }
      let g;
      if (PI.includes(s)) {
        const m = gt(JSON.stringify(d)), w = gt(f);
        g = await this.client.core.verify.register({ id: w, decryptedId: m });
      }
      const y = ye[s].req;
      if (y.attestation = g, o && (y.ttl = o), a && (y.id = a), this.client.core.history.set(r, d), p) {
        const m = Lr(l, r, f);
        await global.Linking.openURL(m, this.client.name);
      } else {
        const m = ye[s].req;
        o && (m.ttl = o), a && (m.id = a), m.tvf = Te(re({}, h), { correlationId: d.id }), u ? (m.internal = Te(re({}, m.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(r, f, m)) : this.client.core.relayer.publish(r, f, m).catch((w) => this.client.logger.error(w));
      }
      return d.id;
    }), R(this, "sendResult", async (i) => {
      const { id: r, topic: s, result: n, throwOnFailedPublish: o, encodeOpts: a, appLink: c } = i, u = ms(r, n);
      let l;
      const h = c && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const p = h ? Ft : ot;
        l = await this.client.core.crypto.encode(s, u, Te(re({}, a || {}), { encoding: p }));
      } catch (p) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), p;
      }
      let d, f;
      try {
        d = await this.client.core.history.get(s, r);
        const p = d.request;
        try {
          this.shouldSetTVF(p.method, p.params) && (f = this.getTVFParams(r, p.params, n));
        } catch (g) {
          this.client.logger.warn("sendResult() -> getTVFParams() failed", g);
        }
      } catch (p) {
        throw this.client.logger.error(`sendResult() -> history.get(${s}, ${r}) failed`), p;
      }
      if (h) {
        const p = Lr(c, s, l);
        await global.Linking.openURL(p, this.client.name);
      } else {
        const p = d.request.method, g = ye[p].res;
        g.tvf = Te(re({}, f), { correlationId: r }), o ? (g.internal = Te(re({}, g.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(s, l, g)) : this.client.core.relayer.publish(s, l, g).catch((y) => this.client.logger.error(y));
      }
      await this.client.core.history.resolve(u);
    }), R(this, "sendError", async (i) => {
      const { id: r, topic: s, error: n, encodeOpts: o, rpcOpts: a, appLink: c } = i, u = bs(r, n);
      let l;
      const h = c && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const f = h ? Ft : ot;
        l = await this.client.core.crypto.encode(s, u, Te(re({}, o || {}), { encoding: f }));
      } catch (f) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), f;
      }
      let d;
      try {
        d = await this.client.core.history.get(s, r);
      } catch (f) {
        throw this.client.logger.error(`sendError() -> history.get(${s}, ${r}) failed`), f;
      }
      if (h) {
        const f = Lr(c, s, l);
        await global.Linking.openURL(f, this.client.name);
      } else {
        const f = d.request.method, p = a || ye[f].res;
        this.client.core.relayer.publish(s, l, p);
      }
      await this.client.core.history.resolve(u);
    }), R(this, "cleanup", async () => {
      const i = [], r = [];
      this.client.session.getAll().forEach((s) => {
        let n = !1;
        Nt(s.expiry) && (n = !0), this.client.core.crypto.keychain.has(s.topic) || (n = !0), n && i.push(s.topic);
      }), this.client.proposal.getAll().forEach((s) => {
        Nt(s.expiryTimestamp) && r.push(s.id);
      }), await Promise.all([...i.map((s) => this.deleteSession({ topic: s })), ...r.map((s) => this.deleteProposal(s))]);
    }), R(this, "onProviderMessageEvent", async (i) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(i) : await this.onRelayMessage(i);
    }), R(this, "onRelayEventRequest", async (i) => {
      this.requestQueue.queue.push(i), await this.processRequestsQueue();
    }), R(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === lt.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = lt.active;
        const i = this.requestQueue.queue.shift();
        if (i)
          try {
            await this.processRequest(i);
          } catch (r) {
            this.client.logger.warn(r);
          }
      }
      this.requestQueue.state = lt.idle;
    }), R(this, "processRequest", async (i) => {
      const { topic: r, payload: s, attestation: n, transportType: o, encryptedId: a } = i, c = s.method;
      if (!this.shouldIgnorePairingRequest({ topic: r, requestMethod: c }))
        switch (c) {
          case "wc_sessionPropose":
            return await this.onSessionProposeRequest({ topic: r, payload: s, attestation: n, encryptedId: a });
          case "wc_sessionSettle":
            return await this.onSessionSettleRequest(r, s);
          case "wc_sessionUpdate":
            return await this.onSessionUpdateRequest(r, s);
          case "wc_sessionExtend":
            return await this.onSessionExtendRequest(r, s);
          case "wc_sessionPing":
            return await this.onSessionPingRequest(r, s);
          case "wc_sessionDelete":
            return await this.onSessionDeleteRequest(r, s);
          case "wc_sessionRequest":
            return await this.onSessionRequest({ topic: r, payload: s, attestation: n, encryptedId: a, transportType: o });
          case "wc_sessionEvent":
            return await this.onSessionEventRequest(r, s);
          case "wc_sessionAuthenticate":
            return await this.onSessionAuthenticateRequest({ topic: r, payload: s, attestation: n, encryptedId: a, transportType: o });
          default:
            return this.client.logger.info(`Unsupported request method ${c}`);
        }
    }), R(this, "onRelayEventResponse", async (i) => {
      const { topic: r, payload: s, transportType: n } = i, o = (await this.client.core.history.get(r, s.id)).request.method;
      switch (o) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(r, s, n);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(r, s);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(r, s);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(r, s);
        case "wc_sessionPing":
          return this.onSessionPingResponse(r, s);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(r, s);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(r, s);
        default:
          return this.client.logger.info(`Unsupported response method ${o}`);
      }
    }), R(this, "onRelayEventUnknownPayload", (i) => {
      const { topic: r } = i, { message: s } = F("MISSING_OR_INVALID", `Decoded payload on topic ${r} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s);
    }), R(this, "shouldIgnorePairingRequest", (i) => {
      const { topic: r, requestMethod: s } = i, n = this.expectedPairingMethodMap.get(r);
      return !n || n.includes(s) ? !1 : !!(n.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), R(this, "onSessionProposeRequest", async (i) => {
      const { topic: r, payload: s, attestation: n, encryptedId: o } = i, { params: a, id: c } = s;
      try {
        const u = this.client.core.eventClient.getEvent({ topic: r });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), u?.setError(St.proposal_listener_not_found)), this.isValidConnect(re({}, s.params));
        const l = a.expiryTimestamp || pe(ye.wc_sessionPropose.req.ttl), h = re({ id: c, pairingTopic: r, expiryTimestamp: l }, a);
        await this.setProposal(c, h);
        const d = await this.getVerifyContext({ attestationId: n, hash: gt(JSON.stringify(s)), encryptedId: o, metadata: h.proposer.metadata });
        u?.addTrace(ht.emit_session_proposal), this.client.events.emit("session_proposal", { id: c, params: h, verifyContext: d });
      } catch (u) {
        await this.sendError({ id: c, topic: r, error: u, rpcOpts: ye.wc_sessionPropose.autoReject }), this.client.logger.error(u);
      }
    }), R(this, "onSessionProposeResponse", async (i, r, s) => {
      const { id: n } = r;
      if (pt(r)) {
        const { result: o } = r;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: o });
        const a = this.client.proposal.get(n);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: a });
        const c = a.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: c });
        const u = o.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: u });
        const l = await this.client.core.crypto.generateSharedKey(c, u);
        this.pendingSessions.set(n, { sessionTopic: l, pairingTopic: i, proposalId: n, publicKey: c });
        const h = await this.client.core.relayer.subscribe(l, { transportType: s });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h }), await this.client.core.pairing.activate({ topic: i });
      } else if (Qe(r)) {
        await this.client.proposal.delete(n, se("USER_DISCONNECTED"));
        const o = X("session_connect", n);
        if (this.events.listenerCount(o) === 0)
          throw new Error(`emitting ${o} without any listeners, 954`);
        this.events.emit(o, { error: r.error });
      }
    }), R(this, "onSessionSettleRequest", async (i, r) => {
      const { id: s, params: n } = r;
      try {
        this.isValidSessionSettleRequest(n);
        const { relay: o, controller: a, expiry: c, namespaces: u, sessionProperties: l, scopedProperties: h, sessionConfig: d } = r.params, f = [...this.pendingSessions.values()].find((y) => y.sessionTopic === i);
        if (!f)
          return this.client.logger.error(`Pending session not found for topic ${i}`);
        const p = this.client.proposal.get(f.proposalId), g = Te(re(re(re({ topic: i, relay: o, expiry: c, namespaces: u, acknowledged: !0, pairingTopic: f.pairingTopic, requiredNamespaces: p.requiredNamespaces, optionalNamespaces: p.optionalNamespaces, controller: a.publicKey, self: { publicKey: f.publicKey, metadata: this.client.metadata }, peer: { publicKey: a.publicKey, metadata: a.metadata } }, l && { sessionProperties: l }), h && { scopedProperties: h }), d && { sessionConfig: d }), { transportType: ce.relay });
        await this.client.session.set(g.topic, g), await this.setExpiry(g.topic, g.expiry), await this.client.core.pairing.updateMetadata({ topic: f.pairingTopic, metadata: g.peer.metadata }), this.client.events.emit("session_connect", { session: g }), this.events.emit(X("session_connect", f.proposalId), { session: g }), this.pendingSessions.delete(f.proposalId), this.deleteProposal(f.proposalId, !1), this.cleanupDuplicatePairings(g), await this.sendResult({ id: r.id, topic: i, result: !0, throwOnFailedPublish: !0 });
      } catch (o) {
        await this.sendError({ id: s, topic: i, error: o }), this.client.logger.error(o);
      }
    }), R(this, "onSessionSettleResponse", async (i, r) => {
      const { id: s } = r;
      pt(r) ? (await this.client.session.update(i, { acknowledged: !0 }), this.events.emit(X("session_approve", s), {})) : Qe(r) && (await this.client.session.delete(i, se("USER_DISCONNECTED")), this.events.emit(X("session_approve", s), { error: r.error }));
    }), R(this, "onSessionUpdateRequest", async (i, r) => {
      const { params: s, id: n } = r;
      try {
        const o = `${i}_session_update`, a = Vi.get(o);
        if (a && this.isRequestOutOfSync(a, n)) {
          this.client.logger.warn(`Discarding out of sync request - ${n}`), this.sendError({ id: n, topic: i, error: se("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(re({ topic: i }, s));
        try {
          Vi.set(o, n), await this.client.session.update(i, { namespaces: s.namespaces }), await this.sendResult({ id: n, topic: i, result: !0, throwOnFailedPublish: !0 });
        } catch (c) {
          throw Vi.delete(o), c;
        }
        this.client.events.emit("session_update", { id: n, topic: i, params: s });
      } catch (o) {
        await this.sendError({ id: n, topic: i, error: o }), this.client.logger.error(o);
      }
    }), R(this, "isRequestOutOfSync", (i, r) => r.toString().slice(0, -3) < i.toString().slice(0, -3)), R(this, "onSessionUpdateResponse", (i, r) => {
      const { id: s } = r, n = X("session_update", s);
      if (this.events.listenerCount(n) === 0)
        throw new Error(`emitting ${n} without any listeners`);
      pt(r) ? this.events.emit(X("session_update", s), {}) : Qe(r) && this.events.emit(X("session_update", s), { error: r.error });
    }), R(this, "onSessionExtendRequest", async (i, r) => {
      const { id: s } = r;
      try {
        this.isValidExtend({ topic: i }), await this.setExpiry(i, pe(bi)), await this.sendResult({ id: s, topic: i, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_extend", { id: s, topic: i });
      } catch (n) {
        await this.sendError({ id: s, topic: i, error: n }), this.client.logger.error(n);
      }
    }), R(this, "onSessionExtendResponse", (i, r) => {
      const { id: s } = r, n = X("session_extend", s);
      if (this.events.listenerCount(n) === 0)
        throw new Error(`emitting ${n} without any listeners`);
      pt(r) ? this.events.emit(X("session_extend", s), {}) : Qe(r) && this.events.emit(X("session_extend", s), { error: r.error });
    }), R(this, "onSessionPingRequest", async (i, r) => {
      const { id: s } = r;
      try {
        this.isValidPing({ topic: i }), await this.sendResult({ id: s, topic: i, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_ping", { id: s, topic: i });
      } catch (n) {
        await this.sendError({ id: s, topic: i, error: n }), this.client.logger.error(n);
      }
    }), R(this, "onSessionPingResponse", (i, r) => {
      const { id: s } = r, n = X("session_ping", s);
      setTimeout(() => {
        if (this.events.listenerCount(n) === 0)
          throw new Error(`emitting ${n} without any listeners 2176`);
        pt(r) ? this.events.emit(X("session_ping", s), {}) : Qe(r) && this.events.emit(X("session_ping", s), { error: r.error });
      }, 500);
    }), R(this, "onSessionDeleteRequest", async (i, r) => {
      const { id: s } = r;
      try {
        this.isValidDisconnect({ topic: i, reason: r.params }), Promise.all([new Promise((n) => {
          this.client.core.relayer.once(be.publish, async () => {
            n(await this.deleteSession({ topic: i, id: s }));
          });
        }), this.sendResult({ id: s, topic: i, result: !0, throwOnFailedPublish: !0 }), this.cleanupPendingSentRequestsForTopic({ topic: i, error: se("USER_DISCONNECTED") })]).catch((n) => this.client.logger.error(n));
      } catch (n) {
        this.client.logger.error(n);
      }
    }), R(this, "onSessionRequest", async (i) => {
      var r, s, n;
      const { topic: o, payload: a, attestation: c, encryptedId: u, transportType: l } = i, { id: h, params: d } = a;
      try {
        await this.isValidRequest(re({ topic: o }, d));
        const f = this.client.session.get(o), p = await this.getVerifyContext({ attestationId: c, hash: gt(JSON.stringify(Qt("wc_sessionRequest", d, h))), encryptedId: u, metadata: f.peer.metadata, transportType: l }), g = { id: h, topic: o, params: d, verifyContext: p };
        await this.setPendingSessionRequest(g), l === ce.link_mode && (r = f.peer.metadata.redirect) != null && r.universal && this.client.core.addLinkModeSupportedApp((s = f.peer.metadata.redirect) == null ? void 0 : s.universal), (n = this.client.signConfig) != null && n.disableRequestQueue ? this.emitSessionRequest(g) : (this.addSessionRequestToSessionRequestQueue(g), this.processSessionRequestQueue());
      } catch (f) {
        await this.sendError({ id: h, topic: o, error: f }), this.client.logger.error(f);
      }
    }), R(this, "onSessionRequestResponse", (i, r) => {
      const { id: s } = r, n = X("session_request", s);
      if (this.events.listenerCount(n) === 0)
        throw new Error(`emitting ${n} without any listeners`);
      pt(r) ? this.events.emit(X("session_request", s), { result: r.result }) : Qe(r) && this.events.emit(X("session_request", s), { error: r.error });
    }), R(this, "onSessionEventRequest", async (i, r) => {
      const { id: s, params: n } = r;
      try {
        const o = `${i}_session_event_${n.event.name}`, a = Vi.get(o);
        if (a && this.isRequestOutOfSync(a, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`);
          return;
        }
        this.isValidEmit(re({ topic: i }, n)), this.client.events.emit("session_event", { id: s, topic: i, params: n }), Vi.set(o, s);
      } catch (o) {
        await this.sendError({ id: s, topic: i, error: o }), this.client.logger.error(o);
      }
    }), R(this, "onSessionAuthenticateResponse", (i, r) => {
      const { id: s } = r;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: i, payload: r }), pt(r) ? this.events.emit(X("session_request", s), { result: r.result }) : Qe(r) && this.events.emit(X("session_request", s), { error: r.error });
    }), R(this, "onSessionAuthenticateRequest", async (i) => {
      var r;
      const { topic: s, payload: n, attestation: o, encryptedId: a, transportType: c } = i;
      try {
        const { requester: u, authPayload: l, expiryTimestamp: h } = n.params, d = await this.getVerifyContext({ attestationId: o, hash: gt(JSON.stringify(n)), encryptedId: a, metadata: u.metadata, transportType: c }), f = { requester: u, pairingTopic: s, id: n.id, authPayload: l, verifyContext: d, expiryTimestamp: h };
        await this.setAuthRequest(n.id, { request: f, pairingTopic: s, transportType: c }), c === ce.link_mode && (r = u.metadata.redirect) != null && r.universal && this.client.core.addLinkModeSupportedApp(u.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s, params: n.params, id: n.id, verifyContext: d });
      } catch (u) {
        this.client.logger.error(u);
        const l = n.params.requester.publicKey, h = await this.client.core.crypto.generateKeyPair(), d = this.getAppLinkIfEnabled(n.params.requester.metadata, c), f = { type: At, receiverPublicKey: l, senderPublicKey: h };
        await this.sendError({ id: n.id, topic: s, error: u, encodeOpts: f, rpcOpts: ye.wc_sessionAuthenticate.autoReject, appLink: d });
      }
    }), R(this, "addSessionRequestToSessionRequestQueue", (i) => {
      this.sessionRequestQueue.queue.push(i);
    }), R(this, "cleanupAfterResponse", (i) => {
      this.deletePendingSessionRequest(i.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = lt.idle, this.processSessionRequestQueue();
      }, T.toMiliseconds(this.requestQueueDelay));
    }), R(this, "cleanupPendingSentRequestsForTopic", ({ topic: i, error: r }) => {
      const s = this.client.core.history.pending;
      s.length > 0 && s.filter((n) => n.topic === i && n.request.method === "wc_sessionRequest").forEach((n) => {
        const o = n.request.id, a = X("session_request", o);
        if (this.events.listenerCount(a) === 0)
          throw new Error(`emitting ${a} without any listeners`);
        this.events.emit(X("session_request", n.request.id), { error: r });
      });
    }), R(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === lt.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const i = this.sessionRequestQueue.queue[0];
      if (!i) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = lt.active, this.emitSessionRequest(i);
      } catch (r) {
        this.client.logger.error(r);
      }
    }), R(this, "emitSessionRequest", (i) => {
      this.client.events.emit("session_request", i);
    }), R(this, "onPairingCreated", (i) => {
      if (i.methods && this.expectedPairingMethodMap.set(i.topic, i.methods), i.active)
        return;
      const r = this.client.proposal.getAll().find((s) => s.pairingTopic === i.topic);
      r && this.onSessionProposeRequest({ topic: i.topic, payload: Qt("wc_sessionPropose", Te(re({}, r), { requiredNamespaces: r.requiredNamespaces, optionalNamespaces: r.optionalNamespaces, relays: r.relays, proposer: r.proposer, sessionProperties: r.sessionProperties, scopedProperties: r.scopedProperties }), r.id) });
    }), R(this, "isValidConnect", async (i) => {
      if (!ke(i)) {
        const { message: u } = F("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(i)}`);
        throw new Error(u);
      }
      const { pairingTopic: r, requiredNamespaces: s, optionalNamespaces: n, sessionProperties: o, scopedProperties: a, relays: c } = i;
      if ($e(r) || await this.isValidPairingTopic(r), !nv(c, !0)) {
        const { message: u } = F("MISSING_OR_INVALID", `connect() relays: ${c}`);
        throw new Error(u);
      }
      if (!$e(s) && ts(s) !== 0 && this.validateNamespaces(s, "requiredNamespaces"), !$e(n) && ts(n) !== 0 && this.validateNamespaces(n, "optionalNamespaces"), $e(o) || this.validateSessionProps(o, "sessionProperties"), !$e(a)) {
        this.validateSessionProps(a, "scopedProperties");
        const u = Object.keys(s || {}).concat(Object.keys(n || {}));
        if (!Object.keys(a).every((l) => u.includes(l)))
          throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(a)}, required/optional namespaces: ${JSON.stringify(u)}`);
      }
    }), R(this, "validateNamespaces", (i, r) => {
      const s = sv(i, "connect()", r);
      if (s)
        throw new Error(s.message);
    }), R(this, "isValidApprove", async (i) => {
      if (!ke(i))
        throw new Error(F("MISSING_OR_INVALID", `approve() params: ${i}`).message);
      const { id: r, namespaces: s, relayProtocol: n, sessionProperties: o, scopedProperties: a } = i;
      this.checkRecentlyDeleted(r), await this.isValidProposalId(r);
      const c = this.client.proposal.get(r), u = Xs(s, "approve()");
      if (u)
        throw new Error(u.message);
      const l = dc(c.requiredNamespaces, s, "approve()");
      if (l)
        throw new Error(l.message);
      if (!de(n, !0)) {
        const { message: h } = F("MISSING_OR_INVALID", `approve() relayProtocol: ${n}`);
        throw new Error(h);
      }
      if ($e(o) || this.validateSessionProps(o, "sessionProperties"), !$e(a)) {
        this.validateSessionProps(a, "scopedProperties");
        const h = new Set(Object.keys(s));
        if (!Object.keys(a).every((d) => h.has(d)))
          throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(a)}, approved namespaces: ${Array.from(h).join(", ")}`);
      }
    }), R(this, "isValidReject", async (i) => {
      if (!ke(i)) {
        const { message: n } = F("MISSING_OR_INVALID", `reject() params: ${i}`);
        throw new Error(n);
      }
      const { id: r, reason: s } = i;
      if (this.checkRecentlyDeleted(r), await this.isValidProposalId(r), !av(s)) {
        const { message: n } = F("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s)}`);
        throw new Error(n);
      }
    }), R(this, "isValidSessionSettleRequest", (i) => {
      if (!ke(i)) {
        const { message: u } = F("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${i}`);
        throw new Error(u);
      }
      const { relay: r, controller: s, namespaces: n, expiry: o } = i;
      if (!Gl(r)) {
        const { message: u } = F("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(u);
      }
      const a = Q0(s, "onSessionSettleRequest()");
      if (a)
        throw new Error(a.message);
      const c = Xs(n, "onSessionSettleRequest()");
      if (c)
        throw new Error(c.message);
      if (Nt(o)) {
        const { message: u } = F("EXPIRED", "onSessionSettleRequest()");
        throw new Error(u);
      }
    }), R(this, "isValidUpdate", async (i) => {
      if (!ke(i)) {
        const { message: c } = F("MISSING_OR_INVALID", `update() params: ${i}`);
        throw new Error(c);
      }
      const { topic: r, namespaces: s } = i;
      this.checkRecentlyDeleted(r), await this.isValidSessionTopic(r);
      const n = this.client.session.get(r), o = Xs(s, "update()");
      if (o)
        throw new Error(o.message);
      const a = dc(n.requiredNamespaces, s, "update()");
      if (a)
        throw new Error(a.message);
    }), R(this, "isValidExtend", async (i) => {
      if (!ke(i)) {
        const { message: s } = F("MISSING_OR_INVALID", `extend() params: ${i}`);
        throw new Error(s);
      }
      const { topic: r } = i;
      this.checkRecentlyDeleted(r), await this.isValidSessionTopic(r);
    }), R(this, "isValidRequest", async (i) => {
      if (!ke(i)) {
        const { message: c } = F("MISSING_OR_INVALID", `request() params: ${i}`);
        throw new Error(c);
      }
      const { topic: r, request: s, chainId: n, expiry: o } = i;
      this.checkRecentlyDeleted(r), await this.isValidSessionTopic(r);
      const { namespaces: a } = this.client.session.get(r);
      if (!hc(a, n)) {
        const { message: c } = F("MISSING_OR_INVALID", `request() chainId: ${n}`);
        throw new Error(c);
      }
      if (!cv(s)) {
        const { message: c } = F("MISSING_OR_INVALID", `request() ${JSON.stringify(s)}`);
        throw new Error(c);
      }
      if (!hv(a, n, s.method)) {
        const { message: c } = F("MISSING_OR_INVALID", `request() method: ${s.method}`);
        throw new Error(c);
      }
      if (o && !gv(o, an)) {
        const { message: c } = F("MISSING_OR_INVALID", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${an.min} and ${an.max}`);
        throw new Error(c);
      }
    }), R(this, "isValidRespond", async (i) => {
      var r;
      if (!ke(i)) {
        const { message: o } = F("MISSING_OR_INVALID", `respond() params: ${i}`);
        throw new Error(o);
      }
      const { topic: s, response: n } = i;
      try {
        await this.isValidSessionTopic(s);
      } catch (o) {
        throw (r = i?.response) != null && r.id && this.cleanupAfterResponse(i), o;
      }
      if (!uv(n)) {
        const { message: o } = F("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(n)}`);
        throw new Error(o);
      }
    }), R(this, "isValidPing", async (i) => {
      if (!ke(i)) {
        const { message: s } = F("MISSING_OR_INVALID", `ping() params: ${i}`);
        throw new Error(s);
      }
      const { topic: r } = i;
      await this.isValidSessionOrPairingTopic(r);
    }), R(this, "isValidEmit", async (i) => {
      if (!ke(i)) {
        const { message: a } = F("MISSING_OR_INVALID", `emit() params: ${i}`);
        throw new Error(a);
      }
      const { topic: r, event: s, chainId: n } = i;
      await this.isValidSessionTopic(r);
      const { namespaces: o } = this.client.session.get(r);
      if (!hc(o, n)) {
        const { message: a } = F("MISSING_OR_INVALID", `emit() chainId: ${n}`);
        throw new Error(a);
      }
      if (!lv(s)) {
        const { message: a } = F("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(a);
      }
      if (!dv(o, n, s.name)) {
        const { message: a } = F("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(a);
      }
    }), R(this, "isValidDisconnect", async (i) => {
      if (!ke(i)) {
        const { message: s } = F("MISSING_OR_INVALID", `disconnect() params: ${i}`);
        throw new Error(s);
      }
      const { topic: r } = i;
      await this.isValidSessionOrPairingTopic(r);
    }), R(this, "isValidAuthenticate", (i) => {
      const { chains: r, uri: s, domain: n, nonce: o } = i;
      if (!Array.isArray(r) || r.length === 0)
        throw new Error("chains is required and must be a non-empty array");
      if (!de(s, !1))
        throw new Error("uri is required parameter");
      if (!de(n, !1))
        throw new Error("domain is required parameter");
      if (!de(o, !1))
        throw new Error("nonce is required parameter");
      if ([...new Set(r.map((c) => jr(c).namespace))].length > 1)
        throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: a } = jr(r[0]);
      if (a !== "eip155")
        throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), R(this, "getVerifyContext", async (i) => {
      const { attestationId: r, hash: s, encryptedId: n, metadata: o, transportType: a } = i, c = { verified: { verifyUrl: o.verifyUrl || er, validation: "UNKNOWN", origin: o.url || "" } };
      try {
        if (a === ce.link_mode) {
          const l = this.getAppLinkIfEnabled(o, a);
          return c.verified.validation = l && new URL(l).origin === new URL(o.url).origin ? "VALID" : "INVALID", c;
        }
        const u = await this.client.core.verify.resolve({ attestationId: r, hash: s, encryptedId: n, verifyUrl: o.verifyUrl });
        u && (c.verified.origin = u.origin, c.verified.isScam = u.isScam, c.verified.validation = u.origin === new URL(o.url).origin ? "VALID" : "INVALID");
      } catch (u) {
        this.client.logger.warn(u);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(c)}`), c;
    }), R(this, "validateSessionProps", (i, r) => {
      Object.values(i).forEach((s, n) => {
        if (s == null) {
          const { message: o } = F("MISSING_OR_INVALID", `${r} must contain an existing value for each key. Received: ${s} for key ${Object.keys(i)[n]}`);
          throw new Error(o);
        }
      });
    }), R(this, "getPendingAuthRequest", (i) => {
      const r = this.client.auth.requests.get(i);
      return typeof r == "object" ? r : void 0;
    }), R(this, "addToRecentlyDeleted", (i, r) => {
      if (this.recentlyDeletedMap.set(i, r), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s = 0;
        const n = this.recentlyDeletedLimit / 2;
        for (const o of this.recentlyDeletedMap.keys()) {
          if (s++ >= n)
            break;
          this.recentlyDeletedMap.delete(o);
        }
      }
    }), R(this, "checkRecentlyDeleted", (i) => {
      const r = this.recentlyDeletedMap.get(i);
      if (r) {
        const { message: s } = F("MISSING_OR_INVALID", `Record was recently deleted - ${r}: ${i}`);
        throw new Error(s);
      }
    }), R(this, "isLinkModeEnabled", (i, r) => {
      var s, n, o, a, c, u, l, h, d;
      return !i || r !== ce.link_mode ? !1 : ((n = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : n.linkMode) === !0 && ((a = (o = this.client.metadata) == null ? void 0 : o.redirect) == null ? void 0 : a.universal) !== void 0 && ((u = (c = this.client.metadata) == null ? void 0 : c.redirect) == null ? void 0 : u.universal) !== "" && ((l = i?.redirect) == null ? void 0 : l.universal) !== void 0 && ((h = i?.redirect) == null ? void 0 : h.universal) !== "" && ((d = i?.redirect) == null ? void 0 : d.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(i.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }), R(this, "getAppLinkIfEnabled", (i, r) => {
      var s;
      return this.isLinkModeEnabled(i, r) ? (s = i?.redirect) == null ? void 0 : s.universal : void 0;
    }), R(this, "handleLinkModeMessage", ({ url: i }) => {
      if (!i || !i.includes("wc_ev") || !i.includes("topic"))
        return;
      const r = Pa(i, "topic") || "", s = decodeURIComponent(Pa(i, "wc_ev") || ""), n = this.client.session.keys.includes(r);
      n && this.client.session.update(r, { transportType: ce.link_mode }), this.client.core.dispatchEnvelope({ topic: r, message: s, sessionExists: n });
    }), R(this, "registerLinkModeListeners", async () => {
      var i;
      if (ao() || Ut() && (i = this.client.metadata.redirect) != null && i.linkMode) {
        const r = global == null ? void 0 : global.Linking;
        if (typeof r < "u") {
          r.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s = await r.getInitialURL();
          s && setTimeout(() => {
            this.handleLinkModeMessage({ url: s });
          }, 50);
        }
      }
    }), R(this, "shouldSetTVF", (i, r) => {
      if (!r || i !== "wc_sessionRequest")
        return !1;
      const { request: s } = r;
      return Object.keys(Wc).includes(s.method);
    }), R(this, "getTVFParams", (i, r, s) => {
      var n, o;
      try {
        const a = r.request.method, c = this.extractTxHashesFromResult(a, s);
        return Te(re({ correlationId: i, rpcMethods: [a], chainId: r.chainId }, this.isValidContractData(r.request.params) && { contractAddresses: [(o = (n = r.request.params) == null ? void 0 : n[0]) == null ? void 0 : o.to] }), { txHashes: c });
      } catch (a) {
        this.client.logger.warn("Error getting TVF params", a);
      }
      return {};
    }), R(this, "isValidContractData", (i) => {
      var r;
      if (!i)
        return !1;
      try {
        const s = i?.data || ((r = i?.[0]) == null ? void 0 : r.data);
        if (!s.startsWith("0x"))
          return !1;
        const n = s.slice(2);
        return /^[0-9a-fA-F]*$/.test(n) ? n.length % 2 === 0 : !1;
      } catch {
      }
      return !1;
    }), R(this, "extractTxHashesFromResult", (i, r) => {
      try {
        const s = Wc[i];
        if (typeof r == "string")
          return [r];
        const n = r[s.key];
        if (Dr(n))
          return i === "solana_signAllTransactions" ? n.map((o) => zb(o)) : n;
        if (typeof n == "string")
          return [n];
      } catch (s) {
        this.client.logger.warn("Error extracting tx hashes from result", s);
      }
      return [];
    });
  }
  async processPendingMessageEvents() {
    try {
      const e = this.client.session.keys, i = this.client.core.relayer.messages.getWithoutAck(e);
      for (const [r, s] of Object.entries(i))
        for (const n of s)
          try {
            await this.onProviderMessageEvent({ topic: r, message: n, publishedAt: Date.now() });
          } catch {
            this.client.logger.warn(`Error processing pending message event for topic: ${r}, message: ${n}`);
          }
    } catch (e) {
      this.client.logger.warn("processPendingMessageEvents failed", e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = F("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(be.message, (e) => {
      this.onProviderMessageEvent(e);
    });
  }
  async onRelayMessage(e) {
    const { topic: i, message: r, attestation: s, transportType: n } = e, { publicKey: o } = this.client.auth.authKeys.keys.includes(Hr) ? this.client.auth.authKeys.get(Hr) : { responseTopic: void 0, publicKey: void 0 };
    try {
      const a = await this.client.core.crypto.decode(i, r, { receiverPublicKey: o, encoding: n === ce.link_mode ? Ft : ot });
      wo(a) ? (this.client.core.history.set(i, a), await this.onRelayEventRequest({ topic: i, payload: a, attestation: s, transportType: n, encryptedId: gt(r) })) : vs(a) ? (await this.client.core.history.resolve(a), await this.onRelayEventResponse({ topic: i, payload: a, transportType: n }), this.client.core.history.delete(i, a.id)) : await this.onRelayEventUnknownPayload({ topic: i, payload: a, transportType: n }), await this.client.core.relayer.messages.ack(i, r);
    } catch (a) {
      this.client.logger.error(a);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(Ze.expired, async (e) => {
      const { topic: i, id: r } = pl(e.target);
      if (r && this.client.pendingRequest.keys.includes(r))
        return await this.deletePendingSessionRequest(r, F("EXPIRED"), !0);
      if (r && this.client.auth.requests.keys.includes(r))
        return await this.deletePendingAuthRequest(r, F("EXPIRED"), !0);
      i ? this.client.session.keys.includes(i) && (await this.deleteSession({ topic: i, expirerHasDeleted: !0 }), this.client.events.emit("session_expire", { topic: i })) : r && (await this.deleteProposal(r, !0), this.client.events.emit("proposal_expire", { id: r }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(Yt.create, (e) => this.onPairingCreated(e)), this.client.core.pairing.events.on(Yt.delete, (e) => {
      this.addToRecentlyDeleted(e.topic, "pairing");
    });
  }
  isValidPairingTopic(e) {
    if (!de(e, !1)) {
      const { message: i } = F("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
      throw new Error(i);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: i } = F("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
      throw new Error(i);
    }
    if (Nt(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: i } = F("EXPIRED", `pairing topic: ${e}`);
      throw new Error(i);
    }
  }
  async isValidSessionTopic(e) {
    if (!de(e, !1)) {
      const { message: i } = F("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
      throw new Error(i);
    }
    if (this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e)) {
      const { message: i } = F("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
      throw new Error(i);
    }
    if (Nt(this.client.session.get(e).expiry)) {
      await this.deleteSession({ topic: e });
      const { message: i } = F("EXPIRED", `session topic: ${e}`);
      throw new Error(i);
    }
    if (!this.client.core.crypto.keychain.has(e)) {
      const { message: i } = F("MISSING_OR_INVALID", `session topic does not exist in keychain: ${e}`);
      throw await this.deleteSession({ topic: e }), new Error(i);
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e))
      await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e))
      this.isValidPairingTopic(e);
    else if (de(e, !1)) {
      const { message: i } = F("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
      throw new Error(i);
    } else {
      const { message: i } = F("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
      throw new Error(i);
    }
  }
  async isValidProposalId(e) {
    if (!ov(e)) {
      const { message: i } = F("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
      throw new Error(i);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: i } = F("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
      throw new Error(i);
    }
    if (Nt(this.client.proposal.get(e).expiryTimestamp)) {
      await this.deleteProposal(e);
      const { message: i } = F("EXPIRED", `proposal id: ${e}`);
      throw new Error(i);
    }
  }
}
class jI extends ci {
  constructor(e, i) {
    super(e, i, $I, bo), this.core = e, this.logger = i;
  }
}
class zI extends ci {
  constructor(e, i) {
    super(e, i, OI, bo), this.core = e, this.logger = i;
  }
}
class VI extends ci {
  constructor(e, i) {
    super(e, i, AI, bo, (r) => r.id), this.core = e, this.logger = i;
  }
}
class KI extends ci {
  constructor(e, i) {
    super(e, i, TI, _s, () => Hr), this.core = e, this.logger = i;
  }
}
class HI extends ci {
  constructor(e, i) {
    super(e, i, NI, _s), this.core = e, this.logger = i;
  }
}
class WI extends ci {
  constructor(e, i) {
    super(e, i, FI, _s, (r) => r.id), this.core = e, this.logger = i;
  }
}
var GI = Object.defineProperty, YI = (t, e, i) => e in t ? GI(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, cn = (t, e, i) => YI(t, typeof e != "symbol" ? e + "" : e, i);
class JI {
  constructor(e, i) {
    this.core = e, this.logger = i, cn(this, "authKeys"), cn(this, "pairingTopics"), cn(this, "requests"), this.authKeys = new KI(this.core, this.logger), this.pairingTopics = new HI(this.core, this.logger), this.requests = new WI(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
}
var ZI = Object.defineProperty, QI = (t, e, i) => e in t ? ZI(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, G = (t, e, i) => QI(t, typeof e != "symbol" ? e + "" : e, i);
class Is extends Hp {
  constructor(e) {
    super(e), G(this, "protocol", yh), G(this, "version", wh), G(this, "name", on.name), G(this, "metadata"), G(this, "core"), G(this, "logger"), G(this, "events", new Ge.EventEmitter()), G(this, "engine"), G(this, "session"), G(this, "proposal"), G(this, "pendingRequest"), G(this, "auth"), G(this, "signConfig"), G(this, "on", (r, s) => this.events.on(r, s)), G(this, "once", (r, s) => this.events.once(r, s)), G(this, "off", (r, s) => this.events.off(r, s)), G(this, "removeListener", (r, s) => this.events.removeListener(r, s)), G(this, "removeAllListeners", (r) => this.events.removeAllListeners(r)), G(this, "connect", async (r) => {
      try {
        return await this.engine.connect(r);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), G(this, "pair", async (r) => {
      try {
        return await this.engine.pair(r);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), G(this, "approve", async (r) => {
      try {
        return await this.engine.approve(r);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), G(this, "reject", async (r) => {
      try {
        return await this.engine.reject(r);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), G(this, "update", async (r) => {
      try {
        return await this.engine.update(r);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), G(this, "extend", async (r) => {
      try {
        return await this.engine.extend(r);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), G(this, "request", async (r) => {
      try {
        return await this.engine.request(r);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), G(this, "respond", async (r) => {
      try {
        return await this.engine.respond(r);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), G(this, "ping", async (r) => {
      try {
        return await this.engine.ping(r);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), G(this, "emit", async (r) => {
      try {
        return await this.engine.emit(r);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), G(this, "disconnect", async (r) => {
      try {
        return await this.engine.disconnect(r);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), G(this, "find", (r) => {
      try {
        return this.engine.find(r);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), G(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (r) {
        throw this.logger.error(r.message), r;
      }
    }), G(this, "authenticate", async (r, s) => {
      try {
        return await this.engine.authenticate(r, s);
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }), G(this, "formatAuthMessage", (r) => {
      try {
        return this.engine.formatAuthMessage(r);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), G(this, "approveSessionAuthenticate", async (r) => {
      try {
        return await this.engine.approveSessionAuthenticate(r);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), G(this, "rejectSessionAuthenticate", async (r) => {
      try {
        return await this.engine.rejectSessionAuthenticate(r);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), this.name = e?.name || on.name, this.metadata = tb(e?.metadata), this.signConfig = e?.signConfig;
    const i = typeof e?.logger < "u" && typeof e?.logger != "string" ? e.logger : as(Gn({ level: e?.logger || on.logger }));
    this.core = e?.core || new SI(e), this.logger = Fe(i, this.name), this.session = new zI(this.core, this.logger), this.proposal = new jI(this.core, this.logger), this.pendingRequest = new VI(this.core, this.logger), this.engine = new qI(this), this.auth = new JI(this.core, this.logger);
  }
  static async init(e) {
    const i = new Is(e);
    return await i.initialize(), i;
  }
  get context() {
    return je(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), setTimeout(() => {
        this.engine.processRelayMessageCache();
      }, T.toMiliseconds(T.ONE_SECOND));
    } catch (e) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e;
    }
  }
}
const un = Ph(), XI = {
  width: "245px",
  height: "245px",
  borderRadius: "40px",
  zIndex: "99999",
  backgroundColor: "white",
  border: "none",
  outline: "none"
}, eD = `
  <div id="argent-mobile-modal-container" style="position: relative; display: flex; justify-content: center; align-items: center">
    <iframe class="argent-iframe" allow="clipboard-write"></iframe>
  </div>
`;
class tD {
  constructor() {
    V(this, "bridgeUrl", "https://login.ready.co");
    V(this, "mobileUrl", "ready://");
    V(this, "type", "overlay");
    V(this, "wcUri");
    V(this, "overlay");
    V(this, "popupWindow");
    V(this, "closingTimeout");
    V(this, "standaloneConnectorModal");
  }
  showWalletConnectModal(e, i) {
    const r = encodeURIComponent(e), s = encodeURIComponent(window.location.href);
    this.showModal(
      {
        desktop: `${this.bridgeUrl}?wc=${r}&href=${s}&device=desktop&onlyQR=true`,
        ios: `${this.mobileUrl}app/wc?uri=${r}&href=${s}&device=mobile&onlyQR=true`,
        android: `${this.mobileUrl}app/wc?uri=${r}&href=${s}&device=mobile&onlyQR=true`
      },
      i
    );
  }
  getWalletConnectQR(e) {
    const i = encodeURIComponent(e), r = encodeURIComponent(window.location.href);
    this.getQR({
      desktop: `${this.bridgeUrl}?wc=${i}&href=${r}&device=desktop&onlyQR=true`,
      ios: `${this.mobileUrl}app/wc?uri=${i}&href=${r}&device=mobile&onlyQR=true`,
      android: `${this.mobileUrl}app/wc?uri=${i}&href=${r}&device=mobile&onlyQR=true`
    });
  }
  openMobileApp(e) {
    const i = document.createElement("button");
    i.style.display = "none", i.addEventListener("click", () => {
      window.location.href = e[un];
    }), i.click();
  }
  getQR(e) {
    if (["android", "ios"].includes(un)) {
      this.openMobileApp(e);
      return;
    }
    const i = document.createElement("div"), r = document.querySelector("#starknetkit-modal-container");
    if (r?.shadowRoot) {
      const s = r.shadowRoot.querySelector(".qr-code-slot");
      if (s) {
        s.innerHTML = eD, document.body.appendChild(i), this.overlay = i;
        const n = s.querySelector("iframe");
        n.setAttribute("src", e.desktop);
        for (const [o, a] of Object.entries(XI))
          n.style[o] = a;
      } else
        throw new Error("Cannot find QR code slot");
    } else
      throw new Error("Cannot find modal");
  }
  showApprovalModal(e) {
    const i = encodeURIComponent(window.location.href), r = {
      desktop: `${this.bridgeUrl}?action=sign&device=desktop&href=${i}`,
      ios: `${this.mobileUrl}app/wc/request?href=${i}&device=mobile`,
      android: `${this.mobileUrl}app/wc/request?href=${i}&device=mobile`
    };
    if (!Nh()) {
      if (this.getModal(void 0, kt.approval), ["android", "ios"].includes(un)) {
        this.openMobileApp(r);
        return;
      }
      return;
    }
    this.showModal(r, void 0);
  }
  closeModal({
    success: e,
    isRequest: i
  } = {
    success: !1,
    isRequest: !1
  }) {
    const r = this.standaloneConnectorModal;
    e ? (r?.$set({ layout: kt.success }), setTimeout(() => r?.$destroy(), 500)) : i ? (r?.$set({ layout: kt.requestFailure }), setTimeout(() => r?.$destroy(), 500)) : r?.$set({ layout: kt.loginFailure });
  }
  getModal(e, i = kt.qrCode) {
    this.standaloneConnectorModal = new Ch({
      target: Rh(),
      props: {
        layout: i,
        dappName: e?.dappName,
        showBackButton: !1,
        selectedWallet: e,
        callback: async (r) => {
          try {
            const s = r?.connector;
            this.standaloneConnectorModal?.$destroy(), await s?.connect();
          } catch {
            this.standaloneConnectorModal?.$set({ layout: kt.loginFailure });
          }
        }
      }
    });
  }
  showModal(e, i) {
    this.getModal(i, kt.qrCode), this.getQR(e);
  }
}
const nt = new tD(), ss = Kt.NetworkName, iD = async ({
  projectId: t,
  chainId: e,
  name: i,
  description: r,
  rpcUrl: s,
  bridgeUrl: n = rD(e),
  mobileUrl: o = sD(e),
  modalType: a = "overlay",
  url: c,
  icons: u,
  walletConnect: l,
  onlyQRCode: h,
  modalWallet: d
}, f) => {
  if (!n)
    throw new Error("bridgeUrl is required");
  if (!o)
    throw new Error("mobileUrl is required");
  nt.bridgeUrl = n, nt.mobileUrl = o, nt.type = a;
  const p = {
    projectId: t,
    metadata: {
      name: i ?? "Unknown dapp",
      description: r ?? "Unknown dapp description",
      url: c ?? "#",
      icons: u ?? [],
      ...l?.metadata
    }
  }, g = await Is.init(p), y = new Zc({ nodeUrl: s }), m = new f({ client: g, chainId: e, rpcUrl: s, provider: y });
  g.on("session_event", (w) => {
  }), g.on("session_update", ({ topic: w, params: b }) => {
    const { namespaces: E } = b, O = g.session.get(w);
    m.updateSession({ ...O, namespaces: E });
  }), g.on("session_delete", () => {
  });
  try {
    const w = g.session.getAll().find(m.isValidSession);
    if (w)
      return m.updateSession(w), m;
    const b = { requiredNamespaces: m.getRequiredNamespaces() };
    Fh(), await new Promise((S) => setTimeout(S, 200));
    const { uri: E, approval: O } = await g.connect(b);
    if (E) {
      h ? nt.getWalletConnectQR(E) : nt.showWalletConnectModal(E, {
        ...d,
        dappName: i || ""
      }), nt.wcUri = E;
      const S = await O();
      m.updateSession(S), nt.closeModal({ success: !0 });
    }
    return m;
  } catch {
    return console.error("@argent/login::error"), nt.closeModal(), null;
  }
}, rD = (t) => {
  if (!t)
    throw new Error(
      `Unknown or unsupported chainId (${t}), either specify a supported chain or set bridgeUrl.`
    );
  const e = parseInt(`${t}`);
  if (String(t).startsWith(ss.SN_SEPOLIA) || e === 11155111)
    return "https://mobile-login.hydrogen.argent47.net";
  if (String(t).startsWith(ss.SN_MAIN) || e === 1)
    return "https://login.argent.xyz";
}, sD = (t) => {
  if (!t)
    throw new Error(
      `Unknown or unsupported chainId (${t}), either specify a supported chain or set mobileUrl.`
    );
  const e = parseInt(`${t}`);
  if (String(t).startsWith(ss.SN_SEPOLIA) || e === 11155111)
    return "argent-dev://";
  if (String(t).startsWith(ss.SN_MAIN) || e === 1)
    return "argent://";
};
var nD = Object.defineProperty, oD = (t, e, i) => e in t ? nD(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Vt = (t, e, i) => oD(t, typeof e != "symbol" ? e + "" : e, i);
function aD(t) {
  return typeof t < "u" && typeof t.context < "u";
}
const ft = { init: "signer_init", uri: "signer_uri", created: "signer_created", updated: "signer_updated", deleted: "signer_deleted", event: "signer_event" };
class cD extends Tv {
  constructor(e) {
    super(), Vt(this, "events", new Ge.EventEmitter()), Vt(this, "requiredNamespaces"), Vt(this, "pending", !1), Vt(this, "session"), Vt(this, "opts"), Vt(this, "client"), Vt(this, "initializing", !1), this.requiredNamespaces = e?.requiredNamespaces || {}, this.opts = e?.client;
  }
  get connected() {
    return typeof this.session < "u";
  }
  get connecting() {
    return this.pending;
  }
  get chains() {
    return this.session ? ul(this.session.namespaces) : zm(this.requiredNamespaces);
  }
  get accounts() {
    return this.session ? cl(this.session.namespaces) : [];
  }
  on(e, i) {
    this.events.on(e, i);
  }
  once(e, i) {
    this.events.once(e, i);
  }
  off(e, i) {
    this.events.off(e, i);
  }
  removeListener(e, i) {
    this.events.removeListener(e, i);
  }
  async open() {
    if (this.pending)
      return new Promise((e, i) => {
        this.events.once("open", () => {
          if (this.events.once("open_error", (r) => {
            i(r);
          }), typeof this.client > "u")
            return i(new Error("Sign Client not initialized"));
          e();
        });
      });
    try {
      this.pending = !0;
      const e = await this.register(), i = e.find({ requiredNamespaces: this.requiredNamespaces });
      if (i.length)
        return this.onOpen(i[0]);
      const { uri: r, approval: s } = await e.connect({ requiredNamespaces: this.requiredNamespaces });
      this.events.emit(ft.uri, { uri: r }), this.session = await s(), this.events.emit(ft.created, this.session), this.onOpen();
    } catch (e) {
      throw this.events.emit("open_error", e), e;
    }
  }
  async close() {
    typeof this.session > "u" || (await (await this.register()).disconnect({ topic: this.session.topic, reason: se("USER_DISCONNECTED") }), this.onClose());
  }
  async send(e, i) {
    if (typeof this.client > "u" && (this.client = await this.register(), this.connected || await this.open()), typeof this.session > "u")
      throw new Error("Signer connection is missing session");
    this.client.request({ topic: this.session.topic, request: e, chainId: i?.chainId }).then((r) => this.events.emit("payload", ms(e.id, r))).catch((r) => this.events.emit("payload", bs(e.id, r.message)));
  }
  async register(e = this.opts) {
    if (typeof this.client < "u")
      return this.client;
    if (this.initializing)
      return new Promise((i, r) => {
        this.events.once("register_error", (s) => {
          r(s);
        }), this.events.once(ft.init, () => {
          if (typeof this.client > "u")
            return r(new Error("Sign Client not initialized"));
          i(this.client);
        });
      });
    if (aD(e))
      return this.client = e, this.registerEventListeners(), this.client;
    try {
      return this.initializing = !0, this.client = await Is.init(e), this.initializing = !1, this.registerEventListeners(), this.events.emit(ft.init), this.client;
    } catch (i) {
      throw this.events.emit("register_error", i), i;
    }
  }
  onOpen(e) {
    this.pending = !1, e && (this.session = e), this.events.emit("open");
  }
  onClose() {
    this.pending = !1, this.client && (this.client = void 0), this.events.emit("close");
  }
  registerEventListeners() {
    typeof this.client < "u" && (this.client.on("session_event", (e) => {
      var i;
      this.session && ((i = this.session) == null ? void 0 : i.topic) !== e.topic || this.events.emit(ft.event, e.params);
    }), this.client.on("session_update", (e) => {
      var i;
      typeof this.client < "u" && (this.session && ((i = this.session) == null ? void 0 : i.topic) !== e.topic || (this.session = this.client.session.get(e.topic), this.events.emit(ft.updated, this.session)));
    }), this.client.on("session_delete", (e) => {
      var i;
      this.session && (this.session && ((i = this.session) == null ? void 0 : i.topic) !== e.topic || (this.onClose(), this.events.emit(ft.deleted, this.session), this.session = void 0));
    }));
  }
}
class uD {
  constructor() {
    V(this, "accounts", []);
    V(this, "eventEmitter", new Ge.EventEmitter());
    V(this, "updateSession", (e) => {
      if (!this.isValidSession(e))
        throw console.warn(
          "updateSession incompatible session",
          e,
          "for adapter",
          this.formatChainId(this.chainId)
        ), new Error("Invalid session");
      this.session = e;
      const i = ul(e.namespaces, [this.namespace]);
      this.setChainIds(i);
      const r = cl(e.namespaces, [
        this.namespace
      ]);
      this.setAccounts(r);
    });
    V(this, "isValidSession", ({
      namespaces: e,
      requiredNamespaces: i
    }) => {
      const r = this.formatChainId(this.chainId);
      return i ? !!i[this.namespace]?.chains?.includes(r) : !!e?.[this.namespace]?.accounts.some(
        (s) => s.startsWith(r)
      );
    });
  }
  getRequiredNamespaces() {
    const e = [this.formatChainId(this.chainId)];
    return {
      [this.namespace]: { chains: e, methods: this.methods, events: this.events }
    };
  }
  isCompatibleChainId(e) {
    return typeof e == "string" ? e.startsWith(`${this.namespace}:`) : !1;
  }
  setChainIds(e) {
    const r = e.filter((s) => this.isCompatibleChainId(s)).map((s) => this.parseChainId(s)).filter((s) => s !== this.chainId);
    r.length && (this.chainId = r[0], this.eventEmitter.emit("chainChanged", this.chainId));
  }
  setChainId(e) {
    if (this.isCompatibleChainId(e)) {
      const i = this.parseChainId(e);
      this.chainId = i, this.eventEmitter.emit("chainChanged", this.chainId);
    }
  }
  parseAccountId(e) {
    const [i, r, s] = e.split(":");
    return { chainId: `${i}:${r}`, address: s };
  }
  getSignerConnection(e) {
    return new cD({
      requiredNamespaces: {
        [this.namespace]: {
          chains: this.rpc.chains,
          methods: this.rpc.methods,
          events: this.rpc.events
        }
      },
      client: e
    });
  }
  registerEventListeners() {
    this.rpcProvider.on("connect", () => {
      const { chains: e, accounts: i } = this.signerConnection;
      e?.length && this.setChainIds(e), i?.length && this.setAccounts(i);
    }), this.signerConnection.on(ft.created, this.updateSession), this.signerConnection.on(ft.updated, this.updateSession), this.signerConnection.on(ft.event, (e) => {
      if (!this.rpc.chains.includes(e.chainId))
        return;
      const { event: i } = e;
      i.name === "accountsChanged" ? (this.accounts = i.data, this.eventEmitter.emit("accountsChanged", this.accounts)) : i.name === "chainChanged" ? this.setChainId(i.data) : this.eventEmitter.emit(i.name, i.data);
    }), this.rpcProvider.on("disconnect", () => {
      this.eventEmitter.emit("disconnect");
    });
  }
}
class Yc extends Th {
  constructor(e, i, r, s) {
    super(e, i, r), this.wallet = s;
  }
  async execute(e, i, r = {}) {
    const s = Array.isArray(e) ? e : [e], n = i === void 0 || Array.isArray(i) ? r : i;
    return await this.wallet.wallet_requestAddInvokeTransaction({
      accountAddress: this.address,
      executionRequest: { calls: s, invocationDetails: n }
    });
  }
  async declare(e, i) {
    throw new Error("Not supported via Ready Login");
  }
  async deployAccount(e, i) {
    throw new Error("Not supported via Ready Login");
  }
}
class lD {
  constructor(e) {
    this.wallet = e;
  }
  async getPubKey() {
    throw new Error("Not supported via Ready Login");
  }
  async signMessage(e, i) {
    const { signature: r } = await this.wallet.wallet_signTypedData({
      accountAddress: i,
      typedData: e
    });
    return r;
  }
  async signTransaction(e, i, r) {
    throw new Error("Not supported via Ready Login");
  }
  async signDeployAccountTransaction(e) {
    throw new Error("Not supported via Ready Login");
  }
  async signDeclareTransaction(e) {
    throw new Error("Not supported via Ready Login");
  }
}
const hD = (t) => t.replace(/^SN_/, "SN"), dD = (t) => t.replace(/^SN/, "SN_");
class pD extends uD {
  // TODO: improve typing
  constructor({ client: i, chainId: r, rpcUrl: s, provider: n }) {
    super();
    V(this, "id", "argentMobile");
    V(this, "name", "Ready (formerly Argent)");
    V(this, "version", "0.1.0");
    V(this, "icon", "");
    V(this, "provider");
    V(this, "signer");
    V(this, "account");
    V(this, "selectedAddress", "");
    // NamespaceAdapter
    V(this, "namespace", "starknet");
    V(this, "methods", [
      "starknet_supportedSpecs",
      "starknet_signTypedData",
      "starknet_requestAddInvokeTransaction",
      "wallet_supportedSpecs",
      "wallet_signTypedData",
      "wallet_addInvokeTransaction"
    ]);
    V(this, "events", ["chainChanged", "accountsChanged"]);
    V(this, "remoteSigner");
    V(this, "signerConnection");
    V(this, "rpcProvider");
    V(this, "chainId");
    V(this, "client");
    V(this, "session");
    V(this, "rpc");
    V(this, "walletRpc");
    V(this, "handleRequest");
    // StarknetWindowObject
    V(this, "request", async (i) => {
      if (!this.session)
        throw new Error("No session");
      let r = i.type;
      (r === "wallet_addInvokeTransaction" || r === "wallet_supportedSpecs" || r === "wallet_signTypedData") && (r = r.replace("wallet_", "starknet_"));
      const s = this.handleRequest[r];
      if (s)
        return s(i.params);
      throw new Error(`Not implemented: .request() for ${i.type}`);
    });
    V(this, "on", (i, r) => {
      this.eventEmitter.on(i, r);
    });
    V(this, "off", (i, r) => {
      this.eventEmitter.off(i, r);
    });
    V(this, "handleRequestChainId", () => this.chainId === Kt.NetworkName.SN_SEPOLIA ? Kt.StarknetChainId.SN_SEPOLIA : Kt.StarknetChainId.SN_MAIN);
    V(this, "handleRequestAccounts", () => this.accounts);
    V(this, "handleGetPermissions", async () => await this.isPreauthorized() ? ["accounts"] : []);
    V(this, "handleAddInvokeTransaction", async (i) => {
      const { calls: r } = i;
      return await this.requestWallet({
        method: "starknet_requestAddInvokeTransaction",
        params: {
          accountAddress: this.account.address,
          executionRequest: {
            // will be removed when argent mobile will support entry_point and contract_address
            calls: r?.map(({ contract_address: s, entry_point: n, ...o }) => ({
              ...o,
              contractAddress: s,
              entrypoint: n
            }))
          }
        }
      });
    });
    V(this, "handleSignTypedData", async (i) => {
      const r = {
        accountAddress: this.account.address,
        typedData: i
      }, s = await this.requestWallet({
        method: "starknet_signTypedData",
        params: r
      });
      return "signature" in s ? s.signature : s;
    });
    V(this, "handleSupportedSpecs", async () => await this.requestWallet({
      method: "starknet_supportedSpecs",
      params: {}
    }));
    this.chainId = String(r ?? Kt.NetworkName.SN_MAIN), this.rpc = {
      chains: r ? [this.formatChainId(this.chainId)] : [],
      methods: this.methods,
      events: this.events
    }, this.signerConnection = this.getSignerConnection(i), this.rpcProvider = new eh(this.signerConnection), this.client = i, this.registerEventListeners(), this.walletRpc = new Proxy({}, {
      get: (o, a) => (c) => this.requestWallet({ method: a, params: c })
    }), this.remoteSigner = new lD(this.walletRpc), this.provider = n || new Zc({ nodeUrl: s }), this.account = new Yc(
      this.provider,
      "",
      this.remoteSigner,
      this.walletRpc
    ), this.handleRequest = Object.freeze({
      wallet_requestChainId: this.handleRequestChainId,
      wallet_requestAccounts: this.handleRequestAccounts,
      wallet_getPermissions: this.handleGetPermissions,
      starknet_addInvokeTransaction: this.handleAddInvokeTransaction,
      starknet_signTypedData: this.handleSignTypedData,
      starknet_supportedSpecs: this.handleSupportedSpecs,
      wallet_addInvokeTransaction: this.handleAddInvokeTransaction,
      wallet_signTypedData: this.handleSignTypedData,
      wallet_supportedSpecs: this.handleSupportedSpecs
    });
  }
  getNetworkName(i) {
    if (i === "SN_SEPOLIA")
      return Kt.NetworkName.SN_SEPOLIA;
    if (i === "SN_MAIN")
      return Kt.NetworkName.SN_MAIN;
    throw new Error(`Unknown starknet.js network name for chainId ${i}`);
  }
  async enable() {
    return await this.rpcProvider.connect(), this.accounts;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  get isConnected() {
    return !0;
  }
  async isPreauthorized() {
    return !!this.client.session.getAll().find(this.isValidSession);
  }
  async requestWallet(i) {
    if (!this.session)
      throw new Error("No session");
    try {
      const { topic: r } = this.session, s = this.formatChainId(this.chainId);
      nt.showApprovalModal(i);
      const n = await this.client.request({ topic: r, chainId: s, request: i });
      return nt.closeModal({ success: !0 }), n;
    } catch (r) {
      throw nt.closeModal({ isRequest: !0 }), r instanceof Error || r && r.message !== void 0 ? new Error(r.message) : new Error("Unknown error on requestWallet");
    }
  }
  // NamespaceAdapter
  get isConnecting() {
    return this.signerConnection.connecting;
  }
  async disable() {
    await this.rpcProvider.disconnect();
  }
  get isWalletConnect() {
    return !0;
  }
  // NamespaceAdapter private methods
  registerEventListeners() {
    super.registerEventListeners(), this.eventEmitter.on("chainChanged", (i) => {
      throw new Error("Not implemented: chainChanged");
    });
  }
  formatChainId(i) {
    return `${this.namespace}:${hD(i)}`;
  }
  parseChainId(i) {
    return dD(i.split(":")[1]);
  }
  setAccounts(i) {
    this.accounts = i.filter(
      (n) => this.parseChainId(this.parseAccountId(n).chainId) === this.chainId
    ).map((n) => this.parseAccountId(n).address);
    const { address: r } = this.parseAccountId(i[0]), s = r.startsWith("0x") ? r : `0x${r}`;
    this.account = new Yc(
      this.provider,
      s,
      this.remoteSigner,
      this.walletRpc
    ), this.eventEmitter.emit("accountsChanged", this.accounts), this.selectedAddress = s;
  }
}
const fD = async (t) => iD(t, pD), nS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getStarknetWindowObject: fD
}, Symbol.toStringTag, { value: "Module" }));
export {
  Ew as H,
  wa as a,
  hw as b,
  YD as c,
  GD as d,
  hs as e,
  ZD as f,
  QD as g,
  nS as i,
  JD as r,
  Qu as t,
  _w as w
};
