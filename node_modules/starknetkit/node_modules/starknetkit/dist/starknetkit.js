import { m as w } from "./core-44275fb6.js";
import { M as $, g as B, L as l } from "./Modal-f68d2590.js";
import { D as E } from "./trpc-63ec2300.js";
import { i as I, f as h, m as R, e as U, A as x, g as F } from "./index-ae60a5dd.js";
import "starknet";
import "./connector-d58f0dd8.js";
import { ArgentX as T } from "./argentX.js";
import { BraavosMobileBaseConnector as _ } from "./braavosMobile.js";
import { C as j } from "./index-bee98e0b.js";
import { Braavos as z } from "./braavos.js";
import { Fordefi as y } from "./fordefi.js";
import { Keplr as W } from "./keplr.js";
import { MetaMask as k } from "./metamask.js";
import { r as A, s as Q } from "./lastConnected-c0cae438.js";
import "./index-0c3fdab2.js";
const q = () => {
  const a = navigator.userAgent.toLowerCase(), s = /android|webos|iphone|ipad|ipod|blackberry|windows phone/.test(a), o = "ontouchstart" in window || navigator.maxTouchPoints > 0, m = window.innerWidth <= 768;
  return s && (o || m);
}, P = () => typeof window < "u" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1, K = ({
  argentMobileOptions: a,
  webWalletUrl: s
}) => {
  const o = (
    // | StarknetkitCompoundConnector
    []
  );
  return o.push(new T()), P() || (o.push(new z()), k.isWalletInjected() && o.push(new k()), y.isWalletInjected() && o.push(new y()), W.isWalletInjected() && o.push(new W())), o.push(new j()), q() && o.push(new _()), o;
}, st = (a) => ({
  starknetkitConnectModal: async () => await V({
    ...a,
    skipEmit: !0,
    resultType: void 0
  })
});
let n = null;
const V = async ({
  modalMode: a = "canAsk",
  storeVersion: s = F(),
  modalTheme: o,
  dappName: m,
  resultType: p = "wallet",
  skipEmit: b = !1,
  ...i
}) => {
  const { webWalletUrl: M = E, argentMobileOptions: v } = i, { connectors: c } = i;
  n = null;
  const d = !c || c.length === 0 ? K({
    argentMobileOptions: v,
    webWalletUrl: M
  }) : c;
  b && d?.map((t) => {
    I(t) && "connector" in t && "_options" in t.connector && (t.connector._options.shouldEmit = !1);
  });
  const f = localStorage.getItem("starknetLastConnectedWallet");
  if (a === "neverAsk")
    try {
      const t = h(d, f);
      let u = null;
      return t && p === "wallet" && (u = await t.connect({
        onlyQRCode: !0
      })), {
        connector: t,
        wallet: t?.wallet ?? null,
        connectorData: u
      };
    } catch (t) {
      throw A(), new Error(t);
    }
  const g = await w.getAvailableWallets(i);
  if (a === "canAsk" && f && ((await w.getAuthorizedWallets(i)).find((e) => e.id === f) ?? g.length === 1 ? g[0] : void 0)) {
    const e = h(d, f);
    let r = null;
    return p === "wallet" && (r = await e?.connect({
      onlyQRCode: !0
    }) ?? null), e && (n = e), {
      connector: n,
      connectorData: r,
      wallet: e?.wallet ?? null
    };
  }
  const L = (await w.getDiscoveryWallets(i)).map(
    (t) => t.id.toLowerCase() === "argentx" ? {
      ...t,
      name: "Ready Wallet (formerly Argent)"
    } : t
  ), S = R({
    availableConnectors: d,
    installedWallets: g,
    discoveryWallets: L,
    storeVersion: s,
    customOrder: c ? c?.length > 0 : !1
  });
  return new Promise((t, u) => {
    const e = new $({
      target: B(),
      props: {
        dappName: m,
        callback: async (r, D = !1) => {
          try {
            if (!r)
              throw new Error("Connector error");
            if (e.$set({ selectedWallet: r }), !r.installed) {
              e.$set({ layout: l.download });
              return;
            }
            if (n = U(
              r.connector,
              D
            ), p === "wallet") {
              n instanceof x ? e.$set({ layout: l.qrCode }) : e.$set({ layout: l.connecting });
              const C = await n?.connect({
                onlyQRCode: !0
              }) ?? null;
              n !== null && Q(n.id), t({
                connector: n,
                connectorData: C,
                wallet: n?.wallet ?? null
              }), e.$set({ layout: l.success }), setTimeout(() => e.$destroy(), 500);
            } else
              t({
                connector: n,
                wallet: null,
                connectorData: null
              }), e.$destroy();
          } catch (C) {
            [l.connecting, l.qrCode].includes(e.getLayout()) ? e.$set({ layout: l.loginFailure }) : u(C);
          }
        },
        theme: o === "system" ? null : o ?? null,
        modalWallets: S
      }
    });
  });
}, it = () => n ? n.wallet : null, ct = async (a = {}) => (A(), n && await n.disconnect(), n = null, w.disconnect(a));
export {
  V as connect,
  ct as disconnect,
  it as getSelectedConnectorWallet,
  st as useStarknetkitConnectModal
};
