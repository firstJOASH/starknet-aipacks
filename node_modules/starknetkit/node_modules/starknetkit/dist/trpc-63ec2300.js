import { constants as Ve } from "starknet";
import { g as dr, c as Fe } from "./connector-d58f0dd8.js";
import { P as Bt } from "./lastConnected-c0cae438.js";
const pn = "https://web.ready.co", Na = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect x="2" y="2" width="28" height="28" rx="5.6" fill="black"/>
  <g clip-path="url(#clip0_9_981)">
    <path d="M10.5 20.9999H21.5C21.9166 20.9999 22.2736 20.7452 22.424 20.383L18.1419 16.3631L16.3739 18.0018C16.163 18.1973 15.837 18.1973 15.6261 18.0018L13.8581 16.3631L9.57603 20.383C9.72637 20.7452 10.0834 20.9999 10.5 20.9999Z" fill="white"/>
    <path d="M18.8771 15.6817L22.5 19.0828V12.3239L18.8771 15.6817Z" fill="white"/>
    <path d="M13.1229 15.6817L9.5 12.3239V19.0828L13.1229 15.6817Z" fill="white"/>
    <path d="M22 10.9999H10C9.8752 10.9999 9.76108 11.0456 9.67348 11.1212L15.7734 16.7748C15.9012 16.8933 16.0988 16.8933 16.2266 16.7748L22.3265 11.1212C22.2389 11.0456 22.1248 10.9999 22 10.9999Z" fill="white"/>
  </g>
  <rect x="20" y="20" width="12" height="12" rx="2.4" fill="#FF875B"/>
  <path d="M26.9611 22.6222H25.0397C24.9755 22.6222 24.924 22.675 24.9226 22.7406C24.8838 24.5841 23.9398 26.3339 22.3148 27.5732C22.2633 27.6126 22.2515 27.6865 22.2892 27.7397L23.4134 29.3279C23.4517 29.3819 23.5262 29.3941 23.5786 29.3544C24.5947 28.5845 25.4119 27.6558 26.0004 26.6264C26.5889 27.6558 27.4062 28.5845 28.4222 29.3544C28.4746 29.3941 28.5492 29.3819 28.5875 29.3279L29.7117 27.7397C29.7493 27.6865 29.7376 27.6126 29.686 27.5732C28.0611 26.3339 27.117 24.5841 27.0782 22.7406C27.0768 22.675 27.0253 22.6222 26.9611 22.6222Z" fill="white"/>
  <defs>
  <clipPath id="clip0_9_981">
    <rect width="16" height="16" fill="white" transform="translate(8 7.99991)"/>
  </clipPath>
  </defs>
</svg>`, La = "https://static.hydrogen.argent47.net/webwallet/iframe_whitelist_testnet.json", Ia = "https://static.argent.net/webwallet/iframe_whitelist_mainnet.json", ja = (t) => t === Ve.StarknetChainId.SN_MAIN ? Ve.StarknetChainId.SN_MAIN : Ve.StarknetChainId.SN_SEPOLIA, Q = Ve.NetworkName, hn = Q.SN_SEPOLIA;
function $a(t) {
  try {
    const { origin: e } = new URL(t);
    if (e.includes("localhost") || e.includes("127.0.0.1"))
      return hn;
    if (e.includes("hydrogen") || e.includes("sepolia-web.staging"))
      return Q.SN_SEPOLIA;
    if (e.includes("staging"))
      return Q.SN_MAIN;
    if (e.includes("dev") || e.includes("sepolia-web.ready.co"))
      return Q.SN_SEPOLIA;
    if (e.includes("ready.co"))
      return Q.SN_MAIN;
  } catch {
    console.warn(
      "Could not determine network from target URL, defaulting to mainnet-alpha"
    );
  }
  return Q.SN_MAIN;
}
function mn(t) {
  return t;
}
function yn(t) {
  return t.length === 0 ? mn : t.length === 1 ? t[0] : function(r) {
    return t.reduce((n, s) => s(n), r);
  };
}
function gn(t) {
  return typeof t == "object" && t !== null && "subscribe" in t;
}
function Ke(t) {
  const e = {
    subscribe(r) {
      let n = null, s = !1, i = !1, a = !1;
      function o() {
        if (n === null) {
          a = !0;
          return;
        }
        i || (i = !0, typeof n == "function" ? n() : n && n.unsubscribe());
      }
      return n = t({
        next(c) {
          s || r.next?.(c);
        },
        error(c) {
          s || (s = !0, r.error?.(c), o());
        },
        complete() {
          s || (s = !0, r.complete?.(), o());
        }
      }), a && o(), {
        unsubscribe: o
      };
    },
    pipe(...r) {
      return yn(r)(e);
    }
  };
  return e;
}
function lr(t) {
  return (e) => {
    let r = 0, n = null;
    const s = [];
    function i() {
      n || (n = e.subscribe({
        next(o) {
          for (const c of s)
            c.next?.(o);
        },
        error(o) {
          for (const c of s)
            c.error?.(o);
        },
        complete() {
          for (const o of s)
            o.complete?.();
        }
      }));
    }
    function a() {
      if (r === 0 && n) {
        const o = n;
        n = null, o.unsubscribe();
      }
    }
    return {
      subscribe(o) {
        return r++, s.push(o), i(), {
          unsubscribe() {
            r--, a();
            const c = s.findIndex((u) => u === o);
            c > -1 && s.splice(c, 1);
          }
        };
      }
    };
  };
}
function _n(t) {
  return (e) => ({
    subscribe(r) {
      let n = 0;
      return e.subscribe({
        next(i) {
          r.next?.(t(i, n++));
        },
        error(i) {
          r.error?.(i);
        },
        complete() {
          r.complete?.();
        }
      });
    }
  });
}
function fr(t) {
  return (e) => ({
    subscribe(r) {
      return e.subscribe({
        next(n) {
          t.next?.(n), r.next?.(n);
        },
        error(n) {
          t.error?.(n), r.error?.(n);
        },
        complete() {
          t.complete?.(), r.complete?.();
        }
      });
    }
  });
}
let vn = class pr extends Error {
  constructor(e) {
    super(e), this.name = "ObservableAbortError", Object.setPrototypeOf(this, pr.prototype);
  }
};
function hr(t) {
  let e;
  return {
    promise: new Promise((n, s) => {
      let i = !1;
      function a() {
        i || (i = !0, s(new vn("This operation was aborted.")), o.unsubscribe());
      }
      const o = t.subscribe({
        next(c) {
          i = !0, n(c), a();
        },
        error(c) {
          i = !0, s(c), a();
        },
        complete() {
          i = !0, a();
        }
      });
      e = a;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: e
  };
}
const bn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isObservable: gn,
  map: _n,
  observable: Ke,
  observableToPromise: hr,
  share: lr,
  tap: fr
}, Symbol.toStringTag, { value: "Module" }));
function mr(t) {
  return Ke((e) => {
    function r(s = 0, i = t.op) {
      const a = t.links[s];
      if (!a)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return a({
        op: i,
        next(c) {
          return r(s + 1, c);
        }
      });
    }
    return r().subscribe(e);
  });
}
function Wt(t) {
  return Array.isArray(t) ? t : [
    t
  ];
}
function wn(t) {
  return (e) => {
    const r = Wt(t.true).map((s) => s(e)), n = Wt(t.false).map((s) => s(e));
    return (s) => Ke((i) => {
      const a = t.condition(s.op) ? r : n;
      return mr({
        op: s.op,
        links: a
      }).subscribe(i);
    });
  };
}
function yr(t) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const r in t) {
    const n = t[r];
    e[n] = r;
  }
  return e;
}
const et = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  // Internal JSON-RPC error
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
yr(et);
yr(et);
const xn = {
  PARSE_ERROR: 400,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  NOT_FOUND: 404,
  FORBIDDEN: 403,
  METHOD_NOT_SUPPORTED: 405,
  TIMEOUT: 408,
  CONFLICT: 409,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  UNPROCESSABLE_CONTENT: 422,
  TOO_MANY_REQUESTS: 429,
  CLIENT_CLOSED_REQUEST: 499,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501
};
function kn(t) {
  return xn[t] ?? 500;
}
function gr(t) {
  return kn(t.code);
}
const _r = () => {
};
function vr(t, e) {
  return new Proxy(_r, {
    get(n, s) {
      if (!(typeof s != "string" || s === "then"))
        return vr(t, [
          ...e,
          s
        ]);
    },
    apply(n, s, i) {
      const a = e[e.length - 1] === "apply";
      return t({
        args: a ? i.length >= 2 ? i[1] : [] : i,
        path: a ? e.slice(0, -1) : e
      });
    }
  });
}
const Pt = (t) => vr(t, []), At = (t) => new Proxy(_r, {
  get(e, r) {
    if (!(typeof r != "string" || r === "then"))
      return t(r);
  }
});
function Tn(t) {
  const { path: e, error: r, config: n } = t, { code: s } = t.error, i = {
    message: r.message,
    code: et[s],
    data: {
      code: s,
      httpStatus: gr(r)
    }
  };
  return n.isDev && typeof t.error.stack == "string" && (i.data.stack = t.error.stack), typeof e == "string" && (i.data.path = e), n.errorFormatter({
    ...t,
    shape: i
  });
}
function Ht(t, e) {
  return "error" in e ? {
    ...e,
    error: t.transformer.output.serialize(e.error)
  } : "data" in e.result ? {
    ...e,
    result: {
      ...e.result,
      data: t.transformer.output.serialize(e.result.data)
    }
  } : e;
}
function En(t, e) {
  return Array.isArray(e) ? e.map((r) => Ht(t, r)) : Ht(t, e);
}
function Cn(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
class Rn extends Error {
}
function Nt(t) {
  if (t instanceof Error)
    return t;
  const e = typeof t;
  if (!(e === "undefined" || e === "function" || t === null)) {
    if (e !== "object")
      return new Error(String(t));
    if (Cn(t)) {
      const r = new Rn();
      for (const n in t)
        r[n] = t[n];
      return r;
    }
  }
}
const On = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createFlatProxy: At,
  createRecursiveProxy: Pt,
  getCauseFromUnknown: Nt,
  getErrorShape: Tn,
  transformTRPCResponse: En
}, Symbol.toStringTag, { value: "Module" }));
function Jt(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
function Sn(t) {
  return t instanceof br || /**
  * @deprecated
  * Delete in next major
  */
  t instanceof Error && t.name === "TRPCClientError";
}
function Pn(t) {
  return Jt(t) && Jt(t.error) && typeof t.error.code == "number" && typeof t.error.message == "string";
}
let br = class we extends Error {
  static from(e, r = {}) {
    const n = e;
    return Sn(n) ? (r.meta && (n.meta = {
      ...n.meta,
      ...r.meta
    }), n) : Pn(n) ? new we(n.error.message, {
      ...r,
      result: n
    }) : n instanceof Error ? new we(n.message, {
      ...r,
      cause: Nt(n)
    }) : new we("Unknown error", {
      ...r,
      cause: n
    });
  }
  constructor(e, r) {
    const n = r?.cause;
    super(e, {
      cause: n
    }), this.meta = r?.meta, this.cause = n, this.shape = r?.result?.error, this.data = r?.result?.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, we.prototype);
  }
};
function An(t) {
  return typeof FormData > "u" ? !1 : t instanceof FormData;
}
const dt = {
  css: {
    query: [
      "72e3ff",
      "3fb0d8"
    ],
    mutation: [
      "c5a3fc",
      "904dfc"
    ],
    subscription: [
      "ff49e1",
      "d83fbe"
    ]
  },
  ansi: {
    regular: {
      // Cyan background, black and white text respectively
      query: [
        "\x1B[30;46m",
        "\x1B[97;46m"
      ],
      // Magenta background, black and white text respectively
      mutation: [
        "\x1B[30;45m",
        "\x1B[97;45m"
      ],
      // Green background, black and white text respectively
      subscription: [
        "\x1B[30;42m",
        "\x1B[97;42m"
      ]
    },
    bold: {
      query: [
        "\x1B[1;30;46m",
        "\x1B[1;97;46m"
      ],
      mutation: [
        "\x1B[1;30;45m",
        "\x1B[1;97;45m"
      ],
      subscription: [
        "\x1B[1;30;42m",
        "\x1B[1;97;42m"
      ]
    }
  }
};
function Nn(t) {
  const { direction: e, type: r, path: n, id: s, input: i } = t, a = [], o = [];
  if (t.colorMode === "ansi") {
    const [h, g] = dt.ansi.regular[r], [k, T] = dt.ansi.bold[r], A = "\x1B[0m";
    return a.push(e === "up" ? h : g, e === "up" ? ">>" : "<<", r, e === "up" ? k : T, `#${s}`, n, A), e === "up" ? o.push({
      input: t.input
    }) : o.push({
      input: t.input,
      // strip context from result cause it's too noisy in terminal wihtout collapse mode
      result: "result" in t.result ? t.result.result : t.result,
      elapsedMs: t.elapsedMs
    }), {
      parts: a,
      args: o
    };
  }
  const [c, u] = dt.css[r], l = `
    background-color: #${e === "up" ? c : u}; 
    color: ${e === "up" ? "black" : "white"};
    padding: 2px;
  `;
  return a.push("%c", e === "up" ? ">>" : "<<", r, `#${s}`, `%c${n}%c`, "%O"), o.push(l, `${l}; font-weight: bold;`, `${l}; font-weight: normal;`), e === "up" ? o.push({
    input: i,
    context: t.context
  }) : o.push({
    input: i,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: t.context
  }), {
    parts: a,
    args: o
  };
}
const Ln = ({ c: t = console, colorMode: e = "css" }) => (r) => {
  const n = r.input, s = An(n) ? Object.fromEntries(n) : n, { parts: i, args: a } = Nn({
    ...r,
    colorMode: e,
    input: s
  }), o = r.direction === "down" && r.result && (r.result instanceof Error || "error" in r.result.result) ? "error" : "log";
  t[o].apply(null, [
    i.join(" ")
  ].concat(a));
};
function In(t = {}) {
  const { enabled: e = () => !0 } = t, r = t.colorMode ?? (typeof window > "u" ? "ansi" : "css"), { logger: n = Ln({
    c: t.console,
    colorMode: r
  }) } = t;
  return () => ({ op: s, next: i }) => Ke((a) => {
    e({
      ...s,
      direction: "up"
    }) && n({
      ...s,
      direction: "up"
    });
    const o = Date.now();
    function c(u) {
      const l = Date.now() - o;
      e({
        ...s,
        direction: "down",
        result: u
      }) && n({
        ...s,
        direction: "down",
        elapsedMs: l,
        result: u
      });
    }
    return i(s).pipe(fr({
      next(u) {
        c(u);
      },
      error(u) {
        c(u);
      }
    })).subscribe(a);
  });
}
let jn = class {
  $request({ type: e, input: r, path: n, context: s = {} }) {
    return mr({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: e,
        path: n,
        input: r,
        context: s
      }
    }).pipe(lr());
  }
  requestAsPromise(e) {
    const r = this.$request(e), { promise: n, abort: s } = hr(r);
    return new Promise((a, o) => {
      e.signal?.addEventListener("abort", s), n.then((c) => {
        a(c.result.data);
      }).catch((c) => {
        o(br.from(c));
      });
    });
  }
  query(e, r, n) {
    return this.requestAsPromise({
      type: "query",
      path: e,
      input: r,
      context: n?.context,
      signal: n?.signal
    });
  }
  mutation(e, r, n) {
    return this.requestAsPromise({
      type: "mutation",
      path: e,
      input: r,
      context: n?.context,
      signal: n?.signal
    });
  }
  subscription(e, r, n) {
    return this.$request({
      type: "subscription",
      path: e,
      input: r,
      context: n?.context
    }).subscribe({
      next(i) {
        i.result.type === "started" ? n.onStarted?.() : i.result.type === "stopped" ? n.onStopped?.() : n.onData?.(i.result.data);
      },
      error(i) {
        n.onError?.(i);
      },
      complete() {
        n.onComplete?.();
      }
    });
  }
  constructor(e) {
    this.requestId = 0;
    const r = (() => {
      const n = e.transformer;
      return n ? "input" in n ? e.transformer : {
        input: n,
        output: n
      } : {
        input: {
          serialize: (s) => s,
          deserialize: (s) => s
        },
        output: {
          serialize: (s) => s,
          deserialize: (s) => s
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (n) => r.input.serialize(n),
        deserialize: (n) => r.output.deserialize(n)
      },
      combinedTransformer: r
    }, this.links = e.links.map((n) => n(this.runtime));
  }
};
const $n = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
}, Mn = (t) => $n[t];
function Zn(t) {
  return At((e) => t.hasOwnProperty(e) ? t[e] : e === "__untypedClient" ? t : Pt(({ path: r, args: n }) => {
    const s = [
      e,
      ...r
    ], i = Mn(s.pop()), a = s.join(".");
    return t[i](a, ...n);
  }));
}
function Dn(t) {
  const e = new jn(t);
  return Zn(e);
}
function Un(t) {
  if (t instanceof pe || t instanceof Error && t.name === "TRPCError")
    return t;
  const e = new pe({
    code: "INTERNAL_SERVER_ERROR",
    cause: t
  });
  return t instanceof Error && t.stack && (e.stack = t.stack), e;
}
class pe extends Error {
  constructor(e) {
    const r = Nt(e.cause), n = e.message ?? r?.message ?? e.code;
    super(n, {
      cause: r
    }), this.code = e.code, this.name = "TRPCError", this.cause || (this.cause = r);
  }
}
function zn(t) {
  return "input" in t ? t : {
    input: t,
    output: t
  };
}
const Ee = {
  _default: !0,
  input: {
    serialize: (t) => t,
    deserialize: (t) => t
  },
  output: {
    serialize: (t) => t,
    deserialize: (t) => t
  }
}, Ce = ({ shape: t }) => t;
function qn(t) {
  return Object.assign(/* @__PURE__ */ Object.create(null), t);
}
const Fn = [
  "query",
  "mutation",
  "subscription"
];
function Vn(t) {
  return "router" in t._def;
}
const Bn = {
  _ctx: null,
  _errorShape: null,
  _meta: null,
  queries: {},
  mutations: {},
  subscriptions: {},
  errorFormatter: Ce,
  transformer: Ee
}, Wn = [
  /**
  * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
  * since JS will think that `.then` is something that exists
  */
  "then"
];
function wr(t) {
  return function(r) {
    const n = new Set(Object.keys(r).filter((c) => Wn.includes(c)));
    if (n.size > 0)
      throw new Error("Reserved words used in `router({})` call: " + Array.from(n).join(", "));
    const s = qn({});
    function i(c, u = "") {
      for (const [l, h] of Object.entries(c ?? {})) {
        const g = `${u}${l}`;
        if (Vn(h)) {
          i(h._def.procedures, `${g}.`);
          continue;
        }
        if (s[g])
          throw new Error(`Duplicate key: ${g}`);
        s[g] = h;
      }
    }
    i(r);
    const a = {
      _config: t,
      router: !0,
      procedures: s,
      ...Bn,
      record: r,
      queries: Object.entries(s).filter((c) => c[1]._def.query).reduce((c, [u, l]) => ({
        ...c,
        [u]: l
      }), {}),
      mutations: Object.entries(s).filter((c) => c[1]._def.mutation).reduce((c, [u, l]) => ({
        ...c,
        [u]: l
      }), {}),
      subscriptions: Object.entries(s).filter((c) => c[1]._def.subscription).reduce((c, [u, l]) => ({
        ...c,
        [u]: l
      }), {})
    }, o = {
      ...r,
      _def: a,
      createCaller(c) {
        return xr()(o)(c);
      },
      getErrorShape(c) {
        const { path: u, error: l } = c, { code: h } = c.error, g = {
          message: l.message,
          code: et[h],
          data: {
            code: h,
            httpStatus: gr(l)
          }
        };
        return t.isDev && typeof c.error.stack == "string" && (g.data.stack = c.error.stack), typeof u == "string" && (g.data.path = u), this._def._config.errorFormatter({
          ...c,
          shape: g
        });
      }
    };
    return o;
  };
}
function Hn(t) {
  const { type: e, path: r } = t;
  if (!(r in t.procedures) || !t.procedures[r]?._def[e])
    throw new pe({
      code: "NOT_FOUND",
      message: `No "${e}"-procedure on path "${r}"`
    });
  const n = t.procedures[r];
  return n(t);
}
function xr() {
  return function(e) {
    const r = e._def;
    return function(s) {
      return Pt(({ path: a, args: o }) => {
        if (a.length === 1 && Fn.includes(a[0]))
          return Hn({
            procedures: r.procedures,
            path: o[0],
            rawInput: o[1],
            ctx: s,
            type: a[0]
          });
        const c = a.join("."), u = r.procedures[c];
        let l = "query";
        return u._def.mutation ? l = "mutation" : u._def.subscription && (l = "subscription"), u({
          path: c,
          rawInput: o[0],
          ctx: s,
          type: l
        });
      });
    };
  };
}
const Yt = typeof window > "u" || "Deno" in window || globalThis.process?.env?.NODE_ENV === "test" || !!globalThis.process?.env?.JEST_WORKER_ID || !!globalThis.process?.env?.VITEST_WORKER_ID;
function Gt(t) {
  const e = t;
  if (typeof e == "function")
    return e;
  if (typeof e.parseAsync == "function")
    return e.parseAsync.bind(e);
  if (typeof e.parse == "function")
    return e.parse.bind(e);
  if (typeof e.validateSync == "function")
    return e.validateSync.bind(e);
  if (typeof e.create == "function")
    return e.create.bind(e);
  if (typeof e.assert == "function")
    return (r) => (e.assert(r), r);
  throw new Error("Could not find a validator fn");
}
function kr(t, ...e) {
  const r = Object.assign(/* @__PURE__ */ Object.create(null), t);
  for (const n of e)
    for (const s in n) {
      if (s in r && r[s] !== n[s])
        throw new Error(`Duplicate key ${s}`);
      r[s] = n[s];
    }
  return r;
}
function Jn() {
  function t(r) {
    return {
      _middlewares: r,
      unstable_pipe(n) {
        const s = "_middlewares" in n ? n._middlewares : [
          n
        ];
        return t([
          ...r,
          ...s
        ]);
      }
    };
  }
  function e(r) {
    return t([
      r
    ]);
  }
  return e;
}
function Qt(t) {
  return t && typeof t == "object" && !Array.isArray(t);
}
function Yn(t) {
  const e = async ({ next: r, rawInput: n, input: s }) => {
    let i;
    try {
      i = await t(n);
    } catch (o) {
      throw new pe({
        code: "BAD_REQUEST",
        cause: o
      });
    }
    const a = Qt(s) && Qt(i) ? {
      ...s,
      ...i
    } : i;
    return r({
      input: a
    });
  };
  return e._type = "input", e;
}
function Gn(t) {
  const e = async ({ next: r }) => {
    const n = await r();
    if (!n.ok)
      return n;
    try {
      const s = await t(n.data);
      return {
        ...n,
        data: s
      };
    } catch (s) {
      throw new pe({
        message: "Output validation failed",
        code: "INTERNAL_SERVER_ERROR",
        cause: s
      });
    }
  };
  return e._type = "output", e;
}
const Tr = "middlewareMarker";
function ue(t, e) {
  const { middlewares: r = [], inputs: n, meta: s, ...i } = e;
  return Er({
    ...kr(t, i),
    inputs: [
      ...t.inputs,
      ...n ?? []
    ],
    middlewares: [
      ...t.middlewares,
      ...r
    ],
    meta: t.meta && s ? {
      ...t.meta,
      ...s
    } : s ?? t.meta
  });
}
function Er(t = {}) {
  const e = {
    inputs: [],
    middlewares: [],
    ...t
  };
  return {
    _def: e,
    input(r) {
      const n = Gt(r);
      return ue(e, {
        inputs: [
          r
        ],
        middlewares: [
          Yn(n)
        ]
      });
    },
    output(r) {
      const n = Gt(r);
      return ue(e, {
        output: r,
        middlewares: [
          Gn(n)
        ]
      });
    },
    meta(r) {
      return ue(e, {
        meta: r
      });
    },
    /**
    * @deprecated
    * This functionality is deprecated and will be removed in the next major version.
    */
    unstable_concat(r) {
      return ue(e, r._def);
    },
    use(r) {
      const n = "_middlewares" in r ? r._middlewares : [
        r
      ];
      return ue(e, {
        middlewares: n
      });
    },
    query(r) {
      return lt({
        ...e,
        query: !0
      }, r);
    },
    mutation(r) {
      return lt({
        ...e,
        mutation: !0
      }, r);
    },
    subscription(r) {
      return lt({
        ...e,
        subscription: !0
      }, r);
    }
  };
}
function lt(t, e) {
  const r = ue(t, {
    resolver: e,
    middlewares: [
      async function(s) {
        const i = await e(s);
        return {
          marker: Tr,
          ok: !0,
          data: i,
          ctx: s.ctx
        };
      }
    ]
  });
  return Xn(r._def);
}
const Qn = `
This is a client-only function.
If you want to call this function on the server, see https://trpc.io/docs/server/server-side-calls
`.trim();
function Xn(t) {
  const e = async function(n) {
    if (!n || !("rawInput" in n))
      throw new Error(Qn);
    const s = async (a = {
      index: 0,
      ctx: n.ctx
    }) => {
      try {
        const o = t.middlewares[a.index];
        return await o({
          ctx: a.ctx,
          type: n.type,
          path: n.path,
          rawInput: a.rawInput ?? n.rawInput,
          meta: t.meta,
          input: a.input,
          next(u) {
            const l = u;
            return s({
              index: a.index + 1,
              ctx: l && "ctx" in l ? {
                ...a.ctx,
                ...l.ctx
              } : a.ctx,
              input: l && "input" in l ? l.input : a.input,
              rawInput: l && "rawInput" in l ? l.rawInput : a.rawInput
            });
          }
        });
      } catch (o) {
        return {
          ok: !1,
          error: Un(o),
          marker: Tr
        };
      }
    }, i = await s();
    if (!i)
      throw new pe({
        code: "INTERNAL_SERVER_ERROR",
        message: "No result from middlewares - did you forget to `return next()`?"
      });
    if (!i.ok)
      throw i.error;
    return i.data;
  };
  return e._def = t, e.meta = t.meta, e;
}
function Kn(...t) {
  const e = kr({}, ...t.map((i) => i._def.record)), r = t.reduce((i, a) => {
    if (a._def._config.errorFormatter && a._def._config.errorFormatter !== Ce) {
      if (i !== Ce && i !== a._def._config.errorFormatter)
        throw new Error("You seem to have several error formatters");
      return a._def._config.errorFormatter;
    }
    return i;
  }, Ce), n = t.reduce((i, a) => {
    if (a._def._config.transformer && a._def._config.transformer !== Ee) {
      if (i !== Ee && i !== a._def._config.transformer)
        throw new Error("You seem to have several transformers");
      return a._def._config.transformer;
    }
    return i;
  }, Ee);
  return wr({
    errorFormatter: r,
    transformer: n,
    isDev: t.some((i) => i._def._config.isDev),
    allowOutsideOfServer: t.some((i) => i._def._config.allowOutsideOfServer),
    isServer: t.some((i) => i._def._config.isServer),
    $types: t[0]?._def._config.$types
  })(e);
}
class Be {
  context() {
    return new Be();
  }
  meta() {
    return new Be();
  }
  create(e) {
    return ts()(e);
  }
}
const es = new Be();
function ts() {
  return function(e) {
    const r = e?.errorFormatter ?? Ce, s = {
      transformer: zn(e?.transformer ?? Ee),
      isDev: e?.isDev ?? globalThis.process?.env?.NODE_ENV !== "production",
      allowOutsideOfServer: e?.allowOutsideOfServer ?? !1,
      errorFormatter: r,
      isServer: e?.isServer ?? Yt,
      /**
      * @internal
      */
      $types: At((i) => {
        throw new Error(`Tried to access "$types.${i}" which is not available at runtime`);
      })
    };
    if (!(e?.isServer ?? Yt) && e?.allowOutsideOfServer !== !0)
      throw new Error("You're trying to use @trpc/server in a non-server environment. This is not supported by default.");
    return {
      /**
      * These are just types, they can't be used
      * @internal
      */
      _config: s,
      /**
      * Builder object for creating procedures
      * @see https://trpc.io/docs/server/procedures
      */
      procedure: Er({
        meta: e?.defaultMeta
      }),
      /**
      * Create reusable middlewares
      * @see https://trpc.io/docs/server/middlewares
      */
      middleware: Jn(),
      /**
      * Create a router
      * @see https://trpc.io/docs/server/routers
      */
      router: wr(s),
      /**
      * Merge Routers
      * @see https://trpc.io/docs/server/merging-routers
      */
      mergeRouters: Kn,
      /**
      * Create a server-side caller for a router
      * @see https://trpc.io/docs/server/server-side-calls
      */
      createCallerFactory: xr()
    };
  };
}
var vt = {}, tt = {}, ge = {}, S = {};
const _e = /* @__PURE__ */ dr(bn);
var Lt = {}, Cr = _e;
function Rr(t) {
  return Cr.observable((e) => {
    function r(s = 0, i = t.op) {
      const a = t.links[s];
      if (!a)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return a({
        op: i,
        next(c) {
          return r(s + 1, c);
        }
      });
    }
    return r().subscribe(e);
  });
}
function Xt(t) {
  return Array.isArray(t) ? t : [
    t
  ];
}
function rs(t) {
  return (e) => {
    const r = Xt(t.true).map((s) => s(e)), n = Xt(t.false).map((s) => s(e));
    return (s) => Cr.observable((i) => {
      const a = t.condition(s.op) ? r : n;
      return Rr({
        op: s.op,
        links: a
      }).subscribe(i);
    });
  };
}
Lt.createChain = Rr;
Lt.splitLink = rs;
var ve = {};
const Or = /* @__PURE__ */ dr(On);
var be = {};
function bt(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
function ns(t, e) {
  if ("error" in t) {
    const n = e.transformer.deserialize(t.error);
    return {
      ok: !1,
      error: {
        ...t,
        error: n
      }
    };
  }
  return {
    ok: !0,
    result: {
      ...t.result,
      ...(!t.result.type || t.result.type === "data") && {
        type: "data",
        data: e.transformer.deserialize(t.result.data)
      }
    }
  };
}
class ft extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
}
function ss(t, e) {
  let r;
  try {
    r = ns(t, e);
  } catch {
    throw new ft();
  }
  if (!r.ok && (!bt(r.error.error) || typeof r.error.error.code != "number"))
    throw new ft();
  if (r.ok && !bt(r.result))
    throw new ft();
  return r;
}
be.isObject = bt;
be.transformResult = ss;
var is = Or, Kt = be;
function as(t) {
  return t instanceof Sr || /**
  * @deprecated
  * Delete in next major
  */
  t instanceof Error && t.name === "TRPCClientError";
}
function os(t) {
  return Kt.isObject(t) && Kt.isObject(t.error) && typeof t.error.code == "number" && typeof t.error.message == "string";
}
let Sr = class xe extends Error {
  static from(e, r = {}) {
    const n = e;
    return as(n) ? (r.meta && (n.meta = {
      ...n.meta,
      ...r.meta
    }), n) : os(n) ? new xe(n.error.message, {
      ...r,
      result: n
    }) : n instanceof Error ? new xe(n.message, {
      ...r,
      cause: is.getCauseFromUnknown(n)
    }) : new xe("Unknown error", {
      ...r,
      cause: n
    });
  }
  constructor(e, r) {
    const n = r?.cause;
    super(e, {
      cause: n
    }), this.meta = r?.meta, this.cause = n, this.shape = r?.result?.error, this.data = r?.result?.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, xe.prototype);
  }
};
ve.TRPCClientError = Sr;
var B = {}, cs = ve;
const er = (t) => typeof t == "function";
function Pr(t) {
  if (t)
    return t;
  if (typeof window < "u" && er(window.fetch))
    return window.fetch;
  if (typeof globalThis < "u" && er(globalThis.fetch))
    return globalThis.fetch;
  throw new Error("No fetch implementation found");
}
function us(t) {
  return t || (typeof window < "u" && window.AbortController ? window.AbortController : typeof globalThis < "u" && globalThis.AbortController ? globalThis.AbortController : null);
}
function ds(t) {
  return {
    url: t.url.toString().replace(/\/$/, ""),
    fetch: t.fetch,
    AbortController: us(t.AbortController)
  };
}
function ls(t) {
  const e = {};
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    e[r] = n;
  }
  return e;
}
const fs = {
  query: "GET",
  mutation: "POST"
};
function Ar(t) {
  return "input" in t ? t.runtime.transformer.serialize(t.input) : ls(t.inputs.map((e) => t.runtime.transformer.serialize(e)));
}
const Nr = (t) => {
  let e = t.url + "/" + t.path;
  const r = [];
  if ("inputs" in t && r.push("batch=1"), t.type === "query") {
    const n = Ar(t);
    n !== void 0 && r.push(`input=${encodeURIComponent(JSON.stringify(n))}`);
  }
  return r.length && (e += "?" + r.join("&")), e;
}, Lr = (t) => {
  if (t.type === "query")
    return;
  const e = Ar(t);
  return e !== void 0 ? JSON.stringify(e) : void 0;
}, ps = (t) => jr({
  ...t,
  contentTypeHeader: "application/json",
  getUrl: Nr,
  getBody: Lr
});
async function Ir(t, e) {
  const r = t.getUrl(t), n = t.getBody(t), { type: s } = t, i = await t.headers();
  /* istanbul ignore if -- @preserve */
  if (s === "subscription")
    throw new Error("Subscriptions should use wsLink");
  const a = {
    ...t.contentTypeHeader ? {
      "content-type": t.contentTypeHeader
    } : {},
    ...t.batchModeHeader ? {
      "trpc-batch-mode": t.batchModeHeader
    } : {},
    ...i
  };
  return Pr(t.fetch)(r, {
    method: fs[s],
    signal: e?.signal,
    body: n,
    headers: a
  });
}
function jr(t) {
  const e = t.AbortController ? new t.AbortController() : null, r = {};
  let n = !1;
  return {
    promise: new Promise((a, o) => {
      Ir(t, e).then((c) => (r.response = c, n = !0, c.json())).then((c) => {
        r.responseJSON = c, a({
          json: c,
          meta: r
        });
      }).catch((c) => {
        n = !0, o(cs.TRPCClientError.from(c, {
          meta: r
        }));
      });
    }),
    cancel: () => {
      n || e?.abort();
    }
  };
}
B.fetchHTTPResponse = Ir;
B.getBody = Lr;
B.getFetch = Pr;
B.getUrl = Nr;
B.httpRequest = jr;
B.jsonHttpRequester = ps;
B.resolveHTTPLinkOptions = ds;
var It = {}, hs = _e, ms = be, tr = ve, wt = B;
const pt = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function ht(t) {
  let e = null, r = null;
  const n = () => {
    clearTimeout(r), r = null, e = null;
  };
  function s(o) {
    const c = [
      []
    ];
    let u = 0;
    for (; ; ) {
      const l = o[u];
      if (!l)
        break;
      const h = c[c.length - 1];
      if (l.aborted) {
        l.reject?.(new Error("Aborted")), u++;
        continue;
      }
      if (t.validate(h.concat(l).map((k) => k.key))) {
        h.push(l), u++;
        continue;
      }
      if (h.length === 0) {
        l.reject?.(new Error("Input is too big for a single dispatch")), u++;
        continue;
      }
      c.push([]);
    }
    return c;
  }
  function i() {
    const o = s(e);
    n();
    for (const c of o) {
      if (!c.length)
        continue;
      const u = {
        items: c,
        cancel: pt
      };
      for (const k of c)
        k.batch = u;
      const l = (k, T) => {
        const A = u.items[k];
        A.resolve?.(T), A.batch = null, A.reject = null, A.resolve = null;
      }, { promise: h, cancel: g } = t.fetch(u.items.map((k) => k.key), l);
      u.cancel = g, h.then((k) => {
        for (let T = 0; T < k.length; T++) {
          const A = k[T];
          l(T, A);
        }
        for (const T of u.items)
          T.reject?.(new Error("Missing result")), T.batch = null;
      }).catch((k) => {
        for (const T of u.items)
          T.reject?.(k), T.batch = null;
      });
    }
  }
  function a(o) {
    const c = {
      aborted: !1,
      key: o,
      batch: null,
      resolve: pt,
      reject: pt
    }, u = new Promise((h, g) => {
      c.reject = g, c.resolve = h, e || (e = []), e.push(c);
    });
    return r || (r = setTimeout(i)), {
      promise: u,
      cancel: () => {
        c.aborted = !0, c.batch?.items.every((h) => h.aborted) && (c.batch.cancel(), c.batch = null);
      }
    };
  }
  return {
    load: a
  };
}
function $r(t) {
  return function(r) {
    const n = wt.resolveHTTPLinkOptions(r), s = r.maxURLLength ?? 1 / 0;
    return (i) => {
      const a = (h) => {
        const g = (T) => {
          if (s === 1 / 0)
            return !0;
          const A = T.map((W) => W.path).join(","), oe = T.map((W) => W.input);
          return wt.getUrl({
            ...n,
            runtime: i,
            type: h,
            path: A,
            inputs: oe
          }).length <= s;
        }, k = t({
          ...n,
          runtime: i,
          type: h,
          opts: r
        });
        return {
          validate: g,
          fetch: k
        };
      }, o = ht(a("query")), c = ht(a("mutation")), u = ht(a("subscription")), l = {
        query: o,
        subscription: u,
        mutation: c
      };
      return ({ op: h }) => hs.observable((g) => {
        const k = l[h.type], { promise: T, cancel: A } = k.load(h);
        let oe;
        return T.then(($) => {
          oe = $;
          const W = ms.transformResult($.json, i);
          if (!W.ok) {
            g.error(tr.TRPCClientError.from(W.error, {
              meta: $.meta
            }));
            return;
          }
          g.next({
            context: $.meta,
            result: W.result
          }), g.complete();
        }).catch(($) => {
          g.error(tr.TRPCClientError.from($, {
            meta: oe?.meta
          }));
        }), () => {
          A();
        };
      });
    };
  };
}
const ys = (t) => (e) => {
  const r = e.map((a) => a.path).join(","), n = e.map((a) => a.input), { promise: s, cancel: i } = wt.jsonHttpRequester({
    ...t,
    path: r,
    inputs: n,
    headers() {
      return t.opts.headers ? typeof t.opts.headers == "function" ? t.opts.headers({
        opList: e
      }) : t.opts.headers : {};
    }
  });
  return {
    promise: s.then((a) => (Array.isArray(a.json) ? a.json : e.map(() => a.json)).map((u) => ({
      meta: a.meta,
      json: u
    }))),
    cancel: i
  };
}, gs = $r(ys);
It.createHTTPBatchLink = $r;
It.httpBatchLink = gs;
var rt = {};
Object.defineProperty(rt, "__esModule", { value: !0 });
var _s = _e, vs = be, rr = ve, Mr = B;
function Zr(t) {
  return (e) => {
    const r = Mr.resolveHTTPLinkOptions(e);
    return (n) => ({ op: s }) => _s.observable((i) => {
      const { path: a, input: o, type: c } = s, { promise: u, cancel: l } = t.requester({
        ...r,
        runtime: n,
        type: c,
        path: a,
        input: o,
        headers() {
          return e.headers ? typeof e.headers == "function" ? e.headers({
            op: s
          }) : e.headers : {};
        }
      });
      let h;
      return u.then((g) => {
        h = g.meta;
        const k = vs.transformResult(g.json, n);
        if (!k.ok) {
          i.error(rr.TRPCClientError.from(k.error, {
            meta: h
          }));
          return;
        }
        i.next({
          context: g.meta,
          result: k.result
        }), i.complete();
      }).catch((g) => {
        i.error(rr.TRPCClientError.from(g, {
          meta: h
        }));
      }), () => {
        l();
      };
    });
  };
}
const bs = Zr({
  requester: Mr.jsonHttpRequester
});
rt.httpLink = bs;
rt.httpLinkFactory = Zr;
var jt = {};
Object.defineProperty(jt, "__esModule", { value: !0 });
var nr = _e;
function ws(t) {
  return typeof FormData > "u" ? !1 : t instanceof FormData;
}
const mt = {
  css: {
    query: [
      "72e3ff",
      "3fb0d8"
    ],
    mutation: [
      "c5a3fc",
      "904dfc"
    ],
    subscription: [
      "ff49e1",
      "d83fbe"
    ]
  },
  ansi: {
    regular: {
      // Cyan background, black and white text respectively
      query: [
        "\x1B[30;46m",
        "\x1B[97;46m"
      ],
      // Magenta background, black and white text respectively
      mutation: [
        "\x1B[30;45m",
        "\x1B[97;45m"
      ],
      // Green background, black and white text respectively
      subscription: [
        "\x1B[30;42m",
        "\x1B[97;42m"
      ]
    },
    bold: {
      query: [
        "\x1B[1;30;46m",
        "\x1B[1;97;46m"
      ],
      mutation: [
        "\x1B[1;30;45m",
        "\x1B[1;97;45m"
      ],
      subscription: [
        "\x1B[1;30;42m",
        "\x1B[1;97;42m"
      ]
    }
  }
};
function xs(t) {
  const { direction: e, type: r, path: n, id: s, input: i } = t, a = [], o = [];
  if (t.colorMode === "ansi") {
    const [h, g] = mt.ansi.regular[r], [k, T] = mt.ansi.bold[r], A = "\x1B[0m";
    return a.push(e === "up" ? h : g, e === "up" ? ">>" : "<<", r, e === "up" ? k : T, `#${s}`, n, A), e === "up" ? o.push({
      input: t.input
    }) : o.push({
      input: t.input,
      // strip context from result cause it's too noisy in terminal wihtout collapse mode
      result: "result" in t.result ? t.result.result : t.result,
      elapsedMs: t.elapsedMs
    }), {
      parts: a,
      args: o
    };
  }
  const [c, u] = mt.css[r], l = `
    background-color: #${e === "up" ? c : u}; 
    color: ${e === "up" ? "black" : "white"};
    padding: 2px;
  `;
  return a.push("%c", e === "up" ? ">>" : "<<", r, `#${s}`, `%c${n}%c`, "%O"), o.push(l, `${l}; font-weight: bold;`, `${l}; font-weight: normal;`), e === "up" ? o.push({
    input: i,
    context: t.context
  }) : o.push({
    input: i,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: t.context
  }), {
    parts: a,
    args: o
  };
}
const ks = ({ c: t = console, colorMode: e = "css" }) => (r) => {
  const n = r.input, s = ws(n) ? Object.fromEntries(n) : n, { parts: i, args: a } = xs({
    ...r,
    colorMode: e,
    input: s
  }), o = r.direction === "down" && r.result && (r.result instanceof Error || "error" in r.result.result) ? "error" : "log";
  t[o].apply(null, [
    i.join(" ")
  ].concat(a));
};
function Ts(t = {}) {
  const { enabled: e = () => !0 } = t, r = t.colorMode ?? (typeof window > "u" ? "ansi" : "css"), { logger: n = ks({
    c: t.console,
    colorMode: r
  }) } = t;
  return () => ({ op: s, next: i }) => nr.observable((a) => {
    e({
      ...s,
      direction: "up"
    }) && n({
      ...s,
      direction: "up"
    });
    const o = Date.now();
    function c(u) {
      const l = Date.now() - o;
      e({
        ...s,
        direction: "down",
        result: u
      }) && n({
        ...s,
        direction: "down",
        elapsedMs: l,
        result: u
      });
    }
    return i(s).pipe(nr.tap({
      next(u) {
        c(u);
      },
      error(u) {
        c(u);
      }
    })).subscribe(a);
  });
}
jt.loggerLink = Ts;
var nt = {};
Object.defineProperty(nt, "__esModule", { value: !0 });
var Es = _e, Cs = be, Dr = ve;
/* istanbul ignore next -- @preserve */
const Rs = (t) => t === 0 ? 0 : Math.min(1e3 * 2 ** t, 3e4);
function Os(t) {
  const { url: e, WebSocket: r = WebSocket, retryDelayMs: n = Rs, onOpen: s, onClose: i } = t;
  /* istanbul ignore next -- @preserve */
  if (!r)
    throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
  let a = [];
  const o = /* @__PURE__ */ Object.create(null);
  let c = 0, u = null, l = null, h = Ft(), g = "connecting";
  function k() {
    g !== "open" || u || (u = setTimeout(() => {
      u = null, a.length === 1 ? h.send(JSON.stringify(a.pop())) : h.send(JSON.stringify(a)), a = [];
    }));
  }
  function T() {
    if (l !== null || g === "closed")
      return;
    const R = n(c++);
    oe(R);
  }
  function A() {
    g = "connecting";
    const R = h;
    h = Ft(), $(R);
  }
  function oe(R) {
    l || (g = "connecting", l = setTimeout(A, R));
  }
  function $(R) {
    Object.values(o).some((ce) => ce.ws === R) || R.close();
  }
  function W() {
    Object.values(o).forEach((R) => {
      R.type === "subscription" && R.callbacks.complete();
    });
  }
  function qt(R) {
    a.some((P) => P.id === R.op.id) || Vt(R.op, R.callbacks);
  }
  function Ft() {
    const R = typeof e == "function" ? e() : e, P = new r(R);
    clearTimeout(l), l = null, P.addEventListener("open", () => {
      /* istanbul ignore next -- @preserve */
      P === h && (c = 0, g = "open", s?.(), k());
    }), P.addEventListener("error", () => {
      P === h && T();
    });
    const ce = (I) => {
      if (I.method === "reconnect" && P === h) {
        g === "open" && i?.(), A();
        for (const E of Object.values(o))
          E.type === "subscription" && qt(E);
      }
    }, ut = (I) => {
      const E = I.id !== null && o[I.id];
      if (E) {
        if (E.callbacks.next?.(I), E.ws !== h && P === h) {
          const H = E.ws;
          E.ws = h, $(H);
        }
        "result" in I && I.result.type === "stopped" && P === h && E.callbacks.complete();
      }
    };
    return P.addEventListener("message", ({ data: I }) => {
      const E = JSON.parse(I);
      "method" in E ? ce(E) : ut(E), (P !== h || g === "closed") && $(P);
    }), P.addEventListener("close", ({ code: I }) => {
      g === "open" && i?.({
        code: I
      }), h === P && T();
      for (const [E, H] of Object.entries(o))
        if (H.ws === P) {
          if (g === "closed") {
            delete o[E], H.callbacks.complete?.();
            continue;
          }
          H.type === "subscription" ? qt(H) : (delete o[E], H.callbacks.error?.(Dr.TRPCClientError.from(new $t("WebSocket closed prematurely"))));
        }
    }), P;
  }
  function Vt(R, P) {
    const { type: ce, input: ut, path: I, id: E } = R, H = {
      id: E,
      method: ce,
      params: {
        input: ut,
        path: I
      }
    };
    return o[E] = {
      ws: h,
      type: ce,
      callbacks: P,
      op: R
    }, a.push(H), k(), () => {
      const ln = o[E]?.callbacks;
      delete o[E], a = a.filter((fn) => fn.id !== E), ln?.complete?.(), h.readyState === r.OPEN && R.type === "subscription" && (a.push({
        id: E,
        method: "subscription.stop"
      }), k());
    };
  }
  return {
    close: () => {
      g = "closed", i?.(), W(), $(h), clearTimeout(l), l = null;
    },
    request: Vt,
    getConnection() {
      return h;
    }
  };
}
class $t extends Error {
  constructor(e) {
    super(e), this.name = "TRPCWebSocketClosedError", Object.setPrototypeOf(this, $t.prototype);
  }
}
function Ss(t) {
  return (e) => {
    const { client: r } = t;
    return ({ op: n }) => Es.observable((s) => {
      const { type: i, path: a, id: o, context: c } = n, u = e.transformer.serialize(n.input), l = r.request({
        type: i,
        path: a,
        input: u,
        id: o,
        context: c
      }, {
        error(h) {
          s.error(h), l();
        },
        complete() {
          s.complete();
        },
        next(h) {
          const g = Cs.transformResult(h, e);
          if (!g.ok) {
            s.error(Dr.TRPCClientError.from(g.error));
            return;
          }
          s.next({
            result: g.result
          }), n.type !== "subscription" && (l(), s.complete());
        }
      });
      return () => {
        l();
      };
    });
  };
}
nt.createWSClient = Os;
nt.wsLink = Ss;
Object.defineProperty(S, "__esModule", { value: !0 });
var sr = _e, Ur = Lt, zr = ve, ir = Or, Re = B, qr = It, Mt = rt, Ps = jt, Fr = nt;
class st {
  $request({ type: e, input: r, path: n, context: s = {} }) {
    return Ur.createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: e,
        path: n,
        input: r,
        context: s
      }
    }).pipe(sr.share());
  }
  requestAsPromise(e) {
    const r = this.$request(e), { promise: n, abort: s } = sr.observableToPromise(r);
    return new Promise((a, o) => {
      e.signal?.addEventListener("abort", s), n.then((c) => {
        a(c.result.data);
      }).catch((c) => {
        o(zr.TRPCClientError.from(c));
      });
    });
  }
  query(e, r, n) {
    return this.requestAsPromise({
      type: "query",
      path: e,
      input: r,
      context: n?.context,
      signal: n?.signal
    });
  }
  mutation(e, r, n) {
    return this.requestAsPromise({
      type: "mutation",
      path: e,
      input: r,
      context: n?.context,
      signal: n?.signal
    });
  }
  subscription(e, r, n) {
    return this.$request({
      type: "subscription",
      path: e,
      input: r,
      context: n?.context
    }).subscribe({
      next(i) {
        i.result.type === "started" ? n.onStarted?.() : i.result.type === "stopped" ? n.onStopped?.() : n.onData?.(i.result.data);
      },
      error(i) {
        n.onError?.(i);
      },
      complete() {
        n.onComplete?.();
      }
    });
  }
  constructor(e) {
    this.requestId = 0;
    const r = (() => {
      const n = e.transformer;
      return n ? "input" in n ? e.transformer : {
        input: n,
        output: n
      } : {
        input: {
          serialize: (s) => s,
          deserialize: (s) => s
        },
        output: {
          serialize: (s) => s,
          deserialize: (s) => s
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (n) => r.input.serialize(n),
        deserialize: (n) => r.output.deserialize(n)
      },
      combinedTransformer: r
    }, this.links = e.links.map((n) => n(this.runtime));
  }
}
function As(t) {
  return new st(t);
}
function Ns(t) {
  return new st(t);
}
const Ls = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
}, Vr = (t) => Ls[t];
function Br(t) {
  return ir.createFlatProxy((e) => t.hasOwnProperty(e) ? t[e] : e === "__untypedClient" ? t : ir.createRecursiveProxy(({ path: r, args: n }) => {
    const s = [
      e,
      ...r
    ], i = Vr(s.pop()), a = s.join(".");
    return t[i](a, ...n);
  }));
}
function Is(t) {
  const e = new st(t);
  return Br(e);
}
function js(t) {
  return t.__untypedClient;
}
function $s(t) {
  if (t)
    return t;
  if (typeof window < "u" && window.TextDecoder)
    return new window.TextDecoder();
  if (typeof globalThis < "u" && globalThis.TextDecoder)
    return new globalThis.TextDecoder();
  throw new Error("No TextDecoder implementation found");
}
async function Ms(t) {
  const e = t.parse ?? JSON.parse, r = (n) => {
    if (t.signal?.aborted || !n || n === "}")
      return;
    const s = n.indexOf(":"), i = n.substring(2, s - 1), a = n.substring(s + 1);
    t.onSingle(Number(i), e(a));
  };
  await Zs(t.readableStream, r, t.textDecoder);
}
async function Zs(t, e, r) {
  let n = "";
  const s = (i) => {
    const o = r.decode(i).split(`
`);
    if (o.length === 1)
      n += o[0];
    else if (o.length > 1) {
      e(n + o[0]);
      for (let c = 1; c < o.length - 1; c++)
        e(o[c]);
      n = o[o.length - 1];
    }
  };
  "getReader" in t ? await Us(t, s) : await Ds(t, s), e(n);
}
function Ds(t, e) {
  return new Promise((r) => {
    t.on("data", e), t.on("end", r);
  });
}
async function Us(t, e) {
  const r = t.getReader();
  let n = await r.read();
  for (; !n.done; )
    e(n.value), n = await r.read();
}
const zs = (t, e) => {
  const r = t.AbortController ? new t.AbortController() : null, n = Re.fetchHTTPResponse({
    ...t,
    contentTypeHeader: "application/json",
    batchModeHeader: "stream",
    getUrl: Re.getUrl,
    getBody: Re.getBody
  }, r), s = () => r?.abort(), i = n.then(async (a) => {
    if (!a.body)
      throw new Error("Received response without body");
    const o = {
      response: a
    };
    return Ms({
      readableStream: a.body,
      onSingle: e,
      parse: (c) => ({
        json: JSON.parse(c),
        meta: o
      }),
      signal: r?.signal,
      textDecoder: t.textDecoder
    });
  });
  return {
    cancel: s,
    promise: i
  };
}, qs = (t) => {
  const e = $s(t.opts.textDecoder);
  return (r, n) => {
    const s = r.map((c) => c.path).join(","), i = r.map((c) => c.input), { cancel: a, promise: o } = zs({
      ...t,
      textDecoder: e,
      path: s,
      inputs: i,
      headers() {
        return t.opts.headers ? typeof t.opts.headers == "function" ? t.opts.headers({
          opList: r
        }) : t.opts.headers : {};
      }
    }, (c, u) => {
      n(c, u);
    });
    return {
      /**
      * return an empty array because the batchLoader expects an array of results
      * but we've already called the `unitResolver` for each of them, there's
      * nothing left to do here.
      */
      promise: o.then(() => []),
      cancel: a
    };
  };
}, Fs = qr.createHTTPBatchLink(qs), Vs = (t) => {
  if ("input" in t) {
    if (!(t.input instanceof FormData))
      throw new Error("Input is not FormData");
    return t.input;
  }
}, Bs = (t) => {
  if (t.type !== "mutation")
    throw new Error("We only handle mutations with formdata");
  return Re.httpRequest({
    ...t,
    getUrl() {
      return `${t.url}/${t.path}`;
    },
    getBody: Vs
  });
}, Ws = Mt.httpLinkFactory({
  requester: Bs
});
S.splitLink = Ur.splitLink;
S.TRPCClientError = zr.TRPCClientError;
S.getFetch = Re.getFetch;
S.httpBatchLink = qr.httpBatchLink;
S.httpLink = Mt.httpLink;
S.httpLinkFactory = Mt.httpLinkFactory;
S.loggerLink = Ps.loggerLink;
S.createWSClient = Fr.createWSClient;
S.wsLink = Fr.wsLink;
S.TRPCUntypedClient = st;
S.clientCallTypeToProcedureType = Vr;
S.createTRPCClient = Ns;
S.createTRPCClientProxy = Br;
S.createTRPCProxyClient = Is;
S.createTRPCUntypedClient = As;
S.experimental_formDataLink = Ws;
S.getUntypedClient = js;
S.unstable_httpBatchStreamLink = Fs;
var re = {}, Zt = {};
function Hs(t) {
  return t;
}
function Js(t) {
  return t.length === 0 ? Hs : t.length === 1 ? t[0] : function(r) {
    return t.reduce((n, s) => s(n), r);
  };
}
function Ys(t) {
  return typeof t == "object" && t !== null && "subscribe" in t;
}
function Gs(t) {
  const e = {
    subscribe(r) {
      let n = null, s = !1, i = !1, a = !1;
      function o() {
        if (n === null) {
          a = !0;
          return;
        }
        i || (i = !0, typeof n == "function" ? n() : n && n.unsubscribe());
      }
      return n = t({
        next(c) {
          s || r.next?.(c);
        },
        error(c) {
          s || (s = !0, r.error?.(c), o());
        },
        complete() {
          s || (s = !0, r.complete?.(), o());
        }
      }), a && o(), {
        unsubscribe: o
      };
    },
    pipe(...r) {
      return Js(r)(e);
    }
  };
  return e;
}
Zt.isObservable = Ys;
Zt.observable = Gs;
Object.defineProperty(re, "__esModule", { value: !0 });
var Wr = Zt;
function Qs(t) {
  return (e) => {
    let r = 0, n = null;
    const s = [];
    function i() {
      n || (n = e.subscribe({
        next(o) {
          for (const c of s)
            c.next?.(o);
        },
        error(o) {
          for (const c of s)
            c.error?.(o);
        },
        complete() {
          for (const o of s)
            o.complete?.();
        }
      }));
    }
    function a() {
      if (r === 0 && n) {
        const o = n;
        n = null, o.unsubscribe();
      }
    }
    return {
      subscribe(o) {
        return r++, s.push(o), i(), {
          unsubscribe() {
            r--, a();
            const c = s.findIndex((u) => u === o);
            c > -1 && s.splice(c, 1);
          }
        };
      }
    };
  };
}
function Xs(t) {
  return (e) => ({
    subscribe(r) {
      let n = 0;
      return e.subscribe({
        next(i) {
          r.next?.(t(i, n++));
        },
        error(i) {
          r.error?.(i);
        },
        complete() {
          r.complete?.();
        }
      });
    }
  });
}
function Ks(t) {
  return (e) => ({
    subscribe(r) {
      return e.subscribe({
        next(n) {
          t.next?.(n), r.next?.(n);
        },
        error(n) {
          t.error?.(n), r.error?.(n);
        },
        complete() {
          t.complete?.(), r.complete?.();
        }
      });
    }
  });
}
class Dt extends Error {
  constructor(e) {
    super(e), this.name = "ObservableAbortError", Object.setPrototypeOf(this, Dt.prototype);
  }
}
function ei(t) {
  let e;
  return {
    promise: new Promise((n, s) => {
      let i = !1;
      function a() {
        i || (i = !0, s(new Dt("This operation was aborted.")), o.unsubscribe());
      }
      const o = t.subscribe({
        next(c) {
          i = !0, n(c), a();
        },
        error(c) {
          i = !0, s(c), a();
        },
        complete() {
          i = !0, a();
        }
      });
      e = a;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: e
  };
}
re.isObservable = Wr.isObservable;
re.observable = Wr.observable;
re.map = Xs;
re.observableToPromise = ei;
re.share = Qs;
re.tap = Ks;
var z = {};
Object.defineProperty(z, "__esModule", { value: !0 });
z.isTRPCRequestWithId = z.isTRPCRequest = z.isTRPCResponse = z.isTRPCMessage = void 0;
function ar(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t);
}
function ti(t) {
  return t == null;
}
function Hr(t) {
  return !!(ar(t) && "trpc" in t && ar(t.trpc));
}
z.isTRPCMessage = Hr;
function Ut(t) {
  return Hr(t) && "id" in t.trpc && !ti(t.trpc.id);
}
function ri(t) {
  return Ut(t) && ("error" in t.trpc || "result" in t.trpc);
}
z.isTRPCResponse = ri;
function Jr(t) {
  return Ut(t) && "method" in t.trpc;
}
z.isTRPCRequest = Jr;
function ni(t) {
  return Jr(t) && Ut(t);
}
z.isTRPCRequestWithId = ni;
Object.defineProperty(ge, "__esModule", { value: !0 });
ge.createBaseLink = void 0;
const yt = S, si = re, ii = z, ai = (t) => (e) => ({ op: r }) => (0, si.observable)((n) => {
  const s = [], { id: i, type: a, path: o } = r;
  try {
    const c = e.transformer.serialize(r.input), u = () => {
      n.error(new yt.TRPCClientError("Port disconnected prematurely"));
    };
    t.addCloseListener(u), s.push(() => t.removeCloseListener(u));
    const l = (h) => {
      if (!(0, ii.isTRPCResponse)(h))
        return;
      const { trpc: g } = h;
      if (i === g.id) {
        if ("error" in g)
          return n.error(yt.TRPCClientError.from(g));
        n.next({
          result: Object.assign(Object.assign({}, g.result), (!g.result.type || g.result.type === "data") && {
            type: "data",
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            data: e.transformer.deserialize(g.result.data)
          })
        }), (a !== "subscription" || g.result.type === "stopped") && n.complete();
      }
    };
    t.addMessageListener(l), s.push(() => t.removeMessageListener(l)), t.postMessage({
      trpc: {
        id: i,
        jsonrpc: void 0,
        method: a,
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        params: { path: o, input: c }
      }
    });
  } catch (c) {
    n.error(new yt.TRPCClientError(c instanceof Error ? c.message : "Unknown error"));
  }
  return () => {
    a === "subscription" && t.postMessage({
      trpc: {
        id: i,
        jsonrpc: void 0,
        method: "subscription.stop"
      }
    }), s.forEach((c) => c());
  };
});
ge.createBaseLink = ai;
Object.defineProperty(tt, "__esModule", { value: !0 });
tt.chromeLink = void 0;
const oi = ge, ci = (t) => (0, oi.createBaseLink)({
  postMessage(e) {
    t.port.postMessage(e);
  },
  addMessageListener(e) {
    t.port.onMessage.addListener(e);
  },
  removeMessageListener(e) {
    t.port.onMessage.removeListener(e);
  },
  addCloseListener(e) {
    t.port.onDisconnect.addListener(e);
  },
  removeCloseListener(e) {
    t.port.onDisconnect.removeListener(e);
  }
});
tt.chromeLink = ci;
var it = {};
Object.defineProperty(it, "__esModule", { value: !0 });
it.windowLink = void 0;
const ui = ge, di = (t) => {
  var e;
  const r = /* @__PURE__ */ new Map(), n = t.window, s = (e = t.postWindow) !== null && e !== void 0 ? e : n, i = (a, o, c) => {
    try {
      n[`${a}EventListener`](o, c);
    } catch (u) {
      console.error(`Failed to ${a} ${o} listener:`, u);
    }
  };
  return (0, ui.createBaseLink)({
    postMessage(a) {
      s.postMessage(a, {
        targetOrigin: t.postOrigin
      });
    },
    addMessageListener(a) {
      const o = (c) => {
        a(c.data);
      };
      r.set(a, o), i("add", "message", o);
    },
    removeMessageListener(a) {
      const o = r.get(a);
      o && i("remove", "message", o);
    },
    addCloseListener(a) {
      i("add", "beforeunload", a);
    },
    removeCloseListener(a) {
      i("remove", "beforeunload", a);
    }
  });
};
it.windowLink = di;
var at = {}, ot = {};
Object.defineProperty(ot, "__esModule", { value: !0 });
ot.TRPC_BROWSER_LOADED_EVENT = void 0;
ot.TRPC_BROWSER_LOADED_EVENT = "TRPC_BROWSER::POPUP_LOADED";
Object.defineProperty(at, "__esModule", { value: !0 });
at.popupLink = void 0;
const li = ot, fi = ge, pi = (t) => {
  const e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set();
  let n = null;
  async function s(i) {
    if (!n || n.closed) {
      n = t.createPopup(), await Promise.race([
        // wait til window is loaded (same origin)
        new Promise((a) => {
          var o;
          try {
            (o = n?.addEventListener) === null || o === void 0 || o.call(n, "load", a);
          } catch {
          }
        }),
        // this is needed for cross-origin popups as they don't have a load event
        new Promise((a) => {
          i.addEventListener("message", (o) => {
            o.data === li.TRPC_BROWSER_LOADED_EVENT && a();
          });
        }),
        // expect the popup to load after 15s max, in case non of the above events fire
        new Promise((a) => {
          console.warn("Could not detect if popup loading succeeded after 15s timeout, continuing anyway"), setTimeout(a, 15e3);
        })
      ]);
      try {
        if (!n.addEventListener)
          throw new Error("popupWindow.addEventListener is not a function");
        n.addEventListener("beforeunload", () => {
          n = null;
        });
      } catch {
        const o = setInterval(() => {
          n && n.closed && (n = null, r.forEach((c) => {
            c();
          }), clearInterval(o));
        }, 1e3);
      }
    }
    return n;
  }
  return (0, fi.createBaseLink)({
    async postMessage(i) {
      return (await s(t.listenWindow)).postMessage(i, {
        targetOrigin: t.postOrigin
      });
    },
    addMessageListener(i) {
      const a = (o) => {
        i(o.data);
      };
      e.set(i, a), t.listenWindow.addEventListener("message", a);
    },
    removeMessageListener(i) {
      const a = e.get(i);
      a && t.listenWindow.removeEventListener("message", a);
    },
    addCloseListener(i) {
      t.listenWindow.addEventListener("beforeunload", i), r.add(i);
    },
    removeCloseListener(i) {
      t.listenWindow.removeEventListener("beforeunload", i), r.delete(i);
    }
  });
};
at.popupLink = pi;
(function(t) {
  var e = Fe && Fe.__createBinding || (Object.create ? function(n, s, i, a) {
    a === void 0 && (a = i);
    var o = Object.getOwnPropertyDescriptor(s, i);
    (!o || ("get" in o ? !s.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
      return s[i];
    } }), Object.defineProperty(n, a, o);
  } : function(n, s, i, a) {
    a === void 0 && (a = i), n[a] = s[i];
  }), r = Fe && Fe.__exportStar || function(n, s) {
    for (var i in n)
      i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(tt, t), r(it, t), r(at, t);
})(vt);
var x;
(function(t) {
  t.assertEqual = (s) => s;
  function e(s) {
  }
  t.assertIs = e;
  function r(s) {
    throw new Error();
  }
  t.assertNever = r, t.arrayToEnum = (s) => {
    const i = {};
    for (const a of s)
      i[a] = a;
    return i;
  }, t.getValidEnumValues = (s) => {
    const i = t.objectKeys(s).filter((o) => typeof s[s[o]] != "number"), a = {};
    for (const o of i)
      a[o] = s[o];
    return t.objectValues(a);
  }, t.objectValues = (s) => t.objectKeys(s).map(function(i) {
    return s[i];
  }), t.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const i = [];
    for (const a in s)
      Object.prototype.hasOwnProperty.call(s, a) && i.push(a);
    return i;
  }, t.find = (s, i) => {
    for (const a of s)
      if (i(a))
        return a;
  }, t.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function n(s, i = " | ") {
    return s.map((a) => typeof a == "string" ? `'${a}'` : a).join(i);
  }
  t.joinValues = n, t.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i;
})(x || (x = {}));
var xt;
(function(t) {
  t.mergeShapes = (e, r) => ({
    ...e,
    ...r
    // second overwrites first
  });
})(xt || (xt = {}));
const m = x.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Y = (t) => {
  switch (typeof t) {
    case "undefined":
      return m.undefined;
    case "string":
      return m.string;
    case "number":
      return isNaN(t) ? m.nan : m.number;
    case "boolean":
      return m.boolean;
    case "function":
      return m.function;
    case "bigint":
      return m.bigint;
    case "symbol":
      return m.symbol;
    case "object":
      return Array.isArray(t) ? m.array : t === null ? m.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? m.promise : typeof Map < "u" && t instanceof Map ? m.map : typeof Set < "u" && t instanceof Set ? m.set : typeof Date < "u" && t instanceof Date ? m.date : m.object;
    default:
      return m.unknown;
  }
}, f = x.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), hi = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class j extends Error {
  get errors() {
    return this.issues;
  }
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e;
  }
  format(e) {
    const r = e || function(i) {
      return i.message;
    }, n = { _errors: [] }, s = (i) => {
      for (const a of i.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(s);
        else if (a.code === "invalid_return_type")
          s(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          s(a.argumentsError);
        else if (a.path.length === 0)
          n._errors.push(r(a));
        else {
          let o = n, c = 0;
          for (; c < a.path.length; ) {
            const u = a.path[c];
            c === a.path.length - 1 ? (o[u] = o[u] || { _errors: [] }, o[u]._errors.push(r(a))) : o[u] = o[u] || { _errors: [] }, o = o[u], c++;
          }
        }
    };
    return s(this), n;
  }
  static assert(e) {
    if (!(e instanceof j))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, x.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (r) => r.message) {
    const r = {}, n = [];
    for (const s of this.issues)
      s.path.length > 0 ? (r[s.path[0]] = r[s.path[0]] || [], r[s.path[0]].push(e(s))) : n.push(e(s));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
j.create = (t) => new j(t);
const he = (t, e) => {
  let r;
  switch (t.code) {
    case f.invalid_type:
      t.received === m.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
      break;
    case f.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(t.expected, x.jsonStringifyReplacer)}`;
      break;
    case f.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${x.joinValues(t.keys, ", ")}`;
      break;
    case f.invalid_union:
      r = "Invalid input";
      break;
    case f.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${x.joinValues(t.options)}`;
      break;
    case f.invalid_enum_value:
      r = `Invalid enum value. Expected ${x.joinValues(t.options)}, received '${t.received}'`;
      break;
    case f.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case f.invalid_return_type:
      r = "Invalid function return type";
      break;
    case f.invalid_date:
      r = "Invalid date";
      break;
    case f.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : x.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
      break;
    case f.too_small:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
      break;
    case f.too_big:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
      break;
    case f.custom:
      r = "Invalid input";
      break;
    case f.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case f.not_multiple_of:
      r = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case f.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = e.defaultError, x.assertNever(t);
  }
  return { message: r };
};
let Yr = he;
function mi(t) {
  Yr = t;
}
function We() {
  return Yr;
}
const He = (t) => {
  const { data: e, path: r, errorMaps: n, issueData: s } = t, i = [...r, ...s.path || []], a = {
    ...s,
    path: i
  };
  if (s.message !== void 0)
    return {
      ...s,
      path: i,
      message: s.message
    };
  let o = "";
  const c = n.filter((u) => !!u).slice().reverse();
  for (const u of c)
    o = u(a, { data: e, defaultError: o }).message;
  return {
    ...s,
    path: i,
    message: o
  };
}, yi = [];
function p(t, e) {
  const r = We(), n = He({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      // contextual error map is first priority
      t.schemaErrorMap,
      // then schema-bound map if available
      r,
      // then global override map
      r === he ? void 0 : he
      // then global default map
    ].filter((s) => !!s)
  });
  t.common.issues.push(n);
}
class N {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, r) {
    const n = [];
    for (const s of r) {
      if (s.status === "aborted")
        return v;
      s.status === "dirty" && e.dirty(), n.push(s.value);
    }
    return { status: e.value, value: n };
  }
  static async mergeObjectAsync(e, r) {
    const n = [];
    for (const s of r) {
      const i = await s.key, a = await s.value;
      n.push({
        key: i,
        value: a
      });
    }
    return N.mergeObjectSync(e, n);
  }
  static mergeObjectSync(e, r) {
    const n = {};
    for (const s of r) {
      const { key: i, value: a } = s;
      if (i.status === "aborted" || a.status === "aborted")
        return v;
      i.status === "dirty" && e.dirty(), a.status === "dirty" && e.dirty(), i.value !== "__proto__" && (typeof a.value < "u" || s.alwaysSet) && (n[i.value] = a.value);
    }
    return { status: e.value, value: n };
  }
}
const v = Object.freeze({
  status: "aborted"
}), le = (t) => ({ status: "dirty", value: t }), L = (t) => ({ status: "valid", value: t }), kt = (t) => t.status === "aborted", Tt = (t) => t.status === "dirty", se = (t) => t.status === "valid", Oe = (t) => typeof Promise < "u" && t instanceof Promise;
function Je(t, e, r, n) {
  if (r === "a" && !n)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !n : !e.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
}
function Gr(t, e, r, n, s) {
  if (n === "m")
    throw new TypeError("Private method is not writable");
  if (n === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !s : !e.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return n === "a" ? s.call(t, r) : s ? s.value = r : e.set(t, r), r;
}
var y;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e?.message;
})(y || (y = {}));
var ke, Te;
class F {
  constructor(e, r, n, s) {
    this._cachedPath = [], this.parent = e, this.data = r, this._path = n, this._key = s;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const or = (t, e) => {
  if (se(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new j(t.common.issues);
      return this._error = r, this._error;
    }
  };
};
function b(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: r, required_error: n, description: s } = t;
  if (e && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (a, o) => {
    var c, u;
    const { message: l } = t;
    return a.code === "invalid_enum_value" ? { message: l ?? o.defaultError } : typeof o.data > "u" ? { message: (c = l ?? n) !== null && c !== void 0 ? c : o.defaultError } : a.code !== "invalid_type" ? { message: o.defaultError } : { message: (u = l ?? r) !== null && u !== void 0 ? u : o.defaultError };
  }, description: s };
}
class w {
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return Y(e.data);
  }
  _getOrReturnCtx(e, r) {
    return r || {
      common: e.parent.common,
      data: e.data,
      parsedType: Y(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new N(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: Y(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const r = this._parse(e);
    if (Oe(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(e) {
    const r = this._parse(e);
    return Promise.resolve(r);
  }
  parse(e, r) {
    const n = this.safeParse(e, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(e, r) {
    var n;
    const s = {
      common: {
        issues: [],
        async: (n = r?.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: r?.errorMap
      },
      path: r?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Y(e)
    }, i = this._parseSync({ data: e, path: s.path, parent: s });
    return or(s, i);
  }
  "~validate"(e) {
    var r, n;
    const s = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Y(e)
    };
    if (!this["~standard"].async)
      try {
        const i = this._parseSync({ data: e, path: [], parent: s });
        return se(i) ? {
          value: i.value
        } : {
          issues: s.common.issues
        };
      } catch (i) {
        !((n = (r = i?.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null || n === void 0) && n.includes("encountered") && (this["~standard"].async = !0), s.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: e, path: [], parent: s }).then((i) => se(i) ? {
      value: i.value
    } : {
      issues: s.common.issues
    });
  }
  async parseAsync(e, r) {
    const n = await this.safeParseAsync(e, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(e, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r?.errorMap,
        async: !0
      },
      path: r?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: Y(e)
    }, s = this._parse({ data: e, path: n.path, parent: n }), i = await (Oe(s) ? s : Promise.resolve(s));
    return or(n, i);
  }
  refine(e, r) {
    const n = (s) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(s) : r;
    return this._refinement((s, i) => {
      const a = e(s), o = () => i.addIssue({
        code: f.custom,
        ...n(s)
      });
      return typeof Promise < "u" && a instanceof Promise ? a.then((c) => c ? !0 : (o(), !1)) : a ? !0 : (o(), !1);
    });
  }
  refinement(e, r) {
    return this._refinement((n, s) => e(n) ? !0 : (s.addIssue(typeof r == "function" ? r(n, s) : r), !1));
  }
  _refinement(e) {
    return new U({
      schema: this,
      typeName: _.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (r) => this["~validate"](r)
    };
  }
  optional() {
    return q.create(this, this._def);
  }
  nullable() {
    return te.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return D.create(this);
  }
  promise() {
    return ye.create(this, this._def);
  }
  or(e) {
    return Ne.create([this, e], this._def);
  }
  and(e) {
    return Le.create(this, e, this._def);
  }
  transform(e) {
    return new U({
      ...b(this._def),
      schema: this,
      typeName: _.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const r = typeof e == "function" ? e : () => e;
    return new Ze({
      ...b(this._def),
      innerType: this,
      defaultValue: r,
      typeName: _.ZodDefault
    });
  }
  brand() {
    return new zt({
      typeName: _.ZodBranded,
      type: this,
      ...b(this._def)
    });
  }
  catch(e) {
    const r = typeof e == "function" ? e : () => e;
    return new De({
      ...b(this._def),
      innerType: this,
      catchValue: r,
      typeName: _.ZodCatch
    });
  }
  describe(e) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return qe.create(this, e);
  }
  readonly() {
    return Ue.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const gi = /^c[^\s-]{8,}$/i, _i = /^[0-9a-z]+$/, vi = /^[0-9A-HJKMNP-TV-Z]{26}$/i, bi = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, wi = /^[a-z0-9_-]{21}$/i, xi = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, ki = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, Ti = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, Ei = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let gt;
const Ci = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Ri = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, Oi = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, Si = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Pi = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Ai = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, Qr = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", Ni = new RegExp(`^${Qr}$`);
function Xr(t) {
  let e = "[0-5]\\d";
  t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`);
  const r = t.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${e})${r}`;
}
function Li(t) {
  return new RegExp(`^${Xr(t)}$`);
}
function Kr(t) {
  let e = `${Qr}T${Xr(t)}`;
  const r = [];
  return r.push(t.local ? "Z?" : "Z"), t.offset && r.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${r.join("|")})`, new RegExp(`^${e}$`);
}
function Ii(t, e) {
  return !!((e === "v4" || !e) && Ci.test(t) || (e === "v6" || !e) && Oi.test(t));
}
function ji(t, e) {
  if (!xi.test(t))
    return !1;
  try {
    const [r] = t.split("."), n = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "="), s = JSON.parse(atob(n));
    return !(typeof s != "object" || s === null || !s.typ || !s.alg || e && s.alg !== e);
  } catch {
    return !1;
  }
}
function $i(t, e) {
  return !!((e === "v4" || !e) && Ri.test(t) || (e === "v6" || !e) && Si.test(t));
}
class Z extends w {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== m.string) {
      const i = this._getOrReturnCtx(e);
      return p(i, {
        code: f.invalid_type,
        expected: m.string,
        received: i.parsedType
      }), v;
    }
    const n = new N();
    let s;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value && (s = this._getOrReturnCtx(e, s), p(s, {
          code: f.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), n.dirty());
      else if (i.kind === "max")
        e.data.length > i.value && (s = this._getOrReturnCtx(e, s), p(s, {
          code: f.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), n.dirty());
      else if (i.kind === "length") {
        const a = e.data.length > i.value, o = e.data.length < i.value;
        (a || o) && (s = this._getOrReturnCtx(e, s), a ? p(s, {
          code: f.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }) : o && p(s, {
          code: f.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }), n.dirty());
      } else if (i.kind === "email")
        Ti.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "email",
          code: f.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "emoji")
        gt || (gt = new RegExp(Ei, "u")), gt.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "emoji",
          code: f.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "uuid")
        bi.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "uuid",
          code: f.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "nanoid")
        wi.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "nanoid",
          code: f.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid")
        gi.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "cuid",
          code: f.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid2")
        _i.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "cuid2",
          code: f.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "ulid")
        vi.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "ulid",
          code: f.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), p(s, {
            validation: "url",
            code: f.invalid_string,
            message: i.message
          }), n.dirty();
        }
      else
        i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "regex",
          code: f.invalid_string,
          message: i.message
        }), n.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "includes" ? e.data.includes(i.value, i.position) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f.invalid_string,
          validation: { includes: i.value, position: i.position },
          message: i.message
        }), n.dirty()) : i.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : i.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f.invalid_string,
          validation: { startsWith: i.value },
          message: i.message
        }), n.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f.invalid_string,
          validation: { endsWith: i.value },
          message: i.message
        }), n.dirty()) : i.kind === "datetime" ? Kr(i).test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f.invalid_string,
          validation: "datetime",
          message: i.message
        }), n.dirty()) : i.kind === "date" ? Ni.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f.invalid_string,
          validation: "date",
          message: i.message
        }), n.dirty()) : i.kind === "time" ? Li(i).test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          code: f.invalid_string,
          validation: "time",
          message: i.message
        }), n.dirty()) : i.kind === "duration" ? ki.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "duration",
          code: f.invalid_string,
          message: i.message
        }), n.dirty()) : i.kind === "ip" ? Ii(e.data, i.version) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "ip",
          code: f.invalid_string,
          message: i.message
        }), n.dirty()) : i.kind === "jwt" ? ji(e.data, i.alg) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "jwt",
          code: f.invalid_string,
          message: i.message
        }), n.dirty()) : i.kind === "cidr" ? $i(e.data, i.version) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "cidr",
          code: f.invalid_string,
          message: i.message
        }), n.dirty()) : i.kind === "base64" ? Pi.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "base64",
          code: f.invalid_string,
          message: i.message
        }), n.dirty()) : i.kind === "base64url" ? Ai.test(e.data) || (s = this._getOrReturnCtx(e, s), p(s, {
          validation: "base64url",
          code: f.invalid_string,
          message: i.message
        }), n.dirty()) : x.assertNever(i);
    return { status: n.value, value: e.data };
  }
  _regex(e, r, n) {
    return this.refinement((s) => e.test(s), {
      validation: r,
      code: f.invalid_string,
      ...y.errToObj(n)
    });
  }
  _addCheck(e) {
    return new Z({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...y.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...y.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...y.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...y.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...y.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...y.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...y.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...y.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...y.errToObj(e) });
  }
  base64url(e) {
    return this._addCheck({
      kind: "base64url",
      ...y.errToObj(e)
    });
  }
  jwt(e) {
    return this._addCheck({ kind: "jwt", ...y.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...y.errToObj(e) });
  }
  cidr(e) {
    return this._addCheck({ kind: "cidr", ...y.errToObj(e) });
  }
  datetime(e) {
    var r, n;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      offset: (r = e?.offset) !== null && r !== void 0 ? r : !1,
      local: (n = e?.local) !== null && n !== void 0 ? n : !1,
      ...y.errToObj(e?.message)
    });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e
    }) : this._addCheck({
      kind: "time",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      ...y.errToObj(e?.message)
    });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...y.errToObj(e) });
  }
  regex(e, r) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...y.errToObj(r)
    });
  }
  includes(e, r) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: r?.position,
      ...y.errToObj(r?.message)
    });
  }
  startsWith(e, r) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...y.errToObj(r)
    });
  }
  endsWith(e, r) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...y.errToObj(r)
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...y.errToObj(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...y.errToObj(r)
    });
  }
  length(e, r) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...y.errToObj(r)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(e) {
    return this.min(1, y.errToObj(e));
  }
  trim() {
    return new Z({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new Z({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new Z({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((e) => e.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((e) => e.kind === "base64url");
  }
  get minLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
Z.create = (t) => {
  var e;
  return new Z({
    checks: [],
    typeName: _.ZodString,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
    ...b(t)
  });
};
function Mi(t, e) {
  const r = (t.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length, s = r > n ? r : n, i = parseInt(t.toFixed(s).replace(".", "")), a = parseInt(e.toFixed(s).replace(".", ""));
  return i % a / Math.pow(10, s);
}
class X extends w {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== m.number) {
      const i = this._getOrReturnCtx(e);
      return p(i, {
        code: f.invalid_type,
        expected: m.number,
        received: i.parsedType
      }), v;
    }
    let n;
    const s = new N();
    for (const i of this._def.checks)
      i.kind === "int" ? x.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), p(n, {
        code: f.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), s.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (n = this._getOrReturnCtx(e, n), p(n, {
        code: f.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (n = this._getOrReturnCtx(e, n), p(n, {
        code: f.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? Mi(e.data, i.value) !== 0 && (n = this._getOrReturnCtx(e, n), p(n, {
        code: f.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : i.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), p(n, {
        code: f.not_finite,
        message: i.message
      }), s.dirty()) : x.assertNever(i);
    return { status: s.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, y.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, y.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, y.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, y.toString(r));
  }
  setLimit(e, r, n, s) {
    return new X({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n,
          message: y.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new X({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: y.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: y.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: y.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: y.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: y.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: y.toString(r)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: y.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: y.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: y.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && x.isInteger(e.value));
  }
  get isFinite() {
    let e = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(e);
  }
}
X.create = (t) => new X({
  checks: [],
  typeName: _.ZodNumber,
  coerce: t?.coerce || !1,
  ...b(t)
});
class K extends w {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce)
      try {
        e.data = BigInt(e.data);
      } catch {
        return this._getInvalidInput(e);
      }
    if (this._getType(e) !== m.bigint)
      return this._getInvalidInput(e);
    let n;
    const s = new N();
    for (const i of this._def.checks)
      i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (n = this._getOrReturnCtx(e, n), p(n, {
        code: f.too_small,
        type: "bigint",
        minimum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (n = this._getOrReturnCtx(e, n), p(n, {
        code: f.too_big,
        type: "bigint",
        maximum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? e.data % i.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n), p(n, {
        code: f.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : x.assertNever(i);
    return { status: s.value, value: e.data };
  }
  _getInvalidInput(e) {
    const r = this._getOrReturnCtx(e);
    return p(r, {
      code: f.invalid_type,
      expected: m.bigint,
      received: r.parsedType
    }), v;
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, y.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, y.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, y.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, y.toString(r));
  }
  setLimit(e, r, n, s) {
    return new K({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n,
          message: y.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new K({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: y.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: y.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: y.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: y.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: y.toString(r)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
K.create = (t) => {
  var e;
  return new K({
    checks: [],
    typeName: _.ZodBigInt,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
    ...b(t)
  });
};
class Se extends w {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== m.boolean) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: f.invalid_type,
        expected: m.boolean,
        received: n.parsedType
      }), v;
    }
    return L(e.data);
  }
}
Se.create = (t) => new Se({
  typeName: _.ZodBoolean,
  coerce: t?.coerce || !1,
  ...b(t)
});
class ie extends w {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== m.date) {
      const i = this._getOrReturnCtx(e);
      return p(i, {
        code: f.invalid_type,
        expected: m.date,
        received: i.parsedType
      }), v;
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return p(i, {
        code: f.invalid_date
      }), v;
    }
    const n = new N();
    let s;
    for (const i of this._def.checks)
      i.kind === "min" ? e.data.getTime() < i.value && (s = this._getOrReturnCtx(e, s), p(s, {
        code: f.too_small,
        message: i.message,
        inclusive: !0,
        exact: !1,
        minimum: i.value,
        type: "date"
      }), n.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (s = this._getOrReturnCtx(e, s), p(s, {
        code: f.too_big,
        message: i.message,
        inclusive: !0,
        exact: !1,
        maximum: i.value,
        type: "date"
      }), n.dirty()) : x.assertNever(i);
    return {
      status: n.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new ie({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: y.toString(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: y.toString(r)
    });
  }
  get minDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
}
ie.create = (t) => new ie({
  checks: [],
  coerce: t?.coerce || !1,
  typeName: _.ZodDate,
  ...b(t)
});
class Ye extends w {
  _parse(e) {
    if (this._getType(e) !== m.symbol) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: f.invalid_type,
        expected: m.symbol,
        received: n.parsedType
      }), v;
    }
    return L(e.data);
  }
}
Ye.create = (t) => new Ye({
  typeName: _.ZodSymbol,
  ...b(t)
});
class Pe extends w {
  _parse(e) {
    if (this._getType(e) !== m.undefined) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: f.invalid_type,
        expected: m.undefined,
        received: n.parsedType
      }), v;
    }
    return L(e.data);
  }
}
Pe.create = (t) => new Pe({
  typeName: _.ZodUndefined,
  ...b(t)
});
class Ae extends w {
  _parse(e) {
    if (this._getType(e) !== m.null) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: f.invalid_type,
        expected: m.null,
        received: n.parsedType
      }), v;
    }
    return L(e.data);
  }
}
Ae.create = (t) => new Ae({
  typeName: _.ZodNull,
  ...b(t)
});
class me extends w {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return L(e.data);
  }
}
me.create = (t) => new me({
  typeName: _.ZodAny,
  ...b(t)
});
class ne extends w {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return L(e.data);
  }
}
ne.create = (t) => new ne({
  typeName: _.ZodUnknown,
  ...b(t)
});
class G extends w {
  _parse(e) {
    const r = this._getOrReturnCtx(e);
    return p(r, {
      code: f.invalid_type,
      expected: m.never,
      received: r.parsedType
    }), v;
  }
}
G.create = (t) => new G({
  typeName: _.ZodNever,
  ...b(t)
});
class Ge extends w {
  _parse(e) {
    if (this._getType(e) !== m.undefined) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: f.invalid_type,
        expected: m.void,
        received: n.parsedType
      }), v;
    }
    return L(e.data);
  }
}
Ge.create = (t) => new Ge({
  typeName: _.ZodVoid,
  ...b(t)
});
class D extends w {
  _parse(e) {
    const { ctx: r, status: n } = this._processInputParams(e), s = this._def;
    if (r.parsedType !== m.array)
      return p(r, {
        code: f.invalid_type,
        expected: m.array,
        received: r.parsedType
      }), v;
    if (s.exactLength !== null) {
      const a = r.data.length > s.exactLength.value, o = r.data.length < s.exactLength.value;
      (a || o) && (p(r, {
        code: a ? f.too_big : f.too_small,
        minimum: o ? s.exactLength.value : void 0,
        maximum: a ? s.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: s.exactLength.message
      }), n.dirty());
    }
    if (s.minLength !== null && r.data.length < s.minLength.value && (p(r, {
      code: f.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.minLength.message
    }), n.dirty()), s.maxLength !== null && r.data.length > s.maxLength.value && (p(r, {
      code: f.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((a, o) => s.type._parseAsync(new F(r, a, r.path, o)))).then((a) => N.mergeArray(n, a));
    const i = [...r.data].map((a, o) => s.type._parseSync(new F(r, a, r.path, o)));
    return N.mergeArray(n, i);
  }
  get element() {
    return this._def.type;
  }
  min(e, r) {
    return new D({
      ...this._def,
      minLength: { value: e, message: y.toString(r) }
    });
  }
  max(e, r) {
    return new D({
      ...this._def,
      maxLength: { value: e, message: y.toString(r) }
    });
  }
  length(e, r) {
    return new D({
      ...this._def,
      exactLength: { value: e, message: y.toString(r) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
D.create = (t, e) => new D({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: _.ZodArray,
  ...b(e)
});
function de(t) {
  if (t instanceof C) {
    const e = {};
    for (const r in t.shape) {
      const n = t.shape[r];
      e[r] = q.create(de(n));
    }
    return new C({
      ...t._def,
      shape: () => e
    });
  } else
    return t instanceof D ? new D({
      ...t._def,
      type: de(t.element)
    }) : t instanceof q ? q.create(de(t.unwrap())) : t instanceof te ? te.create(de(t.unwrap())) : t instanceof V ? V.create(t.items.map((e) => de(e))) : t;
}
class C extends w {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), r = x.objectKeys(e);
    return this._cached = { shape: e, keys: r };
  }
  _parse(e) {
    if (this._getType(e) !== m.object) {
      const u = this._getOrReturnCtx(e);
      return p(u, {
        code: f.invalid_type,
        expected: m.object,
        received: u.parsedType
      }), v;
    }
    const { status: n, ctx: s } = this._processInputParams(e), { shape: i, keys: a } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof G && this._def.unknownKeys === "strip"))
      for (const u in s.data)
        a.includes(u) || o.push(u);
    const c = [];
    for (const u of a) {
      const l = i[u], h = s.data[u];
      c.push({
        key: { status: "valid", value: u },
        value: l._parse(new F(s, h, s.path, u)),
        alwaysSet: u in s.data
      });
    }
    if (this._def.catchall instanceof G) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const l of o)
          c.push({
            key: { status: "valid", value: l },
            value: { status: "valid", value: s.data[l] }
          });
      else if (u === "strict")
        o.length > 0 && (p(s, {
          code: f.unrecognized_keys,
          keys: o
        }), n.dirty());
      else if (u !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const l of o) {
        const h = s.data[l];
        c.push({
          key: { status: "valid", value: l },
          value: u._parse(
            new F(s, h, s.path, l)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: l in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const l of c) {
        const h = await l.key, g = await l.value;
        u.push({
          key: h,
          value: g,
          alwaysSet: l.alwaysSet
        });
      }
      return u;
    }).then((u) => N.mergeObjectSync(n, u)) : N.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return y.errToObj, new C({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (r, n) => {
          var s, i, a, o;
          const c = (a = (i = (s = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(s, r, n).message) !== null && a !== void 0 ? a : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (o = y.errToObj(e).message) !== null && o !== void 0 ? o : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new C({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new C({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new C({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new C({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: _.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, r) {
    return this.augment({ [e]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new C({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const r = {};
    return x.objectKeys(e).forEach((n) => {
      e[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new C({
      ...this._def,
      shape: () => r
    });
  }
  omit(e) {
    const r = {};
    return x.objectKeys(this.shape).forEach((n) => {
      e[n] || (r[n] = this.shape[n]);
    }), new C({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return de(this);
  }
  partial(e) {
    const r = {};
    return x.objectKeys(this.shape).forEach((n) => {
      const s = this.shape[n];
      e && !e[n] ? r[n] = s : r[n] = s.optional();
    }), new C({
      ...this._def,
      shape: () => r
    });
  }
  required(e) {
    const r = {};
    return x.objectKeys(this.shape).forEach((n) => {
      if (e && !e[n])
        r[n] = this.shape[n];
      else {
        let i = this.shape[n];
        for (; i instanceof q; )
          i = i._def.innerType;
        r[n] = i;
      }
    }), new C({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return en(x.objectKeys(this.shape));
  }
}
C.create = (t, e) => new C({
  shape: () => t,
  unknownKeys: "strip",
  catchall: G.create(),
  typeName: _.ZodObject,
  ...b(e)
});
C.strictCreate = (t, e) => new C({
  shape: () => t,
  unknownKeys: "strict",
  catchall: G.create(),
  typeName: _.ZodObject,
  ...b(e)
});
C.lazycreate = (t, e) => new C({
  shape: t,
  unknownKeys: "strip",
  catchall: G.create(),
  typeName: _.ZodObject,
  ...b(e)
});
class Ne extends w {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = this._def.options;
    function s(i) {
      for (const o of i)
        if (o.result.status === "valid")
          return o.result;
      for (const o of i)
        if (o.result.status === "dirty")
          return r.common.issues.push(...o.ctx.common.issues), o.result;
      const a = i.map((o) => new j(o.ctx.common.issues));
      return p(r, {
        code: f.invalid_union,
        unionErrors: a
      }), v;
    }
    if (r.common.async)
      return Promise.all(n.map(async (i) => {
        const a = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: r.data,
            path: r.path,
            parent: a
          }),
          ctx: a
        };
      })).then(s);
    {
      let i;
      const a = [];
      for (const c of n) {
        const u = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, l = c._parseSync({
          data: r.data,
          path: r.path,
          parent: u
        });
        if (l.status === "valid")
          return l;
        l.status === "dirty" && !i && (i = { result: l, ctx: u }), u.common.issues.length && a.push(u.common.issues);
      }
      if (i)
        return r.common.issues.push(...i.ctx.common.issues), i.result;
      const o = a.map((c) => new j(c));
      return p(r, {
        code: f.invalid_union,
        unionErrors: o
      }), v;
    }
  }
  get options() {
    return this._def.options;
  }
}
Ne.create = (t, e) => new Ne({
  options: t,
  typeName: _.ZodUnion,
  ...b(e)
});
const J = (t) => t instanceof je ? J(t.schema) : t instanceof U ? J(t.innerType()) : t instanceof $e ? [t.value] : t instanceof ee ? t.options : t instanceof Me ? x.objectValues(t.enum) : t instanceof Ze ? J(t._def.innerType) : t instanceof Pe ? [void 0] : t instanceof Ae ? [null] : t instanceof q ? [void 0, ...J(t.unwrap())] : t instanceof te ? [null, ...J(t.unwrap())] : t instanceof zt || t instanceof Ue ? J(t.unwrap()) : t instanceof De ? J(t._def.innerType) : [];
class ct extends w {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== m.object)
      return p(r, {
        code: f.invalid_type,
        expected: m.object,
        received: r.parsedType
      }), v;
    const n = this.discriminator, s = r.data[n], i = this.optionsMap.get(s);
    return i ? r.common.async ? i._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : i._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (p(r, {
      code: f.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), v);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, r, n) {
    const s = /* @__PURE__ */ new Map();
    for (const i of r) {
      const a = J(i.shape[e]);
      if (!a.length)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const o of a) {
        if (s.has(o))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o)}`);
        s.set(o, i);
      }
    }
    return new ct({
      typeName: _.ZodDiscriminatedUnion,
      discriminator: e,
      options: r,
      optionsMap: s,
      ...b(n)
    });
  }
}
function Et(t, e) {
  const r = Y(t), n = Y(e);
  if (t === e)
    return { valid: !0, data: t };
  if (r === m.object && n === m.object) {
    const s = x.objectKeys(e), i = x.objectKeys(t).filter((o) => s.indexOf(o) !== -1), a = { ...t, ...e };
    for (const o of i) {
      const c = Et(t[o], e[o]);
      if (!c.valid)
        return { valid: !1 };
      a[o] = c.data;
    }
    return { valid: !0, data: a };
  } else if (r === m.array && n === m.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const s = [];
    for (let i = 0; i < t.length; i++) {
      const a = t[i], o = e[i], c = Et(a, o);
      if (!c.valid)
        return { valid: !1 };
      s.push(c.data);
    }
    return { valid: !0, data: s };
  } else
    return r === m.date && n === m.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class Le extends w {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e), s = (i, a) => {
      if (kt(i) || kt(a))
        return v;
      const o = Et(i.value, a.value);
      return o.valid ? ((Tt(i) || Tt(a)) && r.dirty(), { status: r.value, value: o.data }) : (p(n, {
        code: f.invalid_intersection_types
      }), v);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([i, a]) => s(i, a)) : s(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
Le.create = (t, e, r) => new Le({
  left: t,
  right: e,
  typeName: _.ZodIntersection,
  ...b(r)
});
class V extends w {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== m.array)
      return p(n, {
        code: f.invalid_type,
        expected: m.array,
        received: n.parsedType
      }), v;
    if (n.data.length < this._def.items.length)
      return p(n, {
        code: f.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), v;
    !this._def.rest && n.data.length > this._def.items.length && (p(n, {
      code: f.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const i = [...n.data].map((a, o) => {
      const c = this._def.items[o] || this._def.rest;
      return c ? c._parse(new F(n, a, n.path, o)) : null;
    }).filter((a) => !!a);
    return n.common.async ? Promise.all(i).then((a) => N.mergeArray(r, a)) : N.mergeArray(r, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new V({
      ...this._def,
      rest: e
    });
  }
}
V.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new V({
    items: t,
    typeName: _.ZodTuple,
    rest: null,
    ...b(e)
  });
};
class Ie extends w {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== m.object)
      return p(n, {
        code: f.invalid_type,
        expected: m.object,
        received: n.parsedType
      }), v;
    const s = [], i = this._def.keyType, a = this._def.valueType;
    for (const o in n.data)
      s.push({
        key: i._parse(new F(n, o, n.path, o)),
        value: a._parse(new F(n, n.data[o], n.path, o)),
        alwaysSet: o in n.data
      });
    return n.common.async ? N.mergeObjectAsync(r, s) : N.mergeObjectSync(r, s);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, r, n) {
    return r instanceof w ? new Ie({
      keyType: e,
      valueType: r,
      typeName: _.ZodRecord,
      ...b(n)
    }) : new Ie({
      keyType: Z.create(),
      valueType: e,
      typeName: _.ZodRecord,
      ...b(r)
    });
  }
}
class Qe extends w {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== m.map)
      return p(n, {
        code: f.invalid_type,
        expected: m.map,
        received: n.parsedType
      }), v;
    const s = this._def.keyType, i = this._def.valueType, a = [...n.data.entries()].map(([o, c], u) => ({
      key: s._parse(new F(n, o, n.path, [u, "key"])),
      value: i._parse(new F(n, c, n.path, [u, "value"]))
    }));
    if (n.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of a) {
          const u = await c.key, l = await c.value;
          if (u.status === "aborted" || l.status === "aborted")
            return v;
          (u.status === "dirty" || l.status === "dirty") && r.dirty(), o.set(u.value, l.value);
        }
        return { status: r.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const c of a) {
        const u = c.key, l = c.value;
        if (u.status === "aborted" || l.status === "aborted")
          return v;
        (u.status === "dirty" || l.status === "dirty") && r.dirty(), o.set(u.value, l.value);
      }
      return { status: r.value, value: o };
    }
  }
}
Qe.create = (t, e, r) => new Qe({
  valueType: e,
  keyType: t,
  typeName: _.ZodMap,
  ...b(r)
});
class ae extends w {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== m.set)
      return p(n, {
        code: f.invalid_type,
        expected: m.set,
        received: n.parsedType
      }), v;
    const s = this._def;
    s.minSize !== null && n.data.size < s.minSize.value && (p(n, {
      code: f.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.minSize.message
    }), r.dirty()), s.maxSize !== null && n.data.size > s.maxSize.value && (p(n, {
      code: f.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.maxSize.message
    }), r.dirty());
    const i = this._def.valueType;
    function a(c) {
      const u = /* @__PURE__ */ new Set();
      for (const l of c) {
        if (l.status === "aborted")
          return v;
        l.status === "dirty" && r.dirty(), u.add(l.value);
      }
      return { status: r.value, value: u };
    }
    const o = [...n.data.values()].map((c, u) => i._parse(new F(n, c, n.path, u)));
    return n.common.async ? Promise.all(o).then((c) => a(c)) : a(o);
  }
  min(e, r) {
    return new ae({
      ...this._def,
      minSize: { value: e, message: y.toString(r) }
    });
  }
  max(e, r) {
    return new ae({
      ...this._def,
      maxSize: { value: e, message: y.toString(r) }
    });
  }
  size(e, r) {
    return this.min(e, r).max(e, r);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
ae.create = (t, e) => new ae({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: _.ZodSet,
  ...b(e)
});
class fe extends w {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== m.function)
      return p(r, {
        code: f.invalid_type,
        expected: m.function,
        received: r.parsedType
      }), v;
    function n(o, c) {
      return He({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          We(),
          he
        ].filter((u) => !!u),
        issueData: {
          code: f.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function s(o, c) {
      return He({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          We(),
          he
        ].filter((u) => !!u),
        issueData: {
          code: f.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const i = { errorMap: r.common.contextualErrorMap }, a = r.data;
    if (this._def.returns instanceof ye) {
      const o = this;
      return L(async function(...c) {
        const u = new j([]), l = await o._def.args.parseAsync(c, i).catch((k) => {
          throw u.addIssue(n(c, k)), u;
        }), h = await Reflect.apply(a, this, l);
        return await o._def.returns._def.type.parseAsync(h, i).catch((k) => {
          throw u.addIssue(s(h, k)), u;
        });
      });
    } else {
      const o = this;
      return L(function(...c) {
        const u = o._def.args.safeParse(c, i);
        if (!u.success)
          throw new j([n(c, u.error)]);
        const l = Reflect.apply(a, this, u.data), h = o._def.returns.safeParse(l, i);
        if (!h.success)
          throw new j([s(l, h.error)]);
        return h.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new fe({
      ...this._def,
      args: V.create(e).rest(ne.create())
    });
  }
  returns(e) {
    return new fe({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, r, n) {
    return new fe({
      args: e || V.create([]).rest(ne.create()),
      returns: r || ne.create(),
      typeName: _.ZodFunction,
      ...b(n)
    });
  }
}
class je extends w {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
je.create = (t, e) => new je({
  getter: t,
  typeName: _.ZodLazy,
  ...b(e)
});
class $e extends w {
  _parse(e) {
    if (e.data !== this._def.value) {
      const r = this._getOrReturnCtx(e);
      return p(r, {
        received: r.data,
        code: f.invalid_literal,
        expected: this._def.value
      }), v;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
$e.create = (t, e) => new $e({
  value: t,
  typeName: _.ZodLiteral,
  ...b(e)
});
function en(t, e) {
  return new ee({
    values: t,
    typeName: _.ZodEnum,
    ...b(e)
  });
}
class ee extends w {
  constructor() {
    super(...arguments), ke.set(this, void 0);
  }
  _parse(e) {
    if (typeof e.data != "string") {
      const r = this._getOrReturnCtx(e), n = this._def.values;
      return p(r, {
        expected: x.joinValues(n),
        received: r.parsedType,
        code: f.invalid_type
      }), v;
    }
    if (Je(this, ke, "f") || Gr(this, ke, new Set(this._def.values), "f"), !Je(this, ke, "f").has(e.data)) {
      const r = this._getOrReturnCtx(e), n = this._def.values;
      return p(r, {
        received: r.data,
        code: f.invalid_enum_value,
        options: n
      }), v;
    }
    return L(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Values() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  extract(e, r = this._def) {
    return ee.create(e, {
      ...this._def,
      ...r
    });
  }
  exclude(e, r = this._def) {
    return ee.create(this.options.filter((n) => !e.includes(n)), {
      ...this._def,
      ...r
    });
  }
}
ke = /* @__PURE__ */ new WeakMap();
ee.create = en;
class Me extends w {
  constructor() {
    super(...arguments), Te.set(this, void 0);
  }
  _parse(e) {
    const r = x.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);
    if (n.parsedType !== m.string && n.parsedType !== m.number) {
      const s = x.objectValues(r);
      return p(n, {
        expected: x.joinValues(s),
        received: n.parsedType,
        code: f.invalid_type
      }), v;
    }
    if (Je(this, Te, "f") || Gr(this, Te, new Set(x.getValidEnumValues(this._def.values)), "f"), !Je(this, Te, "f").has(e.data)) {
      const s = x.objectValues(r);
      return p(n, {
        received: n.data,
        code: f.invalid_enum_value,
        options: s
      }), v;
    }
    return L(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
Te = /* @__PURE__ */ new WeakMap();
Me.create = (t, e) => new Me({
  values: t,
  typeName: _.ZodNativeEnum,
  ...b(e)
});
class ye extends w {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== m.promise && r.common.async === !1)
      return p(r, {
        code: f.invalid_type,
        expected: m.promise,
        received: r.parsedType
      }), v;
    const n = r.parsedType === m.promise ? r.data : Promise.resolve(r.data);
    return L(n.then((s) => this._def.type.parseAsync(s, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
ye.create = (t, e) => new ye({
  type: t,
  typeName: _.ZodPromise,
  ...b(e)
});
class U extends w {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === _.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e), s = this._def.effect || null, i = {
      addIssue: (a) => {
        p(n, a), a.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), s.type === "preprocess") {
      const a = s.transform(n.data, i);
      if (n.common.async)
        return Promise.resolve(a).then(async (o) => {
          if (r.value === "aborted")
            return v;
          const c = await this._def.schema._parseAsync({
            data: o,
            path: n.path,
            parent: n
          });
          return c.status === "aborted" ? v : c.status === "dirty" || r.value === "dirty" ? le(c.value) : c;
        });
      {
        if (r.value === "aborted")
          return v;
        const o = this._def.schema._parseSync({
          data: a,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? v : o.status === "dirty" || r.value === "dirty" ? le(o.value) : o;
      }
    }
    if (s.type === "refinement") {
      const a = (o) => {
        const c = s.refinement(o, i);
        if (n.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (n.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? v : (o.status === "dirty" && r.dirty(), a(o.value), { status: r.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => o.status === "aborted" ? v : (o.status === "dirty" && r.dirty(), a(o.value).then(() => ({ status: r.value, value: o.value }))));
    }
    if (s.type === "transform")
      if (n.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!se(a))
          return a;
        const o = s.transform(a.value, i);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => se(a) ? Promise.resolve(s.transform(a.value, i)).then((o) => ({ status: r.value, value: o })) : a);
    x.assertNever(s);
  }
}
U.create = (t, e, r) => new U({
  schema: t,
  typeName: _.ZodEffects,
  effect: e,
  ...b(r)
});
U.createWithPreprocess = (t, e, r) => new U({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: _.ZodEffects,
  ...b(r)
});
class q extends w {
  _parse(e) {
    return this._getType(e) === m.undefined ? L(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
q.create = (t, e) => new q({
  innerType: t,
  typeName: _.ZodOptional,
  ...b(e)
});
class te extends w {
  _parse(e) {
    return this._getType(e) === m.null ? L(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
te.create = (t, e) => new te({
  innerType: t,
  typeName: _.ZodNullable,
  ...b(e)
});
class Ze extends w {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    let n = r.data;
    return r.parsedType === m.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Ze.create = (t, e) => new Ze({
  innerType: t,
  typeName: _.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...b(e)
});
class De extends w {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, s = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return Oe(s) ? s.then((i) => ({
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new j(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new j(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
De.create = (t, e) => new De({
  innerType: t,
  typeName: _.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...b(e)
});
class Xe extends w {
  _parse(e) {
    if (this._getType(e) !== m.nan) {
      const n = this._getOrReturnCtx(e);
      return p(n, {
        code: f.invalid_type,
        expected: m.nan,
        received: n.parsedType
      }), v;
    }
    return { status: "valid", value: e.data };
  }
}
Xe.create = (t) => new Xe({
  typeName: _.ZodNaN,
  ...b(t)
});
const Zi = Symbol("zod_brand");
class zt extends w {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class qe extends w {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return i.status === "aborted" ? v : i.status === "dirty" ? (r.dirty(), le(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return s.status === "aborted" ? v : s.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(e, r) {
    return new qe({
      in: e,
      out: r,
      typeName: _.ZodPipeline
    });
  }
}
class Ue extends w {
  _parse(e) {
    const r = this._def.innerType._parse(e), n = (s) => (se(s) && (s.value = Object.freeze(s.value)), s);
    return Oe(r) ? r.then((s) => n(s)) : n(r);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ue.create = (t, e) => new Ue({
  innerType: t,
  typeName: _.ZodReadonly,
  ...b(e)
});
function cr(t, e) {
  const r = typeof t == "function" ? t(e) : typeof t == "string" ? { message: t } : t;
  return typeof r == "string" ? { message: r } : r;
}
function tn(t, e = {}, r) {
  return t ? me.create().superRefine((n, s) => {
    var i, a;
    const o = t(n);
    if (o instanceof Promise)
      return o.then((c) => {
        var u, l;
        if (!c) {
          const h = cr(e, n), g = (l = (u = h.fatal) !== null && u !== void 0 ? u : r) !== null && l !== void 0 ? l : !0;
          s.addIssue({ code: "custom", ...h, fatal: g });
        }
      });
    if (!o) {
      const c = cr(e, n), u = (a = (i = c.fatal) !== null && i !== void 0 ? i : r) !== null && a !== void 0 ? a : !0;
      s.addIssue({ code: "custom", ...c, fatal: u });
    }
  }) : me.create();
}
const Di = {
  object: C.lazycreate
};
var _;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly";
})(_ || (_ = {}));
const Ui = (t, e = {
  message: `Input not instance of ${t.name}`
}) => tn((r) => r instanceof t, e), rn = Z.create, nn = X.create, zi = Xe.create, qi = K.create, sn = Se.create, Fi = ie.create, Vi = Ye.create, Bi = Pe.create, Wi = Ae.create, Hi = me.create, Ji = ne.create, Yi = G.create, Gi = Ge.create, Qi = D.create, Xi = C.create, Ki = C.strictCreate, ea = Ne.create, ta = ct.create, ra = Le.create, na = V.create, sa = Ie.create, ia = Qe.create, aa = ae.create, oa = fe.create, ca = je.create, ua = $e.create, da = ee.create, la = Me.create, fa = ye.create, ur = U.create, pa = q.create, ha = te.create, ma = U.createWithPreprocess, ya = qe.create, ga = () => rn().optional(), _a = () => nn().optional(), va = () => sn().optional(), ba = {
  string: (t) => Z.create({ ...t, coerce: !0 }),
  number: (t) => X.create({ ...t, coerce: !0 }),
  boolean: (t) => Se.create({
    ...t,
    coerce: !0
  }),
  bigint: (t) => K.create({ ...t, coerce: !0 }),
  date: (t) => ie.create({ ...t, coerce: !0 })
}, wa = v;
var d = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: he,
  setErrorMap: mi,
  getErrorMap: We,
  makeIssue: He,
  EMPTY_PATH: yi,
  addIssueToContext: p,
  ParseStatus: N,
  INVALID: v,
  DIRTY: le,
  OK: L,
  isAborted: kt,
  isDirty: Tt,
  isValid: se,
  isAsync: Oe,
  get util() {
    return x;
  },
  get objectUtil() {
    return xt;
  },
  ZodParsedType: m,
  getParsedType: Y,
  ZodType: w,
  datetimeRegex: Kr,
  ZodString: Z,
  ZodNumber: X,
  ZodBigInt: K,
  ZodBoolean: Se,
  ZodDate: ie,
  ZodSymbol: Ye,
  ZodUndefined: Pe,
  ZodNull: Ae,
  ZodAny: me,
  ZodUnknown: ne,
  ZodNever: G,
  ZodVoid: Ge,
  ZodArray: D,
  ZodObject: C,
  ZodUnion: Ne,
  ZodDiscriminatedUnion: ct,
  ZodIntersection: Le,
  ZodTuple: V,
  ZodRecord: Ie,
  ZodMap: Qe,
  ZodSet: ae,
  ZodFunction: fe,
  ZodLazy: je,
  ZodLiteral: $e,
  ZodEnum: ee,
  ZodNativeEnum: Me,
  ZodPromise: ye,
  ZodEffects: U,
  ZodTransformer: U,
  ZodOptional: q,
  ZodNullable: te,
  ZodDefault: Ze,
  ZodCatch: De,
  ZodNaN: Xe,
  BRAND: Zi,
  ZodBranded: zt,
  ZodPipeline: qe,
  ZodReadonly: Ue,
  custom: tn,
  Schema: w,
  ZodSchema: w,
  late: Di,
  get ZodFirstPartyTypeKind() {
    return _;
  },
  coerce: ba,
  any: Hi,
  array: Qi,
  bigint: qi,
  boolean: sn,
  date: Fi,
  discriminatedUnion: ta,
  effect: ur,
  enum: da,
  function: oa,
  instanceof: Ui,
  intersection: ra,
  lazy: ca,
  literal: ua,
  map: ia,
  nan: zi,
  nativeEnum: la,
  never: Yi,
  null: Wi,
  nullable: ha,
  number: nn,
  object: Xi,
  oboolean: va,
  onumber: _a,
  optional: pa,
  ostring: ga,
  pipeline: ya,
  preprocess: ma,
  promise: fa,
  record: sa,
  set: aa,
  strictObject: Ki,
  string: rn,
  symbol: Vi,
  transformer: ur,
  tuple: na,
  undefined: Bi,
  union: ea,
  unknown: Ji,
  void: Gi,
  NEVER: wa,
  ZodIssueCode: f,
  quotelessJson: hi,
  ZodError: j
});
const an = /^0x[0-9a-f]+$/i, on = /^\d+$/, xa = d.string().min(1, "The short string cannot be empty").max(31, "The short string cannot exceed 31 characters").refine(
  (t) => !an.test(t),
  "The shortString should not be a hex string"
).refine(
  (t) => !on.test(t),
  "The shortString should not be an integer string"
), M = d.union([
  d.string().regex(
    an,
    "Only hex, integers and bigint are supported in calldata"
  ),
  d.string().regex(
    on,
    "Only hex, integers and bigint are supported in calldata"
  ),
  xa,
  d.number().int("Only hex, integers and bigint are supported in calldata"),
  d.bigint()
]), ze = d.object({
  contractAddress: d.string(),
  entrypoint: d.string(),
  calldata: d.array(M.or(d.array(M))).optional()
}), Ct = d.array(ze).nonempty(), cn = d.object({
  types: d.record(
    d.array(
      d.union([
        d.object({
          name: d.string(),
          type: d.literal("merkletree"),
          contains: d.string()
        }),
        d.object({
          name: d.string(),
          type: d.literal("enum"),
          contains: d.string()
        }),
        d.object({
          name: d.string(),
          type: d.string()
        })
      ])
    )
  ),
  primaryType: d.string(),
  domain: d.record(d.unknown()),
  message: d.record(d.unknown()).or(d.object({}))
}), Rt = d.object({
  type: d.literal("ERC20"),
  options: d.object({
    address: d.string(),
    symbol: d.string().optional(),
    decimals: d.number().optional(),
    image: d.string().optional(),
    name: d.string().optional()
  })
}), ka = d.union([
  d.object({
    id: d.string(),
    chain_id: d.string(),
    chain_name: d.string(),
    rpc_urls: d.array(d.string()).optional(),
    native_currency: Rt.optional(),
    block_explorer_url: d.array(d.string()).optional()
  }),
  d.object({
    id: d.string(),
    chainId: d.string(),
    chainName: d.string(),
    rpcUrls: d.array(d.string()).optional(),
    nativeCurrency: Rt.optional(),
    blockExplorerUrl: d.array(d.string()).optional()
  }).transform((t) => ({
    id: t.id,
    chain_id: t.chainId,
    chain_name: t.chainName,
    rpc_urls: t.rpcUrls,
    native_currency: t.nativeCurrency,
    block_explorer_url: t.blockExplorerUrl
  }))
]), _t = {
  enable: d.tuple([
    d.object({
      starknetVersion: d.union([d.literal("v3"), d.literal("v4"), d.literal("v5")]).optional()
    }).optional()
  ]).or(d.tuple([])),
  addStarknetChain: d.tuple([ka]),
  switchStarknetChain: d.tuple([
    d.object({
      chainId: d.string()
    })
  ]),
  watchAsset: d.tuple([Rt]),
  requestAccounts: d.tuple([
    d.object({
      silent_mode: d.boolean().optional()
    })
  ]),
  execute: d.tuple([
    Ct.or(ze),
    d.object({
      nonce: M.optional(),
      maxFee: M.optional(),
      version: M.optional()
    }).optional()
  ]),
  signMessage: d.tuple([cn])
};
d.tuple([
  Ct.or(ze),
  d.object({
    nonce: M.optional(),
    maxFee: M.optional(),
    version: M.optional()
  }).optional()
]).or(
  d.tuple([
    Ct.or(ze),
    d.array(d.any()).optional(),
    d.object({
      nonce: M.optional(),
      maxFee: M.optional(),
      version: M.optional()
    }).optional()
  ])
);
const un = d.object({
  contract_address: d.string(),
  entry_point: d.string(),
  calldata: d.array(M).optional()
}).transform(({ contract_address: t, entry_point: e, calldata: r }) => ({
  contractAddress: t,
  entrypoint: e,
  calldata: r || []
})), Ta = d.array(un).nonempty(), Ea = {
  ZERO: 0,
  ONE: 1
}, Ca = d.object({
  address: d.string(),
  class_hash: d.string(),
  salt: d.string(),
  calldata: d.array(d.string()),
  sigdata: d.array(d.string()).optional(),
  //version: z.literal([0, 1]),
  version: d.nativeEnum(Ea)
  // allow only 0 | 1, workaround since zod doesn't support literals as numbers
}), Ra = d.object({
  callbackData: d.string().optional(),
  approvalRequests: d.array(
    d.object({
      tokenAddress: d.string(),
      amount: d.string(),
      spender: d.string()
    })
  ),
  sessionTypedData: cn
}), Oa = d.object({
  account: d.string().array().optional(),
  chainId: d.string().optional(),
  signature: d.string().array().optional(),
  approvalTransactionHash: d.string().optional(),
  deploymentPayload: d.any().optional(),
  approvalRequestsCalls: d.array(ze).optional(),
  errorCode: d.enum([
    "USER_REJECTED",
    "ACCOUNT_NOT_DEPLOYED",
    "NOT_ENOUGH_BALANCE",
    "NOT_ENOUGH_BALANCE_DEPLOYMENT",
    "GENERIC_ERROR"
  ]).optional()
}), O = es.create({
  isServer: !1,
  allowOutsideOfServer: !0
});
let Ot = pn, St = "", dn = "";
const Za = ({
  width: t = 775,
  height: e = 385,
  origin: r,
  location: n,
  atLeftBottom: s = !1
}) => {
  const i = window?.outerWidth ?? window?.innerWidth ?? window?.screen.width ?? 0, a = window?.outerHeight ?? window?.innerHeight ?? window?.screen.height ?? 0, o = window?.screenLeft ?? window?.screenX ?? 0, c = window?.screenTop ?? window?.screenY ?? 0, u = s ? 0 : o + i / 2 - t / 2, l = s ? window.screen.availHeight + 10 : c + a / 2 - e / 2;
  Ot = r ?? Ot, St = n ?? St, dn = `width=${t},height=${e},top=${l},left=${u},toolbar=no,menubar=no,scrollbars=no,location=no,status=no,popup=1`;
};
O.router({
  authorize: O.procedure.output(d.boolean()).mutation(async () => !0),
  connect: O.procedure.mutation(async () => ""),
  connectWebwallet: O.procedure.input(
    d.object({
      theme: d.enum(["light", "dark", "auto"]).optional()
    })
  ).output(
    d.object({
      account: d.string().array().optional(),
      chainId: d.string().optional()
    })
  ).mutation(async () => ({})),
  connectWebwalletSSO: O.procedure.input(
    d.object({ token: d.string(), authorizedPartyId: d.string().optional() })
  ).output(
    d.object({
      account: d.string().array().optional(),
      chainId: d.string().optional()
    })
  ).mutation(async () => ({})),
  connectAndSignSession: O.procedure.input(Ra).output(Oa).mutation(async () => ({})),
  enable: O.procedure.output(d.string()).mutation(async () => ""),
  execute: O.procedure.input(_t.execute).output(d.string()).mutation(async () => ""),
  signMessage: O.procedure.input(_t.signMessage).output(d.string().array()).mutation(async () => []),
  getLoginStatus: O.procedure.output(
    d.object({
      isLoggedIn: d.boolean(),
      hasSession: d.boolean().optional(),
      isPreauthorized: d.boolean().optional()
    })
  ).mutation(async () => ({
    isLoggedIn: !0
  })),
  // RPC Messages
  requestAccounts: O.procedure.input(d.object({ silent_mode: d.boolean().optional() })).output(d.string().array()).mutation(async () => []),
  requestChainId: O.procedure.output(d.string()).mutation(async () => ""),
  signTypedData: O.procedure.input(_t.signMessage).output(d.string().array()).mutation(async () => []),
  getPermissions: O.procedure.output(d.array(d.enum([Bt.ACCOUNTS]))).mutation(async () => [Bt.ACCOUNTS]),
  addInvokeTransaction: O.procedure.input(un.or(Ta)).output(d.string()).mutation(async (t) => ""),
  addStarknetChain: O.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  switchStarknetChain: O.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  watchAsset: O.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  updateModal: O.procedure.subscription(async () => {
  }),
  deploymentData: O.procedure.output(Ca).mutation(async () => ({
    address: "",
    calldata: [],
    version: 0,
    class_hash: "",
    salt: ""
  }))
});
const Da = ({
  iframe: t
}) => Dn({
  links: [
    In({
      enabled: (e) => process.env.NODE_ENV === "development" && typeof window < "u" || process.env.NODE_ENV === "development" && e.direction === "down" && e.result instanceof Error
    }),
    wn({
      condition(e) {
        if (!t && e.type === "subscription")
          throw new Error(
            "subscription is not supported without an iframe window"
          );
        return !!t;
      },
      true: vt.windowLink({
        window,
        postWindow: t,
        postOrigin: "*"
      }),
      false: vt.popupLink({
        listenWindow: window,
        createPopup: () => {
          let e = null;
          const r = document.createElement("button");
          if (r.style.display = "none", r.addEventListener("click", () => {
            e = window.open(
              `${Ot}${St}`,
              "popup",
              dn
            );
          }), r.click(), (async () => {
            for (; !e; )
              await new Promise((n) => setTimeout(n, 100));
          })(), !e)
            throw new Error("Could not open popup");
          return e;
        },
        postOrigin: "*"
      })
    })
  ]
});
export {
  pn as D,
  Ia as M,
  La as T,
  Na as a,
  ja as g,
  $a as m,
  Za as s,
  Da as t
};
