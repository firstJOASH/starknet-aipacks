import { WalletAccount as N, stark as F, ec as T } from "starknet";
import * as C from "../../../node_modules/.pnpm/@cartridge+controller-wasm@0.2.3/node_modules/@cartridge/controller-wasm/pkg-session/session_wasm_bg.wasm";
import { n as J, B as z, K, b as E } from "./provider-C1UeMjUr.js";
import { F as Y, N as X, R as Z } from "./provider-C1UeMjUr.js";
let a;
function j(n) {
  a = n;
}
const g = new Array(128).fill(void 0);
g.push(void 0, null, !0, !1);
function D(n) {
  return g[n];
}
let _ = 0, b = null;
function O() {
  return (b === null || b.byteLength === 0) && (b = new Uint8Array(a.memory.buffer)), b;
}
const M = typeof TextEncoder > "u" ? (0, module.require)("util").TextEncoder : TextEncoder;
let x = new M("utf-8");
const P = typeof x.encodeInto == "function" ? function(n, e) {
  return x.encodeInto(n, e);
} : function(n, e) {
  const r = x.encode(n);
  return e.set(r), {
    read: n.length,
    written: r.length
  };
};
function k(n, e, r) {
  if (r === void 0) {
    const i = x.encode(n), u = e(i.length, 1) >>> 0;
    return O().subarray(u, u + i.length).set(i), _ = i.length, u;
  }
  let t = n.length, s = e(t, 1) >>> 0;
  const c = O();
  let o = 0;
  for (; o < t; o++) {
    const i = n.charCodeAt(o);
    if (i > 127) break;
    c[s + o] = i;
  }
  if (o !== t) {
    o !== 0 && (n = n.slice(o)), s = r(s, t, t = o + n.length * 3, 1) >>> 0;
    const i = O().subarray(s + o, s + t), u = P(n, i);
    o += u.written, s = r(s, t, o, 1) >>> 0;
  }
  return _ = o, s;
}
let h = null;
function f() {
  return (h === null || h.buffer.detached === !0 || h.buffer.detached === void 0 && h.buffer !== a.memory.buffer) && (h = new DataView(a.memory.buffer)), h;
}
const V = typeof TextDecoder > "u" ? (0, module.require)("util").TextDecoder : TextDecoder;
let $ = new V("utf-8", { ignoreBOM: !0, fatal: !0 });
$.decode();
let y = g.length;
function l(n) {
  y === g.length && g.push(g.length + 1);
  const e = y;
  return y = g[e], g[e] = n, e;
}
function G(n) {
  n < 132 || (g[n] = y, y = n);
}
function w(n) {
  const e = D(n);
  return G(n), e;
}
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => {
  a.__wbindgen_export_4.get(n.dtor)(n.a, n.b);
});
function v(n, e) {
  const r = e(n.length * 4, 4) >>> 0, t = f();
  for (let s = 0; s < n.length; s++)
    t.setUint32(r + 4 * s, l(n[s]), !0);
  return _ = n.length, r;
}
const R = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((n) => a.__wbg_cartridgesessionaccount_free(n >>> 0, 1));
class S {
  static __wrap(e) {
    e = e >>> 0;
    const r = Object.create(S.prototype);
    return r.__wbg_ptr = e, R.register(r, r.__wbg_ptr, r), r;
  }
  __destroy_into_raw() {
    const e = this.__wbg_ptr;
    return this.__wbg_ptr = 0, R.unregister(this), e;
  }
  free() {
    const e = this.__destroy_into_raw();
    a.__wbg_cartridgesessionaccount_free(e, 0);
  }
  /**
   * @param {string} rpc_url
   * @param {JsFelt} signer
   * @param {JsFelt} address
   * @param {JsFelt} chain_id
   * @param {JsFelt[]} session_authorization
   * @param {Session} session
   * @returns {CartridgeSessionAccount}
   */
  static new(e, r, t, s, c, o) {
    try {
      const d = a.__wbindgen_add_to_stack_pointer(-16), m = k(e, a.__wbindgen_export_0, a.__wbindgen_export_1), I = _, U = v(c, a.__wbindgen_export_0), A = _;
      a.cartridgesessionaccount_new(d, m, I, l(r), l(t), l(s), U, A, l(o));
      var i = f().getInt32(d + 4 * 0, !0), u = f().getInt32(d + 4 * 1, !0), p = f().getInt32(d + 4 * 2, !0);
      if (p)
        throw w(u);
      return S.__wrap(i);
    } finally {
      a.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} rpc_url
   * @param {JsFelt} signer
   * @param {JsFelt} address
   * @param {JsFelt} owner_guid
   * @param {JsFelt} chain_id
   * @param {Session} session
   * @returns {CartridgeSessionAccount}
   */
  static newAsRegistered(e, r, t, s, c, o) {
    try {
      const d = a.__wbindgen_add_to_stack_pointer(-16), m = k(e, a.__wbindgen_export_0, a.__wbindgen_export_1), I = _;
      a.cartridgesessionaccount_newAsRegistered(d, m, I, l(r), l(t), l(s), l(c), l(o));
      var i = f().getInt32(d + 4 * 0, !0), u = f().getInt32(d + 4 * 1, !0), p = f().getInt32(d + 4 * 2, !0);
      if (p)
        throw w(u);
      return S.__wrap(i);
    } finally {
      a.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {JsFelt} hash
   * @param {JsCall[]} calls
   * @returns {Promise<Felts>}
   */
  sign(e, r) {
    const t = v(r, a.__wbindgen_export_0), s = _, c = a.cartridgesessionaccount_sign(this.__wbg_ptr, l(e), t, s);
    return w(c);
  }
  /**
   * @param {JsCall[]} calls
   * @returns {Promise<any>}
   */
  execute(e) {
    const r = v(e, a.__wbindgen_export_0), t = _, s = a.cartridgesessionaccount_execute(this.__wbg_ptr, r, t);
    return w(s);
  }
  /**
   * @param {JsCall[]} calls
   * @returns {Promise<any>}
   */
  executeFromOutside(e) {
    const r = v(e, a.__wbindgen_export_0), t = _, s = a.cartridgesessionaccount_executeFromOutside(this.__wbg_ptr, r, t);
    return w(s);
  }
}
typeof FinalizationRegistry > "u" || new FinalizationRegistry((n) => a.__wbg_jscontrollererror_free(n >>> 0, 1));
j(C);
class W extends N {
  controller;
  constructor(e, {
    rpcUrl: r,
    privateKey: t,
    address: s,
    ownerGuid: c,
    chainId: o,
    expiresAt: i,
    policies: u,
    guardianKeyGuid: p,
    metadataHash: d,
    sessionKeyGuid: m
  }) {
    super({ nodeUrl: r }, e, s), this.controller = S.newAsRegistered(
      r,
      t,
      s,
      c,
      o,
      {
        expiresAt: i,
        policies: u,
        guardianKeyGuid: p,
        metadataHash: d,
        sessionKeyGuid: m
      }
    );
  }
  /**
   * Invoke execute function in account contract
   *
   * @param calls the invocation object or an array of them, containing:
   * - contractAddress - the address of the contract
   * - entrypoint - the entrypoint of the contract
   * - calldata - (defaults to []) the calldata
   * - signature - (defaults to []) the signature
   * @param abis (optional) the abi of the contract for better displaying
   *
   * @returns response from addTransaction
   */
  async execute(e) {
    return this.controller.execute(J(e));
  }
}
class Q extends z {
  id = "controller_session";
  name = "Controller Session";
  _chainId;
  _rpcUrl;
  _username;
  _redirectUrl;
  _policies;
  _keychainUrl;
  constructor({
    rpc: e,
    chainId: r,
    policies: t,
    redirectUrl: s,
    keychainUrl: c
  }) {
    super(), this._policies = {
      verified: !1,
      contracts: t.contracts ? Object.fromEntries(
        Object.entries(t.contracts).map(([o, i]) => [
          o,
          {
            ...i,
            methods: i.methods.map((u) => ({
              ...u,
              authorized: !0
            }))
          }
        ])
      ) : void 0,
      messages: t.messages?.map((o) => ({
        ...o,
        authorized: !0
      }))
    }, this._rpcUrl = e, this._chainId = r, this._redirectUrl = s, this._keychainUrl = c || K, typeof window < "u" && (window.starknet_controller_session = this);
  }
  validatePoliciesSubset(e, r) {
    if (e.contracts) {
      if (!r.contracts) return !1;
      for (const [t, s] of Object.entries(e.contracts)) {
        const c = r.contracts[t];
        if (!c) return !1;
        for (const o of s.methods) {
          const i = c.methods.find(
            (u) => u.entrypoint === o.entrypoint
          );
          if (!i || !i.authorized) return !1;
        }
      }
    }
    if (e.messages) {
      if (!r.messages) return !1;
      for (const t of e.messages) {
        const s = r.messages.find(
          (c) => JSON.stringify(c.domain) === JSON.stringify(t.domain) && JSON.stringify(c.types) === JSON.stringify(t.types)
        );
        if (!s || !s.authorized) return !1;
      }
    }
    return !0;
  }
  async username() {
    return await this.tryRetrieveFromQueryOrStorage(), this._username;
  }
  async probe() {
    return this.account ? this.account : (this.account = await this.tryRetrieveFromQueryOrStorage(), this.account);
  }
  async connect() {
    if (this.account)
      return this.account;
    if (this.account = await this.tryRetrieveFromQueryOrStorage(), this.account)
      return this.account;
    const e = F.randomAddress(), r = T.starkCurve.getStarkKey(e);
    localStorage.setItem(
      "sessionSigner",
      JSON.stringify({
        privKey: e,
        pubKey: r
      })
    ), localStorage.setItem("sessionPolicies", JSON.stringify(this._policies));
    const t = `${this._keychainUrl}/session?public_key=${r}&redirect_uri=${this._redirectUrl}&redirect_query_name=startapp&policies=${JSON.stringify(
      this._policies
    )}&rpc_url=${this._rpcUrl}`;
    return localStorage.setItem("lastUsedConnector", this.id), window.open(t, "_blank"), this.account;
  }
  switchStarknetChain(e) {
    throw new Error("switchStarknetChain not implemented");
  }
  addStarknetChain(e) {
    throw new Error("addStarknetChain not implemented");
  }
  disconnect() {
    return localStorage.removeItem("sessionSigner"), localStorage.removeItem("session"), localStorage.removeItem("sessionPolicies"), this.account = void 0, this._username = void 0, Promise.resolve();
  }
  async tryRetrieveFromQueryOrStorage() {
    if (this.account)
      return this.account;
    const e = localStorage.getItem("sessionSigner"), r = e ? JSON.parse(e) : null;
    let t = null;
    if (window.location.search.includes("startapp")) {
      const o = new URLSearchParams(window.location.search), i = o.get("startapp");
      if (i) {
        t = JSON.parse(atob(i)), localStorage.setItem("session", JSON.stringify(t)), o.delete("startapp");
        const u = window.location.pathname + (o.toString() ? `?${o.toString()}` : "") + window.location.hash;
        window.history.replaceState({}, document.title, u);
      }
    }
    if (!t) {
      const o = localStorage.getItem("session");
      o && (t = JSON.parse(o));
    }
    if (!t || !r)
      return;
    const s = parseInt(t.expiresAt) * 1e3;
    if (Date.now() >= s) {
      this.clearStoredSession();
      return;
    }
    const c = localStorage.getItem("sessionPolicies");
    if (c) {
      const o = JSON.parse(
        c
      );
      if (!this.validatePoliciesSubset(
        this._policies,
        o
      )) {
        this.clearStoredSession();
        return;
      }
    }
    return this._username = t.username, this.account = new W(this, {
      rpcUrl: this._rpcUrl,
      privateKey: r.privKey,
      address: t.address,
      ownerGuid: t.ownerGuid,
      chainId: this._chainId,
      expiresAt: parseInt(t.expiresAt),
      policies: E(this._policies),
      guardianKeyGuid: t.guardianKeyGuid,
      metadataHash: t.metadataHash,
      sessionKeyGuid: t.sessionKeyGuid
    }), this.account;
  }
  clearStoredSession() {
    localStorage.removeItem("sessionSigner"), localStorage.removeItem("session"), localStorage.removeItem("sessionPolicies");
  }
}
export {
  Y as FeeSource,
  X as NotReadyToConnect,
  Z as ResponseCodes,
  Q as default
};
//# sourceMappingURL=session.js.map
