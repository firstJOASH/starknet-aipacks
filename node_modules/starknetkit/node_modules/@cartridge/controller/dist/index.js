import { WalletAccount as ge, constants as $, shortString as W, num as ye } from "starknet";
import { R, t as be, K as we, B as _e, v as ke, N as p, p as Ae, A as Ie } from "./provider-C1UeMjUr.js";
import { F as tr, h as rr, n as nr, a as sr, b as or } from "./provider-C1UeMjUr.js";
import { connect as ve } from "starknetkit";
import { InjectedConnector as Ee } from "starknetkit/injected";
import { MetaMaskSDK as xe } from "@metamask/sdk";
import { Transaction as Ce } from "@solana/web3.js";
class H extends ge {
  keychain;
  modal;
  options;
  constructor(e, t, n, s, o, a) {
    super({ nodeUrl: t }, e, n), this.keychain = s, this.options = o, this.modal = a;
  }
  /**
   * Invoke execute function in account contract
   *
   * @param calls the invocation object or an array of them, containing:
   * - contractAddress - the address of the contract
   * - entrypoint - the entrypoint of the contract
   * - calldata - (defaults to []) the calldata
   * - signature - (defaults to []) the signature
   * @param abis (optional) the abi of the contract for better displaying
   *
   * @returns response from addTransaction
   */
  async execute(e) {
    return e = be(e), new Promise(async (t, n) => {
      const s = await this.keychain.execute(
        e,
        void 0,
        void 0,
        !1,
        this.options?.feeSource
      );
      if (s.code === R.SUCCESS) {
        t(s);
        return;
      }
      if (this.options?.propagateSessionErrors && s.code !== R.USER_INTERACTION_REQUIRED) {
        n(s.error);
        return;
      }
      this.modal.open();
      const o = await this.keychain.execute(
        e,
        void 0,
        void 0,
        !0,
        s.error
      );
      if (o.code === R.SUCCESS) {
        t(o), this.modal.close();
        return;
      }
      n(o.error);
    });
  }
  /**
   * Sign an JSON object for off-chain usage with the starknet private key and return the signature
   * This adds a message prefix so it cant be interchanged with transactions
   *
   * @param json - JSON object to be signed
   * @returns the signature of the JSON object
   * @throws {Error} if the JSON object is not a valid JSON
   */
  async signMessage(e) {
    return new Promise(async (t, n) => {
      const s = await this.keychain.signMessage(e, "", !0);
      if (!("code" in s)) {
        t(s);
        return;
      }
      this.modal.open();
      const o = await this.keychain.signMessage(e, "", !1);
      "code" in o ? n(o.error) : t(o), this.modal.close();
    });
  }
}
var b;
(function(r) {
  r.Call = "call", r.Reply = "reply", r.Syn = "syn", r.SynAck = "synAck", r.Ack = "ack";
})(b || (b = {}));
var v;
(function(r) {
  r.Fulfilled = "fulfilled", r.Rejected = "rejected";
})(v || (v = {}));
var N;
(function(r) {
  r.ConnectionDestroyed = "ConnectionDestroyed", r.ConnectionTimeout = "ConnectionTimeout", r.NoIframeSrc = "NoIframeSrc";
})(N || (N = {}));
var z;
(function(r) {
  r.DataCloneError = "DataCloneError";
})(z || (z = {}));
var A;
(function(r) {
  r.Message = "message";
})(A || (A = {}));
const Re = (r, e) => {
  const t = [];
  let n = !1;
  return {
    destroy(s) {
      n || (n = !0, e(`${r}: Destroying connection`), t.forEach((o) => {
        o(s);
      }));
    },
    onDestroy(s) {
      n ? s() : t.push(s);
    }
  };
}, Se = (r) => (...e) => {
  r && console.log("[Penpal]", ...e);
}, Pe = {
  "http:": "80",
  "https:": "443"
}, De = /^(https?:)?\/\/([^/:]+)?(:(\d+))?/, Ne = ["file:", "data:"], Me = (r) => {
  if (r && Ne.find((i) => r.startsWith(i)))
    return "null";
  const e = document.location, t = De.exec(r);
  let n, s, o;
  t ? (n = t[1] ? t[1] : e.protocol, s = t[2], o = t[4]) : (n = e.protocol, s = e.hostname, o = e.port);
  const a = o && o !== Pe[n] ? `:${o}` : "";
  return `${n}//${s}${a}`;
}, K = ({ name: r, message: e, stack: t }) => ({
  name: r,
  message: e,
  stack: t
}), Be = (r) => {
  const e = new Error();
  return Object.keys(r).forEach((t) => e[t] = r[t]), e;
}, Te = (r, e, t) => {
  const { localName: n, local: s, remote: o, originForSending: a, originForReceiving: i } = r;
  let c = !1;
  const l = (d) => {
    if (d.source !== o || d.data.penpal !== b.Call)
      return;
    if (i !== "*" && d.origin !== i) {
      t(`${n} received message from origin ${d.origin} which did not match expected origin ${i}`);
      return;
    }
    const h = d.data, { methodName: g, args: u, id: _ } = h;
    t(`${n}: Received ${g}() call`);
    const k = (y) => (I) => {
      if (t(`${n}: Sending ${g}() reply`), c) {
        t(`${n}: Unable to send ${g}() reply due to destroyed connection`);
        return;
      }
      const w = {
        penpal: b.Reply,
        id: _,
        resolution: y,
        returnValue: I
      };
      y === v.Rejected && I instanceof Error && (w.returnValue = K(I), w.returnValueIsError = !0);
      try {
        o.postMessage(w, a);
      } catch (f) {
        if (f.name === z.DataCloneError) {
          const E = {
            penpal: b.Reply,
            id: _,
            resolution: v.Rejected,
            returnValue: K(f),
            returnValueIsError: !0
          };
          o.postMessage(E, a);
        }
        throw f;
      }
    };
    new Promise((y) => y(e[g].call(e, d.origin).apply(e, u))).then(k(v.Fulfilled), k(v.Rejected));
  };
  return s.addEventListener(A.Message, l), () => {
    c = !0, s.removeEventListener(A.Message, l);
  };
};
let Qe = 0;
const Ue = () => ++Qe, re = ".", ne = (r) => r ? r.split(re) : [], $e = (r) => r.join(re), ze = (r, e) => {
  const t = ne(e || "");
  return t.push(r), $e(t);
}, Oe = (r, e, t) => {
  const n = ne(e);
  return n.reduce((s, o, a) => (typeof s[o] > "u" && (s[o] = {}), a === n.length - 1 && (s[o] = t), s[o]), r), r;
}, se = (r, e) => {
  const t = {};
  return Object.keys(r).forEach((n) => {
    const s = r[n], o = ze(n, e);
    typeof s == "object" && Object.assign(t, se(s, o)), typeof s == "function" && (t[o] = s);
  }), t;
}, Le = (r) => {
  const e = {};
  for (const t in r)
    Oe(e, t, r[t]);
  return e;
}, Ye = (r, e, t, n, s) => {
  const { localName: o, local: a, remote: i, originForSending: c, originForReceiving: l } = e;
  let d = !1;
  s(`${o}: Connecting call sender`);
  const h = (u) => (..._) => {
    s(`${o}: Sending ${u}() call`);
    let k;
    try {
      i.closed && (k = !0);
    } catch {
      k = !0;
    }
    if (k && n(), d) {
      const y = new Error(`Unable to send ${u}() call due to destroyed connection`);
      throw y.code = N.ConnectionDestroyed, y;
    }
    return new Promise((y, I) => {
      const w = Ue(), f = (x) => {
        if (x.source !== i || x.data.penpal !== b.Reply || x.data.id !== w)
          return;
        if (l !== "*" && x.origin !== l) {
          s(`${o} received message from origin ${x.origin} which did not match expected origin ${l}`);
          return;
        }
        const Q = x.data;
        s(`${o}: Received ${u}() reply`), a.removeEventListener(A.Message, f);
        let U = Q.returnValue;
        Q.returnValueIsError && (U = Be(U)), (Q.resolution === v.Fulfilled ? y : I)(U);
      };
      a.addEventListener(A.Message, f);
      const E = {
        penpal: b.Call,
        id: w,
        methodName: u,
        args: _
      };
      i.postMessage(E, c);
    });
  }, g = t.reduce((u, _) => (u[_] = h(_), u), {});
  return Object.assign(r, Le(g)), () => {
    d = !0;
  };
}, Fe = (r, e, t, n, s) => {
  const { destroy: o, onDestroy: a } = n;
  let i, c;
  const l = {};
  return (d) => {
    if (e !== "*" && d.origin !== e) {
      s(`Parent: Handshake - Received ACK message from origin ${d.origin} which did not match expected origin ${e}`);
      return;
    }
    s("Parent: Handshake - Received ACK");
    const h = {
      localName: "Parent",
      local: window,
      remote: d.source,
      originForSending: t,
      originForReceiving: e
    };
    i && i(), i = Te(h, r, s), a(i), c && c.forEach((u) => {
      delete l[u];
    }), c = d.data.methodNames;
    const g = Ye(l, h, c, o, s);
    return a(g), l;
  };
}, We = (r, e, t, n) => (s) => {
  if (!s.source)
    return;
  if (t !== "*" && s.origin !== t) {
    r(`Parent: Handshake - Received SYN message from origin ${s.origin} which did not match expected origin ${t}`);
    return;
  }
  r("Parent: Handshake - Received SYN, responding with SYN-ACK");
  const o = {
    penpal: b.SynAck,
    methodNames: Object.keys(e)
  };
  s.source.postMessage(o, n);
}, He = 6e4, Ke = (r, e) => {
  const { destroy: t, onDestroy: n } = e, s = setInterval(() => {
    r.isConnected || (clearInterval(s), t());
  }, He);
  n(() => {
    clearInterval(s);
  });
}, je = (r, e) => {
  let t;
  return r !== void 0 && (t = window.setTimeout(() => {
    const n = new Error(`Connection timed out after ${r}ms`);
    n.code = N.ConnectionTimeout, e(n);
  }, r)), () => {
    clearTimeout(t);
  };
}, qe = (r) => {
  if (!r.src && !r.srcdoc) {
    const e = new Error("Iframe must have src or srcdoc property defined.");
    throw e.code = N.NoIframeSrc, e;
  }
}, Xe = (r) => {
  let { iframe: e, methods: t = {}, childOrigin: n, timeout: s, debug: o = !1 } = r;
  const a = Se(o), i = Re("Parent", a), { onDestroy: c, destroy: l } = i;
  n || (qe(e), n = Me(e.src));
  const d = n === "null" ? "*" : n, h = se(t), g = We(a, h, n, d), u = Fe(h, n, d, i, a);
  return {
    promise: new Promise((k, y) => {
      const I = je(s, l), w = (f) => {
        if (!(f.source !== e.contentWindow || !f.data)) {
          if (f.data.penpal === b.Syn) {
            g(f);
            return;
          }
          if (f.data.penpal === b.Ack) {
            const E = u(f);
            E && (I(), k(E));
            return;
          }
        }
      };
      window.addEventListener(A.Message, w), a("Parent: Awaiting handshake"), Ke(e, i), c((f) => {
        window.removeEventListener(A.Message, w), f && y(f);
      });
    }),
    destroy() {
      l();
    }
  };
};
class Ge {
  url;
  iframe;
  container;
  onClose;
  child;
  closeTimeout;
  constructor({
    id: e,
    url: t,
    preset: n,
    onClose: s,
    onConnect: o,
    methods: a = {}
  }) {
    if (typeof document > "u" || typeof window > "u")
      return;
    n && t.searchParams.set("preset", n), this.url = t;
    const i = document.createElement("iframe");
    i.src = t.toString(), i.id = e, i.style.border = "none", i.sandbox.add("allow-forms"), i.sandbox.add("allow-popups"), i.sandbox.add("allow-popups-to-escape-sandbox"), i.sandbox.add("allow-scripts"), i.sandbox.add("allow-same-origin"), i.allow = "publickey-credentials-create *; publickey-credentials-get *; clipboard-write", document.hasStorageAccess && i.sandbox.add("allow-storage-access-by-user-activation");
    const c = document.createElement("div");
    c.id = "controller", c.style.position = "fixed", c.style.height = "100%", c.style.width = "100%", c.style.top = "0", c.style.left = "0", c.style.zIndex = "10000", c.style.backgroundColor = "rgba(0,0,0,0.6)", c.style.display = "none", c.style.alignItems = "center", c.style.justifyContent = "center", c.style.transition = "opacity 0.2s ease", c.style.opacity = "0", c.style.pointerEvents = "auto", c.appendChild(i), c.addEventListener("click", (h) => {
      h.target === c && (e === "controller-keychain" && this.child && this.child.reset?.().catch((g) => console.error("Error resetting context:", g)), this.close());
    }), this.iframe = i, this.container = c, Xe({
      iframe: this.iframe,
      methods: {
        close: (h) => () => this.close(),
        reload: (h) => () => window.location.reload(),
        ...a
      }
    }).promise.then((h) => {
      this.child = h, o(h);
    }), this.resize(), window.addEventListener("resize", () => this.resize());
    const l = new MutationObserver(() => {
      if (typeof document > "u") return;
      const h = document.getElementById("controller");
      document.body && e === "controller-keychain" && !h && (document.body.appendChild(c), l.disconnect());
    });
    l.observe(document.documentElement, {
      childList: !0,
      subtree: !0
    });
    const d = document.getElementById("controller");
    document.body && e === "controller-keychain" && !d && document.body.appendChild(c), this.onClose = s;
  }
  open() {
    !this.container || typeof document > "u" || !document.body || (this.closeTimeout && (clearTimeout(this.closeTimeout), this.closeTimeout = void 0), document.body.style.overflow = "hidden", this.container.style.display = "flex", requestAnimationFrame(() => {
      this.container && (this.container.style.opacity = "1");
    }));
  }
  close() {
    !this.container || typeof document > "u" || !document.body || (this.onClose?.(), document.body.style.overflow = "auto", this.container.style.opacity = "0", this.closeTimeout = setTimeout(() => {
      this.container && (this.container.style.display = "none"), this.closeTimeout = void 0;
    }, 200));
  }
  sendBackward() {
    this.container && (this.container.style.zIndex = "9999");
  }
  sendForward() {
    this.container && (this.container.style.zIndex = "10000");
  }
  resize() {
    if (!(!this.iframe || typeof window > "u")) {
      if (this.iframe.style.userSelect = "none", window.innerWidth < 768) {
        this.iframe.style.height = "100%", this.iframe.style.width = "100%", this.iframe.style.borderRadius = "0";
        return;
      }
      this.iframe.style.height = "600px", this.iframe.style.width = "432px", this.iframe.style.borderRadius = "8px";
    }
  }
  isOpen() {
    return this.container?.style.display !== "none";
  }
}
const Ve = "6.13.7";
function j(r, e, t) {
  for (let n in e) {
    let s = e[n];
    Object.defineProperty(r, n, { enumerable: !0, value: s, writable: !1 });
  }
}
function C(r) {
  if (r == null)
    return "null";
  if (Array.isArray(r))
    return "[ " + r.map(C).join(", ") + " ]";
  if (r instanceof Uint8Array) {
    const e = "0123456789abcdef";
    let t = "0x";
    for (let n = 0; n < r.length; n++)
      t += e[r[n] >> 4], t += e[r[n] & 15];
    return t;
  }
  if (typeof r == "object" && typeof r.toJSON == "function")
    return C(r.toJSON());
  switch (typeof r) {
    case "boolean":
    case "symbol":
      return r.toString();
    case "bigint":
      return BigInt(r).toString();
    case "number":
      return r.toString();
    case "string":
      return JSON.stringify(r);
    case "object": {
      const e = Object.keys(r);
      return e.sort(), "{ " + e.map((t) => `${C(t)}: ${C(r[t])}`).join(", ") + " }";
    }
  }
  return "[ COULD NOT SERIALIZE ]";
}
function Je(r, e, t) {
  let n = r;
  {
    const o = [];
    if (t) {
      if ("message" in t || "code" in t || "name" in t)
        throw new Error(`value will overwrite populated values: ${C(t)}`);
      for (const a in t) {
        if (a === "shortMessage")
          continue;
        const i = t[a];
        o.push(a + "=" + C(i));
      }
    }
    o.push(`code=${e}`), o.push(`version=${Ve}`), o.length && (r += " (" + o.join(", ") + ")");
  }
  let s;
  switch (e) {
    case "INVALID_ARGUMENT":
      s = new TypeError(r);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      s = new RangeError(r);
      break;
    default:
      s = new Error(r);
  }
  return j(s, { code: e }), t && Object.assign(s, t), s.shortMessage == null && j(s, { shortMessage: n }), s;
}
function Ze(r, e, t, n) {
  if (!r)
    throw Je(e, t, n);
}
function D(r, e, t, n) {
  Ze(r, e, "INVALID_ARGUMENT", { argument: t, value: n });
}
["NFD", "NFC", "NFKD", "NFKC"].reduce((r, e) => {
  try {
    if ("test".normalize(e) !== "test")
      throw new Error("bad");
    if (e === "NFD" && "é".normalize("NFD") !== "é")
      throw new Error("broken");
    r.push(e);
  } catch {
  }
  return r;
}, []);
function et(r, e, t) {
  if (r instanceof Uint8Array)
    return r;
  if (typeof r == "string" && r.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const n = new Uint8Array((r.length - 2) / 2);
    let s = 2;
    for (let o = 0; o < n.length; o++)
      n[o] = parseInt(r.substring(s, s + 2), 16), s += 2;
    return n;
  }
  D(!1, "invalid BytesLike value", e || "value", r);
}
function O(r, e) {
  return et(r, e);
}
const q = "0123456789abcdef";
function tt(r) {
  const e = O(r);
  let t = "0x";
  for (let n = 0; n < e.length; n++) {
    const s = e[n];
    t += q[(s & 240) >> 4] + q[s & 15];
  }
  return t;
}
function X(r) {
  if (!Number.isSafeInteger(r) || r < 0)
    throw new Error(`Wrong positive integer: ${r}`);
}
function oe(r, ...e) {
  if (!(r instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (e.length > 0 && !e.includes(r.length))
    throw new Error(`Expected Uint8Array of length ${e}, not of length=${r.length}`);
}
function G(r, e = !0) {
  if (r.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && r.finished)
    throw new Error("Hash#digest() has already been called");
}
function rt(r, e) {
  oe(r);
  const t = e.outputLen;
  if (r.length < t)
    throw new Error(`digestInto() expects output buffer of length at least ${t}`);
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const nt = (r) => r instanceof Uint8Array, st = (r) => new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4)), ot = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!ot)
  throw new Error("Non little-endian hardware is not supported");
function at(r) {
  if (typeof r != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof r}`);
  return new Uint8Array(new TextEncoder().encode(r));
}
function ae(r) {
  if (typeof r == "string" && (r = at(r)), !nt(r))
    throw new Error(`expected Uint8Array, got ${typeof r}`);
  return r;
}
class it {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function ct(r) {
  const e = (n) => r().update(ae(n)).digest(), t = r();
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = () => r(), e;
}
const B = /* @__PURE__ */ BigInt(2 ** 32 - 1), V = /* @__PURE__ */ BigInt(32);
function lt(r, e = !1) {
  return e ? { h: Number(r & B), l: Number(r >> V & B) } : { h: Number(r >> V & B) | 0, l: Number(r & B) | 0 };
}
function dt(r, e = !1) {
  let t = new Uint32Array(r.length), n = new Uint32Array(r.length);
  for (let s = 0; s < r.length; s++) {
    const { h: o, l: a } = lt(r[s], e);
    [t[s], n[s]] = [o, a];
  }
  return [t, n];
}
const ht = (r, e, t) => r << t | e >>> 32 - t, ut = (r, e, t) => e << t | r >>> 32 - t, ft = (r, e, t) => e << t - 32 | r >>> 64 - t, pt = (r, e, t) => r << t - 32 | e >>> 64 - t, [ie, ce, le] = [[], [], []], mt = /* @__PURE__ */ BigInt(0), P = /* @__PURE__ */ BigInt(1), gt = /* @__PURE__ */ BigInt(2), yt = /* @__PURE__ */ BigInt(7), bt = /* @__PURE__ */ BigInt(256), wt = /* @__PURE__ */ BigInt(113);
for (let r = 0, e = P, t = 1, n = 0; r < 24; r++) {
  [t, n] = [n, (2 * t + 3 * n) % 5], ie.push(2 * (5 * n + t)), ce.push((r + 1) * (r + 2) / 2 % 64);
  let s = mt;
  for (let o = 0; o < 7; o++)
    e = (e << P ^ (e >> yt) * wt) % bt, e & gt && (s ^= P << (P << /* @__PURE__ */ BigInt(o)) - P);
  le.push(s);
}
const [_t, kt] = /* @__PURE__ */ dt(le, !0), J = (r, e, t) => t > 32 ? ft(r, e, t) : ht(r, e, t), Z = (r, e, t) => t > 32 ? pt(r, e, t) : ut(r, e, t);
function At(r, e = 24) {
  const t = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let a = 0; a < 10; a++)
      t[a] = r[a] ^ r[a + 10] ^ r[a + 20] ^ r[a + 30] ^ r[a + 40];
    for (let a = 0; a < 10; a += 2) {
      const i = (a + 8) % 10, c = (a + 2) % 10, l = t[c], d = t[c + 1], h = J(l, d, 1) ^ t[i], g = Z(l, d, 1) ^ t[i + 1];
      for (let u = 0; u < 50; u += 10)
        r[a + u] ^= h, r[a + u + 1] ^= g;
    }
    let s = r[2], o = r[3];
    for (let a = 0; a < 24; a++) {
      const i = ce[a], c = J(s, o, i), l = Z(s, o, i), d = ie[a];
      s = r[d], o = r[d + 1], r[d] = c, r[d + 1] = l;
    }
    for (let a = 0; a < 50; a += 10) {
      for (let i = 0; i < 10; i++)
        t[i] = r[a + i];
      for (let i = 0; i < 10; i++)
        r[a + i] ^= ~t[(i + 2) % 10] & t[(i + 4) % 10];
    }
    r[0] ^= _t[n], r[1] ^= kt[n];
  }
  t.fill(0);
}
class L extends it {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, t, n, s = !1, o = 24) {
    if (super(), this.blockLen = e, this.suffix = t, this.outputLen = n, this.enableXOF = s, this.rounds = o, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, X(n), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = st(this.state);
  }
  keccak() {
    At(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    G(this);
    const { blockLen: t, state: n } = this;
    e = ae(e);
    const s = e.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(t - this.pos, s - o);
      for (let i = 0; i < a; i++)
        n[this.pos++] ^= e[o++];
      this.pos === t && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: t, pos: n, blockLen: s } = this;
    e[n] ^= t, (t & 128) !== 0 && n === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    G(this, !1), oe(e), this.finish();
    const t = this.state, { blockLen: n } = this;
    for (let s = 0, o = e.length; s < o; ) {
      this.posOut >= n && this.keccak();
      const a = Math.min(n - this.posOut, o - s);
      e.set(t.subarray(this.posOut, this.posOut + a), s), this.posOut += a, s += a;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return X(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (rt(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: t, suffix: n, outputLen: s, rounds: o, enableXOF: a } = this;
    return e || (e = new L(t, n, s, a, o)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = o, e.suffix = n, e.outputLen = s, e.enableXOF = a, e.destroyed = this.destroyed, e;
  }
}
const It = (r, e, t) => ct(() => new L(e, r, t)), vt = /* @__PURE__ */ It(1, 136, 256 / 8);
let de = !1;
const he = function(r) {
  return vt(r);
};
let ue = he;
function M(r) {
  const e = O(r, "data");
  return tt(ue(e));
}
M._ = he;
M.lock = function() {
  de = !0;
};
M.register = function(r) {
  if (de)
    throw new TypeError("keccak256 is locked");
  ue = r;
};
Object.freeze(M);
const Et = BigInt(0), xt = BigInt(36);
function ee(r) {
  r = r.toLowerCase();
  const e = r.substring(2).split(""), t = new Uint8Array(40);
  for (let s = 0; s < 40; s++)
    t[s] = e[s].charCodeAt(0);
  const n = O(M(t));
  for (let s = 0; s < 40; s += 2)
    n[s >> 1] >> 4 >= 8 && (e[s] = e[s].toUpperCase()), (n[s >> 1] & 15) >= 8 && (e[s + 1] = e[s + 1].toUpperCase());
  return "0x" + e.join("");
}
const Y = {};
for (let r = 0; r < 10; r++)
  Y[String(r)] = String(r);
for (let r = 0; r < 26; r++)
  Y[String.fromCharCode(65 + r)] = String(10 + r);
const te = 15;
function Ct(r) {
  r = r.toUpperCase(), r = r.substring(4) + r.substring(0, 2) + "00";
  let e = r.split("").map((n) => Y[n]).join("");
  for (; e.length >= te; ) {
    let n = e.substring(0, te);
    e = parseInt(n, 10) % 97 + e.substring(n.length);
  }
  let t = String(98 - parseInt(e, 10) % 97);
  for (; t.length < 2; )
    t = "0" + t;
  return t;
}
const Rt = function() {
  const r = {};
  for (let e = 0; e < 36; e++) {
    const t = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
    r[t] = BigInt(e);
  }
  return r;
}();
function St(r) {
  r = r.toLowerCase();
  let e = Et;
  for (let t = 0; t < r.length; t++)
    e = e * xt + Rt[r[t]];
  return e;
}
function m(r) {
  if (D(typeof r == "string", "invalid address", "address", r), r.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    r.startsWith("0x") || (r = "0x" + r);
    const e = ee(r);
    return D(!r.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === r, "bad address checksum", "address", r), e;
  }
  if (r.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    D(r.substring(2, 4) === Ct(r), "bad icap checksum", "address", r);
    let e = St(r.substring(4)).toString(16);
    for (; e.length < 40; )
      e = "0" + e;
    return ee("0x" + e);
  }
  D(!1, "invalid address", "address", r);
}
class Pt {
  type = "argent";
  platform = "starknet";
  wallet = void 0;
  account = void 0;
  connectedAccounts = [];
  isAvailable() {
    return typeof window < "u" && !!window.starknet_argentX;
  }
  getInfo() {
    const e = this.isAvailable();
    return {
      type: this.type,
      available: e,
      version: e ? window.starknet_argentX?.version || "Unknown" : void 0,
      chainId: e ? window.starknet_argentX?.chainId : void 0,
      name: "Argent",
      platform: this.platform
    };
  }
  async connect() {
    if (this.account)
      return { success: !0, wallet: this.type, account: this.account };
    try {
      if (!this.isAvailable())
        throw new Error("Argent is not available");
      const { wallet: e, connectorData: t } = await ve({
        connectors: [new Ee({ options: { id: "argentX" } })]
      });
      if (!e)
        throw new Error("No wallet found");
      return this.wallet = e, this.account = t?.account, { success: !0, wallet: this.type, account: this.account };
    } catch (e) {
      return console.error("Error connecting to Argent:", e), {
        success: !1,
        wallet: this.type,
        error: e.message || "Unknown error"
      };
    }
  }
  getConnectedAccounts() {
    return this.connectedAccounts;
  }
  async signTypedData(e) {
    try {
      if (!this.isAvailable() || !this.wallet)
        throw new Error("Argent is not connected");
      const t = await this.wallet.request({
        type: "wallet_signTypedData",
        params: e
      });
      return { success: !0, wallet: this.type, result: t };
    } catch (t) {
      return console.error("Error signing typed data with Argent:", t), {
        success: !1,
        wallet: this.type,
        error: t.message || "Unknown error"
      };
    }
  }
  async sendTransaction(e) {
    return {
      success: !1,
      wallet: this.type,
      error: "Not implemented"
    };
  }
  async switchChain(e) {
    return console.warn(
      "Chain switching for Argent may require custom implementation"
    ), !1;
  }
  async getBalance(e) {
    try {
      if (!this.isAvailable() || !this.wallet)
        throw new Error("Argent is not connected");
      return {
        success: !0,
        wallet: this.type,
        result: "Implement based on Argent API"
      };
    } catch (t) {
      return console.error("Error getting balance from Argent:", t), {
        success: !1,
        wallet: this.type,
        error: t.message || "Unknown error"
      };
    }
  }
}
function Dt(r) {
  if (typeof window > "u")
    return;
  const e = (t) => r(t.detail);
  return window.addEventListener("eip6963:announceProvider", e), window.dispatchEvent(new CustomEvent("eip6963:requestProvider")), () => window.removeEventListener("eip6963:announceProvider", e);
}
function fe() {
  const r = /* @__PURE__ */ new Set();
  let e = [];
  const t = () => Dt((s) => {
    e.some(({ info: o }) => o.uuid === s.info.uuid) || (e = [...e, s], r.forEach((o) => o(e, { added: [s] })));
  });
  let n = t();
  return {
    _listeners() {
      return r;
    },
    clear() {
      r.forEach((s) => s([], { removed: [...e] })), e = [];
    },
    destroy() {
      this.clear(), r.clear(), n?.();
    },
    findProvider({ rdns: s }) {
      return e.find((o) => o.info.rdns === s);
    },
    getProviders() {
      return e;
    },
    reset() {
      this.clear(), n?.(), n = t();
    },
    subscribe(s, { emitImmediately: o } = {}) {
      return r.add(s), o && s(e, { added: e }), () => r.delete(s);
    }
  };
}
class Nt {
  type = "metamask";
  platform = "ethereum";
  MMSDK;
  store = fe();
  account = void 0;
  connectedAccounts = [];
  constructor() {
    this.MMSDK = new xe({
      dappMetadata: {
        name: "Cartridge Controller",
        url: window.location.href
      }
    }), this.isAvailable() && this.MMSDK.sdkInitPromise?.then(() => {
      this.MMSDK.getProvider()?.request({
        method: "eth_accounts"
      }).then((e) => {
        e && e.length > 0 && (this.account = m(e[0]), this.connectedAccounts = e.map(m));
      }), this.MMSDK.getProvider()?.on("accountsChanged", (e) => {
        Array.isArray(e) && e.length > 0 && (this.account = m(e?.[0]), this.connectedAccounts = e.map(m));
      });
    });
  }
  isAvailable() {
    return typeof window < "u" && this.store.getProviders().some((e) => e.info.rdns === "io.metamask");
  }
  getInfo() {
    const e = this.isAvailable();
    return {
      type: this.type,
      available: e,
      version: e ? window.ethereum?.version || "Unknown" : void 0,
      chainId: e ? window.ethereum?.chainId : void 0,
      name: "MetaMask",
      platform: this.platform,
      connectedAccounts: this.connectedAccounts
    };
  }
  async connect() {
    if (this.account)
      return { success: !0, wallet: this.type, account: this.account };
    try {
      if (!this.isAvailable())
        throw new Error("MetaMask is not available");
      const e = await this.MMSDK.connect();
      if (e && e.length > 0)
        return this.account = m(e[0]), this.connectedAccounts = e.map(
          (t) => m(t)
        ), { success: !0, wallet: this.type, account: this.account };
      throw new Error("No accounts found");
    } catch (e) {
      return console.error("Error connecting to MetaMask:", e), {
        success: !1,
        wallet: this.type,
        error: e.message || "Unknown error"
      };
    }
  }
  getConnectedAccounts() {
    return this.connectedAccounts;
  }
  async signTransaction(e) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("MetaMask is not connected");
      const t = this.MMSDK.getProvider();
      if (!t)
        throw new Error("MetaMask is not connected");
      const n = await t.request({
        method: "eth_sendTransaction",
        params: [e]
      });
      return { success: !0, wallet: this.type, result: n };
    } catch (t) {
      return console.error("Error signing transaction with MetaMask:", t), {
        success: !1,
        wallet: this.type,
        error: t.message || "Unknown error"
      };
    }
  }
  async signMessage(e, t) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("MetaMask is not connected");
      const n = await this.MMSDK.getProvider()?.request({
        method: "personal_sign",
        params: [t || this.account, e]
      });
      return { success: !0, wallet: this.type, result: n };
    } catch (n) {
      return console.error("Error signing message with MetaMask:", n), {
        success: !1,
        wallet: this.type,
        error: n.message || "Unknown error"
      };
    }
  }
  async signTypedData(e) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("MetaMask is not connected");
      const t = this.MMSDK.getProvider();
      if (!t)
        throw new Error("MetaMask is not connected");
      const n = await t.request({
        method: "eth_signTypedData_v4",
        params: [this.account, JSON.stringify(e)]
      });
      return { success: !0, wallet: this.type, result: n };
    } catch (t) {
      return console.error("Error signing typed data with MetaMask:", t), {
        success: !1,
        wallet: this.type,
        error: t.message || "Unknown error"
      };
    }
  }
  async sendTransaction(e) {
    return {
      success: !1,
      wallet: this.type,
      error: "Not implemented"
    };
  }
  async switchChain(e) {
    try {
      if (!this.isAvailable())
        throw new Error("MetaMask is not available");
      const t = this.MMSDK.getProvider();
      if (!t)
        throw new Error("MetaMask is not connected");
      try {
        return await t.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: e }]
        }), !0;
      } catch (n) {
        throw n.code === 4902 && console.warn("Chain not added to MetaMask"), n;
      }
    } catch (t) {
      return console.error("Error switching chain for MetaMask:", t), !1;
    }
  }
  async getBalance(e) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("MetaMask is not connected");
      if (e)
        return {
          success: !1,
          wallet: this.type,
          error: "Not implemented for ERC20"
        };
      {
        const t = this.MMSDK.getProvider();
        if (!t)
          throw new Error("MetaMask is not connected");
        const n = await t.request({
          method: "eth_getBalance",
          params: [this.account, "latest"]
        });
        return { success: !0, wallet: this.type, result: n };
      }
    } catch (t) {
      return console.error("Error getting balance from MetaMask:", t), {
        success: !1,
        wallet: this.type,
        error: t.message || "Unknown error"
      };
    }
  }
}
class Mt {
  type = "phantom";
  platform = "solana";
  account = void 0;
  connectedAccounts = [];
  getProvider() {
    if (typeof window > "u")
      throw new Error("Not ready");
    const e = window.solana;
    if (!e?.isPhantom)
      throw new Error("Phantom is not available");
    return e;
  }
  isAvailable() {
    return typeof window < "u" && !!window.solana?.isPhantom;
  }
  getInfo() {
    const e = this.isAvailable();
    return {
      type: this.type,
      available: e,
      version: "Unknown",
      name: "Phantom",
      platform: this.platform
    };
  }
  async connect() {
    if (this.account)
      return { success: !0, wallet: this.type, account: this.account };
    try {
      if (!this.isAvailable())
        throw new Error("Phantom is not available");
      const e = await this.getProvider().connect();
      if (e.publicKey)
        return this.account = e.publicKey.toString(), { success: !0, wallet: this.type, account: this.account };
      throw new Error("No accounts found");
    } catch (e) {
      return console.error("Error connecting to Phantom:", e), {
        success: !1,
        wallet: this.type,
        error: e.message || "Unknown error"
      };
    }
  }
  getConnectedAccounts() {
    return this.connectedAccounts;
  }
  async signMessage(e) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Phantom is not connected");
      const t = new TextEncoder().encode(e), n = await this.getProvider().signMessage(
        t,
        "utf8"
      );
      return { success: !0, wallet: this.type, result: n };
    } catch (t) {
      return console.error("Error signing message with Phantom:", t), {
        success: !1,
        wallet: this.type,
        error: t.message || "Unknown error"
      };
    }
  }
  async sendTransaction(e) {
    if (!this.isAvailable() || !this.account)
      throw new Error("Phantom is not connected");
    try {
      const t = Ce.from(e), s = await this.getProvider().signAndSendTransaction(t);
      return {
        success: !0,
        wallet: this.type,
        result: s
      };
    } catch (t) {
      return console.error("Error sending transaction with Phantom:", t), {
        success: !1,
        wallet: this.type,
        error: t.message || "Unknown error"
      };
    }
  }
  async switchChain(e) {
    return console.warn("Chain switching not supported for Phantom"), !1;
  }
  async getBalance(e) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Phantom is not connected");
      return {
        success: !0,
        wallet: this.type,
        result: "Implement based on Phantom API"
      };
    } catch (t) {
      return console.error("Error getting balance from Phantom:", t), {
        success: !1,
        wallet: this.type,
        error: t.message || "Unknown error"
      };
    }
  }
}
const Bt = "io.rabby";
class Tt {
  type = "rabby";
  platform = "ethereum";
  account = void 0;
  store = fe();
  provider;
  connectedAccounts = [];
  constructor() {
    this.provider = this.store.getProviders().find((e) => e.info.rdns === Bt), this.provider?.provider.request({
      method: "eth_accounts"
    }).then((e) => {
      this.connectedAccounts = e.map(m), e.length > 0 && (this.account = m(e?.[0]));
    }), this.provider?.provider?.on("accountsChanged", (e) => {
      e && (this.connectedAccounts = e.map((t) => m(t)), this.account = m(e?.[0]));
    });
  }
  isAvailable() {
    return typeof window < "u" && !!this.provider;
  }
  getInfo() {
    const e = this.isAvailable();
    return {
      type: this.type,
      available: e,
      version: e ? window.ethereum?.version || "Unknown" : void 0,
      chainId: e ? window.ethereum?.chainId : void 0,
      name: "Rabby",
      platform: this.platform,
      connectedAccounts: this.connectedAccounts
    };
  }
  async connect(e) {
    if (e && this.connectedAccounts.includes(m(e)) && (this.account = m(e)), this.account)
      return { success: !0, wallet: this.type, account: this.account };
    try {
      if (!this.isAvailable())
        throw new Error("Rabby is not available");
      const t = await this.provider?.provider.request({
        method: "eth_requestAccounts"
      });
      if (t && t.length > 0)
        return this.account = m(t[0]), this.connectedAccounts = t.map(m), { success: !0, wallet: this.type, account: this.account };
      throw new Error("No accounts found");
    } catch (t) {
      return console.error("Error connecting to Rabby:", t), {
        success: !1,
        wallet: this.type,
        error: t.message || "Unknown error"
      };
    }
  }
  getConnectedAccounts() {
    return this.connectedAccounts;
  }
  async signTransaction(e) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Rabby is not connected");
      const t = this.provider?.provider;
      if (!t)
        throw new Error("Rabby is not connected");
      const n = await t.request({
        method: "eth_sendTransaction",
        params: [e]
      });
      return { success: !0, wallet: this.type, result: n };
    } catch (t) {
      return console.error("Error signing transaction with Rabby:", t), {
        success: !1,
        wallet: this.type,
        error: t.message || "Unknown error"
      };
    }
  }
  async signMessage(e, t) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Rabby is not connected");
      const n = await this.provider?.provider.request({
        method: "personal_sign",
        params: [t || this.account, e]
      });
      return { success: !0, wallet: this.type, result: n };
    } catch (n) {
      return console.error("Error signing message with Rabby:", n), {
        success: !1,
        wallet: this.type,
        error: n.message || "Unknown error"
      };
    }
  }
  async signTypedData(e) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Rabby is not connected");
      const t = this.provider?.provider;
      if (!t)
        throw new Error("Rabby is not connected");
      const n = await t.request({
        method: "eth_signTypedData_v4",
        params: [this.account, JSON.stringify(e)]
      });
      return { success: !0, wallet: this.type, result: n };
    } catch (t) {
      return console.error("Error signing typed data with Rabby:", t), {
        success: !1,
        wallet: this.type,
        error: t.message || "Unknown error"
      };
    }
  }
  async sendTransaction(e) {
    return {
      success: !1,
      wallet: this.type,
      error: "Not implemented"
    };
  }
  async switchChain(e) {
    try {
      if (!this.isAvailable())
        throw new Error("Rabby is not available");
      const t = this.provider?.provider;
      if (!t)
        throw new Error("Rabby is not connected");
      try {
        return await t.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: e }]
        }), !0;
      } catch (n) {
        throw n.code === 4902 && console.warn("Chain not added to Rabby"), n;
      }
    } catch (t) {
      return console.error("Error switching chain for Rabby:", t), !1;
    }
  }
  async getBalance(e) {
    try {
      if (!this.isAvailable() || !this.account)
        throw new Error("Rabby is not connected");
      if (e)
        return {
          success: !1,
          wallet: this.type,
          error: "Not implemented for ERC20"
        };
      {
        const t = this.provider?.provider;
        if (!t)
          throw new Error("Rabby is not connected");
        const n = await t.request({
          method: "eth_getBalance",
          params: [this.account, "latest"]
        });
        return { success: !0, wallet: this.type, result: n };
      }
    } catch (t) {
      return console.error("Error getting balance from Rabby:", t), {
        success: !1,
        wallet: this.type,
        error: t.message || "Unknown error"
      };
    }
  }
}
class Qt {
  walletAdapters;
  constructor() {
    if (this.walletAdapters = /* @__PURE__ */ new Map(), typeof window > "u")
      return;
    const e = new Nt();
    e.isAvailable() && this.walletAdapters.set("metamask", e);
    const t = new Mt();
    t.isAvailable() && this.walletAdapters.set("phantom", t);
    const n = new Pt();
    n.isAvailable() && this.walletAdapters.set("argent", n);
    const s = new Tt();
    s.isAvailable() && this.walletAdapters.set("rabby", s), window.wallet_bridge = this;
  }
  getIFrameMethods() {
    return {
      externalDetectWallets: (e) => () => this.detectWallets(),
      externalConnectWallet: (e) => (t) => this.connectWallet(t),
      externalSignMessage: (e) => (t, n) => this.signMessage(t, n),
      externalSignTypedData: (e) => (t, n) => this.signTypedData(t, n),
      externalSendTransaction: (e) => (t, n) => this.sendTransaction(t, n),
      externalGetBalance: (e) => (t, n) => this.getBalance(t, n)
    };
  }
  async detectWallets() {
    return Array.from(this.walletAdapters.values()).map(
      (t) => t.getInfo()
    );
  }
  getWalletAdapterByType(e) {
    const t = this.walletAdapters.get(e);
    if (!t)
      throw new Error(`Unsupported wallet type: ${e}`);
    return t;
  }
  handleError(e, t, n, s) {
    const o = t instanceof Error ? t.message : "Unknown error";
    let a = "unknown";
    if (typeof e == "string") {
      const i = this.getConnectedWalletAdapter(e);
      a = s ?? i?.type ?? e;
    } else
      a = e;
    return console.error(`Error ${n} with ${e} wallet:`, t), {
      success: !1,
      wallet: a,
      error: o
    };
  }
  async connectWallet(e) {
    try {
      const n = await this.getWalletAdapterByType(e).connect();
      if (n.success && n.account)
        console.log(
          `Wallet ${e} connected with address ${n.account}`
        );
      else if (n.success && !n.account)
        return console.error(
          `Wallet ${e} connected successfully but did not provide an address.`
        ), {
          ...n,
          success: !1,
          error: "Wallet connected but address not found."
        };
      return n;
    } catch (t) {
      return this.handleError(e, t, "connecting to");
    }
  }
  getConnectedWalletAdapter(e) {
    let t;
    if (typeof e == "string") {
      const n = m(e);
      t = this.walletAdapters.values().find((s) => s.getConnectedAccounts().includes(n));
    } else
      t = this.walletAdapters.get(e);
    if (!t)
      throw new Error(
        `Wallet with identifier ${e} is not connected or supported`
      );
    return t;
  }
  async signMessage(e, t) {
    let n;
    try {
      if (n = this.getConnectedWalletAdapter(e), !n.signMessage)
        throw new Error(
          `Wallet type ${n.type} (identifier: ${e}) does not support signing messages`
        );
      return await n.signMessage(t, e);
    } catch (s) {
      return this.handleError(
        e,
        s,
        "signing message with",
        n?.type
      );
    }
  }
  async signTypedData(e, t) {
    let n;
    try {
      if (n = this.getConnectedWalletAdapter(e), !n.signTypedData)
        throw new Error(
          `Wallet type ${n.type} (identifier: ${e}) does not support signing typed data`
        );
      return await n.signTypedData(t);
    } catch (s) {
      return this.handleError(
        e,
        s,
        "signing typed data with",
        n?.type
      );
    }
  }
  async sendTransaction(e, t) {
    let n;
    try {
      return n = this.getConnectedWalletAdapter(e), await n.sendTransaction(t);
    } catch (s) {
      return this.handleError(
        e,
        s,
        "sending transaction with",
        n?.type
      );
    }
  }
  async getBalance(e, t) {
    let n;
    try {
      return n = this.getConnectedWalletAdapter(e), await n.getBalance(t);
    } catch (s) {
      return this.handleError(
        e,
        s,
        "getting balance from",
        n?.type
      );
    }
  }
}
class Ut extends Ge {
  walletBridge;
  constructor({
    url: e,
    policies: t,
    version: n,
    slot: s,
    namespace: o,
    tokens: a,
    ...i
  }) {
    const c = new URL(e ?? we), l = new Qt();
    t && c.searchParams.set(
      "policies",
      encodeURIComponent(JSON.stringify(t))
    ), n && c.searchParams.set("v", encodeURIComponent(n)), s && c.searchParams.set("ps", encodeURIComponent(s)), o && c.searchParams.set("ns", encodeURIComponent(o)), a?.erc20 && c.searchParams.set(
      "erc20",
      encodeURIComponent(a.erc20.toString())
    ), super({
      ...i,
      id: "controller-keychain",
      url: c,
      methods: l.getIFrameMethods()
    }), this.walletBridge = l, typeof window < "u" && (window.external_wallets = this.walletBridge);
  }
  getWalletBridge() {
    return this.walletBridge;
  }
}
class Ht extends _e {
  keychain;
  options;
  iframes;
  selectedChain;
  chains;
  isReady() {
    return !!this.keychain;
  }
  constructor(e = {}) {
    super();
    const n = [...[
      { rpcUrl: "https://api.cartridge.gg/x/starknet/sepolia" },
      { rpcUrl: "https://api.cartridge.gg/x/starknet/mainnet" }
    ], ...e.chains || []], s = e.defaultChainId || $.StarknetChainId.SN_MAIN;
    this.selectedChain = s, this.chains = /* @__PURE__ */ new Map(), this.iframes = {
      keychain: new Ut({
        ...e,
        onClose: this.keychain?.reset,
        onConnect: (o) => {
          this.keychain = o;
        },
        version: ke
      })
    }, this.options = { ...e, chains: n, defaultChainId: s }, this.initializeChains(n), typeof window < "u" && (window.starknet_controller = this);
  }
  async logout() {
    if (!this.keychain) {
      console.error(new p().message);
      return;
    }
    try {
      await this.disconnect(), document.querySelectorAll('iframe[id^="controller-"]').forEach((t) => {
        const n = t.parentElement;
        n && (n.style.opacity = "0", setTimeout(() => {
          n.style.display = "none";
        }, 200));
      }), document.body && (document.body.style.overflow = "auto"), window.location.reload();
    } catch (e) {
      throw console.error("Logout failed:", e), e;
    }
  }
  async probe() {
    try {
      if (await this.waitForKeychain(), !this.keychain) {
        console.error(new p().message);
        return;
      }
      const e = await this.keychain.probe(this.rpcUrl());
      let t = e?.rpcUrl || this.rpcUrl();
      this.account = new H(
        this,
        t,
        e.address,
        this.keychain,
        this.options,
        this.iframes.keychain
      );
    } catch (e) {
      console.error(e);
      return;
    }
    return this.account;
  }
  async connect() {
    if (this.account)
      return this.account;
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new p().message);
      return;
    }
    typeof document < "u" && document.hasStorageAccess && (await document.hasStorageAccess() || await document.requestStorageAccess()), this.iframes.keychain.open();
    try {
      let e = await this.keychain.connect(
        // Policy precedence logic:
        // 1. If shouldOverridePresetPolicies is true and policies are provided, use policies
        // 2. Otherwise, if preset is defined, use empty object (let preset take precedence)
        // 3. Otherwise, use provided policies or empty object
        this.options.shouldOverridePresetPolicies && this.options.policies ? this.options.policies : this.options.preset ? {} : this.options.policies || {},
        this.rpcUrl(),
        this.options.signupOptions
      );
      if (e.code !== R.SUCCESS)
        throw new Error(e.message);
      return e = e, this.account = new H(
        this,
        this.rpcUrl(),
        e.address,
        this.keychain,
        this.options,
        this.iframes.keychain
      ), this.account;
    } catch (e) {
      console.log(e);
    } finally {
      this.iframes.keychain.close();
    }
  }
  async switchStarknetChain(e) {
    if (!this.keychain || !this.iframes.keychain)
      return console.error(new p().message), !1;
    try {
      if (this.selectedChain = e, (await this.keychain.probe(this.rpcUrl())).rpcUrl === this.rpcUrl())
        return !0;
      await this.keychain.switchChain(this.rpcUrl());
    } catch (t) {
      return console.error(t), !1;
    }
    return this.emitNetworkChanged(e), !0;
  }
  addStarknetChain(e) {
    return Promise.resolve(!0);
  }
  async disconnect() {
    if (!this.keychain) {
      console.error(new p().message);
      return;
    }
    return typeof document < "u" && document.hasStorageAccess && (await document.hasStorageAccess() || await document.requestStorageAccess()), this.account = void 0, this.keychain.disconnect();
  }
  async openProfile(e = "inventory") {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new p().message);
      return;
    }
    if (!this.account) {
      console.error("Account is not ready");
      return;
    }
    const t = await this.keychain.username();
    await this.keychain.navigate(`/account/${t}/${e}`), this.iframes.keychain.open();
  }
  async openProfileTo(e) {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new p().message);
      return;
    }
    if (!this.account) {
      console.error("Account is not ready");
      return;
    }
    const t = await this.keychain.username();
    await this.keychain.navigate(`/account/${t}/${e}`), this.iframes.keychain.open();
  }
  async openProfileAt(e) {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new p().message);
      return;
    }
    if (!this.account) {
      console.error("Account is not ready");
      return;
    }
    await this.keychain.navigate(e), this.iframes.keychain.open();
  }
  openSettings() {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new p().message);
      return;
    }
    this.iframes.keychain.open(), this.keychain.openSettings();
  }
  revoke(e, t) {
    return this.keychain ? this.keychain.revoke(e) : (console.error(new p().message), null);
  }
  rpcUrl() {
    const e = this.chains.get(this.selectedChain);
    if (!e) {
      const t = Array.from(this.chains.keys()).map(
        (n) => W.decodeShortString(n)
      );
      throw new Error(
        `Chain not found: ${W.decodeShortString(this.selectedChain)}. Available chains: ${t.join(", ")}`
      );
    }
    return e.rpcUrl;
  }
  username() {
    if (!this.keychain) {
      console.error(new p().message);
      return;
    }
    return this.keychain.username();
  }
  openPurchaseCredits() {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new p().message);
      return;
    }
    this.iframes.keychain.open(), this.keychain.openPurchaseCredits();
  }
  openStarterPack(e) {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new p().message);
      return;
    }
    this.keychain.navigate(`/starter-pack/${e}`).then(() => {
      this.iframes.keychain.open();
    });
  }
  async openExecute(e, t) {
    if (!this.keychain || !this.iframes.keychain) {
      console.error(new p().message);
      return;
    }
    let n = this.selectedChain;
    t && this.switchStarknetChain(t), this.iframes.keychain.open();
    const s = await this.keychain.execute(e, void 0, void 0, !0);
    return this.iframes.keychain.close(), t && this.switchStarknetChain(n), {
      status: !(s && (s.code === R.NOT_CONNECTED || s.code === R.CANCELED)),
      transactionHash: s?.transaction_hash
    };
  }
  async delegateAccount() {
    return this.keychain ? await this.keychain.delegateAccount() : (console.error(new p().message), null);
  }
  initializeChains(e) {
    for (const t of e)
      try {
        const n = new URL(t.rpcUrl), s = Ae(n), o = s === $.StarknetChainId.SN_MAIN, a = s === $.StarknetChainId.SN_SEPOLIA, i = n.hostname === "api.cartridge.gg", c = n.hostname === "localhost" || n.hostname === "127.0.0.1";
        if ((o || a) && !(i || c))
          throw new Error(
            `Only Cartridge RPC providers are allowed for ${o ? "mainnet" : "sepolia"}. Please use: https://api.cartridge.gg/x/starknet/${o ? "mainnet" : "sepolia"}`
          );
        this.chains.set(s, t);
      } catch (n) {
        throw console.error(`Failed to parse chainId for ${t.rpcUrl}:`, n), n;
      }
    this.chains.has(this.selectedChain) || console.warn(
      `Selected chain ${this.selectedChain} not found in configured chains. Available chains: ${Array.from(this.chains.keys()).join(", ")}`
    );
  }
  waitForKeychain({
    timeout: e = 5e4,
    interval: t = 100
  } = {}) {
    return new Promise((n, s) => {
      const o = Date.now(), a = setInterval(() => {
        if (Date.now() - o > e) {
          clearInterval(a), s(new Error("Timeout waiting for keychain"));
          return;
        }
        this.keychain && (clearInterval(a), n());
      }, t);
    });
  }
}
const S = /* @__PURE__ */ new Map();
async function pe(r) {
  if (!r.addresses?.length && !r.usernames?.length)
    return { results: [] };
  const e = await fetch(`${Ie}/lookup`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(r)
  });
  if (!e.ok)
    throw new Error(`HTTP error! status: ${e.status}`);
  return e.json();
}
async function Kt(r) {
  const e = r.filter((t) => !S.has(t));
  return e.length > 0 && (await pe({ usernames: e })).results.forEach((n) => {
    S.set(n.username, n.addresses[0]);
  }), new Map(
    r.map((t) => [t, S.get(t)]).filter((t) => t[1] !== void 0)
  );
}
async function jt(r) {
  r = r.map(ye.toHex);
  const e = r.filter((t) => !S.has(t));
  return e.length > 0 && (await pe({
    addresses: e
  })).results.forEach((n) => {
    S.set(n.addresses[0], n.username);
  }), new Map(
    r.map((t) => [t, S.get(t)]).filter((t) => t[1] !== void 0)
  );
}
var $t = [
  {
    name: "Wrapped BTC",
    symbol: "WBTC",
    decimals: 8,
    l2_token_address: "0x03fe2b97c1fd336e750087d68b9b867997fd64a2661ff3ca5a7c771641e8e7ac",
    sort_order: 0,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/7dcb2db2-a7a7-44af-660b-8262e057a100/logo"
  },
  {
    name: "USD Coin",
    symbol: "USDC",
    decimals: 6,
    l2_token_address: "0x053c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8",
    sort_order: 5,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e5aaa970-a998-47e8-bd43-4a3b56b87200/logo"
  },
  {
    name: "LUSD Stablecoin",
    symbol: "LUSD",
    decimals: 18,
    l2_token_address: "0x070a76fd48ca0ef910631754d77dd822147fe98a569b826ec85e3c33fde586ac",
    sort_order: 3,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dc0ae733-5498-4afa-f475-48dba677aa00/logo"
  },
  {
    name: "Tether USD",
    symbol: "USDT",
    decimals: 6,
    l2_token_address: "0x068f5c6a61780768455de69077e07e89787839bf8166decfbf92b645209c0fb8",
    sort_order: 4,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c8a721d1-07c3-46e4-ab4e-523977c30b00/logo"
  },
  {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    l2_token_address: "0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7",
    sort_order: 3,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e07829b7-0382-4e03-7ecd-a478c5aa9f00/logo"
  },
  {
    name: "Dai Stablecoin",
    symbol: "DAIv0",
    decimals: 18,
    l2_token_address: "0x00da114221cb83fa859dbdb4c44beeaa0bb37c7537ad5ae66fe5e0efd20e6eb3",
    sort_order: 4,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/919e761b-56f7-4f53-32aa-5e066f7f6200/logo"
  },
  {
    name: "Dai Stablecoin",
    symbol: "DAI",
    decimals: 18,
    l2_token_address: "0x05574eb6b8789a91466f902c380d978e472db68170ff82a5b650b95a58ddf4ad",
    sort_order: 4,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/919e761b-56f7-4f53-32aa-5e066f7f6200/logo"
  },
  {
    name: "Legacy Starknet Wrapped Staked Ether",
    symbol: "wstETH-legacy",
    decimals: 18,
    l2_token_address: "0x042b8f0484674ca266ac5d08e4ac6a3fe65bd3129795def2dca5c34ecc5f96d2",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/26162dcc-29c2-4f5e-3acd-5e6be1f07a00/logo"
  },
  {
    name: "Wrapped Staked Ether",
    symbol: "wstETH",
    decimals: 18,
    l2_token_address: "0x0057912720381af14b0e5c87aa4718ed5e527eab60b3801ebf702ab09139e38b",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dbbcbdea-1a92-437d-3701-4a5ee129d000/logo"
  },
  {
    name: "Rocket Pool ETH",
    symbol: "rETH",
    decimals: 18,
    l2_token_address: "0x0319111a5037cbec2b3e638cc34a3474e2d2608299f3e62866e9cc683208c610",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c9f2d6fe-fbc6-4384-0990-923dfcb7a200/logo"
  },
  {
    name: "LORDS",
    symbol: "LORDS",
    decimals: 18,
    l2_token_address: "0x0124aeb495b947201f5fac96fd1138e326ad86195b98df6dec9009158a533b49",
    sort_order: 1,
    total_supply: 509e5,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/a3bfe959-50c4-4f89-0aef-b19207d82a00/logo"
  },
  {
    name: "R Stablecoin",
    symbol: "R",
    decimals: 18,
    l2_token_address: "0x01fa2fb85f624600112040e1f3a848f53a37ed5a7385810063d5fe6887280333",
    sort_order: 3,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/77612e4e-f7ee-4dba-2066-af321843ef00/logo"
  },
  {
    name: "Frax",
    symbol: "FRAX",
    decimals: 18,
    l2_token_address: "0x009c6b4fb13dfaa025c1383ed6190af8ed8cbb09d9588a3bb020feb152442406",
    sort_order: 1,
    total_supply: 649462235,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/eeaf0779-e492-474c-ef19-b27843525600/logo"
  },
  {
    name: "Frax Share",
    symbol: "FXS",
    decimals: 18,
    l2_token_address: "0x0058efd0e73c33a848ffaa88738d128ebf0af98ea78cf3c14dc757bb02d39ffb",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/98bea621-1e4f-4d63-9689-bdaef0d56500/logo"
  },
  {
    name: "Staked Frax Ether",
    symbol: "sfrxETH",
    decimals: 18,
    l2_token_address: "0x04578fffc279e61b5cb0267a5f8e24b6089d40f93158fbbad2cb23b8622c9233",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/cd6fe18a-25db-4de9-758a-daf3b364ea00/logo"
  },
  {
    name: "Uniswap",
    symbol: "UNI",
    decimals: 18,
    l2_token_address: "0x049210ffc442172463f3177147c1aeaa36c51d152c1b0630f2364c300d4f48ee",
    sort_order: 1,
    total_supply: 1e9,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/361b018e-bd53-4019-27c8-7cf8d9031b00/logo"
  },
  {
    name: "Paper",
    symbol: "PAPER",
    decimals: 18,
    l2_token_address: "0x0410466536b5ae074f7fea81e5533b8134a9fa08b3dd077dd9db08f64997d113",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/811f019a-0461-4cff-6c1e-442102863f00/logo"
  },
  {
    name: "StarkPepe",
    symbol: "xSPEPE",
    decimals: 18,
    l2_token_address: "0x06f15ec4b6ff0b7f7a216c4b2ccdefc96cbf114d6242292ca82971592f62273b",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    disabled: !0
  },
  {
    name: "StarkNet Token",
    symbol: "STRK",
    decimals: 18,
    l2_token_address: "0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d",
    sort_order: 2,
    total_supply: 1e10,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/1b126320-367c-48ed-cf5a-ba7580e49600/logo"
  },
  {
    name: "zkLend Token",
    symbol: "ZEND",
    decimals: 18,
    l2_token_address: "0x00585c32b625999e6e5e78645ff8df7a9001cf5cf3eb6b80ccdd16cb64bd3a34",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/95515b0e-1230-4158-10f1-56888f613c00/logo"
  },
  {
    name: "Ekubo Protocol",
    symbol: "EKUBO",
    decimals: 18,
    l2_token_address: "0x075afe6402ad5a5c20dd25e10ec3b3986acaa647b77e4ae24b0cbc9a54a27a87",
    sort_order: 1,
    total_supply: 1e7,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/634d9c36-2f0b-4781-93e6-72d701b5af00/logo"
  },
  {
    name: "SOCKS",
    symbol: "SOCKS",
    decimals: 18,
    l2_token_address: "0x023ed2ba4fb5709302c5dfd739fa7613359042f143286c115b6c7f7dc2601015",
    sort_order: 1,
    total_supply: 1e11,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/2db5a2a6-c98e-4b80-35e0-31b489132100/logo"
  },
  {
    name: "Nostra",
    symbol: "NSTR",
    decimals: 18,
    l2_token_address: "0x00c530f2c0aa4c16a0806365b0898499fba372e5df7a7172dc6fe9ba777e8007",
    sort_order: 1,
    total_supply: 1e8,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/a45c2224-17a7-4269-ea7e-3924e9755800/logo"
  },
  {
    name: "Carmine",
    symbol: "CRM",
    decimals: 18,
    l2_token_address: "0x51c4b1fe3bf6774b87ad0b15ef5d1472759076e42944fff9b9f641ff13e5bbe",
    sort_order: 1,
    total_supply: 1e8,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6ab817f1-8075-4a94-6e14-f112f1f89d00/logo"
  },
  {
    name: "Cash",
    symbol: "CASH",
    decimals: 18,
    l2_token_address: "0x498edfaf50ca5855666a700c25dd629d577eb9afccdf3b5977aec79aee55ada",
    sort_order: 3,
    total_supply: null,
    hidden: !1,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6bd6d156-f509-4b51-5dfc-3ee566143600/logo"
  },
  {
    name: "Nums",
    symbol: "NUMS",
    decimals: 18,
    l2_token_address: "0xe5f10eddc01699dc899a30dbc3c9858148fa4aa0a47c0ffd85f887ffc4653e",
    sort_order: 1,
    total_supply: 1,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/90868d05-cb75-4c42-278c-5a540db2cf00/logo"
  },
  {
    name: "Flip",
    symbol: "FLIP",
    decimals: 18,
    l2_token_address: "0x01bfe97d729138fc7c2d93c77d6d1d8a24708d5060608017d9b384adf38f04c7",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/275f0fa8-a691-471c-ace6-0eb0315dde00/logo"
  },
  {
    name: "Eternum Stone",
    symbol: "STONE",
    decimals: 18,
    l2_token_address: "0x439a1c010e3e1bb2d43d43411000893c0042bd88f6c701611a0ea914d426da4",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/932e7f83-a4c2-40f0-3048-35af3b194100/logo"
  },
  {
    name: "Eternum Coal",
    symbol: "COAL",
    decimals: 18,
    l2_token_address: "0xce635e3f241b0ae78c46a929d84a9101910188f9c4024eaa7559556503c31a",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/cf2ee180-06bf-4443-e3aa-724d7c28e800/logo"
  },
  {
    name: "Eternum Wood",
    symbol: "WOOD",
    decimals: 18,
    l2_token_address: "0x40d8907cec0f7ae9c364dfb12485a1314d84c129bf1898d2f3d4b7fcc7d44f4",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/1db5f954-c1ef-447e-9f8f-05bd9f3b2b00/logo"
  },
  {
    name: "Eternum Copper",
    symbol: "COPPER",
    decimals: 18,
    l2_token_address: "0x66ed5c928ee027a9419ace1cbea8389885161db5572a7c5c4fef2310e9bf494",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6bbcdcc9-6146-404d-9501-92a664cf3100/logo"
  },
  {
    name: "Eternum Ironwood",
    symbol: "IRONWOOD",
    decimals: 18,
    l2_token_address: "0x1720cf6318bff45e62acc588680ae3cd4d5f8465b1d52cb710533c9299b031a",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/5af7c03b-e4ae-4aee-eba4-a4e2160a1d00/logo"
  },
  {
    name: "Eternum Obsidian",
    symbol: "OBSIDIAN",
    decimals: 18,
    l2_token_address: "0x3b6448d09dcd023507376402686261f5d6739455fa02f804907b066e488da66",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/8be9bc66-486b-4181-6804-725a1db8ad00/logo"
  },
  {
    name: "Eternum Gold",
    symbol: "GOLD",
    decimals: 18,
    l2_token_address: "0xdff9dca192609c4e86ab3be22c7ec1e968876c992d21986f3c542be97fa2f",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/fb9e90f7-3c2f-4c64-7e43-c3f694f35e00/logo"
  },
  {
    name: "Eternum Silver",
    symbol: "SILVER",
    decimals: 18,
    l2_token_address: "0x6fe21d2d4a8a05bdb70f09c9250af9870020d5dcc35f410b4a39d6605c3e353",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e443afeb-850b-46a0-a7ba-a473306d6b00/logo"
  },
  {
    name: "Eternum Mithral",
    symbol: "MITHRAL",
    decimals: 18,
    l2_token_address: "0x67ba235c569c23877064b2ac6ebd4d79f32d3c00f5fab8e28a3b5700b957f6",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/33dc517f-8a66-45eb-f2c5-de5388e47500/logo"
  },
  {
    name: "Eternum Alchemical Silver",
    symbol: "ALCHEMICALSILVER",
    decimals: 18,
    l2_token_address: "0x3956a5301e99522038a2e7dcb9c2a89bf087ffa79310ee0a508b5538efd8ddd",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/3d2e0fd8-4af8-49a0-4bdb-691a4d6ef800/logo"
  },
  {
    name: "Eternum Cold Iron",
    symbol: "COLDIRON",
    decimals: 18,
    l2_token_address: "0x555d713e59d4ff96b7960447e9bc9e79bfdeab5b0eea74e3df81bce61cfbc77",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/878c0d8a-8e2c-4281-0896-9cbbb2ef9400/logo"
  },
  {
    name: "Eternum Deep Crystal",
    symbol: "DEEPCRYSTAL",
    decimals: 18,
    l2_token_address: "0x1d655ac834d38df7921074fc1588411e202b1af83307cbd996983aff52db3a8",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/1c2c954f-448c-476b-a4a6-19b52efe3e00/logo"
  },
  {
    name: "Eternum Ruby",
    symbol: "RUBY",
    decimals: 18,
    l2_token_address: "0x3d9b66720959d0e7687b898292c10e62e78626f2dba5e1909961a2ce3f86612",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6a45b34d-3bfe-4994-45b0-f2bee8abac00/logo"
  },
  {
    name: "Eternum Diamonds",
    symbol: "DIAMONDS",
    decimals: 18,
    l2_token_address: "0xe03ea8ae385f64754820af5c01c36abf1b8130dd6797d3fd9d430e4114e876",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/b1fa609d-8799-4754-cdea-ab69514ca700/logo"
  },
  {
    name: "Eternum Hartwood",
    symbol: "HARTWOOD",
    decimals: 18,
    l2_token_address: "0x5620aa7170cd66dbcbc37d03087bfe4633ffef91d3e4d97b501de906004f79b",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/27e37e85-91bd-4ee1-0552-1e0795077400/logo"
  },
  {
    name: "Eternum Ignium",
    symbol: "IGNIUM",
    decimals: 18,
    l2_token_address: "0x625c1f789b03ebebc7a9322366f38ebad1f693b84b2abd8cb8f5b2748b0cdd5",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/58591e20-24fb-4353-417a-81d877a5a200/logo"
  },
  {
    name: "Eternum Twilight Quartz",
    symbol: "TWILIGHTQUARTZ",
    decimals: 18,
    l2_token_address: "0x35e24c02409c3cfe8d5646399a62c4d102bb782938d5f5180e92c9c62d3faf7",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/2f8cb892-e82a-4af3-bd09-316061faec00/logo"
  },
  {
    name: "Eternum True Ice",
    symbol: "TRUEICE",
    decimals: 18,
    l2_token_address: "0x4485f5a6e16562e1c761cd348e63256d00389e3ddf4f5d98afe7ab44c57c481",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/fe4bfc17-6553-4dc5-58d2-f452b4aa8a00/logo"
  },
  {
    name: "Eternum Adamantine",
    symbol: "ADAMANTINE",
    decimals: 18,
    l2_token_address: "0x367f838f85a2f5e1580d6f011e4476f581083314cff8721ba3dda9706076eed",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/13bd026b-3612-480e-0119-04cf4c505a00/logo"
  },
  {
    name: "Eternum Sapphire",
    symbol: "SAPPHIRE",
    decimals: 18,
    l2_token_address: "0x2f8dd022568af8f9f718aa37707a9b858529db56910633a160456838b6cbcbc",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/0ebf555f-e732-4054-f8e5-55b2ed49ba00/logo"
  },
  {
    name: "Eternum Ethereal Silica",
    symbol: "ETHEREALSILICA",
    decimals: 18,
    l2_token_address: "0x68b6e23cbbd58a644700f55e96c83580921e9f521b6e5175396b53ba7910e7d",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/f02a5b43-bfcf-408c-7d1b-fcfe68b02d00/logo"
  },
  {
    name: "Eternum Dragon Hide",
    symbol: "DRAGONHIDE",
    decimals: 18,
    l2_token_address: "0x3bf856515bece3c93f5061b7941b8645f817a0acab93c758b8c7b4bc0afa3c6",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/e74955fc-5c8a-4dff-4882-a49a46a5a800/logo"
  },
  {
    name: "Eternum Ancient Fragment",
    symbol: "ANCIENTFRAGMENT",
    decimals: 18,
    l2_token_address: "0x0695b08ecdfdd828c2e6267da62f59e6d7543e690ef56a484df25c8566b332a5",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/9af855b7-4790-4390-9466-6bed4481ab00/logo"
  },
  {
    name: "Eternum Donkey",
    symbol: "DONKEY",
    decimals: 18,
    l2_token_address: "0x264be95a4a2ace20add68cb321acdccd2f9f8440ee1c7abd85da44ddab01085",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/20817378-a45e-4521-f464-10f6dd13c500/logo"
  },
  {
    name: "Eternum Knight",
    symbol: "KNIGHT",
    decimals: 18,
    l2_token_address: "0xac965f9e67164723c16735a9da8dbc9eb8e43b1bd0323591e87c056badf606",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/8787ed1f-af5c-4873-c01a-55f05e999a00/logo"
  },
  {
    name: "Eternum Crossbowman",
    symbol: "CROSSBOWMAN",
    decimals: 18,
    l2_token_address: "0x67e4ac00a241be06ba6afc11fa2715ec7da0c42c05a67ef6ecfcfeda725aaa8",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/dec7f31b-4b1d-46bb-4fca-c0253cf55a00/logo"
  },
  {
    name: "Eternum Paladin",
    symbol: "PALADIN",
    decimals: 18,
    l2_token_address: "0x3bc86299bee061c7c8d7546ccb62b9daf9bffc653b1508facb722c6593874bc",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/7d2cd5a5-f38a-49f6-11f8-ba3b59a59e00/logo"
  },
  {
    name: "Eternum Wheat",
    symbol: "WHEAT",
    decimals: 18,
    l2_token_address: "0x57a3f1ee475e072ce3be41785c0e889b7295d7a0dcc22b992c5b9408dbeb280",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/c338b6a8-77c4-4dd6-34f5-1af0d3fb1e00/logo"
  },
  {
    name: "Eternum Fish",
    symbol: "FISH",
    decimals: 18,
    l2_token_address: "0x27719173cfe10f1aa38d2aaed0a075b6077290f1e817aa3485d2b828394f4d9",
    sort_order: 1,
    total_supply: null,
    hidden: !0,
    logo_url: "https://imagedelivery.net/0xPAQaDtnQhBs8IzYRIlNg/6deef27f-df40-4248-4e1b-ed1d79a3f000/logo"
  },
  {
    name: "Fools",
    symbol: "FOOLS",
    decimals: 18,
    l2_token_address: "0x068a7a07e08fc3e723a878223d00f669106780d5ea6665eb15d893476d47bf3b",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://assets.underware.gg/pistols/fools.svg"
  },
  {
    name: "Fame",
    symbol: "FAME",
    decimals: 18,
    l2_token_address: "0x02549653a4ae1ff8d04a20b8820a49cbe97486c536ec0e4c8f68aa33d80067cf",
    sort_order: 1,
    total_supply: null,
    logo_url: "https://assets.underware.gg/pistols/fame.svg"
  }
], me = {
  theme: {
    name: "Cartridge",
    icon: "icon.svg"
  }
}, T = "https://static.cartridge.gg/presets";
async function F() {
  try {
    const r = await fetch(`${T}/index.json`);
    if (!r.ok)
      throw new Error(`Failed to load configs index: ${r.statusText}`);
    return await r.json();
  } catch (r) {
    return console.error("Error loading configs index:", r), { configs: [], baseUrl: T };
  }
}
async function qt() {
  return (await F()).configs;
}
async function Xt(r) {
  try {
    const n = `${(await F()).baseUrl || T}/${r}`, s = await fetch(`${n}/config.json`);
    if (!s.ok)
      throw new Error(
        `Failed to load config ${r}: ${s.statusText}`
      );
    const o = await s.json();
    if (o && o.theme) {
      o.theme.icon && !o.theme.icon.startsWith("http") && (o.theme.icon = `${n}/${o.theme.icon}`), o.theme.cover && (typeof o.theme.cover == "string" ? o.theme.cover.startsWith("http") || (o.theme.cover = `${n}/${o.theme.cover}`) : (o.theme.cover.light && !o.theme.cover.light.startsWith("http") && (o.theme.cover.light = `${n}/${o.theme.cover.light}`), o.theme.cover.dark && !o.theme.cover.dark.startsWith("http") && (o.theme.cover.dark = `${n}/${o.theme.cover.dark}`)));
      const a = (i) => {
        if (i) {
          for (const c in i)
            if (i[c])
              for (const l in i[c])
                i[c][l] && !i[c][l].startsWith("http") && (i[c][l] = `${n}/${i[c][l]}`);
        }
      };
      if (o.theme.optimizedIcon && a(o.theme.optimizedIcon), o.theme.optimizedCover)
        if (typeof o.theme.optimizedCover == "string")
          o.theme.optimizedCover.startsWith("http") || (o.theme.optimizedCover = `${n}/${o.theme.optimizedCover}`);
        else if (o.theme.optimizedCover.light || o.theme.optimizedCover.dark) {
          const i = o.theme.optimizedCover;
          i.light && a(i.light), i.dark && a(i.dark);
        } else
          a(o.theme.optimizedCover);
    }
    return o;
  } catch (e) {
    return console.error(`Error loading config ${r}:`, e), null;
  }
}
async function Gt() {
  const r = await F(), e = r.configs, t = r.baseUrl || T, n = {};
  return await Promise.all(
    e.map(async (s) => {
      try {
        const o = await fetch(`${t}/${s}/config.json`);
        if (o.ok) {
          const a = await o.json();
          n[s] = a;
        }
      } catch (o) {
        console.error(`Error loading config ${s}:`, o);
      }
    })
  ), n;
}
me.theme.icon = "https://static.cartridge.gg/presets/cartridge/icon.svg";
var Vt = $t, Jt = me.theme;
export {
  Pt as ArgentWallet,
  tr as FeeSource,
  Nt as MetaMaskWallet,
  p as NotReadyToConnect,
  Mt as PhantomWallet,
  Tt as RabbyWallet,
  R as ResponseCodes,
  Qt as WalletBridge,
  Ht as default,
  Jt as defaultTheme,
  Vt as erc20Metadata,
  qt as getAvailableConfigs,
  F as getConfigsIndex,
  rr as humanizeString,
  Gt as loadAllConfigs,
  Xt as loadConfig,
  jt as lookupAddresses,
  Kt as lookupUsernames,
  nr as normalizeCalls,
  Ae as parseChainId,
  be as toArray,
  sr as toSessionPolicies,
  or as toWasmPolicies
};
//# sourceMappingURL=index.js.map
