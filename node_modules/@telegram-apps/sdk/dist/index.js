class G extends Error {
  constructor(t, n, o) {
    super(
      typeof n == "object" ? n.message : n || t,
      {
        cause: typeof n == "object" ? n.cause : o
      }
    ), this.type = t, this.name = "TypedError", Object.setPrototypeOf(this, G.prototype);
  }
}
function zn(e) {
  return e.replace(/[A-Z]/g, (t) => `_${t.toLowerCase()}`);
}
function Bs(e) {
  return e.replace(/_[a-z]/g, (t) => t[1].toUpperCase());
}
const Ms = "ERR_INVALID_VALUE", Is = "ERR_UNEXPECTED_VALUE", Ds = "ERR_UNEXPECTED_TYPE", Qn = "ERR_PARSE";
function Jn(e, t) {
  const n = {};
  for (const o in e) {
    const s = e[o];
    if (!s)
      continue;
    let r, a;
    typeof s == "function" ? (r = o, a = s) : [r, a] = s;
    try {
      const i = a(t(r));
      i !== void 0 && (n[o] = i);
    } catch (i) {
      throw new G(
        Qn,
        `Parser for "${o}" property failed${r === o ? "" : `. Source field: "${r}"`}`,
        i
      );
    }
  }
  return n;
}
function Yn(e) {
  let t = e;
  if (typeof t == "string")
    try {
      t = JSON.parse(t);
    } catch (n) {
      throw new G(Ms, { cause: n });
    }
  if (typeof t != "object" || !t || Array.isArray(t))
    throw new G(Is);
  return t;
}
function j(e, t) {
  return (n) => {
    const o = (s) => {
      if (!(n && s === void 0))
        try {
          return t(s);
        } catch (r) {
          throw new G(Qn, {
            message: `"${e}" transformer failed to parse the value`,
            cause: r
          });
        }
    };
    return /* @__PURE__ */ Object.assign(
      o,
      {
        isValid(s) {
          try {
            return o(s), !0;
          } catch {
            return !1;
          }
        }
      }
    );
  };
}
function He(e, t) {
  return j(t || "object", (n) => {
    const o = Yn(n);
    return Jn(e, (s) => o[s]);
  });
}
function Te(e) {
  throw new G(Ds, `Unexpected value received: ${JSON.stringify(e)}`);
}
const Ns = j("boolean", (e) => {
  if (typeof e == "boolean")
    return e;
  const t = String(e);
  if (t === "1" || t === "true")
    return !0;
  if (t === "0" || t === "false")
    return !1;
  Te(e);
}), L = j("string", (e) => {
  if (typeof e == "string" || typeof e == "number")
    return e.toString();
  Te(e);
}), Ue = j("number", (e) => {
  if (typeof e == "number")
    return e;
  if (typeof e == "string") {
    const t = Number(e);
    if (!Number.isNaN(t))
      return t;
  }
  Te(e);
}), Nt = j("date", (e) => e instanceof Date ? e : new Date(Ue()(e) * 1e3));
function Kn(e, t) {
  return j(t || "searchParams", (n) => {
    typeof n != "string" && !(n instanceof URLSearchParams) && Te(n);
    const o = typeof n == "string" ? new URLSearchParams(n) : n;
    return Jn(e, (s) => {
      const r = o.get(s);
      return r === null ? void 0 : r;
    });
  });
}
function mt(e) {
  for (const t in e)
    e[t] = [zn(t), e[t]];
  return e;
}
const ks = (e) => {
  const t = Ue(), n = Ue(!0), o = L(), s = L(!0), r = Ns(!0), a = He(mt({
    addedToAttachmentMenu: r,
    allowsWriteToPm: r,
    firstName: o,
    id: t,
    isBot: r,
    isPremium: r,
    languageCode: s,
    lastName: s,
    photoUrl: s,
    username: s
  }), "User")(!0);
  return Kn(
    mt({
      authDate: Nt(),
      canSendAfter: n,
      chat: He(
        mt({
          id: t,
          type: o,
          title: o,
          photoUrl: s,
          username: s
        }),
        "Chat"
      )(!0),
      chatInstance: s,
      chatType: s,
      hash: o,
      queryId: s,
      receiver: a,
      startParam: s,
      signature: o,
      user: a
    }),
    "initData"
  )(e);
};
function fe(e) {
  return /^#[\da-f]{6}$/i.test(e);
}
function xs(e) {
  return /^#[\da-f]{3}$/i.test(e);
}
function Zn(e) {
  const t = e.replace(/\s/g, "").toLowerCase();
  if (fe(t))
    return t;
  if (xs(t)) {
    let o = "#";
    for (let s = 0; s < 3; s += 1)
      o += t[1 + s].repeat(2);
    return o;
  }
  const n = t.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || t.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
  if (!n)
    throw new Error(`Value "${e}" does not satisfy any of known RGB formats.`);
  return n.slice(1).reduce((o, s) => {
    const r = parseInt(s, 10).toString(16);
    return o + (r.length === 1 ? "0" : "") + r;
  }, "#");
}
const Vs = j("rgb", (e) => Zn(L()(e))), Ls = j(
  "themeParams",
  (e) => {
    const t = Vs(!0);
    return Object.entries(Yn(e)).reduce((n, [o, s]) => (n[Bs(o)] = t(s), n), {});
  }
);
// @__NO_SIDE_EFFECTS__
function vn(e) {
  return JSON.stringify(
    Object.fromEntries(
      Object.entries(e).map(([t, n]) => [zn(t), n])
    )
  );
}
// @__NO_SIDE_EFFECTS__
function Ic(e) {
  const {
    initDataRaw: t,
    startParam: n,
    showSettings: o,
    botInline: s,
    fullscreen: r,
    defaultColors: a
  } = e, i = new URLSearchParams();
  return i.set("tgWebAppPlatform", e.platform), i.set("tgWebAppThemeParams", /* @__PURE__ */ vn(e.themeParams)), i.set("tgWebAppVersion", e.version), t && i.set("tgWebAppData", t), n && i.set("tgWebAppStartParam", n), typeof o == "boolean" && i.set("tgWebAppShowSettings", o ? "1" : "0"), typeof s == "boolean" && i.set("tgWebAppBotInline", s ? "1" : "0"), typeof r == "boolean" && i.set("tgWebAppFullscreen", r ? "1" : "0"), a && i.set("tgWebAppDefaultColors", /* @__PURE__ */ vn(a)), i.toString();
}
function js(e, t) {
  return j("array", (n) => {
    let o;
    if (Array.isArray(n))
      o = n;
    else if (typeof n == "string")
      try {
        const s = JSON.parse(n);
        Array.isArray(s) && (o = s);
      } catch {
      }
    return o || Te(n), o.map(e);
  });
}
function Xn(e) {
  return !!e && typeof e == "object" && !Array.isArray(e);
}
function yt(...e) {
  return e.map((t) => {
    if (typeof t == "string")
      return t;
    if (Xn(t))
      return yt(Object.entries(t).map((n) => n[1] && n[0]));
    if (Array.isArray(t))
      return yt(...t);
  }).filter(Boolean).join(" ");
}
function Dc(...e) {
  return e.reduce((t, n) => (Xn(n) && Object.entries(n).forEach(([o, s]) => {
    const r = yt(t[o], s);
    r && (t[o] = r);
  }), t), {});
}
class z extends Error {
  constructor(t, n, o) {
    super(
      typeof n == "object" ? n.message : n || t,
      {
        cause: typeof n == "object" ? n.cause : o
      }
    ), this.type = t, this.name = "TypedError", Object.setPrototypeOf(this, z.prototype);
  }
}
function eo(e) {
  return e.replace(/[A-Z]/g, (t) => `_${t.toLowerCase()}`);
}
function Hs(e) {
  return e.replace(/_[a-z]/g, (t) => t[1].toUpperCase());
}
const Us = "ERR_INVALID_VALUE", qs = "ERR_UNEXPECTED_VALUE", Fs = "ERR_UNEXPECTED_TYPE", to = "ERR_PARSE";
function no(e, t) {
  const n = {};
  for (const o in e) {
    const s = e[o];
    if (!s)
      continue;
    let r, a;
    typeof s == "function" ? (r = o, a = s) : [r, a] = s;
    try {
      const i = a(t(r));
      i !== void 0 && (n[o] = i);
    } catch (i) {
      throw new z(
        to,
        `Parser for "${o}" property failed${r === o ? "" : `. Source field: "${r}"`}`,
        i
      );
    }
  }
  return n;
}
function oo(e) {
  let t = e;
  if (typeof t == "string")
    try {
      t = JSON.parse(t);
    } catch (n) {
      throw new z(Us, { cause: n });
    }
  if (typeof t != "object" || !t || Array.isArray(t))
    throw new z(qs);
  return t;
}
function I(e, t) {
  return (n) => {
    const o = (s) => {
      if (!(n && s === void 0))
        try {
          return t(s);
        } catch (r) {
          throw new z(to, {
            message: `"${e}" transformer failed to parse the value`,
            cause: r
          });
        }
    };
    return /* @__PURE__ */ Object.assign(
      o,
      {
        isValid(s) {
          try {
            return o(s), !0;
          } catch {
            return !1;
          }
        }
      }
    );
  };
}
function M(e, t) {
  return I(t || "object", (n) => {
    const o = oo(n);
    return no(e, (s) => o[s]);
  });
}
function $e(e) {
  throw new z(Fs, `Unexpected value received: ${JSON.stringify(e)}`);
}
const qe = I("boolean", (e) => {
  if (typeof e == "boolean")
    return e;
  const t = String(e);
  if (t === "1" || t === "true")
    return !0;
  if (t === "0" || t === "false")
    return !1;
  $e(e);
}), R = I("string", (e) => {
  if (typeof e == "string" || typeof e == "number")
    return e.toString();
  $e(e);
}), de = I("number", (e) => {
  if (typeof e == "number")
    return e;
  if (typeof e == "string") {
    const t = Number(e);
    if (!Number.isNaN(t))
      return t;
  }
  $e(e);
}), Ws = I("date", (e) => e instanceof Date ? e : new Date(de()(e) * 1e3));
function so(e, t) {
  return I(t || "searchParams", (n) => {
    typeof n != "string" && !(n instanceof URLSearchParams) && $e(n);
    const o = typeof n == "string" ? new URLSearchParams(n) : n;
    return no(e, (s) => {
      const r = o.get(s);
      return r === null ? void 0 : r;
    });
  });
}
function ht(e) {
  for (const t in e)
    e[t] = [eo(t), e[t]];
  return e;
}
const Gs = (e) => {
  const t = de(), n = de(!0), o = R(), s = R(!0), r = qe(!0), a = M(ht({
    addedToAttachmentMenu: r,
    allowsWriteToPm: r,
    firstName: o,
    id: t,
    isBot: r,
    isPremium: r,
    languageCode: s,
    lastName: s,
    photoUrl: s,
    username: s
  }), "User")(!0);
  return so(
    ht({
      authDate: Ws(),
      canSendAfter: n,
      chat: M(
        ht({
          id: t,
          type: o,
          title: o,
          photoUrl: s,
          username: s
        }),
        "Chat"
      )(!0),
      chatInstance: s,
      chatType: s,
      hash: o,
      queryId: s,
      receiver: a,
      startParam: s,
      signature: o,
      user: a
    }),
    "initData"
  )(e);
};
function zs(e) {
  return /^#[\da-f]{6}$/i.test(e);
}
function Qs(e) {
  return /^#[\da-f]{3}$/i.test(e);
}
function Js(e) {
  const t = e.replace(/\s/g, "").toLowerCase();
  if (zs(t))
    return t;
  if (Qs(t)) {
    let o = "#";
    for (let s = 0; s < 3; s += 1)
      o += t[1 + s].repeat(2);
    return o;
  }
  const n = t.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || t.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
  if (!n)
    throw new Error(`Value "${e}" does not satisfy any of known RGB formats.`);
  return n.slice(1).reduce((o, s) => {
    const r = parseInt(s, 10).toString(16);
    return o + (r.length === 1 ? "0" : "") + r;
  }, "#");
}
const Ys = I("rgb", (e) => Js(R()(e))), Tn = I(
  "themeParams",
  (e) => {
    const t = Ys(!0);
    return Object.entries(oo(e)).reduce((n, [o, s]) => (n[Hs(o)] = t(s), n), {});
  }
);
// @__NO_SIDE_EFFECTS__
function At(e) {
  return JSON.stringify(
    Object.fromEntries(
      Object.entries(e).map(([t, n]) => [eo(t), n])
    )
  );
}
const Ks = (e) => {
  const t = R(), n = R(!0), o = qe(!0);
  return so({
    botInline: ["tgWebAppBotInline", o],
    defaultColors: ["tgWebAppDefaultColors", Tn(!0)],
    fullscreen: ["tgWebAppFullscreen", o],
    initData: ["tgWebAppData", Gs(!0)],
    initDataRaw: ["tgWebAppData", n],
    platform: ["tgWebAppPlatform", t],
    showSettings: ["tgWebAppShowSettings", o],
    startParam: ["tgWebAppStartParam", n],
    themeParams: ["tgWebAppThemeParams", Tn()],
    version: ["tgWebAppVersion", t]
  }, "launchParams")(e);
};
// @__NO_SIDE_EFFECTS__
function Zs(e) {
  const {
    initDataRaw: t,
    startParam: n,
    showSettings: o,
    botInline: s,
    fullscreen: r,
    defaultColors: a
  } = e, i = new URLSearchParams();
  return i.set("tgWebAppPlatform", e.platform), i.set("tgWebAppThemeParams", /* @__PURE__ */ At(e.themeParams)), i.set("tgWebAppVersion", e.version), t && i.set("tgWebAppData", t), n && i.set("tgWebAppStartParam", n), typeof o == "boolean" && i.set("tgWebAppShowSettings", o ? "1" : "0"), typeof s == "boolean" && i.set("tgWebAppBotInline", s ? "1" : "0"), typeof r == "boolean" && i.set("tgWebAppFullscreen", r ? "1" : "0"), a && i.set("tgWebAppDefaultColors", /* @__PURE__ */ At(a)), i.toString();
}
const ro = M({
  eventType: R(),
  eventData: (e) => e
}, "miniAppsMessage"), ao = I("fn", (e) => {
  if (typeof e == "function")
    return e;
  $e(e);
});
function Xs(e) {
  return !!e && typeof e == "object" && !Array.isArray(e);
}
const er = M({
  TelegramWebviewProxy: M({ postEvent: ao() })()
});
function io(e) {
  return er().isValid(e);
}
function tr() {
  try {
    return window.self !== window.top;
  } catch {
    return !0;
  }
}
var nr = Object.defineProperty, or = (e, t, n) => t in e ? nr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, co = (e, t, n) => or(e, typeof t != "symbol" ? t + "" : t, n);
let l = class uo extends Error {
  constructor(t, n, o) {
    super(
      typeof n == "object" ? n.message : n || t,
      {
        cause: typeof n == "object" ? n.cause : o
      }
    ), this.type = t, this.name = "TypedError", Object.setPrototypeOf(this, uo.prototype);
  }
};
function lo(e, t, n) {
  return e.addEventListener(t, n), () => e.removeEventListener(t, n);
}
function te(...e) {
  const t = e.flat(1);
  return [
    t.push.bind(t),
    () => {
      t.forEach((n) => {
        n();
      });
    }
  ];
}
function sr(e, t) {
  return e instanceof l && e.type === t;
}
function kt(e) {
  return (t) => sr(t, e);
}
const po = "ERR_ABORTED", _o = "ERR_CANCELED", fo = "ERR_TIMED_OUT";
function $n(e) {
  return new l(po, { cause: e });
}
const Nc = kt(fo), kc = kt(po), xc = kt(_o);
function Rn(e, t) {
  return e.reject = t.reject, e;
}
class b extends Promise {
  constructor(t, n) {
    let o, s;
    typeof t == "function" ? (o = t, s = n) : s = t;
    let r, a;
    super((i, p) => {
      s || (s = {});
      const { abortSignal: u } = s;
      if (u && u.aborted)
        return p($n(u.reason));
      const [d, w] = te(), A = (m) => (...W) => (w(), m(...W)), x = new AbortController(), { signal: T } = x;
      a = A((m) => {
        x.abort(m), p(m);
      }), r = A(i), u && d(
        lo(u, "abort", () => {
          a($n(u.reason));
        })
      );
      const { timeout: g } = s;
      if (g) {
        const m = setTimeout(() => {
          a(new l(fo, `Timeout reached: ${g}ms`));
        }, g);
        d(() => {
          clearTimeout(m);
        });
      }
      o && o(r, a, T);
    }), co(this, "reject"), this.reject = a;
  }
  /**
   * Creates a new BetterPromise instance using executor, resolving promise when a result
   * was returned.
   * @param fn - function returning promise result.
   * @param options - additional options.
   */
  static withFn(t, n) {
    return new b((o, s, r) => {
      try {
        const a = t(r);
        return a instanceof Promise ? a.then(o, s) : o(a);
      } catch (a) {
        s(a);
      }
    }, n);
  }
  /**
   * @see Promise.resolve
   */
  static resolve(t) {
    return new b((n) => {
      n(t);
    });
  }
  /**
   * @see Promise.reject
   */
  static reject(t) {
    return new b((n, o) => {
      o(t);
    });
  }
  /**
   * Cancels the promise execution.
   */
  cancel() {
    this.reject(new l(_o));
  }
  /**
   * @see Promise.catch
   */
  catch(t) {
    return this.then(void 0, t);
  }
  /**
   * @see Promise.finally
   */
  finally(t) {
    return Rn(super.finally(t), this);
  }
  /**
   * @see Promise.then
   */
  then(t, n) {
    return Rn(super.then(t, n), this);
  }
}
function On(e, t) {
  return e.resolve = t.resolve, e;
}
let rr = class Me extends b {
  constructor(t, n) {
    let o, s;
    typeof t == "function" ? (o = t, s = n) : s = t;
    let r;
    super((a, i, p) => {
      r = a, o && o(a, i, p);
    }, s), co(this, "resolve"), this.resolve = r;
  }
  /**
   * Creates a new EnhancedPromise instance using executor, resolving promise when a result
   * was returned.
   * @param fn - function returning promise result.
   * @param options - additional options.
   */
  static withFn(t, n) {
    return new Me(
      (o, s, r) => b.withFn(t, { abortSignal: r }).then(o, s),
      n
    );
  }
  /**
   * @see Promise.resolve
   */
  static resolve(t) {
    return new Me((n) => {
      n(t);
    });
  }
  /**
   * @see Promise.reject
   */
  static reject(t) {
    return new Me((n, o) => {
      o(t);
    });
  }
  /**
   * @see Promise.catch
   */
  catch(t) {
    return this.then(void 0, t);
  }
  /**
   * @see Promise.finally
   */
  finally(t) {
    return On(super.finally(t), this);
  }
  /**
   * @see Promise.then
   */
  then(t, n) {
    return On(super.then(t, n), this);
  }
};
function ar(e, t) {
  return new b((n) => {
    setTimeout(n, e);
  }, { abortSignal: t });
}
function mo(e) {
  return `tapps/${e}`;
}
function O(e, t) {
  sessionStorage.setItem(mo(e), JSON.stringify(t));
}
function P(e) {
  const t = sessionStorage.getItem(mo(e));
  try {
    return t ? JSON.parse(t) : void 0;
  } catch {
  }
}
function xt(e) {
  return e.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
}
// @__NO_SIDE_EFFECTS__
function ir(e, t) {
  t || (t = {});
  const {
    textColor: n,
    bgColor: o,
    shouldLog: s = !0
  } = t;
  function r(a, ...i) {
    if (!s || typeof s == "function" && !s())
      return;
    const p = "font-weight:bold;padding:0 5px;border-radius:5px";
    console[a](
      `%c${Intl.DateTimeFormat("en-GB", {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        fractionalSecondDigits: 3,
        timeZone: "UTC"
      }).format(/* @__PURE__ */ new Date())}%c / %c${e}`,
      `${p};background-color: lightblue;color:black`,
      "",
      `${p};${n ? `color:${n};` : ""}${o ? `background-color:${o}` : ""}`,
      ...i
    );
  }
  return [
    function(...a) {
      r("log", ...a);
    },
    function(...a) {
      r("error", ...a);
    }
  ];
}
function Vt(e, t) {
  document.documentElement.style.setProperty(e, t);
}
function Lt(e) {
  document.documentElement.style.removeProperty(e);
}
function cr(e, t) {
  t();
}
// @__NO_SIDE_EFFECTS__
function ne(e, t) {
  t || (t = {});
  const n = t.equals || Object.is;
  let o = [], s = e;
  const r = (u) => {
    if (!n(s, u)) {
      const d = s;
      s = u, cr(p, () => {
        [...o].forEach(([w, A]) => {
          w(u, d), A && i(w, !0);
        });
      });
    }
  };
  function a(u) {
    const d = typeof u != "object" ? { once: u } : u;
    return {
      once: d.once || !1,
      signal: d.signal || !1
    };
  }
  const i = (u, d) => {
    const w = a(d), A = o.findIndex(([x, T]) => x === u && T.once === w.once && T.signal === w.signal);
    A >= 0 && o.splice(A, 1);
  }, p = Object.assign(
    function() {
      return ur(p), s;
    },
    {
      destroy() {
        o = [];
      },
      set: r,
      reset() {
        r(e);
      },
      sub(u, d) {
        return o.push([u, a(d)]), () => i(u, d);
      },
      unsub: i,
      unsubAll() {
        o = o.filter((u) => u[1].signal);
      }
    }
  );
  return p;
}
const bt = [];
function ur(e) {
  bt.length && bt[bt.length - 1].add(e);
}
const lr = /* @__PURE__ */ ne(!1), [jt, pr] = /* @__PURE__ */ ir("Bridge", {
  bgColor: "#9147ff",
  textColor: "white",
  shouldLog: lr
}), _r = {
  clipboard_text_received: M({
    req_id: R(),
    data: (e) => e === null ? e : R(!0)(e)
  }, "clipboard_text_received"),
  custom_method_invoked: M({
    req_id: R(),
    result: (e) => e,
    error: R(!0)
  }, "custom_method_invoked"),
  popup_closed: I("popup_closed", (e) => e ? M({
    button_id: (t) => t == null ? void 0 : R()(t)
  })()(e) : {}),
  viewport_changed: M({
    height: de(),
    width: (e) => e == null ? window.innerWidth : de()(e),
    is_state_stable: qe(),
    is_expanded: qe()
  }, "viewport_changed")
};
function fr(e) {
  const t = window, [, n] = te(
    // Add listener, which handles events sent from the Telegram web application and also events
    // generated by the local emitEvent function.
    lo(t, "message", (o) => {
      if (o.source !== t.parent)
        return;
      let s;
      try {
        s = ro()(o.data);
      } catch {
        return;
      }
      const { eventType: r, eventData: a } = s, i = _r[r];
      try {
        const p = i ? i()(a) : a;
        jt("Event received:", p ? { eventType: r, eventData: p } : { eventType: r }), e([r, p]);
      } catch (p) {
        pr(
          [
            `An error occurred processing the "${r}" event from the Telegram application.`,
            "Please, file an issue here:",
            "https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose"
          ].join(`
`),
          s,
          p
        );
      }
    })
  );
  return n;
}
const Ct = /* @__PURE__ */ ne(), Pn = /* @__PURE__ */ ne();
function ho() {
  return Pn() || Pn.set(fr(Ct.set)), Ct;
}
const gt = /* @__PURE__ */ ne({});
function bo(e) {
  let t = gt()[e];
  return t || (t = /* @__PURE__ */ ne(void 0, {
    equals() {
      return !1;
    }
  }), ho().sub((n) => {
    n && n[0] === e && t.set(n[1]);
  }), gt.set({ ...gt(), [e]: t })), t;
}
function E(e, t, n) {
  return bo(e).sub(t, n);
}
const dr = "ERR_METHOD_UNSUPPORTED", mr = "ERR_RETRIEVE_LP_FAILED", hr = "ERR_METHOD_PARAMETER_UNSUPPORTED", go = "ERR_UNKNOWN_ENV", br = "ERR_INVOKE_CUSTOM_METHOD_RESPONSE", gr = /* @__PURE__ */ ne("https://web.telegram.org");
function Ht(e, t) {
  jt("Posting event:", t ? { eventType: e, eventData: t } : { eventType: e });
  const n = window;
  if (io(n)) {
    n.TelegramWebviewProxy.postEvent(e, JSON.stringify(t));
    return;
  }
  const o = JSON.stringify({ eventType: e, eventData: t });
  if (tr())
    return n.parent.postMessage(o, gr());
  const { external: s } = n;
  if (M({ notify: ao() })().isValid(s)) {
    s.notify(o);
    return;
  }
  throw new l(go);
}
function Ut(e, t, n) {
  n || (n = {});
  const { capture: o } = n, [s, r] = te();
  return new b((a) => {
    (Array.isArray(t) ? t : [t]).forEach((i) => {
      s(
        E(i, (p) => {
          (!o || (Array.isArray(t) ? o({
            event: i,
            payload: p
          }) : o(p))) && a(p);
        })
      );
    }), (n.postEvent || Ht)(e, n.params);
  }, n).finally(r);
}
function qt(e) {
  return Ks()(e);
}
function Eo(e) {
  return qt(
    e.replace(/^[^?#]*[?#]/, "").replace(/[?#]/g, "&")
  );
}
function Er() {
  return Eo(window.location.href);
}
function wr() {
  const e = performance.getEntriesByType("navigation")[0];
  if (!e)
    throw new Error("Unable to get first navigation entry.");
  return Eo(e.name);
}
const Sr = "launchParams";
function yr() {
  return qt(P(Sr) || "");
}
function wo(e) {
  O("launchParams", /* @__PURE__ */ Zs(e));
}
function So(e) {
  return e instanceof Error ? e.message + (e.cause ? `
  ${So(e.cause)}` : "") : JSON.stringify(e);
}
function oe() {
  const e = [];
  for (const t of [
    // Try to retrieve launch parameters from the current location. This method can return
    // nothing in case, location was changed, and then the page was reloaded.
    Er,
    // Then, try using the lower level API - window.performance.
    wr,
    // Finally, try to extract launch parameters from the session storage.
    yr
  ])
    try {
      const n = t();
      return wo(n), n;
    } catch (n) {
      e.push(n);
    }
  throw new l(mr, [
    "Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?",
    "📖 Refer to docs for more information:",
    "https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment",
    "Collected errors:",
    ...e.map((t) => `— ${So(t)}`)
  ].join(`
`));
}
function Bn(e) {
  if (e === "simple")
    try {
      return oe(), !0;
    } catch {
      return !1;
    }
  return b.withFn(async () => {
    if (io(window))
      return !0;
    try {
      return await Ut("web_app_request_theme", "theme_changed", { timeout: 100 }), !0;
    } catch {
      return !1;
    }
  }, e);
}
function vt(e, t) {
  window.dispatchEvent(new MessageEvent("message", {
    data: JSON.stringify({ eventType: e, eventData: t }),
    // We specify window.parent to imitate the case, the parent iframe sent us this event.
    source: window.parent
  }));
}
function Ar(e, t) {
  if (typeof t == "string")
    try {
      const { eventType: n } = ro()(t);
      n === "web_app_request_theme" && vt("theme_changed", {
        theme_params: JSON.parse(/* @__PURE__ */ At(e))
      }), n === "web_app_request_viewport" && vt("viewport_changed", {
        width: window.innerWidth,
        height: window.innerHeight,
        is_state_stable: !0,
        is_expanded: !0
      });
    } catch {
    }
}
function Vc(e) {
  var t;
  const n = typeof e == "string" ? qt(e) : e;
  wo(n);
  const o = (t = window.TelegramWebviewProxy) == null ? void 0 : t.postEvent;
  window.TelegramWebviewProxy = {
    postEvent(s, r) {
      Ar(n.themeParams, JSON.stringify({ eventType: s, eventData: r })), o == null || o(s, r);
    }
  }, jt("Environment was mocked by the mockTelegramEnv function");
}
function Cr() {
  [
    ["TelegramGameProxy_receiveEvent"],
    // Windows Phone.
    ["TelegramGameProxy", "receiveEvent"],
    // Desktop.
    ["Telegram", "WebView", "receiveEvent"]
    // Android and iOS.
  ].forEach((e) => {
    let t = window;
    e.forEach((n, o, s) => {
      if (o === s.length - 1) {
        t[n] = vt;
        return;
      }
      n in t || (t[n] = {}), t = t[n];
    });
  });
}
function vr() {
  ["TelegramGameProxy_receiveEvent", "TelegramGameProxy", "Telegram"].forEach((e) => {
    delete window[e];
  });
}
function v(e, t, n) {
  bo(e).unsub(t, n);
}
function Lc(e, t) {
  return ho().sub(e, t);
}
function jc(e, t) {
  Ct.unsub(e, t);
}
function yo(e) {
  return ({ req_id: t }) => t === e;
}
function Mn(e) {
  return e.split(".").map(Number);
}
function Tr(e, t) {
  const n = Mn(e), o = Mn(t), s = Math.max(n.length, o.length);
  for (let r = 0; r < s; r += 1) {
    const a = n[r] || 0, i = o[r] || 0;
    if (a !== i)
      return a > i ? 1 : -1;
  }
  return 0;
}
function S(e, t) {
  return Tr(e, t) <= 0;
}
function Q(e, t, n) {
  if (typeof n == "string") {
    if (e === "web_app_open_link") {
      if (t === "try_instant_view")
        return S("6.4", n);
      if (t === "try_browser")
        return S("7.6", n);
    }
    if (e === "web_app_set_header_color" && t === "color")
      return S("6.9", n);
    if (e === "web_app_close" && t === "return_back")
      return S("7.6", n);
    if (e === "web_app_setup_main_button" && t === "has_shine_effect")
      return S("7.10", n);
  }
  switch (e) {
    case "web_app_open_tg_link":
    case "web_app_open_invoice":
    case "web_app_setup_back_button":
    case "web_app_set_background_color":
    case "web_app_set_header_color":
    case "web_app_trigger_haptic_feedback":
      return S("6.1", t);
    case "web_app_open_popup":
      return S("6.2", t);
    case "web_app_close_scan_qr_popup":
    case "web_app_open_scan_qr_popup":
    case "web_app_read_text_from_clipboard":
      return S("6.4", t);
    case "web_app_switch_inline_query":
      return S("6.7", t);
    case "web_app_invoke_custom_method":
    case "web_app_request_write_access":
    case "web_app_request_phone":
      return S("6.9", t);
    case "web_app_setup_settings_button":
      return S("6.10", t);
    case "web_app_biometry_get_info":
    case "web_app_biometry_open_settings":
    case "web_app_biometry_request_access":
    case "web_app_biometry_request_auth":
    case "web_app_biometry_update_token":
      return S("7.2", t);
    case "web_app_setup_swipe_behavior":
      return S("7.7", t);
    case "web_app_share_to_story":
      return S("7.8", t);
    case "web_app_setup_secondary_button":
    case "web_app_set_bottom_bar_color":
      return S("7.10", t);
    case "web_app_request_safe_area":
    case "web_app_request_content_safe_area":
    case "web_app_request_fullscreen":
    case "web_app_exit_fullscreen":
    case "web_app_set_emoji_status":
    case "web_app_add_to_home_screen":
    case "web_app_check_home_screen":
    case "web_app_request_emoji_status_access":
      return S("8.0", t);
    default:
      return [
        "iframe_ready",
        "iframe_will_reload",
        "web_app_close",
        "web_app_data_send",
        "web_app_expand",
        "web_app_open_link",
        "web_app_ready",
        "web_app_request_theme",
        "web_app_request_viewport",
        "web_app_setup_main_button",
        "web_app_setup_closing_behavior"
      ].includes(e);
  }
}
function $r(e, t) {
  t || (t = "strict");
  const n = typeof t == "function" ? t : (o) => {
    const { method: s, version: r } = o;
    let a, i;
    if ("param" in o ? (a = `Parameter "${o.param}" of "${s}" method is unsupported in Mini Apps version ${r}`, i = hr) : (a = `Method "${s}" is unsupported in Mini Apps version ${r}`, i = dr), t === "strict")
      throw new l(i, a);
    return console.warn(a);
  };
  return (o, s) => Q(o, e) ? Xs(s) && o === "web_app_set_header_color" && "color" in s && !Q(o, "color", e) ? n({ version: e, method: o, param: "color" }) : Ht(o, s) : n({ version: e, method: o });
}
function Rr(e, t, n, o) {
  return Ut("web_app_invoke_custom_method", "custom_method_invoked", {
    ...o || {},
    params: { method: e, params: t, req_id: n },
    capture: yo(n)
  }).then(({ result: s, error: r }) => {
    if (r)
      throw new l(br, r);
    return s;
  });
}
function Or() {
  return performance.getEntriesByType("navigation")[0];
}
function D() {
  const e = Or();
  return !!e && e.type === "reload";
}
let Z;
function Pr(e, t) {
  Z && Z.set(e, t) || t();
}
function Tt(e) {
  if (Z)
    return e();
  Z = /* @__PURE__ */ new Map();
  try {
    e();
  } finally {
    Z.forEach((t) => t()), Z = void 0;
  }
}
// @__NO_SIDE_EFFECTS__
function c(e, t) {
  t || (t = {});
  const n = t.equals || Object.is;
  let o = [], s = e;
  const r = (u) => {
    if (!n(s, u)) {
      const d = s;
      s = u, Pr(p, () => {
        [...o].forEach(([w, A]) => {
          w(u, d), A && i(w, !0);
        });
      });
    }
  };
  function a(u) {
    const d = typeof u != "object" ? { once: u } : u;
    return {
      once: d.once || !1,
      signal: d.signal || !1
    };
  }
  const i = (u, d) => {
    const w = a(d), A = o.findIndex(([x, T]) => x === u && T.once === w.once && T.signal === w.signal);
    A >= 0 && o.splice(A, 1);
  }, p = Object.assign(
    function() {
      return Br(p), s;
    },
    {
      destroy() {
        o = [];
      },
      set: r,
      reset() {
        r(e);
      },
      sub(u, d) {
        return o.push([u, a(d)]), () => i(u, d);
      },
      unsub: i,
      unsubAll() {
        o = o.filter((u) => u[1].signal);
      }
    }
  );
  return p;
}
const ue = [];
function Br(e) {
  ue.length && ue[ue.length - 1].add(e);
}
// @__NO_SIDE_EFFECTS__
function _(e, t) {
  let n = /* @__PURE__ */ new Set(), o;
  function s() {
    return o || (o = /* @__PURE__ */ c(a(), t));
  }
  function r() {
    s().set(a());
  }
  function a() {
    n.forEach((u) => {
      u.unsub(r, { signal: !0 });
    });
    const i = /* @__PURE__ */ new Set();
    let p;
    ue.push(i);
    try {
      p = e();
    } finally {
      ue.pop();
    }
    return i.forEach((u) => {
      u.sub(r, { signal: !0 });
    }), n = i, p;
  }
  return Object.assign(function() {
    return s()();
  }, {
    destroy() {
      s().destroy();
    },
    sub(...i) {
      return s().sub(...i);
    },
    unsub(...i) {
      s().unsub(...i);
    },
    unsubAll(...i) {
      s().unsubAll(...i);
    }
  });
}
const Mr = /* @__PURE__ */ c(/* @__PURE__ */ (() => {
  let e = 0;
  return () => (e += 1).toString();
})()), Ao = /* @__PURE__ */ c(Ht), V = /* @__PURE__ */ c("0.0");
function Ir(e) {
  e || (e = {});
  const { postEvent: t } = e, n = e.version || oe().version;
  V.set(n), Ao.set(
    typeof t == "function" ? t : $r(n)
  );
}
function Co() {
  return Mr()();
}
function se(e, t, n) {
  return Rr(e, t, Co(), {
    ...n || {},
    postEvent: f
  });
}
const y = (e, t, n) => (n || (n = {}), n.postEvent || (n.postEvent = f), Ut(e, t, n)), f = (e, t) => Ao()(e, t);
function N(e) {
  return /* @__PURE__ */ _(() => Q(e, V()));
}
const ce = "ERR_POPUP_INVALID_PARAMS", Ft = "ERR_INVALID_URL", Dr = "ERR_INVALID_SLUG", Nr = "ERR_DATA_INVALID_SIZE", kr = "ERR_ACCESS_DENIED", q = "ERR_ALREADY_REQUESTING", Wt = "ERR_ALREADY_OPENED", xr = "ERR_ALREADY_MOUNTING", Vr = "ERR_VARS_ALREADY_BOUND", Lr = "ERR_NOT_AVAILABLE", jr = "ERR_NOT_INITIALIZED", In = "ERR_NOT_SUPPORTED", Hr = "ERR_NOT_MOUNTED", Ur = "ERR_FULLSCREEN_FAILED", qr = "ERR_EMOJI_STATUS_SET_FAILED";
function Dn() {
  return typeof window > "u";
}
// @__NO_SIDE_EFFECTS__
function h(e, t, { isSupported: n, isMounted: o, component: s, supports: r } = {}) {
  const a = `${s ? `${s}.` : ""}${e}()`;
  n = n ? Array.isArray(n) || typeof n == "object" && "any" in n ? n : [n] : void 0;
  function i(g) {
    if (r) {
      const m = r[g];
      return Q(m[0], m[1], V());
    }
    return !0;
  }
  const p = () => {
    if (!n)
      return;
    const g = `it is unsupported in Mini Apps version ${V()}`;
    function m($) {
      return typeof $ == "string" ? Q($, V()) ? void 0 : g : $.fn() ? void 0 : $.error;
    }
    if (Array.isArray(n)) {
      for (const $ of n) {
        const Cn = m($);
        if (Cn)
          return Cn;
      }
      return;
    }
    let W;
    for (const $ of n.any)
      if (W = m($), !W)
        return;
    return g;
  }, u = (...g) => {
    if (r) {
      for (const m in r)
        if (r[m][2](...g) && !i(m))
          return `option ${m} is not supported in Mini Apps version ${V()}`;
    }
  }, d = /* @__PURE__ */ _(() => !p()), w = /* @__PURE__ */ _(() => V() !== "0.0"), A = /* @__PURE__ */ _(() => !o || o()), x = /* @__PURE__ */ _(
    () => Bn("simple") && !Dn() && w() && d() && A()
  );
  let T;
  if (r) {
    T = {};
    for (const g in r)
      T[g] = /* @__PURE__ */ _(() => i(g));
  }
  return Object.assign(
    (...g) => {
      const m = `Unable to call the ${a} ${s ? "method" : "function"}:`;
      if (Dn() || !Bn("simple"))
        throw new l(
          go,
          `${m} it can't be called outside Mini Apps`
        );
      if (!w())
        throw new l(
          jr,
          `${m} the SDK was not initialized. Use the SDK init() function`
        );
      const W = p();
      if (W)
        throw new l(In, `${m} ${W}`);
      const $ = u(...g);
      if ($)
        throw new l(In, `${m} ${$}`);
      if (!A())
        throw new l(
          Hr,
          `${m} the component is not mounted. Use the ${s}.mount() method`
        );
      return t(...g);
    },
    t,
    {
      isAvailable: x,
      ifAvailable(...g) {
        return x() ? t(...g) : void 0;
      }
    },
    n ? {
      isSupported: d
    } : {},
    T ? {
      supports: T
    } : {}
  );
}
function We(e, t) {
  return t || (t = {}), (n, o, s, r) => /* @__PURE__ */ h(n, o, {
    ...t,
    isSupported: s || t.isSupported,
    supports: r,
    component: e
  });
}
function J(e, t, n) {
  return We(e, { isSupported: n, isMounted: t });
}
function B(e, t) {
  return We(e, { isSupported: t });
}
const Ge = "web_app_setup_back_button", vo = "back_button_pressed", ze = "backButton", $t = /* @__PURE__ */ c(!1), me = /* @__PURE__ */ c(!1), Fr = N(Ge), To = J(ze, me, Ge), Gt = B(ze, Ge), Wr = To("hide", () => {
  zt(!1);
}), Gr = Gt("mount", () => {
  me() || (zt(D() && P(ze) || !1), me.set(!0));
});
function zt(e) {
  e !== $t() && (f(Ge, { is_visible: e }), O(ze, e), $t.set(e));
}
const zr = Gt(
  "onClick",
  (e) => E(vo, e)
), Qr = Gt(
  "offClick",
  (e) => {
    v(vo, e);
  }
), Jr = To("show", () => {
  zt(!0);
});
function Yr() {
  me.set(!1);
}
const Hc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hide: Wr,
  isMounted: me,
  isSupported: Fr,
  isVisible: $t,
  mount: Gr,
  offClick: Qr,
  onClick: zr,
  show: Jr,
  unmount: Yr
}, Symbol.toStringTag, { value: "Module" }));
// @__NO_SIDE_EFFECTS__
function Re(e, t, n, o, s) {
  const r = s === void 0 || s ? b : Promise;
  return Object.assign((...a) => r.resolve().then(async () => {
    if (n()) {
      const p = t();
      throw o.set(p), p;
    }
    Tt(() => {
      n.set(
        r.resolve(e(...a))
      ), o.set(void 0);
    });
    let i;
    try {
      i = [!0, await n()];
    } catch (p) {
      i = [!1, p];
    }
    if (Tt(() => {
      n.set(void 0), o.set(i[0] ? void 0 : i[1]);
    }), !i[0])
      throw i[1];
    return i[1];
  }), e);
}
// @__NO_SIDE_EFFECTS__
function $o(e, t, n, o, s, r) {
  const a = /* @__PURE__ */ Re(
    t,
    () => new l(
      xr,
      `The ${e} component is already mounting`
    ),
    s,
    r
  );
  return (i) => b.resolve().then(async () => {
    if (!o()) {
      const p = await a(i);
      Tt(() => {
        o.set(!0), n(p);
      });
    }
  });
}
const H = We, Qe = /* @__PURE__ */ c({ available: !1 }), Ie = /* @__PURE__ */ c(!1), De = /* @__PURE__ */ c(!1), Je = /* @__PURE__ */ c(!1), Kr = /* @__PURE__ */ _(() => !!Qt()), Ro = /* @__PURE__ */ c(), Qt = /* @__PURE__ */ c(), Zr = /* @__PURE__ */ _(() => {
  const e = Qe();
  return e && e.available;
});
function Jt(e) {
  return e.available ? {
    available: !0,
    tokenSaved: e.token_saved,
    deviceId: e.device_id,
    accessRequested: e.access_requested,
    type: e.type,
    accessGranted: e.access_granted
  } : {
    available: !1
  };
}
const Nn = "web_app_biometry_get_info", Xr = /* @__PURE__ */ h(
  "requestBiometry",
  (e) => y(Nn, "biometry_info_received", e).then(Jt),
  {
    isSupported: Nn
  }
), Ye = "web_app_biometry_request_auth", ea = "web_app_biometry_request_access", ta = "web_app_biometry_open_settings", na = "web_app_biometry_update_token", Yt = "biometry_info_received", ee = "biometry", oa = N(Ye), sa = H(ee), ra = B(ee, Ye), Kt = J(ee, Je, Ye);
function Oo() {
  throw new l(Lr, "Biometry is not available");
}
const aa = Kt(
  "authenticate",
  (e) => b.withFn(async (t) => {
    if (Ie())
      throw new l(q, "Authentication is already in progress");
    const n = Qe();
    (!n || !n.available) && Oo(), Ie.set(!0);
    try {
      const o = await y(
        Ye,
        "biometry_auth_requested",
        {
          abortSignal: t,
          params: {
            reason: ((e || {}).reason || "").trim()
          }
        }
      ), { token: s } = o;
      return typeof s == "string" && Ke({ ...n, token: s }), o;
    } finally {
      Ie.set(!1);
    }
  }, e)
), ia = ra("openSettings", () => {
  f(ta);
}), ca = Kt(
  "requestAccess",
  (e) => b.withFn(async (t) => {
    if (De())
      throw new l(q, "Access request is already in progress");
    De.set(!0);
    try {
      const n = await y(ea, Yt, {
        abortSignal: t,
        params: { reason: (e || {}).reason || "" }
      }).then(Jt);
      return n.available || Oo(), Ke(n), n.accessGranted;
    } finally {
      De.set(!1);
    }
  }, e)
), ua = sa("mount", /* @__PURE__ */ $o(
  ee,
  (e) => {
    const t = D() && P(ee);
    return t || Xr(e);
  },
  (e) => {
    E(Yt, Po), Ke(e);
  },
  Je,
  Qt,
  Ro
)), Po = (e) => {
  Ke(Jt(e));
};
function Ke(e) {
  Qe.set(e), O(ee, e);
}
function la() {
  v(Yt, Po), Je.set(!1);
}
const pa = Kt(
  "updateToken",
  (e) => (e || (e = {}), y(na, "biometry_token_updated", {
    ...e,
    params: {
      token: e.token || "",
      reason: e.reason
    }
  }).then((t) => t.status))
), Uc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  authenticate: aa,
  isAuthenticating: Ie,
  isAvailable: Zr,
  isMounted: Je,
  isMounting: Kr,
  isRequestingAccess: De,
  isSupported: oa,
  mount: ua,
  mountError: Ro,
  mountPromise: Qt,
  openSettings: ia,
  requestAccess: ca,
  state: Qe,
  unmount: la,
  updateToken: pa
}, Symbol.toStringTag, { value: "Module" }));
function Ze(e, t) {
  return We(e, { isMounted: t });
}
const Xe = "closingBehavior", Rt = /* @__PURE__ */ c(!1), he = /* @__PURE__ */ c(!1), Bo = Ze(Xe, he), _a = H(Xe), fa = Bo("disableConfirmation", () => {
  Zt(!1);
}), da = Bo("enableConfirmation", () => {
  Zt(!0);
}), ma = _a("mount", () => {
  he() || (Zt(
    D() && P(Xe) || !1
  ), he.set(!0));
});
function Zt(e) {
  e !== Rt() && (f("web_app_setup_closing_behavior", { need_confirmation: e }), O(Xe, e), Rt.set(e));
}
function ha() {
  he.set(!1);
}
const qc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  disableConfirmation: fa,
  enableConfirmation: da,
  isConfirmationEnabled: Rt,
  isMounted: he,
  mount: ma,
  unmount: ha
}, Symbol.toStringTag, { value: "Module" })), Mo = "web_app_invoke_custom_method", et = B("cloudStorage", Mo), ba = N(Mo), ga = et("deleteItem", (e, t) => {
  const n = Array.isArray(e) ? e : [e];
  return n.length ? se("deleteStorageValues", { keys: n }, t).then() : b.resolve();
});
function Ea(e, t) {
  const n = Array.isArray(e) ? e : [e];
  return n.length ? se("getStorageValues", { keys: n }, t).then((o) => {
    const s = He(
      Object.fromEntries(n.map((r) => [r, L()]))
    )()(o);
    return Array.isArray(e) ? s : s[e];
  }) : b.resolve(typeof e == "string" ? "" : {});
}
const wa = et("getItem", Ea), Sa = et("getKeys", (e) => se("getStorageKeys", {}, e).then(js(L())())), ya = et("setItem", (e, t, n) => se("saveStorageValue", {
  key: e,
  value: t
}, n).then()), Fc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  deleteItem: ga,
  getItem: wa,
  getKeys: Sa,
  isSupported: ba,
  setItem: ya
}, Symbol.toStringTag, { value: "Module" })), Oe = "web_app_trigger_haptic_feedback", Xt = B("hapticFeedback", Oe), Aa = N(Oe), Ca = Xt(
  "impactOccurred",
  (e) => {
    f(Oe, {
      type: "impact",
      impact_style: e
    });
  }
), va = Xt(
  "notificationOccurred",
  (e) => {
    f(Oe, {
      type: "notification",
      notification_type: e
    });
  }
), Ta = Xt(
  "selectionChanged",
  () => {
    f(Oe, { type: "selection_change" });
  }
), Wc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  impactOccurred: Ca,
  isSupported: Aa,
  notificationOccurred: va,
  selectionChanged: Ta
}, Symbol.toStringTag, { value: "Module" })), en = /* @__PURE__ */ c(void 0);
function k(e) {
  return /* @__PURE__ */ _(() => {
    const t = en();
    return t ? t[e] : void 0;
  });
}
const Io = k("authDate"), Do = k("canSendAfter"), $a = /* @__PURE__ */ _(() => {
  const e = Io(), t = Do();
  return t && e ? new Date(e.getTime() + t * 1e3) : void 0;
}), Ra = k("chat"), Oa = k("chatType"), Pa = k("chatInstance"), Ba = k("hash"), Ma = k("queryId"), No = /* @__PURE__ */ c(), Ia = k("receiver");
function Da() {
  const e = oe();
  en.set(e.initData), No.set(e.initDataRaw);
}
const Na = k("startParam"), ka = k("user"), Gc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  authDate: Io,
  canSendAfter: Do,
  canSendAfterDate: $a,
  chat: Ra,
  chatInstance: Pa,
  chatType: Oa,
  hash: Ba,
  queryId: Ma,
  raw: No,
  receiver: Ia,
  restore: Da,
  startParam: Na,
  state: en,
  user: ka
}, Symbol.toStringTag, { value: "Module" }));
function zc(e) {
  return ks()(e);
}
const tn = "web_app_open_invoice", xa = B("invoice", tn), Ne = /* @__PURE__ */ c(!1), Va = N(tn);
async function ko(e, t, n) {
  if (Ne())
    throw new l(Wt, "An invoice is already opened");
  let o;
  if (t === "url") {
    const { hostname: s, pathname: r } = new URL(e, window.location.href);
    if (s !== "t.me")
      throw new l(Ft, `Link has unexpected hostname: ${s}`);
    const a = r.match(/^\/(\$|invoice\/)([A-Za-z0-9\-_=]+)$/);
    if (!a)
      throw new l(
        Dr,
        'Expected to receive a link with a pathname in format "/invoice/{slug}" or "/${slug}"'
      );
    [, , o] = a;
  } else
    o = e, n = t;
  return Ne.set(!0), y(tn, "invoice_closed", {
    ...n,
    params: { slug: o },
    capture: (s) => o === s.slug
  }).then((s) => s.status).finally(() => {
    Ne.set(!1);
  });
}
const La = xa("open", ko), Qc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _open: ko,
  isOpened: Ne,
  isSupported: Va,
  open: La
}, Symbol.toStringTag, { value: "Module" }));
function xo(e) {
  return Object.fromEntries(
    Object.entries(e).filter((t) => t[1] !== void 0)
  );
}
function Vo(e) {
  const t = Zn(e);
  return Math.sqrt(
    [0.299, 0.587, 0.114].reduce((n, o, s) => {
      const r = parseInt(t.slice(1 + s * 2, 1 + (s + 1) * 2), 16);
      return n + r * r * o;
    }, 0)
  ) < 120;
}
const be = /* @__PURE__ */ c(!1), ke = /* @__PURE__ */ c(!1), U = /* @__PURE__ */ c({});
function C(e) {
  return /* @__PURE__ */ _(() => U()[e]);
}
const ja = C("accentTextColor"), nn = C("bgColor"), on = C("buttonColor"), Lo = C("buttonTextColor"), jo = C("bottomBarBgColor"), Ha = C("destructiveTextColor"), Ua = C("headerBgColor"), qa = C("hintColor"), Fa = /* @__PURE__ */ _(() => {
  const { bgColor: e } = U();
  return !e || Vo(e);
}), Wa = C("linkColor"), Fe = C("secondaryBgColor"), Ga = C("sectionBgColor"), za = C("sectionHeaderTextColor"), Qa = C("sectionSeparatorColor"), Ja = C("subtitleTextColor"), Ya = C("textColor");
function Y(e) {
  return /* @__PURE__ */ _(() => sn()[e]);
}
const le = /* @__PURE__ */ c({
  hasShineEffect: !1,
  isEnabled: !0,
  isLoaderVisible: !1,
  isVisible: !1,
  text: "Continue"
}), sn = /* @__PURE__ */ _(() => {
  const e = le();
  return {
    ...e,
    backgroundColor: e.backgroundColor || on() || "#2481cc",
    textColor: e.textColor || Lo() || "#ffffff"
  };
}), ge = /* @__PURE__ */ c(!1), Ka = Y("backgroundColor"), Za = Y("hasShineEffect"), Xa = Y("isEnabled"), ei = Y("isLoaderVisible"), ti = Y("isVisible"), ni = Y("text"), oi = Y("textColor"), si = "web_app_setup_main_button", Ho = "main_button_pressed", tt = "mainButton", rn = H(tt), ri = Ze(tt, ge), ai = rn("mount", () => {
  if (!ge()) {
    const e = D() && P(tt);
    e && le.set(e), ge.set(!0);
  }
}), ii = rn(
  "onClick",
  (e) => E(Ho, e)
), ci = rn(
  "offClick",
  (e) => {
    v(Ho, e);
  }
), ui = ri(
  "setParams",
  (e) => {
    le.set({ ...le(), ...xo(e) }), O(tt, le());
    const t = sn();
    t.text && f(si, {
      color: t.backgroundColor,
      has_shine_effect: t.hasShineEffect,
      is_active: t.isEnabled,
      is_progress_visible: t.isLoaderVisible,
      is_visible: t.isVisible,
      text: t.text,
      text_color: t.textColor
    });
  }
);
function li() {
  ge.set(!1);
}
const Jc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: Ka,
  hasShineEffect: Za,
  isEnabled: Xa,
  isLoaderVisible: ei,
  isMounted: ge,
  isVisible: ti,
  mount: ai,
  offClick: ci,
  onClick: ii,
  setParams: ui,
  state: sn,
  text: ni,
  textColor: oi,
  unmount: li
}, Symbol.toStringTag, { value: "Module" }));
function an() {
  throw new l(
    Vr,
    "CSS variables are already bound"
  );
}
function pi(e) {
  return Ls()(e);
}
const nt = "themeParams", Uo = "theme_changed", _i = H(nt), fi = Ze(nt, be), di = fi(
  "bindCssVars",
  (e) => {
    ke() && an(), e || (e = (o) => `--tg-theme-${xt(o)}`);
    function t(o) {
      Object.entries(U()).forEach(([s, r]) => {
        r && o(s, r);
      });
    }
    function n() {
      t((o, s) => {
        Vt(e(o), s);
      });
    }
    return n(), U.sub(n), ke.set(!0), () => {
      t(Lt), U.unsub(n), ke.set(!1);
    };
  }
), qo = _i("mount", () => {
  be() || (E(Uo, Fo), U.set(
    D() && P(nt) || oe().themeParams
  ), be.set(!0));
}), Fo = (e) => {
  const t = pi(e.theme_params);
  U.set(t), O(nt, t);
};
function mi() {
  v(Uo, Fo), be.set(!1);
}
// @__NO_SIDE_EFFECTS__
function Wo(e) {
  return /* @__PURE__ */ _(() => {
    const t = e();
    return fe(t) ? t : t === "bg_color" ? nn() : Fe();
  });
}
const Ee = /* @__PURE__ */ c("bg_color"), cn = /* @__PURE__ */ Wo(Ee), we = /* @__PURE__ */ c("bottom_bar_bg_color"), un = /* @__PURE__ */ _(() => {
  const e = we();
  return fe(e) ? e : e === "bottom_bar_bg_color" ? jo() || Fe() : e === "secondary_bg_color" ? Fe() : nn();
}), Se = /* @__PURE__ */ c("bg_color"), Go = /* @__PURE__ */ Wo(Se), ye = /* @__PURE__ */ c(!1), xe = /* @__PURE__ */ c(!1), hi = /* @__PURE__ */ _(() => {
  const e = cn();
  return e ? Vo(e) : !1;
}), ot = /* @__PURE__ */ c(!0), zo = /* @__PURE__ */ _(() => ({
  backgroundColor: Ee(),
  bottomBarColor: we(),
  headerColor: Se(),
  isActive: ot()
})), Ot = "web_app_set_background_color", Pt = "web_app_set_bottom_bar_color", Ve = "web_app_set_header_color", Qo = "visibility_changed", Pe = "miniApp", ln = {
  any: [
    Ot,
    Pt,
    Ve
  ]
}, bi = /* @__PURE__ */ _(() => ln.any.some((e) => Q(e, V()))), Jo = H(Pe), gi = B(Pe, ln), st = J(Pe, ye, ln), Ei = st(
  "bindCssVars",
  (e) => {
    xe() && an();
    const [t, n] = te();
    function o(s, r) {
      function a() {
        Vt(s, r() || null);
      }
      a(), t(r.sub(a), Lt.bind(null, s));
    }
    return e || (e = (s) => `--tg-${xt(s)}`), o(e("bgColor"), cn), o(e("bottomBarColor"), un), o(e("headerColor"), Go), t(() => {
      xe.set(!1);
    }), xe.set(!0), n;
  }
), wi = Jo("close", (e) => {
  f("web_app_close", { return_back: e });
}), Yo = (e) => {
  ot.set(e.is_visible), rt();
}, Si = gi(
  "mount",
  () => {
    if (!ye()) {
      const e = D() && P(Pe);
      qo(), Ko.ifAvailable(e ? e.backgroundColor : "bg_color"), Zo.ifAvailable(e ? e.bottomBarColor : "bottom_bar_bg_color"), Xo.ifAvailable(e ? e.headerColor : "bg_color"), ot.set(e ? e.isActive : !0), E(Qo, Yo), ye.set(!0);
    }
  }
), yi = Jo("ready", () => {
  f("web_app_ready");
});
function rt() {
  O(Pe, zo());
}
const Ko = st(
  "setBackgroundColor",
  (e) => {
    e !== Ee() && (f(Ot, { color: e }), Ee.set(e), rt());
  },
  Ot
), Zo = st(
  "setBottomBarColor",
  (e) => {
    e !== we() && (f(Pt, { color: e }), we.set(e), rt());
  },
  Pt
), Xo = st(
  "setHeaderColor",
  (e) => {
    e !== Se() && (f(Ve, fe(e) ? { color: e } : { color_key: e }), Se.set(e), rt());
  },
  Ve,
  {
    rgb: [Ve, "color", fe]
  }
);
function Ai() {
  v(Qo, Yo), ye.set(!1);
}
const Yc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: Ee,
  backgroundColorRGB: cn,
  bindCssVars: Ei,
  bottomBarColor: we,
  bottomBarColorRGB: un,
  close: wi,
  headerColor: Se,
  headerColorRGB: Go,
  isActive: ot,
  isCssVarsBound: xe,
  isDark: hi,
  isMounted: ye,
  isSupported: bi,
  mount: Si,
  ready: yi,
  setBackgroundColor: Ko,
  setBottomBarColor: Zo,
  setHeaderColor: Xo,
  state: zo,
  unmount: Ai
}, Symbol.toStringTag, { value: "Module" }));
function Ci(e) {
  const t = e.message.trim(), n = (e.title || "").trim(), o = e.buttons || [];
  if (n.length > 64)
    throw new l(ce, `Invalid title: ${n}`);
  if (!t || t.length > 256)
    throw new l(ce, `Invalid message: ${t}`);
  if (o.length > 3)
    throw new l(ce, `Invalid buttons count: ${o.length}`);
  return {
    title: n,
    message: t,
    buttons: o.length ? o.map((s, r) => {
      const a = s.id || "";
      if (a.length > 64)
        throw new l(ce, `Button with index ${r} has invalid id: ${a}`);
      if (!s.type || s.type === "default" || s.type === "destructive") {
        const i = s.text.trim();
        if (!i || i.length > 64)
          throw new l(ce, `Button with index ${r} has invalid text: ${i}`);
        return { type: s.type, text: i, id: a };
      }
      return { type: s.type, id: a };
    }) : [{ type: "close", id: "" }]
  };
}
const pn = "web_app_open_popup", vi = B("popup", pn), Le = /* @__PURE__ */ c(!1), Ti = N(pn), $i = vi(
  "open",
  async (e) => {
    if (Le())
      throw new l(Wt, "A popup is already opened");
    Le.set(!0);
    try {
      const { button_id: t = null } = await y(pn, "popup_closed", {
        ...e,
        params: Ci(e)
      });
      return t;
    } finally {
      Le.set(!1);
    }
  }
), Kc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isOpened: Le,
  isSupported: Ti,
  open: $i
}, Symbol.toStringTag, { value: "Module" })), Ri = "web_app_close_scan_qr_popup", _n = "web_app_open_scan_qr_popup", Oi = "scan_qr_popup_closed", Pi = "qr_text_received", es = B("qrScanner", _n), Bt = es("close", () => {
  X.set(!1), f(Ri);
}), X = /* @__PURE__ */ c(!1), Bi = N(_n);
function Mi(e) {
  return b.withFn((t) => {
    if (X())
      throw new l(Wt, "The QR Scanner is already opened");
    X.set(!0), e || (e = {});
    const { onCaptured: n, text: o, capture: s } = e, [, r] = te(
      // Whenever the scanner was closed for some reason (by a developer or a
      // user), we should resolve the promise with undefined.
      X.sub(() => {
        a.resolve();
      }),
      // Whenever user closed the scanner, update the isOpened signal state.
      E(Oi, () => {
        X.set(!1);
      }),
      // Whenever some QR was scanned, we should check if it must be captured.
      E(Pi, (i) => {
        n ? n(i.data) : (!s || s(i.data)) && (a.resolve(i.data), Bt());
      })
    ), a = new rr({ abortSignal: t }).catch(Bt).finally(r);
    return (e.postEvent || f)(_n, { text: o }), a;
  }, e);
}
const Ii = es("open", Mi), Zc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  close: Bt,
  isOpened: X,
  isSupported: Bi,
  open: Ii
}, Symbol.toStringTag, { value: "Module" }));
function F(e) {
  return /* @__PURE__ */ _(() => fn()[e]);
}
const pe = /* @__PURE__ */ c({
  hasShineEffect: !1,
  isEnabled: !0,
  isLoaderVisible: !1,
  isVisible: !1,
  position: "left",
  text: "Cancel"
}), fn = /* @__PURE__ */ _(() => {
  const e = pe();
  return {
    ...e,
    backgroundColor: e.backgroundColor || un() || "#000000",
    textColor: e.textColor || on() || "#2481cc"
  };
}), Ae = /* @__PURE__ */ c(!1), Di = F("backgroundColor"), Ni = F("hasShineEffect"), ki = F("isEnabled"), xi = F("isLoaderVisible"), Vi = F("isVisible"), Li = F("position"), ji = F("text"), Hi = F("textColor"), at = "web_app_setup_secondary_button", ts = "secondary_button_pressed", it = "secondaryButton", dn = B(it, at), Ui = J(it, Ae, at), qi = N(at), Fi = dn("mount", () => {
  if (!Ae()) {
    const e = D() && P(it);
    e && pe.set(e), Ae.set(!0);
  }
}), Wi = dn(
  "onClick",
  (e) => E(ts, e)
), Gi = dn(
  "offClick",
  (e) => {
    v(ts, e);
  }
), zi = Ui(
  "setParams",
  (e) => {
    pe.set({
      ...pe(),
      ...Object.fromEntries(
        Object.entries(e).filter(([, n]) => n !== void 0)
      )
    }), O(it, pe());
    const t = fn();
    t.text && f(at, {
      color: t.backgroundColor,
      has_shine_effect: t.hasShineEffect,
      is_active: t.isEnabled,
      is_progress_visible: t.isLoaderVisible,
      is_visible: t.isVisible,
      position: t.position,
      text: t.text,
      text_color: t.textColor
    });
  }
);
function Qi() {
  Ae.set(!1);
}
const Xc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backgroundColor: Di,
  hasShineEffect: Ni,
  isEnabled: ki,
  isLoaderVisible: xi,
  isMounted: Ae,
  isSupported: qi,
  isVisible: Vi,
  mount: Fi,
  offClick: Gi,
  onClick: Wi,
  position: Li,
  setParams: zi,
  state: fn,
  text: ji,
  textColor: Hi,
  unmount: Qi
}, Symbol.toStringTag, { value: "Module" })), ct = "web_app_setup_settings_button", ns = "settings_button_pressed", ut = "settingsButton", Mt = /* @__PURE__ */ c(!1), Ce = /* @__PURE__ */ c(!1), Ji = N(ct), mn = B(ut, ct), os = J(ut, Ce, ct), Yi = os("hide", () => {
  hn(!1);
}), Ki = mn("mount", () => {
  Ce() || (hn(D() && P(ut) || !1), Ce.set(!0));
});
function hn(e) {
  e !== Mt() && (f(ct, { is_visible: e }), O(ut, e), Mt.set(e));
}
const Zi = mn(
  "onClick",
  (e) => E(ns, e)
), Xi = mn(
  "offClick",
  (e) => {
    v(ns, e);
  }
), ec = os("show", () => {
  hn(!0);
});
function tc() {
  Ce.set(!1);
}
const eu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hide: Yi,
  isMounted: Ce,
  isSupported: Ji,
  isVisible: Mt,
  mount: Ki,
  offClick: Xi,
  onClick: Zi,
  show: ec,
  unmount: tc
}, Symbol.toStringTag, { value: "Module" })), lt = "web_app_setup_swipe_behavior", pt = "swipeBehavior", ve = /* @__PURE__ */ c(!1), nc = N(lt), It = /* @__PURE__ */ c(!0), oc = B(pt, lt), ss = J(pt, ve, lt), sc = ss("disableVertical", () => {
  bn(!1);
}), rc = ss("enableVertical", () => {
  bn(!0);
}), ac = oc("mount", () => {
  ve() || (bn(
    D() && P(pt) || !1,
    !0
  ), ve.set(!0));
});
function bn(e, t) {
  (e !== It() || t) && (f(lt, { allow_vertical_swipe: e }), O(pt, e), It.set(e));
}
function ic() {
  ve.set(!1);
}
const tu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  disableVertical: sc,
  enableVertical: rc,
  isMounted: ve,
  isSupported: nc,
  isVerticalEnabled: It,
  mount: ac,
  unmount: ic
}, Symbol.toStringTag, { value: "Module" })), nu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accentTextColor: ja,
  backgroundColor: nn,
  bindCssVars: di,
  bottomBarBgColor: jo,
  buttonColor: on,
  buttonTextColor: Lo,
  destructiveTextColor: Ha,
  headerBackgroundColor: Ua,
  hintColor: qa,
  isCssVarsBound: ke,
  isDark: Fa,
  isMounted: be,
  linkColor: Wa,
  mount: qo,
  secondaryBackgroundColor: Fe,
  sectionBackgroundColor: Ga,
  sectionHeaderTextColor: za,
  sectionSeparatorColor: Qa,
  state: U,
  subtitleTextColor: Ja,
  textColor: Ya,
  unmount: mi
}, Symbol.toStringTag, { value: "Module" })), re = "viewport", rs = "web_app_request_fullscreen", cc = "fullscreen_failed", gn = "fullscreen_changed", as = "safe_area_changed", is = "content_safe_area_changed", cs = "viewport_changed", kn = "web_app_request_safe_area", xn = "web_app_request_content_safe_area", Vn = {
  left: 0,
  top: 0,
  bottom: 0,
  right: 0
};
function Et(e) {
  return Math.max(e, 0);
}
const _e = /* @__PURE__ */ c({
  contentSafeAreaInsets: Vn,
  height: 0,
  isExpanded: !1,
  isFullscreen: !1,
  safeAreaInsets: Vn,
  stableHeight: 0,
  width: 0
});
function K(e) {
  return /* @__PURE__ */ _(() => _e()[e]);
}
function ae(e) {
  const { height: t, stableHeight: n, width: o } = e;
  _e.set({
    ..._e(),
    ...xo({
      ...e,
      height: t ? Et(t) : void 0,
      width: o ? Et(o) : void 0,
      stableHeight: n ? Et(n) : void 0
    })
  }), O(re, _e());
}
function uc() {
  return P(re);
}
const us = K("isFullscreen"), En = /* @__PURE__ */ c(), lc = /* @__PURE__ */ _(() => !!En()), ls = /* @__PURE__ */ c(), Be = /* @__PURE__ */ c(!1), pc = /* @__PURE__ */ _(() => !!_t()), ps = /* @__PURE__ */ c(void 0), _t = /* @__PURE__ */ c(), _c = J(re, Be, rs);
function _s(e, t) {
  return _c(e, /* @__PURE__ */ Re(
    (n) => y(t, [gn, cc], n).then((o) => {
      if ("error" in o) {
        if (o.error === "ALREADY_FULLSCREEN")
          return !0;
        throw new l(Ur, "Fullscreen request failed", o.error);
      }
      return o.is_fullscreen;
    }).then((o) => {
      o !== us() && ae({ isFullscreen: o });
    }),
    () => new l(q, "Fullscreen mode change is already being requested"),
    En,
    ls
  ));
}
const fc = _s("requestFullscreen", rs), dc = _s("exitFullscreen", "web_app_exit_fullscreen"), fs = H(re), mc = Ze(re, Be);
function ft(e) {
  return /* @__PURE__ */ _(() => wn()[e]);
}
const wn = K("safeAreaInsets"), ds = ft("bottom"), ms = ft("left"), hs = ft("right"), bs = ft("top");
function dt(e) {
  return /* @__PURE__ */ _(() => Sn()[e]);
}
const Sn = K("contentSafeAreaInsets"), gs = dt("bottom"), Es = dt("left"), ws = dt("right"), Ss = dt("top"), hc = /* @__PURE__ */ h(
  "requestContentSafeAreaInsets",
  (e) => y(xn, "content_safe_area_changed", e),
  { isSupported: xn }
), bc = /* @__PURE__ */ h(
  "requestSafeAreaInsets",
  (e) => y(kn, "safe_area_changed", e),
  { isSupported: kn }
);
function gc(e) {
  return y("web_app_request_viewport", "viewport_changed", e).then((t) => ({
    height: t.height,
    width: t.width,
    isExpanded: t.is_expanded,
    isStable: t.is_state_stable
  }));
}
const ys = (e) => {
  const { height: t } = e;
  ae({
    isExpanded: e.is_expanded,
    height: t,
    width: e.width,
    stableHeight: e.is_state_stable ? t : void 0
  });
}, As = (e) => {
  ae({ isFullscreen: e.is_fullscreen });
}, Cs = (e) => {
  ae({ safeAreaInsets: e });
}, vs = (e) => {
  ae({ contentSafeAreaInsets: e });
}, Ec = fs("mount", /* @__PURE__ */ $o(
  re,
  (e) => b.resolve().then(async () => {
    const t = D() && uc();
    if (t)
      return t;
    const [
      n,
      o
    ] = await b.all([
      bc.ifAvailable(e) || wn(),
      hc.ifAvailable(e) || Sn()
    ]), s = oe(), r = {
      contentSafeAreaInsets: o,
      isFullscreen: !!s.fullscreen,
      safeAreaInsets: n
    };
    if (["macos", "tdesktop", "unigram", "webk", "weba", "web"].includes(s.platform)) {
      const a = window;
      return {
        ...r,
        height: a.innerHeight,
        isExpanded: !0,
        stableHeight: a.innerHeight,
        width: a.innerWidth
      };
    }
    return gc(e).then((a) => ({
      ...r,
      height: a.height,
      isExpanded: a.isExpanded,
      stableHeight: a.isStable ? a.height : 0,
      width: a.width
    }));
  }),
  (e) => {
    E(cs, ys), E(gn, As), E(as, Cs), E(is, vs), ae(e);
  },
  Be,
  _t,
  ps
));
function wc() {
  const e = _t();
  e && e.cancel(), v(cs, ys), v(gn, As), v(as, Cs), v(is, vs), Be.set(!1);
}
const je = /* @__PURE__ */ c(!1), yn = K("height"), An = K("stableHeight"), Ts = K("width"), Sc = mc(
  "bindCssVars",
  (e) => {
    je() && an(), e || (e = (n) => `--tg-viewport-${xt(n)}`);
    const t = [
      ["height", yn],
      ["stableHeight", An],
      ["width", Ts],
      ["safeAreaInsetTop", bs],
      ["safeAreaInsetBottom", ds],
      ["safeAreaInsetLeft", ms],
      ["safeAreaInsetRight", hs],
      ["contentSafeAreaInsetTop", Ss],
      ["contentSafeAreaInsetBottom", gs],
      ["contentSafeAreaInsetLeft", Es],
      ["contentSafeAreaInsetRight", ws]
    ].reduce((n, [o, s]) => {
      const r = e(o);
      if (r) {
        const a = () => {
          Vt(r, `${s()}px`);
        };
        n.push([a, s.sub(a), r]);
      }
      return n;
    }, []);
    return t.forEach((n) => {
      n[0]();
    }), je.set(!0), () => {
      t.forEach((n) => {
        n[1](), Lt(n[2]);
      }), je.set(!1);
    };
  }
), yc = fs("expand", () => {
  f("web_app_expand");
}), Ac = K("isExpanded"), Cc = /* @__PURE__ */ _(() => yn() === An()), ou = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bindCssVars: Sc,
  changeFullscreenError: ls,
  changeFullscreenPromise: En,
  contentSafeAreaInsetBottom: gs,
  contentSafeAreaInsetLeft: Es,
  contentSafeAreaInsetRight: ws,
  contentSafeAreaInsetTop: Ss,
  contentSafeAreaInsets: Sn,
  exitFullscreen: dc,
  expand: yc,
  height: yn,
  isChangingFullscreen: lc,
  isCssVarsBound: je,
  isExpanded: Ac,
  isFullscreen: us,
  isMounted: Be,
  isMounting: pc,
  isStable: Cc,
  mount: Ec,
  mountError: ps,
  mountPromise: _t,
  requestFullscreen: fc,
  safeAreaInsetBottom: ds,
  safeAreaInsetLeft: ms,
  safeAreaInsetRight: hs,
  safeAreaInsetTop: bs,
  safeAreaInsets: wn,
  stableHeight: An,
  state: _e,
  unmount: wc,
  width: Ts
}, Symbol.toStringTag, { value: "Module" })), Ln = "web_app_request_emoji_status_access", $s = /* @__PURE__ */ c(), vc = /* @__PURE__ */ c(), su = /* @__PURE__ */ _(() => !!$s()), ru = /* @__PURE__ */ h(
  "requestEmojiStatusAccess",
  /* @__PURE__ */ Re(
    () => y(Ln, "emoji_status_access_requested").then((e) => e.status),
    () => new l(
      q,
      "Emoji status access request is currently in progress"
    ),
    $s,
    vc,
    !1
  ),
  { isSupported: Ln }
), jn = "web_app_set_emoji_status", Rs = /* @__PURE__ */ c(), Tc = /* @__PURE__ */ c(), au = /* @__PURE__ */ _(() => !!Rs()), iu = /* @__PURE__ */ h(
  "setEmojiStatus",
  /* @__PURE__ */ Re(
    async (e, t) => {
      const n = await y(jn, ["emoji_status_set", "emoji_status_failed"], {
        params: {
          custom_emoji_id: e,
          duration: t
        }
      });
      if (n && "error" in n)
        throw new l(qr, "Failed to set emoji status", n.error);
    },
    () => new l(
      q,
      "Emoji status set request is currently in progress"
    ),
    Rs,
    Tc,
    !1
  ),
  { isSupported: jn }
), Os = "web_app_add_to_home_screen", ie = { isSupported: Os }, Ps = /* @__PURE__ */ c(), $c = /* @__PURE__ */ c(), cu = /* @__PURE__ */ _(() => !!Ps()), uu = /* @__PURE__ */ h(
  "addToHomeScreen",
  () => {
    f(Os);
  },
  ie
), lu = /* @__PURE__ */ h(
  "checkHomeScreenStatus",
  /* @__PURE__ */ Re(
    (e) => y("web_app_check_home_screen", "home_screen_checked", e).then((t) => t.status || "unknown"),
    () => new l(
      q,
      "Check home screen status request is currently in progress"
    ),
    Ps,
    $c
  ),
  ie
), pu = /* @__PURE__ */ h(
  "onAddedToHomeScreen",
  (e, t) => E("home_screen_added", e, t),
  ie
), _u = /* @__PURE__ */ h(
  "onAddToHomeScreenFailed",
  (e, t) => E("home_screen_failed", e, t),
  ie
), fu = /* @__PURE__ */ h(
  "offAddedToHomeScreen",
  (e) => {
    v("home_screen_added", e);
  },
  ie
), du = /* @__PURE__ */ h(
  "offAddToHomeScreenFailed",
  (e) => {
    v("home_screen_failed", e);
  },
  ie
), Rc = H(), mu = Rc(
  "openLink",
  (e, t) => {
    if (typeof e == "string")
      try {
        e = new URL(e);
      } catch (n) {
        throw new l(Ft, `"${e.toString()}" is invalid URL`, n);
      }
    t || (t = {}), f("web_app_open_link", {
      url: e.toString(),
      try_browser: t.tryBrowser,
      try_instant_view: t.tryInstantView
    });
  }
), Hn = "web_app_open_tg_link", Oc = H(), Pc = Oc(
  "openTelegramLink",
  (e) => {
    const t = e.toString();
    if (!t.match(/^https:\/\/t.me\/.+/))
      throw new l(Ft, `"${t}" is invalid URL`);
    if (!Q(Hn, V())) {
      window.location.href = t;
      return;
    }
    e = new URL(e), f(Hn, { path_full: e.pathname + e.search });
  }
), Bc = H(), hu = Bc(
  "shareURL",
  (e, t) => {
    Pc(
      "https://t.me/share/url?" + new URLSearchParams({ url: e, text: t || "" }).toString().replace(/\+/g, "%20")
    );
  }
), Dt = "web_app_request_phone", wt = /* @__PURE__ */ c(!1), Mc = /* @__PURE__ */ h(
  "requestPhoneAccess",
  (e) => {
    if (wt())
      throw new l(q, "Phone access request is currently in progress");
    return wt.set(!0), y(Dt, "phone_requested", e).then((t) => t.status).finally(() => {
      wt.set(!1);
    });
  },
  {
    isSupported: Dt
  }
);
function Un(e) {
  return e || (e = {}), se("getRequestedContact", {}, {
    ...e,
    timeout: e.timeout || 5e3
  }).then(
    Kn({
      contact: He({
        userId: ["user_id", Ue()],
        phoneNumber: ["phone_number", L()],
        firstName: ["first_name", L()],
        lastName: ["last_name", L(!0)]
      })(),
      authDate: ["auth_date", Nt()],
      hash: L()
    })()
  );
}
const bu = /* @__PURE__ */ h(
  "requestContact",
  (e) => b.withFn(
    async (t) => {
      const n = { abortSignal: t };
      try {
        return await Un(n);
      } catch {
      }
      if (await Mc(n) !== "sent")
        throw new l(kr, "User denied access");
      let s = 50;
      for (; !t.aborted; ) {
        try {
          return await Un(n);
        } catch {
        }
        await ar(s), s += 50;
      }
      return null;
    },
    e
  ),
  {
    isSupported: Dt
  }
), qn = "web_app_request_write_access", St = /* @__PURE__ */ c(!1), gu = /* @__PURE__ */ h(
  "requestWriteAccess",
  (e) => {
    if (St())
      throw new l(q, "Write access request is currently in progress");
    return St.set(!0), y(qn, "write_access_requested", e).then((t) => t.status).finally(() => {
      St.set(!1);
    });
  },
  {
    isSupported: qn
  }
), Eu = /* @__PURE__ */ h(
  "getCurrentTime",
  (e) => se("getCurrentTime", {}, e).then(Nt()),
  {
    isSupported: "web_app_invoke_custom_method"
  }
), Fn = "web_app_read_text_from_clipboard", wu = /* @__PURE__ */ h(
  "readTextFromClipboard",
  (e) => {
    const t = Co();
    return y(Fn, "clipboard_text_received", {
      ...e,
      params: { req_id: t },
      capture: yo(t)
    }).then(({ data: n = null }) => n);
  },
  {
    isSupported: Fn
  }
), Su = /* @__PURE__ */ h(
  "sendData",
  (e) => {
    const { size: t } = new Blob([e]);
    if (!t || t > 4096)
      throw new l(Nr, t ? "Maximum size of data to send is 4096 bytes" : "Attempted to send empty data");
    f("web_app_data_send", { data: e });
  }
), Wn = "web_app_share_to_story", yu = /* @__PURE__ */ h(
  "shareStory",
  (e, t) => {
    t || (t = {}), f(Wn, {
      text: t.text,
      media_url: e,
      widget_link: t.widgetLink
    });
  },
  { isSupported: Wn }
), Gn = "web_app_switch_inline_query", Au = /* @__PURE__ */ h(
  "switchInlineQuery",
  (e, t) => {
    f(Gn, {
      query: e,
      chat_types: t || []
    });
  },
  {
    isSupported: [Gn, {
      fn: () => !!oe().botInline,
      error: "Mini App should be ran in Bot inline mode"
    }]
  }
);
function Cu(e) {
  try {
    return { result: e() };
  } catch (t) {
    return { error: t };
  }
}
function vu(e) {
  Ir(e), Cr();
  const [t, n] = te(
    E("reload_iframe", () => {
      f("iframe_will_reload"), window.location.reload();
    }),
    vr
  ), { acceptCustomStyles: o = !0 } = e || {};
  if (o) {
    const s = document.createElement("style");
    s.id = "telegram-custom-styles", document.head.appendChild(s), t(
      E("set_custom_style", (r) => {
        s.innerHTML = r;
      }),
      () => {
        document.head.removeChild(s);
      }
    );
  }
  return f("iframe_ready", { reload_supported: !0 }), n;
}
export {
  Mr as $createRequestId,
  lr as $debug,
  Ao as $postEvent,
  gr as $targetOrigin,
  V as $version,
  b as CancelablePromise,
  po as ERR_ABORTED,
  kr as ERR_ACCESS_DENIED,
  xr as ERR_ALREADY_MOUNTING,
  Wt as ERR_ALREADY_OPENED,
  q as ERR_ALREADY_REQUESTING,
  _o as ERR_CANCELED,
  Vr as ERR_CSS_VARS_ALREADY_BOUND,
  br as ERR_CUSTOM_METHOD_ERR_RESPONSE,
  Nr as ERR_DATA_INVALID_SIZE,
  qr as ERR_EMOJI_STATUS_SET_FAILED,
  Ur as ERR_FULLSCREEN_FAILED,
  Dr as ERR_INVALID_SLUG,
  Ft as ERR_INVALID_URL,
  Ms as ERR_INVALID_VALUE,
  hr as ERR_METHOD_PARAMETER_UNSUPPORTED,
  dr as ERR_METHOD_UNSUPPORTED,
  Lr as ERR_NOT_AVAILABLE,
  jr as ERR_NOT_INITIALIZED,
  Hr as ERR_NOT_MOUNTED,
  In as ERR_NOT_SUPPORTED,
  Qn as ERR_PARSE,
  ce as ERR_POPUP_INVALID_PARAMS,
  mr as ERR_RETRIEVE_LP_FAILED,
  fo as ERR_TIMED_OUT,
  Ds as ERR_UNEXPECTED_TYPE,
  Is as ERR_UNEXPECTED_VALUE,
  go as ERR_UNKNOWN_ENV,
  l as TypedError,
  lo as addEventListener,
  uu as addToHomeScreen,
  aa as authenticateBiometry,
  Hc as backButton,
  Ei as bindMiniAppCssVars,
  di as bindThemeParamsCssVars,
  Sc as bindViewportCssVars,
  Uc as biometry,
  Ro as biometryMountError,
  Qe as biometryState,
  ls as changeFullscreenError,
  En as changeFullscreenPromise,
  lu as checkHomeScreenStatus,
  $c as checkHomeScreenStatusError,
  Ps as checkHomeScreenStatusPromise,
  yt as classNames,
  wi as closeMiniApp,
  Bt as closeQrScanner,
  qc as closingBehavior,
  Fc as cloudStorage,
  Tr as compareVersions,
  $r as createPostEvent,
  Cr as defineEventHandlers,
  ga as deleteCloudStorageItem,
  Lt as deleteCssVar,
  fa as disableClosingConfirmation,
  sc as disableVerticalSwipes,
  vt as emitMiniAppsEvent,
  da as enableClosingConfirmation,
  rc as enableVerticalSwipes,
  dc as exitFullscreen,
  yc as expandViewport,
  wa as getCloudStorageItem,
  Sa as getCloudStorageKeys,
  Eu as getCurrentTime,
  Wc as hapticFeedback,
  Ca as hapticFeedbackImpactOccurred,
  va as hapticFeedbackNotificationOccurred,
  Ta as hapticFeedbackSelectionChanged,
  Wr as hideBackButton,
  Yi as hideSettingsButton,
  vu as init,
  Gc as initData,
  Io as initDataAuthDate,
  Do as initDataCanSendAfter,
  $a as initDataCanSendAfterDate,
  Ra as initDataChat,
  Pa as initDataChatInstance,
  Oa as initDataChatType,
  Ba as initDataHash,
  Ma as initDataQueryId,
  No as initDataRaw,
  Ia as initDataReceiver,
  Na as initDataStartParam,
  en as initDataState,
  ka as initDataUser,
  Qc as invoice,
  Rr as invokeCustomMethod,
  kc as isAbortError,
  Ie as isAuthenticatingBiometry,
  me as isBackButtonMounted,
  Fr as isBackButtonSupported,
  $t as isBackButtonVisible,
  Je as isBiometryMounted,
  Kr as isBiometryMounting,
  oa as isBiometrySupported,
  xc as isCanceledError,
  lc as isChangingFullscreen,
  cu as isCheckingHomeScreenStatus,
  he as isClosingBehaviorMounted,
  Rt as isClosingConfirmationEnabled,
  ba as isCloudStorageSupported,
  Vo as isColorDark,
  us as isFullscreen,
  Aa as isHapticFeedbackSupported,
  tr as isIframe,
  Ne as isInvoiceOpened,
  Va as isInvoiceSupported,
  Xa as isMainButtonEnabled,
  ei as isMainButtonLoaderVisible,
  ge as isMainButtonMounted,
  ti as isMainButtonVisible,
  ot as isMiniAppActive,
  xe as isMiniAppCssVarsBound,
  hi as isMiniAppDark,
  ye as isMiniAppMounted,
  bi as isMiniAppSupported,
  Le as isPopupOpened,
  Ti as isPopupSupported,
  X as isQrScannerOpened,
  Bi as isQrScannerSupported,
  fe as isRGB,
  xs as isRGBShort,
  Xn as isRecord,
  De as isRequestingBiometryAccess,
  su as isRequestingEmojiStatusAccess,
  wt as isRequestingPhoneAccess,
  St as isRequestingWriteAccess,
  Dn as isSSR,
  ki as isSecondaryButtonEnabled,
  xi as isSecondaryButtonLoaderVisible,
  Ae as isSecondaryButtonMounted,
  qi as isSecondaryButtonSupported,
  Vi as isSecondaryButtonVisible,
  au as isSettingEmojiStatus,
  Ce as isSettingsButtonMounted,
  Ji as isSettingsButtonSupported,
  Mt as isSettingsButtonVisible,
  ve as isSwipeBehaviorMounted,
  nc as isSwipeBehaviorSupported,
  Bn as isTMA,
  ke as isThemeParamsCssVarsBound,
  Fa as isThemeParamsDark,
  be as isThemeParamsMounted,
  Nc as isTimeoutError,
  It as isVerticalSwipesEnabled,
  je as isViewportCssVarsBound,
  Ac as isViewportExpanded,
  Be as isViewportMounted,
  pc as isViewportMounting,
  Cc as isViewportStable,
  Jc as mainButton,
  Ka as mainButtonBackgroundColor,
  Za as mainButtonHasShineEffect,
  sn as mainButtonState,
  ni as mainButtonText,
  oi as mainButtonTextColor,
  Dc as mergeClassNames,
  Yc as miniApp,
  Ee as miniAppBackgroundColor,
  cn as miniAppBackgroundColorRGB,
  we as miniAppBottomBarColor,
  un as miniAppBottomBarColorRGB,
  Se as miniAppHeaderColor,
  Go as miniAppHeaderColorRGB,
  yi as miniAppReady,
  zo as miniAppState,
  Vc as mockTelegramEnv,
  Gr as mountBackButton,
  ua as mountBiometry,
  ma as mountClosingBehavior,
  ai as mountMainButton,
  Si as mountMiniApp,
  Fi as mountSecondaryButton,
  Ki as mountSettingsButton,
  ac as mountSwipeBehavior,
  qo as mountThemeParams,
  Ec as mountViewport,
  v as off,
  du as offAddToHomeScreenFailed,
  fu as offAddedToHomeScreen,
  Qr as offBackButtonClick,
  ci as offMainButtonClick,
  Gi as offSecondaryButtonClick,
  Xi as offSettingsButtonClick,
  E as on,
  _u as onAddToHomeScreenFailed,
  pu as onAddedToHomeScreen,
  zr as onBackButtonClick,
  ii as onMainButtonClick,
  Wi as onSecondaryButtonClick,
  Zi as onSettingsButtonClick,
  ia as openBiometrySettings,
  La as openInvoice,
  mu as openLink,
  $i as openPopup,
  Ii as openQrScanner,
  Pc as openTelegramLink,
  zc as parseInitData,
  pi as parseThemeParams,
  Kc as popup,
  Ht as postEvent,
  Zc as qrScanner,
  wu as readTextFromClipboard,
  vr as removeEventHandlers,
  Ut as request,
  Xr as requestBiometry,
  ca as requestBiometryAccess,
  bu as requestContact,
  hc as requestContentSafeAreaInsets,
  ru as requestEmojiStatusAccess,
  vc as requestEmojiStatusAccessError,
  $s as requestEmojiStatusAccessPromise,
  fc as requestFullscreen,
  Mc as requestPhoneAccess,
  bc as requestSafeAreaInsets,
  gc as requestViewport,
  gu as requestWriteAccess,
  Da as restoreInitData,
  oe as retrieveLaunchParams,
  Cu as safeCall,
  Xc as secondaryButton,
  Di as secondaryButtonBackgroundColor,
  Ni as secondaryButtonHasShineEffect,
  Li as secondaryButtonPosition,
  fn as secondaryButtonState,
  ji as secondaryButtonText,
  Hi as secondaryButtonTextColor,
  Su as sendData,
  Ic as serializeLaunchParams,
  vn as serializeThemeParams,
  ya as setCloudStorageItem,
  Vt as setCssVar,
  iu as setEmojiStatus,
  Tc as setEmojiStatusError,
  Rs as setEmojiStatusPromise,
  ui as setMainButtonParams,
  Ko as setMiniAppBackgroundColor,
  Zo as setMiniAppBottomBarColor,
  Xo as setMiniAppHeaderColor,
  zi as setSecondaryButtonParams,
  eu as settingsButton,
  yu as shareStory,
  hu as shareURL,
  Jr as showBackButton,
  ec as showSettingsButton,
  Lc as subscribe,
  Q as supports,
  tu as swipeBehavior,
  Au as switchInlineQuery,
  nu as themeParams,
  ja as themeParamsAccentTextColor,
  nn as themeParamsBackgroundColor,
  jo as themeParamsBottomBarBgColor,
  on as themeParamsButtonColor,
  Lo as themeParamsButtonTextColor,
  Ha as themeParamsDestructiveTextColor,
  Ua as themeParamsHeaderBackgroundColor,
  qa as themeParamsHintColor,
  Wa as themeParamsLinkColor,
  Fe as themeParamsSecondaryBackgroundColor,
  Ga as themeParamsSectionBackgroundColor,
  za as themeParamsSectionHeaderTextColor,
  Qa as themeParamsSectionSeparatorColor,
  U as themeParamsState,
  Ja as themeParamsSubtitleTextColor,
  Ya as themeParamsTextColor,
  Zn as toRGB,
  Yn as toRecord,
  Yr as unmountBackButton,
  la as unmountBiometry,
  ha as unmountClosingBehavior,
  li as unmountMainButton,
  Ai as unmountMiniApp,
  Qi as unmountSecondaryButton,
  tc as unmountSettingsButton,
  ic as unmountSwipeBehavior,
  mi as unmountThemeParams,
  wc as unmountViewport,
  jc as unsubscribe,
  pa as updateBiometryToken,
  ou as viewport,
  gs as viewportContentSafeAreaInsetBottom,
  Es as viewportContentSafeAreaInsetLeft,
  ws as viewportContentSafeAreaInsetRight,
  Ss as viewportContentSafeAreaInsetTop,
  Sn as viewportContentSafeAreaInsets,
  yn as viewportHeight,
  ps as viewportMountError,
  _t as viewportMountPromise,
  ds as viewportSafeAreaInsetBottom,
  ms as viewportSafeAreaInsetLeft,
  hs as viewportSafeAreaInsetRight,
  bs as viewportSafeAreaInsetTop,
  wn as viewportSafeAreaInsets,
  An as viewportStableHeight,
  _e as viewportState,
  Ts as viewportWidth
};
//# sourceMappingURL=index.js.map
