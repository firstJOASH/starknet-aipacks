import {
  e
} from "./chunk-OCOZLJAH.js";
import {
  F,
  q
} from "./chunk-IZCIPCCQ.js";
import {
  constants_exports
} from "./chunk-ALJOHPWU.js";

// node_modules/starknetkit/dist/trpc-870d4938.js
var fn = "https://web.ready.co";
var Ea = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect x="2" y="2" width="28" height="28" rx="5.6" fill="black"/>
  <g clip-path="url(#clip0_9_981)">
    <path d="M10.5 20.9999H21.5C21.9166 20.9999 22.2736 20.7452 22.424 20.383L18.1419 16.3631L16.3739 18.0018C16.163 18.1973 15.837 18.1973 15.6261 18.0018L13.8581 16.3631L9.57603 20.383C9.72637 20.7452 10.0834 20.9999 10.5 20.9999Z" fill="white"/>
    <path d="M18.8771 15.6817L22.5 19.0828V12.3239L18.8771 15.6817Z" fill="white"/>
    <path d="M13.1229 15.6817L9.5 12.3239V19.0828L13.1229 15.6817Z" fill="white"/>
    <path d="M22 10.9999H10C9.8752 10.9999 9.76108 11.0456 9.67348 11.1212L15.7734 16.7748C15.9012 16.8933 16.0988 16.8933 16.2266 16.7748L22.3265 11.1212C22.2389 11.0456 22.1248 10.9999 22 10.9999Z" fill="white"/>
  </g>
  <rect x="20" y="20" width="12" height="12" rx="2.4" fill="#FF875B"/>
  <path d="M26.9611 22.6222H25.0397C24.9755 22.6222 24.924 22.675 24.9226 22.7406C24.8838 24.5841 23.9398 26.3339 22.3148 27.5732C22.2633 27.6126 22.2515 27.6865 22.2892 27.7397L23.4134 29.3279C23.4517 29.3819 23.5262 29.3941 23.5786 29.3544C24.5947 28.5845 25.4119 27.6558 26.0004 26.6264C26.5889 27.6558 27.4062 28.5845 28.4222 29.3544C28.4746 29.3941 28.5492 29.3819 28.5875 29.3279L29.7117 27.7397C29.7493 27.6865 29.7376 27.6126 29.686 27.5732C28.0611 26.3339 27.117 24.5841 27.0782 22.7406C27.0768 22.675 27.0253 22.6222 26.9611 22.6222Z" fill="white"/>
  <defs>
  <clipPath id="clip0_9_981">
    <rect width="16" height="16" fill="white" transform="translate(8 7.99991)"/>
  </clipPath>
  </defs>
</svg>`;
var Ca = "https://static.hydrogen.argent47.net/webwallet/iframe_whitelist_testnet.json";
var Ra = "https://static.argent.net/webwallet/iframe_whitelist_mainnet.json";
var Oa = (t) => t === constants_exports.StarknetChainId.SN_MAIN ? constants_exports.StarknetChainId.SN_MAIN : constants_exports.StarknetChainId.SN_SEPOLIA;
var G = constants_exports.NetworkName;
var pn = G.SN_SEPOLIA;
function Sa(t) {
  try {
    const { origin: e2 } = new URL(t);
    if (e2.includes("localhost") || e2.includes("127.0.0.1"))
      return pn;
    if (e2.includes("hydrogen") || e2.includes("sepolia-web.staging"))
      return G.SN_SEPOLIA;
    if (e2.includes("staging"))
      return G.SN_MAIN;
    if (e2.includes("dev") || e2.includes("sepolia-web.ready.co"))
      return G.SN_SEPOLIA;
    if (e2.includes("ready.co"))
      return G.SN_MAIN;
  } catch {
    console.warn(
      "Could not determine network from target URL, defaulting to mainnet-alpha"
    );
  }
  return G.SN_MAIN;
}
function hn(t) {
  return t;
}
function mn(t) {
  return t.length === 0 ? hn : t.length === 1 ? t[0] : function(r) {
    return t.reduce((n, s) => s(n), r);
  };
}
function yn(t) {
  return typeof t == "object" && t !== null && "subscribe" in t;
}
function Ke(t) {
  const e2 = {
    subscribe(r) {
      let n = null, s = false, i = false, a = false;
      function o() {
        if (n === null) {
          a = true;
          return;
        }
        i || (i = true, typeof n == "function" ? n() : n && n.unsubscribe());
      }
      return n = t({
        next(c) {
          var _a3;
          s || ((_a3 = r.next) == null ? void 0 : _a3.call(r, c));
        },
        error(c) {
          var _a3;
          s || (s = true, (_a3 = r.error) == null ? void 0 : _a3.call(r, c), o());
        },
        complete() {
          var _a3;
          s || (s = true, (_a3 = r.complete) == null ? void 0 : _a3.call(r), o());
        }
      }), a && o(), {
        unsubscribe: o
      };
    },
    pipe(...r) {
      return mn(r)(e2);
    }
  };
  return e2;
}
function dr(t) {
  return (e2) => {
    let r = 0, n = null;
    const s = [];
    function i() {
      n || (n = e2.subscribe({
        next(o) {
          var _a3;
          for (const c of s)
            (_a3 = c.next) == null ? void 0 : _a3.call(c, o);
        },
        error(o) {
          var _a3;
          for (const c of s)
            (_a3 = c.error) == null ? void 0 : _a3.call(c, o);
        },
        complete() {
          var _a3;
          for (const o of s)
            (_a3 = o.complete) == null ? void 0 : _a3.call(o);
        }
      }));
    }
    function a() {
      if (r === 0 && n) {
        const o = n;
        n = null, o.unsubscribe();
      }
    }
    return {
      subscribe(o) {
        return r++, s.push(o), i(), {
          unsubscribe() {
            r--, a();
            const c = s.findIndex((u) => u === o);
            c > -1 && s.splice(c, 1);
          }
        };
      }
    };
  };
}
function gn(t) {
  return (e2) => ({
    subscribe(r) {
      let n = 0;
      return e2.subscribe({
        next(i) {
          var _a3;
          (_a3 = r.next) == null ? void 0 : _a3.call(r, t(i, n++));
        },
        error(i) {
          var _a3;
          (_a3 = r.error) == null ? void 0 : _a3.call(r, i);
        },
        complete() {
          var _a3;
          (_a3 = r.complete) == null ? void 0 : _a3.call(r);
        }
      });
    }
  });
}
function lr(t) {
  return (e2) => ({
    subscribe(r) {
      return e2.subscribe({
        next(n) {
          var _a3, _b2;
          (_a3 = t.next) == null ? void 0 : _a3.call(t, n), (_b2 = r.next) == null ? void 0 : _b2.call(r, n);
        },
        error(n) {
          var _a3, _b2;
          (_a3 = t.error) == null ? void 0 : _a3.call(t, n), (_b2 = r.error) == null ? void 0 : _b2.call(r, n);
        },
        complete() {
          var _a3, _b2;
          (_a3 = t.complete) == null ? void 0 : _a3.call(t), (_b2 = r.complete) == null ? void 0 : _b2.call(r);
        }
      });
    }
  });
}
var _n = class fr extends Error {
  constructor(e2) {
    super(e2), this.name = "ObservableAbortError", Object.setPrototypeOf(this, fr.prototype);
  }
};
function pr(t) {
  let e2;
  return {
    promise: new Promise((n, s) => {
      let i = false;
      function a() {
        i || (i = true, s(new _n("This operation was aborted.")), o.unsubscribe());
      }
      const o = t.subscribe({
        next(c) {
          i = true, n(c), a();
        },
        error(c) {
          i = true, s(c), a();
        },
        complete() {
          i = true, a();
        }
      });
      e2 = a;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: e2
  };
}
var vn = Object.freeze(Object.defineProperty({
  __proto__: null,
  isObservable: yn,
  map: gn,
  observable: Ke,
  observableToPromise: pr,
  share: dr,
  tap: lr
}, Symbol.toStringTag, { value: "Module" }));
function hr(t) {
  return Ke((e2) => {
    function r(s = 0, i = t.op) {
      const a = t.links[s];
      if (!a)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return a({
        op: i,
        next(c) {
          return r(s + 1, c);
        }
      });
    }
    return r().subscribe(e2);
  });
}
function Ht(t) {
  return Array.isArray(t) ? t : [
    t
  ];
}
function bn(t) {
  return (e2) => {
    const r = Ht(t.true).map((s) => s(e2)), n = Ht(t.false).map((s) => s(e2));
    return (s) => Ke((i) => {
      const a = t.condition(s.op) ? r : n;
      return hr({
        op: s.op,
        links: a
      }).subscribe(i);
    });
  };
}
function mr(t) {
  const e2 = /* @__PURE__ */ Object.create(null);
  for (const r in t) {
    const n = t[r];
    e2[n] = r;
  }
  return e2;
}
var et = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  // Internal JSON-RPC error
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
mr(et);
mr(et);
var wn = {
  PARSE_ERROR: 400,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  NOT_FOUND: 404,
  FORBIDDEN: 403,
  METHOD_NOT_SUPPORTED: 405,
  TIMEOUT: 408,
  CONFLICT: 409,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  UNPROCESSABLE_CONTENT: 422,
  TOO_MANY_REQUESTS: 429,
  CLIENT_CLOSED_REQUEST: 499,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501
};
function xn(t) {
  return wn[t] ?? 500;
}
function yr(t) {
  return xn(t.code);
}
var gr = () => {
};
function _r(t, e2) {
  return new Proxy(gr, {
    get(n, s) {
      if (!(typeof s != "string" || s === "then"))
        return _r(t, [
          ...e2,
          s
        ]);
    },
    apply(n, s, i) {
      const a = e2[e2.length - 1] === "apply";
      return t({
        args: a ? i.length >= 2 ? i[1] : [] : i,
        path: a ? e2.slice(0, -1) : e2
      });
    }
  });
}
var Pt = (t) => _r(t, []);
var Nt = (t) => new Proxy(gr, {
  get(e2, r) {
    if (!(typeof r != "string" || r === "then"))
      return t(r);
  }
});
function kn(t) {
  const { path: e2, error: r, config: n } = t, { code: s } = t.error, i = {
    message: r.message,
    code: et[s],
    data: {
      code: s,
      httpStatus: yr(r)
    }
  };
  return n.isDev && typeof t.error.stack == "string" && (i.data.stack = t.error.stack), typeof e2 == "string" && (i.data.path = e2), n.errorFormatter({
    ...t,
    shape: i
  });
}
function Ft(t, e2) {
  return "error" in e2 ? {
    ...e2,
    error: t.transformer.output.serialize(e2.error)
  } : "data" in e2.result ? {
    ...e2,
    result: {
      ...e2.result,
      data: t.transformer.output.serialize(e2.result.data)
    }
  } : e2;
}
function Tn(t, e2) {
  return Array.isArray(e2) ? e2.map((r) => Ft(t, r)) : Ft(t, e2);
}
function En(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
var Cn = class extends Error {
};
function Lt(t) {
  if (t instanceof Error)
    return t;
  const e2 = typeof t;
  if (!(e2 === "undefined" || e2 === "function" || t === null)) {
    if (e2 !== "object")
      return new Error(String(t));
    if (En(t)) {
      const r = new Cn();
      for (const n in t)
        r[n] = t[n];
      return r;
    }
  }
}
var Rn = Object.freeze(Object.defineProperty({
  __proto__: null,
  createFlatProxy: Nt,
  createRecursiveProxy: Pt,
  getCauseFromUnknown: Lt,
  getErrorShape: kn,
  transformTRPCResponse: Tn
}, Symbol.toStringTag, { value: "Module" }));
function Jt(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
function On(t) {
  return t instanceof vr || /**
  * @deprecated
  * Delete in next major
  */
  t instanceof Error && t.name === "TRPCClientError";
}
function Sn(t) {
  return Jt(t) && Jt(t.error) && typeof t.error.code == "number" && typeof t.error.message == "string";
}
var vr = class be extends Error {
  static from(e2, r = {}) {
    const n = e2;
    return On(n) ? (r.meta && (n.meta = {
      ...n.meta,
      ...r.meta
    }), n) : Sn(n) ? new be(n.error.message, {
      ...r,
      result: n
    }) : n instanceof Error ? new be(n.message, {
      ...r,
      cause: Lt(n)
    }) : new be("Unknown error", {
      ...r,
      cause: n
    });
  }
  constructor(e2, r) {
    var _a3, _b2;
    const n = r == null ? void 0 : r.cause;
    super(e2, {
      cause: n
    }), this.meta = r == null ? void 0 : r.meta, this.cause = n, this.shape = (_a3 = r == null ? void 0 : r.result) == null ? void 0 : _a3.error, this.data = (_b2 = r == null ? void 0 : r.result) == null ? void 0 : _b2.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, be.prototype);
  }
};
function Pn(t) {
  return typeof FormData > "u" ? false : t instanceof FormData;
}
var dt = {
  css: {
    query: [
      "72e3ff",
      "3fb0d8"
    ],
    mutation: [
      "c5a3fc",
      "904dfc"
    ],
    subscription: [
      "ff49e1",
      "d83fbe"
    ]
  },
  ansi: {
    regular: {
      // Cyan background, black and white text respectively
      query: [
        "\x1B[30;46m",
        "\x1B[97;46m"
      ],
      // Magenta background, black and white text respectively
      mutation: [
        "\x1B[30;45m",
        "\x1B[97;45m"
      ],
      // Green background, black and white text respectively
      subscription: [
        "\x1B[30;42m",
        "\x1B[97;42m"
      ]
    },
    bold: {
      query: [
        "\x1B[1;30;46m",
        "\x1B[1;97;46m"
      ],
      mutation: [
        "\x1B[1;30;45m",
        "\x1B[1;97;45m"
      ],
      subscription: [
        "\x1B[1;30;42m",
        "\x1B[1;97;42m"
      ]
    }
  }
};
function Nn(t) {
  const { direction: e2, type: r, path: n, id: s, input: i } = t, a = [], o = [];
  if (t.colorMode === "ansi") {
    const [m, y] = dt.ansi.regular[r], [k, T] = dt.ansi.bold[r], N = "\x1B[0m";
    return a.push(e2 === "up" ? m : y, e2 === "up" ? ">>" : "<<", r, e2 === "up" ? k : T, `#${s}`, n, N), e2 === "up" ? o.push({
      input: t.input
    }) : o.push({
      input: t.input,
      // strip context from result cause it's too noisy in terminal wihtout collapse mode
      result: "result" in t.result ? t.result.result : t.result,
      elapsedMs: t.elapsedMs
    }), {
      parts: a,
      args: o
    };
  }
  const [c, u] = dt.css[r], l = `
    background-color: #${e2 === "up" ? c : u}; 
    color: ${e2 === "up" ? "black" : "white"};
    padding: 2px;
  `;
  return a.push("%c", e2 === "up" ? ">>" : "<<", r, `#${s}`, `%c${n}%c`, "%O"), o.push(l, `${l}; font-weight: bold;`, `${l}; font-weight: normal;`), e2 === "up" ? o.push({
    input: i,
    context: t.context
  }) : o.push({
    input: i,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: t.context
  }), {
    parts: a,
    args: o
  };
}
var Ln = ({ c: t = console, colorMode: e2 = "css" }) => (r) => {
  const n = r.input, s = Pn(n) ? Object.fromEntries(n) : n, { parts: i, args: a } = Nn({
    ...r,
    colorMode: e2,
    input: s
  }), o = r.direction === "down" && r.result && (r.result instanceof Error || "error" in r.result.result) ? "error" : "log";
  t[o].apply(null, [
    i.join(" ")
  ].concat(a));
};
function In(t = {}) {
  const { enabled: e2 = () => true } = t, r = t.colorMode ?? (typeof window > "u" ? "ansi" : "css"), { logger: n = Ln({
    c: t.console,
    colorMode: r
  }) } = t;
  return () => ({ op: s, next: i }) => Ke((a) => {
    e2({
      ...s,
      direction: "up"
    }) && n({
      ...s,
      direction: "up"
    });
    const o = Date.now();
    function c(u) {
      const l = Date.now() - o;
      e2({
        ...s,
        direction: "down",
        result: u
      }) && n({
        ...s,
        direction: "down",
        elapsedMs: l,
        result: u
      });
    }
    return i(s).pipe(lr({
      next(u) {
        c(u);
      },
      error(u) {
        c(u);
      }
    })).subscribe(a);
  });
}
var jn = class {
  $request({ type: e2, input: r, path: n, context: s = {} }) {
    return hr({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: e2,
        path: n,
        input: r,
        context: s
      }
    }).pipe(dr());
  }
  requestAsPromise(e2) {
    const r = this.$request(e2), { promise: n, abort: s } = pr(r);
    return new Promise((a, o) => {
      var _a3;
      (_a3 = e2.signal) == null ? void 0 : _a3.addEventListener("abort", s), n.then((c) => {
        a(c.result.data);
      }).catch((c) => {
        o(vr.from(c));
      });
    });
  }
  query(e2, r, n) {
    return this.requestAsPromise({
      type: "query",
      path: e2,
      input: r,
      context: n == null ? void 0 : n.context,
      signal: n == null ? void 0 : n.signal
    });
  }
  mutation(e2, r, n) {
    return this.requestAsPromise({
      type: "mutation",
      path: e2,
      input: r,
      context: n == null ? void 0 : n.context,
      signal: n == null ? void 0 : n.signal
    });
  }
  subscription(e2, r, n) {
    return this.$request({
      type: "subscription",
      path: e2,
      input: r,
      context: n == null ? void 0 : n.context
    }).subscribe({
      next(i) {
        var _a3, _b2, _c2;
        i.result.type === "started" ? (_a3 = n.onStarted) == null ? void 0 : _a3.call(n) : i.result.type === "stopped" ? (_b2 = n.onStopped) == null ? void 0 : _b2.call(n) : (_c2 = n.onData) == null ? void 0 : _c2.call(n, i.result.data);
      },
      error(i) {
        var _a3;
        (_a3 = n.onError) == null ? void 0 : _a3.call(n, i);
      },
      complete() {
        var _a3;
        (_a3 = n.onComplete) == null ? void 0 : _a3.call(n);
      }
    });
  }
  constructor(e2) {
    this.requestId = 0;
    const r = (() => {
      const n = e2.transformer;
      return n ? "input" in n ? e2.transformer : {
        input: n,
        output: n
      } : {
        input: {
          serialize: (s) => s,
          deserialize: (s) => s
        },
        output: {
          serialize: (s) => s,
          deserialize: (s) => s
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (n) => r.input.serialize(n),
        deserialize: (n) => r.output.deserialize(n)
      },
      combinedTransformer: r
    }, this.links = e2.links.map((n) => n(this.runtime));
  }
};
var An = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
var $n = (t) => An[t];
function Mn(t) {
  return Nt((e2) => t.hasOwnProperty(e2) ? t[e2] : e2 === "__untypedClient" ? t : Pt(({ path: r, args: n }) => {
    const s = [
      e2,
      ...r
    ], i = $n(s.pop()), a = s.join(".");
    return t[i](a, ...n);
  }));
}
function Dn(t) {
  const e2 = new jn(t);
  return Mn(e2);
}
function Zn(t) {
  if (t instanceof fe || t instanceof Error && t.name === "TRPCError")
    return t;
  const e2 = new fe({
    code: "INTERNAL_SERVER_ERROR",
    cause: t
  });
  return t instanceof Error && t.stack && (e2.stack = t.stack), e2;
}
var fe = class extends Error {
  constructor(e2) {
    const r = Lt(e2.cause), n = e2.message ?? (r == null ? void 0 : r.message) ?? e2.code;
    super(n, {
      cause: r
    }), this.code = e2.code, this.name = "TRPCError", this.cause || (this.cause = r);
  }
};
function Un(t) {
  return "input" in t ? t : {
    input: t,
    output: t
  };
}
var Te = {
  _default: true,
  input: {
    serialize: (t) => t,
    deserialize: (t) => t
  },
  output: {
    serialize: (t) => t,
    deserialize: (t) => t
  }
};
var Ee = ({ shape: t }) => t;
function qn(t) {
  return Object.assign(/* @__PURE__ */ Object.create(null), t);
}
var Bn = [
  "query",
  "mutation",
  "subscription"
];
function Vn(t) {
  return "router" in t._def;
}
var zn = {
  _ctx: null,
  _errorShape: null,
  _meta: null,
  queries: {},
  mutations: {},
  subscriptions: {},
  errorFormatter: Ee,
  transformer: Te
};
var Wn = [
  /**
  * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
  * since JS will think that `.then` is something that exists
  */
  "then"
];
function br(t) {
  return function(r) {
    const n = new Set(Object.keys(r).filter((c) => Wn.includes(c)));
    if (n.size > 0)
      throw new Error("Reserved words used in `router({})` call: " + Array.from(n).join(", "));
    const s = qn({});
    function i(c, u = "") {
      for (const [l, m] of Object.entries(c ?? {})) {
        const y = `${u}${l}`;
        if (Vn(m)) {
          i(m._def.procedures, `${y}.`);
          continue;
        }
        if (s[y])
          throw new Error(`Duplicate key: ${y}`);
        s[y] = m;
      }
    }
    i(r);
    const a = {
      _config: t,
      router: true,
      procedures: s,
      ...zn,
      record: r,
      queries: Object.entries(s).filter((c) => c[1]._def.query).reduce((c, [u, l]) => ({
        ...c,
        [u]: l
      }), {}),
      mutations: Object.entries(s).filter((c) => c[1]._def.mutation).reduce((c, [u, l]) => ({
        ...c,
        [u]: l
      }), {}),
      subscriptions: Object.entries(s).filter((c) => c[1]._def.subscription).reduce((c, [u, l]) => ({
        ...c,
        [u]: l
      }), {})
    }, o = {
      ...r,
      _def: a,
      createCaller(c) {
        return wr()(o)(c);
      },
      getErrorShape(c) {
        const { path: u, error: l } = c, { code: m } = c.error, y = {
          message: l.message,
          code: et[m],
          data: {
            code: m,
            httpStatus: yr(l)
          }
        };
        return t.isDev && typeof c.error.stack == "string" && (y.data.stack = c.error.stack), typeof u == "string" && (y.data.path = u), this._def._config.errorFormatter({
          ...c,
          shape: y
        });
      }
    };
    return o;
  };
}
function Hn(t) {
  var _a3;
  const { type: e2, path: r } = t;
  if (!(r in t.procedures) || !((_a3 = t.procedures[r]) == null ? void 0 : _a3._def[e2]))
    throw new fe({
      code: "NOT_FOUND",
      message: `No "${e2}"-procedure on path "${r}"`
    });
  const n = t.procedures[r];
  return n(t);
}
function wr() {
  return function(e2) {
    const r = e2._def;
    return function(s) {
      return Pt(({ path: a, args: o }) => {
        if (a.length === 1 && Bn.includes(a[0]))
          return Hn({
            procedures: r.procedures,
            path: o[0],
            rawInput: o[1],
            ctx: s,
            type: a[0]
          });
        const c = a.join("."), u = r.procedures[c];
        let l = "query";
        return u._def.mutation ? l = "mutation" : u._def.subscription && (l = "subscription"), u({
          path: c,
          rawInput: o[0],
          ctx: s,
          type: l
        });
      });
    };
  };
}
var _a, _b, _c, _d, _e, _f;
var Yt = typeof window > "u" || "Deno" in window || ((_b = (_a = globalThis.process) == null ? void 0 : _a.env) == null ? void 0 : _b.NODE_ENV) === "test" || !!((_d = (_c = globalThis.process) == null ? void 0 : _c.env) == null ? void 0 : _d.JEST_WORKER_ID) || !!((_f = (_e = globalThis.process) == null ? void 0 : _e.env) == null ? void 0 : _f.VITEST_WORKER_ID);
function Gt(t) {
  const e2 = t;
  if (typeof e2 == "function")
    return e2;
  if (typeof e2.parseAsync == "function")
    return e2.parseAsync.bind(e2);
  if (typeof e2.parse == "function")
    return e2.parse.bind(e2);
  if (typeof e2.validateSync == "function")
    return e2.validateSync.bind(e2);
  if (typeof e2.create == "function")
    return e2.create.bind(e2);
  if (typeof e2.assert == "function")
    return (r) => (e2.assert(r), r);
  throw new Error("Could not find a validator fn");
}
function xr(t, ...e2) {
  const r = Object.assign(/* @__PURE__ */ Object.create(null), t);
  for (const n of e2)
    for (const s in n) {
      if (s in r && r[s] !== n[s])
        throw new Error(`Duplicate key ${s}`);
      r[s] = n[s];
    }
  return r;
}
function Fn() {
  function t(r) {
    return {
      _middlewares: r,
      unstable_pipe(n) {
        const s = "_middlewares" in n ? n._middlewares : [
          n
        ];
        return t([
          ...r,
          ...s
        ]);
      }
    };
  }
  function e2(r) {
    return t([
      r
    ]);
  }
  return e2;
}
function Qt(t) {
  return t && typeof t == "object" && !Array.isArray(t);
}
function Jn(t) {
  const e2 = async ({ next: r, rawInput: n, input: s }) => {
    let i;
    try {
      i = await t(n);
    } catch (o) {
      throw new fe({
        code: "BAD_REQUEST",
        cause: o
      });
    }
    const a = Qt(s) && Qt(i) ? {
      ...s,
      ...i
    } : i;
    return r({
      input: a
    });
  };
  return e2._type = "input", e2;
}
function Yn(t) {
  const e2 = async ({ next: r }) => {
    const n = await r();
    if (!n.ok)
      return n;
    try {
      const s = await t(n.data);
      return {
        ...n,
        data: s
      };
    } catch (s) {
      throw new fe({
        message: "Output validation failed",
        code: "INTERNAL_SERVER_ERROR",
        cause: s
      });
    }
  };
  return e2._type = "output", e2;
}
var kr = "middlewareMarker";
function ce(t, e2) {
  const { middlewares: r = [], inputs: n, meta: s, ...i } = e2;
  return Tr({
    ...xr(t, i),
    inputs: [
      ...t.inputs,
      ...n ?? []
    ],
    middlewares: [
      ...t.middlewares,
      ...r
    ],
    meta: t.meta && s ? {
      ...t.meta,
      ...s
    } : s ?? t.meta
  });
}
function Tr(t = {}) {
  const e2 = {
    inputs: [],
    middlewares: [],
    ...t
  };
  return {
    _def: e2,
    input(r) {
      const n = Gt(r);
      return ce(e2, {
        inputs: [
          r
        ],
        middlewares: [
          Jn(n)
        ]
      });
    },
    output(r) {
      const n = Gt(r);
      return ce(e2, {
        output: r,
        middlewares: [
          Yn(n)
        ]
      });
    },
    meta(r) {
      return ce(e2, {
        meta: r
      });
    },
    /**
    * @deprecated
    * This functionality is deprecated and will be removed in the next major version.
    */
    unstable_concat(r) {
      return ce(e2, r._def);
    },
    use(r) {
      const n = "_middlewares" in r ? r._middlewares : [
        r
      ];
      return ce(e2, {
        middlewares: n
      });
    },
    query(r) {
      return lt({
        ...e2,
        query: true
      }, r);
    },
    mutation(r) {
      return lt({
        ...e2,
        mutation: true
      }, r);
    },
    subscription(r) {
      return lt({
        ...e2,
        subscription: true
      }, r);
    }
  };
}
function lt(t, e2) {
  const r = ce(t, {
    resolver: e2,
    middlewares: [
      async function(s) {
        const i = await e2(s);
        return {
          marker: kr,
          ok: true,
          data: i,
          ctx: s.ctx
        };
      }
    ]
  });
  return Qn(r._def);
}
var Gn = `
This is a client-only function.
If you want to call this function on the server, see https://trpc.io/docs/server/server-side-calls
`.trim();
function Qn(t) {
  const e2 = async function(n) {
    if (!n || !("rawInput" in n))
      throw new Error(Gn);
    const s = async (a = {
      index: 0,
      ctx: n.ctx
    }) => {
      try {
        const o = t.middlewares[a.index];
        return await o({
          ctx: a.ctx,
          type: n.type,
          path: n.path,
          rawInput: a.rawInput ?? n.rawInput,
          meta: t.meta,
          input: a.input,
          next(u) {
            const l = u;
            return s({
              index: a.index + 1,
              ctx: l && "ctx" in l ? {
                ...a.ctx,
                ...l.ctx
              } : a.ctx,
              input: l && "input" in l ? l.input : a.input,
              rawInput: l && "rawInput" in l ? l.rawInput : a.rawInput
            });
          }
        });
      } catch (o) {
        return {
          ok: false,
          error: Zn(o),
          marker: kr
        };
      }
    }, i = await s();
    if (!i)
      throw new fe({
        code: "INTERNAL_SERVER_ERROR",
        message: "No result from middlewares - did you forget to `return next()`?"
      });
    if (!i.ok)
      throw i.error;
    return i.data;
  };
  return e2._def = t, e2.meta = t.meta, e2;
}
function Xn(...t) {
  var _a3;
  const e2 = xr({}, ...t.map((i) => i._def.record)), r = t.reduce((i, a) => {
    if (a._def._config.errorFormatter && a._def._config.errorFormatter !== Ee) {
      if (i !== Ee && i !== a._def._config.errorFormatter)
        throw new Error("You seem to have several error formatters");
      return a._def._config.errorFormatter;
    }
    return i;
  }, Ee), n = t.reduce((i, a) => {
    if (a._def._config.transformer && a._def._config.transformer !== Te) {
      if (i !== Te && i !== a._def._config.transformer)
        throw new Error("You seem to have several transformers");
      return a._def._config.transformer;
    }
    return i;
  }, Te);
  return br({
    errorFormatter: r,
    transformer: n,
    isDev: t.some((i) => i._def._config.isDev),
    allowOutsideOfServer: t.some((i) => i._def._config.allowOutsideOfServer),
    isServer: t.some((i) => i._def._config.isServer),
    $types: (_a3 = t[0]) == null ? void 0 : _a3._def._config.$types
  })(e2);
}
var We = class _We {
  context() {
    return new _We();
  }
  meta() {
    return new _We();
  }
  create(e2) {
    return es()(e2);
  }
};
var Kn = new We();
function es() {
  return function(e2) {
    var _a3, _b2;
    const r = (e2 == null ? void 0 : e2.errorFormatter) ?? Ee, s = {
      transformer: Un((e2 == null ? void 0 : e2.transformer) ?? Te),
      isDev: (e2 == null ? void 0 : e2.isDev) ?? ((_b2 = (_a3 = globalThis.process) == null ? void 0 : _a3.env) == null ? void 0 : _b2.NODE_ENV) !== "production",
      allowOutsideOfServer: (e2 == null ? void 0 : e2.allowOutsideOfServer) ?? false,
      errorFormatter: r,
      isServer: (e2 == null ? void 0 : e2.isServer) ?? Yt,
      /**
      * @internal
      */
      $types: Nt((i) => {
        throw new Error(`Tried to access "$types.${i}" which is not available at runtime`);
      })
    };
    if (!((e2 == null ? void 0 : e2.isServer) ?? Yt) && (e2 == null ? void 0 : e2.allowOutsideOfServer) !== true)
      throw new Error("You're trying to use @trpc/server in a non-server environment. This is not supported by default.");
    return {
      /**
      * These are just types, they can't be used
      * @internal
      */
      _config: s,
      /**
      * Builder object for creating procedures
      * @see https://trpc.io/docs/server/procedures
      */
      procedure: Tr({
        meta: e2 == null ? void 0 : e2.defaultMeta
      }),
      /**
      * Create reusable middlewares
      * @see https://trpc.io/docs/server/middlewares
      */
      middleware: Fn(),
      /**
      * Create a router
      * @see https://trpc.io/docs/server/routers
      */
      router: br(s),
      /**
      * Merge Routers
      * @see https://trpc.io/docs/server/merging-routers
      */
      mergeRouters: Xn,
      /**
      * Create a server-side caller for a router
      * @see https://trpc.io/docs/server/server-side-calls
      */
      createCallerFactory: wr()
    };
  };
}
var vt = {};
var tt = {};
var ye = {};
var S = {};
var ge = F(vn);
var It = {};
var Er = ge;
function Cr(t) {
  return Er.observable((e2) => {
    function r(s = 0, i = t.op) {
      const a = t.links[s];
      if (!a)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return a({
        op: i,
        next(c) {
          return r(s + 1, c);
        }
      });
    }
    return r().subscribe(e2);
  });
}
function Xt(t) {
  return Array.isArray(t) ? t : [
    t
  ];
}
function ts(t) {
  return (e2) => {
    const r = Xt(t.true).map((s) => s(e2)), n = Xt(t.false).map((s) => s(e2));
    return (s) => Er.observable((i) => {
      const a = t.condition(s.op) ? r : n;
      return Cr({
        op: s.op,
        links: a
      }).subscribe(i);
    });
  };
}
It.createChain = Cr;
It.splitLink = ts;
var _e2 = {};
var Rr = F(Rn);
var ve = {};
function bt(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
function rs(t, e2) {
  if ("error" in t) {
    const n = e2.transformer.deserialize(t.error);
    return {
      ok: false,
      error: {
        ...t,
        error: n
      }
    };
  }
  return {
    ok: true,
    result: {
      ...t.result,
      ...(!t.result.type || t.result.type === "data") && {
        type: "data",
        data: e2.transformer.deserialize(t.result.data)
      }
    }
  };
}
var ft = class extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
};
function ns(t, e2) {
  let r;
  try {
    r = rs(t, e2);
  } catch {
    throw new ft();
  }
  if (!r.ok && (!bt(r.error.error) || typeof r.error.error.code != "number"))
    throw new ft();
  if (r.ok && !bt(r.result))
    throw new ft();
  return r;
}
ve.isObject = bt;
ve.transformResult = ns;
var ss = Rr;
var Kt = ve;
function is(t) {
  return t instanceof Or || /**
  * @deprecated
  * Delete in next major
  */
  t instanceof Error && t.name === "TRPCClientError";
}
function as(t) {
  return Kt.isObject(t) && Kt.isObject(t.error) && typeof t.error.code == "number" && typeof t.error.message == "string";
}
var Or = class we extends Error {
  static from(e2, r = {}) {
    const n = e2;
    return is(n) ? (r.meta && (n.meta = {
      ...n.meta,
      ...r.meta
    }), n) : as(n) ? new we(n.error.message, {
      ...r,
      result: n
    }) : n instanceof Error ? new we(n.message, {
      ...r,
      cause: ss.getCauseFromUnknown(n)
    }) : new we("Unknown error", {
      ...r,
      cause: n
    });
  }
  constructor(e2, r) {
    var _a3, _b2;
    const n = r == null ? void 0 : r.cause;
    super(e2, {
      cause: n
    }), this.meta = r == null ? void 0 : r.meta, this.cause = n, this.shape = (_a3 = r == null ? void 0 : r.result) == null ? void 0 : _a3.error, this.data = (_b2 = r == null ? void 0 : r.result) == null ? void 0 : _b2.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, we.prototype);
  }
};
_e2.TRPCClientError = Or;
var W = {};
var os = _e2;
var er = (t) => typeof t == "function";
function Sr(t) {
  if (t)
    return t;
  if (typeof window < "u" && er(window.fetch))
    return window.fetch;
  if (typeof globalThis < "u" && er(globalThis.fetch))
    return globalThis.fetch;
  throw new Error("No fetch implementation found");
}
function cs(t) {
  return t || (typeof window < "u" && window.AbortController ? window.AbortController : typeof globalThis < "u" && globalThis.AbortController ? globalThis.AbortController : null);
}
function us(t) {
  return {
    url: t.url.toString().replace(/\/$/, ""),
    fetch: t.fetch,
    AbortController: cs(t.AbortController)
  };
}
function ds(t) {
  const e2 = {};
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    e2[r] = n;
  }
  return e2;
}
var ls = {
  query: "GET",
  mutation: "POST"
};
function Pr(t) {
  return "input" in t ? t.runtime.transformer.serialize(t.input) : ds(t.inputs.map((e2) => t.runtime.transformer.serialize(e2)));
}
var Nr = (t) => {
  let e2 = t.url + "/" + t.path;
  const r = [];
  if ("inputs" in t && r.push("batch=1"), t.type === "query") {
    const n = Pr(t);
    n !== void 0 && r.push(`input=${encodeURIComponent(JSON.stringify(n))}`);
  }
  return r.length && (e2 += "?" + r.join("&")), e2;
};
var Lr = (t) => {
  if (t.type === "query")
    return;
  const e2 = Pr(t);
  return e2 !== void 0 ? JSON.stringify(e2) : void 0;
};
var fs = (t) => jr({
  ...t,
  contentTypeHeader: "application/json",
  getUrl: Nr,
  getBody: Lr
});
async function Ir(t, e2) {
  const r = t.getUrl(t), n = t.getBody(t), { type: s } = t, i = await t.headers();
  if (s === "subscription")
    throw new Error("Subscriptions should use wsLink");
  const a = {
    ...t.contentTypeHeader ? {
      "content-type": t.contentTypeHeader
    } : {},
    ...t.batchModeHeader ? {
      "trpc-batch-mode": t.batchModeHeader
    } : {},
    ...i
  };
  return Sr(t.fetch)(r, {
    method: ls[s],
    signal: e2 == null ? void 0 : e2.signal,
    body: n,
    headers: a
  });
}
function jr(t) {
  const e2 = t.AbortController ? new t.AbortController() : null, r = {};
  let n = false;
  return {
    promise: new Promise((a, o) => {
      Ir(t, e2).then((c) => (r.response = c, n = true, c.json())).then((c) => {
        r.responseJSON = c, a({
          json: c,
          meta: r
        });
      }).catch((c) => {
        n = true, o(os.TRPCClientError.from(c, {
          meta: r
        }));
      });
    }),
    cancel: () => {
      n || (e2 == null ? void 0 : e2.abort());
    }
  };
}
W.fetchHTTPResponse = Ir;
W.getBody = Lr;
W.getFetch = Sr;
W.getUrl = Nr;
W.httpRequest = jr;
W.jsonHttpRequester = fs;
W.resolveHTTPLinkOptions = us;
var jt = {};
var ps = ge;
var hs = ve;
var tr = _e2;
var wt = W;
var pt = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function ht(t) {
  let e2 = null, r = null;
  const n = () => {
    clearTimeout(r), r = null, e2 = null;
  };
  function s(o) {
    var _a3, _b2;
    const c = [
      []
    ];
    let u = 0;
    for (; ; ) {
      const l = o[u];
      if (!l)
        break;
      const m = c[c.length - 1];
      if (l.aborted) {
        (_a3 = l.reject) == null ? void 0 : _a3.call(l, new Error("Aborted")), u++;
        continue;
      }
      if (t.validate(m.concat(l).map((k) => k.key))) {
        m.push(l), u++;
        continue;
      }
      if (m.length === 0) {
        (_b2 = l.reject) == null ? void 0 : _b2.call(l, new Error("Input is too big for a single dispatch")), u++;
        continue;
      }
      c.push([]);
    }
    return c;
  }
  function i() {
    const o = s(e2);
    n();
    for (const c of o) {
      if (!c.length)
        continue;
      const u = {
        items: c,
        cancel: pt
      };
      for (const k of c)
        k.batch = u;
      const l = (k, T) => {
        var _a3;
        const N = u.items[k];
        (_a3 = N.resolve) == null ? void 0 : _a3.call(N, T), N.batch = null, N.reject = null, N.resolve = null;
      }, { promise: m, cancel: y } = t.fetch(u.items.map((k) => k.key), l);
      u.cancel = y, m.then((k) => {
        var _a3;
        for (let T = 0; T < k.length; T++) {
          const N = k[T];
          l(T, N);
        }
        for (const T of u.items)
          (_a3 = T.reject) == null ? void 0 : _a3.call(T, new Error("Missing result")), T.batch = null;
      }).catch((k) => {
        var _a3;
        for (const T of u.items)
          (_a3 = T.reject) == null ? void 0 : _a3.call(T, k), T.batch = null;
      });
    }
  }
  function a(o) {
    const c = {
      aborted: false,
      key: o,
      batch: null,
      resolve: pt,
      reject: pt
    }, u = new Promise((m, y) => {
      c.reject = y, c.resolve = m, e2 || (e2 = []), e2.push(c);
    });
    return r || (r = setTimeout(i)), {
      promise: u,
      cancel: () => {
        var _a3;
        c.aborted = true, ((_a3 = c.batch) == null ? void 0 : _a3.items.every((m) => m.aborted)) && (c.batch.cancel(), c.batch = null);
      }
    };
  }
  return {
    load: a
  };
}
function Ar(t) {
  return function(r) {
    const n = wt.resolveHTTPLinkOptions(r), s = r.maxURLLength ?? 1 / 0;
    return (i) => {
      const a = (m) => {
        const y = (T) => {
          if (s === 1 / 0)
            return true;
          const N = T.map((H) => H.path).join(","), ae = T.map((H) => H.input);
          return wt.getUrl({
            ...n,
            runtime: i,
            type: m,
            path: N,
            inputs: ae
          }).length <= s;
        }, k = t({
          ...n,
          runtime: i,
          type: m,
          opts: r
        });
        return {
          validate: y,
          fetch: k
        };
      }, o = ht(a("query")), c = ht(a("mutation")), u = ht(a("subscription")), l = {
        query: o,
        subscription: u,
        mutation: c
      };
      return ({ op: m }) => ps.observable((y) => {
        const k = l[m.type], { promise: T, cancel: N } = k.load(m);
        let ae;
        return T.then(($) => {
          ae = $;
          const H = hs.transformResult($.json, i);
          if (!H.ok) {
            y.error(tr.TRPCClientError.from(H.error, {
              meta: $.meta
            }));
            return;
          }
          y.next({
            context: $.meta,
            result: H.result
          }), y.complete();
        }).catch(($) => {
          y.error(tr.TRPCClientError.from($, {
            meta: ae == null ? void 0 : ae.meta
          }));
        }), () => {
          N();
        };
      });
    };
  };
}
var ms = (t) => (e2) => {
  const r = e2.map((a) => a.path).join(","), n = e2.map((a) => a.input), { promise: s, cancel: i } = wt.jsonHttpRequester({
    ...t,
    path: r,
    inputs: n,
    headers() {
      return t.opts.headers ? typeof t.opts.headers == "function" ? t.opts.headers({
        opList: e2
      }) : t.opts.headers : {};
    }
  });
  return {
    promise: s.then((a) => (Array.isArray(a.json) ? a.json : e2.map(() => a.json)).map((u) => ({
      meta: a.meta,
      json: u
    }))),
    cancel: i
  };
};
var ys = Ar(ms);
jt.createHTTPBatchLink = Ar;
jt.httpBatchLink = ys;
var rt = {};
Object.defineProperty(rt, "__esModule", { value: true });
var gs = ge;
var _s = ve;
var rr = _e2;
var $r = W;
function Mr(t) {
  return (e2) => {
    const r = $r.resolveHTTPLinkOptions(e2);
    return (n) => ({ op: s }) => gs.observable((i) => {
      const { path: a, input: o, type: c } = s, { promise: u, cancel: l } = t.requester({
        ...r,
        runtime: n,
        type: c,
        path: a,
        input: o,
        headers() {
          return e2.headers ? typeof e2.headers == "function" ? e2.headers({
            op: s
          }) : e2.headers : {};
        }
      });
      let m;
      return u.then((y) => {
        m = y.meta;
        const k = _s.transformResult(y.json, n);
        if (!k.ok) {
          i.error(rr.TRPCClientError.from(k.error, {
            meta: m
          }));
          return;
        }
        i.next({
          context: y.meta,
          result: k.result
        }), i.complete();
      }).catch((y) => {
        i.error(rr.TRPCClientError.from(y, {
          meta: m
        }));
      }), () => {
        l();
      };
    });
  };
}
var vs = Mr({
  requester: $r.jsonHttpRequester
});
rt.httpLink = vs;
rt.httpLinkFactory = Mr;
var At = {};
Object.defineProperty(At, "__esModule", { value: true });
var nr = ge;
function bs(t) {
  return typeof FormData > "u" ? false : t instanceof FormData;
}
var mt = {
  css: {
    query: [
      "72e3ff",
      "3fb0d8"
    ],
    mutation: [
      "c5a3fc",
      "904dfc"
    ],
    subscription: [
      "ff49e1",
      "d83fbe"
    ]
  },
  ansi: {
    regular: {
      // Cyan background, black and white text respectively
      query: [
        "\x1B[30;46m",
        "\x1B[97;46m"
      ],
      // Magenta background, black and white text respectively
      mutation: [
        "\x1B[30;45m",
        "\x1B[97;45m"
      ],
      // Green background, black and white text respectively
      subscription: [
        "\x1B[30;42m",
        "\x1B[97;42m"
      ]
    },
    bold: {
      query: [
        "\x1B[1;30;46m",
        "\x1B[1;97;46m"
      ],
      mutation: [
        "\x1B[1;30;45m",
        "\x1B[1;97;45m"
      ],
      subscription: [
        "\x1B[1;30;42m",
        "\x1B[1;97;42m"
      ]
    }
  }
};
function ws(t) {
  const { direction: e2, type: r, path: n, id: s, input: i } = t, a = [], o = [];
  if (t.colorMode === "ansi") {
    const [m, y] = mt.ansi.regular[r], [k, T] = mt.ansi.bold[r], N = "\x1B[0m";
    return a.push(e2 === "up" ? m : y, e2 === "up" ? ">>" : "<<", r, e2 === "up" ? k : T, `#${s}`, n, N), e2 === "up" ? o.push({
      input: t.input
    }) : o.push({
      input: t.input,
      // strip context from result cause it's too noisy in terminal wihtout collapse mode
      result: "result" in t.result ? t.result.result : t.result,
      elapsedMs: t.elapsedMs
    }), {
      parts: a,
      args: o
    };
  }
  const [c, u] = mt.css[r], l = `
    background-color: #${e2 === "up" ? c : u}; 
    color: ${e2 === "up" ? "black" : "white"};
    padding: 2px;
  `;
  return a.push("%c", e2 === "up" ? ">>" : "<<", r, `#${s}`, `%c${n}%c`, "%O"), o.push(l, `${l}; font-weight: bold;`, `${l}; font-weight: normal;`), e2 === "up" ? o.push({
    input: i,
    context: t.context
  }) : o.push({
    input: i,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: t.context
  }), {
    parts: a,
    args: o
  };
}
var xs = ({ c: t = console, colorMode: e2 = "css" }) => (r) => {
  const n = r.input, s = bs(n) ? Object.fromEntries(n) : n, { parts: i, args: a } = ws({
    ...r,
    colorMode: e2,
    input: s
  }), o = r.direction === "down" && r.result && (r.result instanceof Error || "error" in r.result.result) ? "error" : "log";
  t[o].apply(null, [
    i.join(" ")
  ].concat(a));
};
function ks(t = {}) {
  const { enabled: e2 = () => true } = t, r = t.colorMode ?? (typeof window > "u" ? "ansi" : "css"), { logger: n = xs({
    c: t.console,
    colorMode: r
  }) } = t;
  return () => ({ op: s, next: i }) => nr.observable((a) => {
    e2({
      ...s,
      direction: "up"
    }) && n({
      ...s,
      direction: "up"
    });
    const o = Date.now();
    function c(u) {
      const l = Date.now() - o;
      e2({
        ...s,
        direction: "down",
        result: u
      }) && n({
        ...s,
        direction: "down",
        elapsedMs: l,
        result: u
      });
    }
    return i(s).pipe(nr.tap({
      next(u) {
        c(u);
      },
      error(u) {
        c(u);
      }
    })).subscribe(a);
  });
}
At.loggerLink = ks;
var nt = {};
Object.defineProperty(nt, "__esModule", { value: true });
var Ts = ge;
var Es = ve;
var Dr = _e2;
var Cs = (t) => t === 0 ? 0 : Math.min(1e3 * 2 ** t, 3e4);
function Rs(t) {
  const { url: e2, WebSocket: r = WebSocket, retryDelayMs: n = Cs, onOpen: s, onClose: i } = t;
  if (!r)
    throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
  let a = [];
  const o = /* @__PURE__ */ Object.create(null);
  let c = 0, u = null, l = null, m = Vt(), y = "connecting";
  function k() {
    y !== "open" || u || (u = setTimeout(() => {
      u = null, a.length === 1 ? m.send(JSON.stringify(a.pop())) : m.send(JSON.stringify(a)), a = [];
    }));
  }
  function T() {
    if (l !== null || y === "closed")
      return;
    const R = n(c++);
    ae(R);
  }
  function N() {
    y = "connecting";
    const R = m;
    m = Vt(), $(R);
  }
  function ae(R) {
    l || (y = "connecting", l = setTimeout(N, R));
  }
  function $(R) {
    Object.values(o).some((oe) => oe.ws === R) || R.close();
  }
  function H() {
    Object.values(o).forEach((R) => {
      R.type === "subscription" && R.callbacks.complete();
    });
  }
  function Bt(R) {
    a.some((P) => P.id === R.op.id) || zt(R.op, R.callbacks);
  }
  function Vt() {
    const R = typeof e2 == "function" ? e2() : e2, P = new r(R);
    clearTimeout(l), l = null, P.addEventListener("open", () => {
      P === m && (c = 0, y = "open", s == null ? void 0 : s(), k());
    }), P.addEventListener("error", () => {
      P === m && T();
    });
    const oe = (j) => {
      if (j.method === "reconnect" && P === m) {
        y === "open" && (i == null ? void 0 : i()), N();
        for (const E of Object.values(o))
          E.type === "subscription" && Bt(E);
      }
    }, ut = (j) => {
      var _a3, _b2;
      const E = j.id !== null && o[j.id];
      if (E) {
        if ((_b2 = (_a3 = E.callbacks).next) == null ? void 0 : _b2.call(_a3, j), E.ws !== m && P === m) {
          const F2 = E.ws;
          E.ws = m, $(F2);
        }
        "result" in j && j.result.type === "stopped" && P === m && E.callbacks.complete();
      }
    };
    return P.addEventListener("message", ({ data: j }) => {
      const E = JSON.parse(j);
      "method" in E ? oe(E) : ut(E), (P !== m || y === "closed") && $(P);
    }), P.addEventListener("close", ({ code: j }) => {
      var _a3, _b2, _c2, _d2;
      y === "open" && (i == null ? void 0 : i({
        code: j
      })), m === P && T();
      for (const [E, F2] of Object.entries(o))
        if (F2.ws === P) {
          if (y === "closed") {
            delete o[E], (_b2 = (_a3 = F2.callbacks).complete) == null ? void 0 : _b2.call(_a3);
            continue;
          }
          F2.type === "subscription" ? Bt(F2) : (delete o[E], (_d2 = (_c2 = F2.callbacks).error) == null ? void 0 : _d2.call(_c2, Dr.TRPCClientError.from(new $t("WebSocket closed prematurely"))));
        }
    }), P;
  }
  function zt(R, P) {
    const { type: oe, input: ut, path: j, id: E } = R, F2 = {
      id: E,
      method: oe,
      params: {
        input: ut,
        path: j
      }
    };
    return o[E] = {
      ws: m,
      type: oe,
      callbacks: P,
      op: R
    }, a.push(F2), k(), () => {
      var _a3, _b2;
      const dn = (_a3 = o[E]) == null ? void 0 : _a3.callbacks;
      delete o[E], a = a.filter((ln) => ln.id !== E), (_b2 = dn == null ? void 0 : dn.complete) == null ? void 0 : _b2.call(dn), m.readyState === r.OPEN && R.type === "subscription" && (a.push({
        id: E,
        method: "subscription.stop"
      }), k());
    };
  }
  return {
    close: () => {
      y = "closed", i == null ? void 0 : i(), H(), $(m), clearTimeout(l), l = null;
    },
    request: zt,
    getConnection() {
      return m;
    }
  };
}
var $t = class _$t extends Error {
  constructor(e2) {
    super(e2), this.name = "TRPCWebSocketClosedError", Object.setPrototypeOf(this, _$t.prototype);
  }
};
function Os(t) {
  return (e2) => {
    const { client: r } = t;
    return ({ op: n }) => Ts.observable((s) => {
      const { type: i, path: a, id: o, context: c } = n, u = e2.transformer.serialize(n.input), l = r.request({
        type: i,
        path: a,
        input: u,
        id: o,
        context: c
      }, {
        error(m) {
          s.error(m), l();
        },
        complete() {
          s.complete();
        },
        next(m) {
          const y = Es.transformResult(m, e2);
          if (!y.ok) {
            s.error(Dr.TRPCClientError.from(y.error));
            return;
          }
          s.next({
            result: y.result
          }), n.type !== "subscription" && (l(), s.complete());
        }
      });
      return () => {
        l();
      };
    });
  };
}
nt.createWSClient = Rs;
nt.wsLink = Os;
Object.defineProperty(S, "__esModule", { value: true });
var sr = ge;
var Zr = It;
var Ur = _e2;
var ir = Rr;
var Ce = W;
var qr = jt;
var Mt = rt;
var Ss = At;
var Br = nt;
var st = class {
  $request({ type: e2, input: r, path: n, context: s = {} }) {
    return Zr.createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: e2,
        path: n,
        input: r,
        context: s
      }
    }).pipe(sr.share());
  }
  requestAsPromise(e2) {
    const r = this.$request(e2), { promise: n, abort: s } = sr.observableToPromise(r);
    return new Promise((a, o) => {
      var _a3;
      (_a3 = e2.signal) == null ? void 0 : _a3.addEventListener("abort", s), n.then((c) => {
        a(c.result.data);
      }).catch((c) => {
        o(Ur.TRPCClientError.from(c));
      });
    });
  }
  query(e2, r, n) {
    return this.requestAsPromise({
      type: "query",
      path: e2,
      input: r,
      context: n == null ? void 0 : n.context,
      signal: n == null ? void 0 : n.signal
    });
  }
  mutation(e2, r, n) {
    return this.requestAsPromise({
      type: "mutation",
      path: e2,
      input: r,
      context: n == null ? void 0 : n.context,
      signal: n == null ? void 0 : n.signal
    });
  }
  subscription(e2, r, n) {
    return this.$request({
      type: "subscription",
      path: e2,
      input: r,
      context: n == null ? void 0 : n.context
    }).subscribe({
      next(i) {
        var _a3, _b2, _c2;
        i.result.type === "started" ? (_a3 = n.onStarted) == null ? void 0 : _a3.call(n) : i.result.type === "stopped" ? (_b2 = n.onStopped) == null ? void 0 : _b2.call(n) : (_c2 = n.onData) == null ? void 0 : _c2.call(n, i.result.data);
      },
      error(i) {
        var _a3;
        (_a3 = n.onError) == null ? void 0 : _a3.call(n, i);
      },
      complete() {
        var _a3;
        (_a3 = n.onComplete) == null ? void 0 : _a3.call(n);
      }
    });
  }
  constructor(e2) {
    this.requestId = 0;
    const r = (() => {
      const n = e2.transformer;
      return n ? "input" in n ? e2.transformer : {
        input: n,
        output: n
      } : {
        input: {
          serialize: (s) => s,
          deserialize: (s) => s
        },
        output: {
          serialize: (s) => s,
          deserialize: (s) => s
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (n) => r.input.serialize(n),
        deserialize: (n) => r.output.deserialize(n)
      },
      combinedTransformer: r
    }, this.links = e2.links.map((n) => n(this.runtime));
  }
};
function Ps(t) {
  return new st(t);
}
function Ns(t) {
  return new st(t);
}
var Ls = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
var Vr = (t) => Ls[t];
function zr(t) {
  return ir.createFlatProxy((e2) => t.hasOwnProperty(e2) ? t[e2] : e2 === "__untypedClient" ? t : ir.createRecursiveProxy(({ path: r, args: n }) => {
    const s = [
      e2,
      ...r
    ], i = Vr(s.pop()), a = s.join(".");
    return t[i](a, ...n);
  }));
}
function Is(t) {
  const e2 = new st(t);
  return zr(e2);
}
function js(t) {
  return t.__untypedClient;
}
function As(t) {
  if (t)
    return t;
  if (typeof window < "u" && window.TextDecoder)
    return new window.TextDecoder();
  if (typeof globalThis < "u" && globalThis.TextDecoder)
    return new globalThis.TextDecoder();
  throw new Error("No TextDecoder implementation found");
}
async function $s(t) {
  const e2 = t.parse ?? JSON.parse, r = (n) => {
    var _a3;
    if (((_a3 = t.signal) == null ? void 0 : _a3.aborted) || !n || n === "}")
      return;
    const s = n.indexOf(":"), i = n.substring(2, s - 1), a = n.substring(s + 1);
    t.onSingle(Number(i), e2(a));
  };
  await Ms(t.readableStream, r, t.textDecoder);
}
async function Ms(t, e2, r) {
  let n = "";
  const s = (i) => {
    const o = r.decode(i).split(`
`);
    if (o.length === 1)
      n += o[0];
    else if (o.length > 1) {
      e2(n + o[0]);
      for (let c = 1; c < o.length - 1; c++)
        e2(o[c]);
      n = o[o.length - 1];
    }
  };
  "getReader" in t ? await Zs(t, s) : await Ds(t, s), e2(n);
}
function Ds(t, e2) {
  return new Promise((r) => {
    t.on("data", e2), t.on("end", r);
  });
}
async function Zs(t, e2) {
  const r = t.getReader();
  let n = await r.read();
  for (; !n.done; )
    e2(n.value), n = await r.read();
}
var Us = (t, e2) => {
  const r = t.AbortController ? new t.AbortController() : null, n = Ce.fetchHTTPResponse({
    ...t,
    contentTypeHeader: "application/json",
    batchModeHeader: "stream",
    getUrl: Ce.getUrl,
    getBody: Ce.getBody
  }, r), s = () => r == null ? void 0 : r.abort(), i = n.then(async (a) => {
    if (!a.body)
      throw new Error("Received response without body");
    const o = {
      response: a
    };
    return $s({
      readableStream: a.body,
      onSingle: e2,
      parse: (c) => ({
        json: JSON.parse(c),
        meta: o
      }),
      signal: r == null ? void 0 : r.signal,
      textDecoder: t.textDecoder
    });
  });
  return {
    cancel: s,
    promise: i
  };
};
var qs = (t) => {
  const e2 = As(t.opts.textDecoder);
  return (r, n) => {
    const s = r.map((c) => c.path).join(","), i = r.map((c) => c.input), { cancel: a, promise: o } = Us({
      ...t,
      textDecoder: e2,
      path: s,
      inputs: i,
      headers() {
        return t.opts.headers ? typeof t.opts.headers == "function" ? t.opts.headers({
          opList: r
        }) : t.opts.headers : {};
      }
    }, (c, u) => {
      n(c, u);
    });
    return {
      /**
      * return an empty array because the batchLoader expects an array of results
      * but we've already called the `unitResolver` for each of them, there's
      * nothing left to do here.
      */
      promise: o.then(() => []),
      cancel: a
    };
  };
};
var Bs = qr.createHTTPBatchLink(qs);
var Vs = (t) => {
  if ("input" in t) {
    if (!(t.input instanceof FormData))
      throw new Error("Input is not FormData");
    return t.input;
  }
};
var zs = (t) => {
  if (t.type !== "mutation")
    throw new Error("We only handle mutations with formdata");
  return Ce.httpRequest({
    ...t,
    getUrl() {
      return `${t.url}/${t.path}`;
    },
    getBody: Vs
  });
};
var Ws = Mt.httpLinkFactory({
  requester: zs
});
S.splitLink = Zr.splitLink;
S.TRPCClientError = Ur.TRPCClientError;
S.getFetch = Ce.getFetch;
S.httpBatchLink = qr.httpBatchLink;
S.httpLink = Mt.httpLink;
S.httpLinkFactory = Mt.httpLinkFactory;
S.loggerLink = Ss.loggerLink;
S.createWSClient = Br.createWSClient;
S.wsLink = Br.wsLink;
S.TRPCUntypedClient = st;
S.clientCallTypeToProcedureType = Vr;
S.createTRPCClient = Ns;
S.createTRPCClientProxy = zr;
S.createTRPCProxyClient = Is;
S.createTRPCUntypedClient = Ps;
S.experimental_formDataLink = Ws;
S.getUntypedClient = js;
S.unstable_httpBatchStreamLink = Bs;
var re = {};
var Dt = {};
function Hs(t) {
  return t;
}
function Fs(t) {
  return t.length === 0 ? Hs : t.length === 1 ? t[0] : function(r) {
    return t.reduce((n, s) => s(n), r);
  };
}
function Js(t) {
  return typeof t == "object" && t !== null && "subscribe" in t;
}
function Ys(t) {
  const e2 = {
    subscribe(r) {
      let n = null, s = false, i = false, a = false;
      function o() {
        if (n === null) {
          a = true;
          return;
        }
        i || (i = true, typeof n == "function" ? n() : n && n.unsubscribe());
      }
      return n = t({
        next(c) {
          var _a3;
          s || ((_a3 = r.next) == null ? void 0 : _a3.call(r, c));
        },
        error(c) {
          var _a3;
          s || (s = true, (_a3 = r.error) == null ? void 0 : _a3.call(r, c), o());
        },
        complete() {
          var _a3;
          s || (s = true, (_a3 = r.complete) == null ? void 0 : _a3.call(r), o());
        }
      }), a && o(), {
        unsubscribe: o
      };
    },
    pipe(...r) {
      return Fs(r)(e2);
    }
  };
  return e2;
}
Dt.isObservable = Js;
Dt.observable = Ys;
Object.defineProperty(re, "__esModule", { value: true });
var Wr = Dt;
function Gs(t) {
  return (e2) => {
    let r = 0, n = null;
    const s = [];
    function i() {
      n || (n = e2.subscribe({
        next(o) {
          var _a3;
          for (const c of s)
            (_a3 = c.next) == null ? void 0 : _a3.call(c, o);
        },
        error(o) {
          var _a3;
          for (const c of s)
            (_a3 = c.error) == null ? void 0 : _a3.call(c, o);
        },
        complete() {
          var _a3;
          for (const o of s)
            (_a3 = o.complete) == null ? void 0 : _a3.call(o);
        }
      }));
    }
    function a() {
      if (r === 0 && n) {
        const o = n;
        n = null, o.unsubscribe();
      }
    }
    return {
      subscribe(o) {
        return r++, s.push(o), i(), {
          unsubscribe() {
            r--, a();
            const c = s.findIndex((u) => u === o);
            c > -1 && s.splice(c, 1);
          }
        };
      }
    };
  };
}
function Qs(t) {
  return (e2) => ({
    subscribe(r) {
      let n = 0;
      return e2.subscribe({
        next(i) {
          var _a3;
          (_a3 = r.next) == null ? void 0 : _a3.call(r, t(i, n++));
        },
        error(i) {
          var _a3;
          (_a3 = r.error) == null ? void 0 : _a3.call(r, i);
        },
        complete() {
          var _a3;
          (_a3 = r.complete) == null ? void 0 : _a3.call(r);
        }
      });
    }
  });
}
function Xs(t) {
  return (e2) => ({
    subscribe(r) {
      return e2.subscribe({
        next(n) {
          var _a3, _b2;
          (_a3 = t.next) == null ? void 0 : _a3.call(t, n), (_b2 = r.next) == null ? void 0 : _b2.call(r, n);
        },
        error(n) {
          var _a3, _b2;
          (_a3 = t.error) == null ? void 0 : _a3.call(t, n), (_b2 = r.error) == null ? void 0 : _b2.call(r, n);
        },
        complete() {
          var _a3, _b2;
          (_a3 = t.complete) == null ? void 0 : _a3.call(t), (_b2 = r.complete) == null ? void 0 : _b2.call(r);
        }
      });
    }
  });
}
var Zt = class _Zt extends Error {
  constructor(e2) {
    super(e2), this.name = "ObservableAbortError", Object.setPrototypeOf(this, _Zt.prototype);
  }
};
function Ks(t) {
  let e2;
  return {
    promise: new Promise((n, s) => {
      let i = false;
      function a() {
        i || (i = true, s(new Zt("This operation was aborted.")), o.unsubscribe());
      }
      const o = t.subscribe({
        next(c) {
          i = true, n(c), a();
        },
        error(c) {
          i = true, s(c), a();
        },
        complete() {
          i = true, a();
        }
      });
      e2 = a;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: e2
  };
}
re.isObservable = Wr.isObservable;
re.observable = Wr.observable;
re.map = Qs;
re.observableToPromise = Ks;
re.share = Gs;
re.tap = Xs;
var q2 = {};
Object.defineProperty(q2, "__esModule", { value: true });
q2.isTRPCRequestWithId = q2.isTRPCRequest = q2.isTRPCResponse = q2.isTRPCMessage = void 0;
function ar(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t);
}
function ei(t) {
  return t == null;
}
function Hr(t) {
  return !!(ar(t) && "trpc" in t && ar(t.trpc));
}
q2.isTRPCMessage = Hr;
function Ut(t) {
  return Hr(t) && "id" in t.trpc && !ei(t.trpc.id);
}
function ti(t) {
  return Ut(t) && ("error" in t.trpc || "result" in t.trpc);
}
q2.isTRPCResponse = ti;
function Fr(t) {
  return Ut(t) && "method" in t.trpc;
}
q2.isTRPCRequest = Fr;
function ri(t) {
  return Fr(t) && Ut(t);
}
q2.isTRPCRequestWithId = ri;
Object.defineProperty(ye, "__esModule", { value: true });
ye.createBaseLink = void 0;
var yt = S;
var ni = re;
var si = q2;
var ii = (t) => (e2) => ({ op: r }) => (0, ni.observable)((n) => {
  const s = [], { id: i, type: a, path: o } = r;
  try {
    const c = e2.transformer.serialize(r.input), u = () => {
      n.error(new yt.TRPCClientError("Port disconnected prematurely"));
    };
    t.addCloseListener(u), s.push(() => t.removeCloseListener(u));
    const l = (m) => {
      if (!(0, si.isTRPCResponse)(m))
        return;
      const { trpc: y } = m;
      if (i === y.id) {
        if ("error" in y)
          return n.error(yt.TRPCClientError.from(y));
        n.next({
          result: Object.assign(Object.assign({}, y.result), (!y.result.type || y.result.type === "data") && {
            type: "data",
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            data: e2.transformer.deserialize(y.result.data)
          })
        }), (a !== "subscription" || y.result.type === "stopped") && n.complete();
      }
    };
    t.addMessageListener(l), s.push(() => t.removeMessageListener(l)), t.postMessage({
      trpc: {
        id: i,
        jsonrpc: void 0,
        method: a,
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        params: { path: o, input: c }
      }
    });
  } catch (c) {
    n.error(new yt.TRPCClientError(c instanceof Error ? c.message : "Unknown error"));
  }
  return () => {
    a === "subscription" && t.postMessage({
      trpc: {
        id: i,
        jsonrpc: void 0,
        method: "subscription.stop"
      }
    }), s.forEach((c) => c());
  };
});
ye.createBaseLink = ii;
Object.defineProperty(tt, "__esModule", { value: true });
tt.chromeLink = void 0;
var ai = ye;
var oi = (t) => (0, ai.createBaseLink)({
  postMessage(e2) {
    t.port.postMessage(e2);
  },
  addMessageListener(e2) {
    t.port.onMessage.addListener(e2);
  },
  removeMessageListener(e2) {
    t.port.onMessage.removeListener(e2);
  },
  addCloseListener(e2) {
    t.port.onDisconnect.addListener(e2);
  },
  removeCloseListener(e2) {
    t.port.onDisconnect.removeListener(e2);
  }
});
tt.chromeLink = oi;
var it = {};
Object.defineProperty(it, "__esModule", { value: true });
it.windowLink = void 0;
var ci = ye;
var ui = (t) => {
  var e2;
  const r = /* @__PURE__ */ new Map(), n = t.window, s = (e2 = t.postWindow) !== null && e2 !== void 0 ? e2 : n;
  return (0, ci.createBaseLink)({
    postMessage(i) {
      s.postMessage(i, {
        targetOrigin: t.postOrigin
      });
    },
    addMessageListener(i) {
      const a = (o) => {
        i(o.data);
      };
      r.set(i, a), n.addEventListener("message", a);
    },
    removeMessageListener(i) {
      const a = r.get(i);
      a && n.removeEventListener("message", a);
    },
    addCloseListener(i) {
      n.addEventListener("beforeunload", i);
    },
    removeCloseListener(i) {
      n.removeEventListener("beforeunload", i);
    }
  });
};
it.windowLink = ui;
var at = {};
var ot = {};
Object.defineProperty(ot, "__esModule", { value: true });
ot.TRPC_BROWSER_LOADED_EVENT = void 0;
ot.TRPC_BROWSER_LOADED_EVENT = "TRPC_BROWSER::POPUP_LOADED";
Object.defineProperty(at, "__esModule", { value: true });
at.popupLink = void 0;
var di = ot;
var li = ye;
var fi = (t) => {
  const e2 = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set();
  let n = null;
  async function s(i) {
    if (!n || n.closed) {
      n = t.createPopup(), await Promise.race([
        // wait til window is loaded (same origin)
        new Promise((a) => {
          var o;
          try {
            (o = n == null ? void 0 : n.addEventListener) === null || o === void 0 || o.call(n, "load", a);
          } catch {
          }
        }),
        // this is needed for cross-origin popups as they don't have a load event
        new Promise((a) => {
          i.addEventListener("message", (o) => {
            o.data === di.TRPC_BROWSER_LOADED_EVENT && a();
          });
        }),
        // expect the popup to load after 15s max, in case non of the above events fire
        new Promise((a) => {
          console.warn("Could not detect if popup loading succeeded after 15s timeout, continuing anyway"), setTimeout(a, 15e3);
        })
      ]);
      try {
        if (!n.addEventListener)
          throw new Error("popupWindow.addEventListener is not a function");
        n.addEventListener("beforeunload", () => {
          n = null;
        });
      } catch {
        const o = setInterval(() => {
          n && n.closed && (n = null, r.forEach((c) => {
            c();
          }), clearInterval(o));
        }, 1e3);
      }
    }
    return n;
  }
  return (0, li.createBaseLink)({
    async postMessage(i) {
      return (await s(t.listenWindow)).postMessage(i, {
        targetOrigin: t.postOrigin
      });
    },
    addMessageListener(i) {
      const a = (o) => {
        i(o.data);
      };
      e2.set(i, a), t.listenWindow.addEventListener("message", a);
    },
    removeMessageListener(i) {
      const a = e2.get(i);
      a && t.listenWindow.removeEventListener("message", a);
    },
    addCloseListener(i) {
      t.listenWindow.addEventListener("beforeunload", i), r.add(i);
    },
    removeCloseListener(i) {
      t.listenWindow.removeEventListener("beforeunload", i), r.delete(i);
    }
  });
};
at.popupLink = fi;
(function(t) {
  var e2 = q && q.__createBinding || (Object.create ? function(n, s, i, a) {
    a === void 0 && (a = i);
    var o = Object.getOwnPropertyDescriptor(s, i);
    (!o || ("get" in o ? !s.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, a, o);
  } : function(n, s, i, a) {
    a === void 0 && (a = i), n[a] = s[i];
  }), r = q && q.__exportStar || function(n, s) {
    for (var i in n)
      i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e2(s, n, i);
  };
  Object.defineProperty(t, "__esModule", { value: true }), r(tt, t), r(it, t), r(at, t);
})(vt);
var x;
(function(t) {
  t.assertEqual = (s) => s;
  function e2(s) {
  }
  t.assertIs = e2;
  function r(s) {
    throw new Error();
  }
  t.assertNever = r, t.arrayToEnum = (s) => {
    const i = {};
    for (const a of s)
      i[a] = a;
    return i;
  }, t.getValidEnumValues = (s) => {
    const i = t.objectKeys(s).filter((o) => typeof s[s[o]] != "number"), a = {};
    for (const o of i)
      a[o] = s[o];
    return t.objectValues(a);
  }, t.objectValues = (s) => t.objectKeys(s).map(function(i) {
    return s[i];
  }), t.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const i = [];
    for (const a in s)
      Object.prototype.hasOwnProperty.call(s, a) && i.push(a);
    return i;
  }, t.find = (s, i) => {
    for (const a of s)
      if (i(a))
        return a;
  }, t.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function n(s, i = " | ") {
    return s.map((a) => typeof a == "string" ? `'${a}'` : a).join(i);
  }
  t.joinValues = n, t.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i;
})(x || (x = {}));
var xt;
(function(t) {
  t.mergeShapes = (e2, r) => ({
    ...e2,
    ...r
    // second overwrites first
  });
})(xt || (xt = {}));
var h = x.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var Q = (t) => {
  switch (typeof t) {
    case "undefined":
      return h.undefined;
    case "string":
      return h.string;
    case "number":
      return isNaN(t) ? h.nan : h.number;
    case "boolean":
      return h.boolean;
    case "function":
      return h.function;
    case "bigint":
      return h.bigint;
    case "symbol":
      return h.symbol;
    case "object":
      return Array.isArray(t) ? h.array : t === null ? h.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? h.promise : typeof Map < "u" && t instanceof Map ? h.map : typeof Set < "u" && t instanceof Set ? h.set : typeof Date < "u" && t instanceof Date ? h.date : h.object;
    default:
      return h.unknown;
  }
};
var f = x.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var pi = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
var A = class _A extends Error {
  constructor(e2) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e2;
  }
  get errors() {
    return this.issues;
  }
  format(e2) {
    const r = e2 || function(i) {
      return i.message;
    }, n = { _errors: [] }, s = (i) => {
      for (const a of i.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(s);
        else if (a.code === "invalid_return_type")
          s(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          s(a.argumentsError);
        else if (a.path.length === 0)
          n._errors.push(r(a));
        else {
          let o = n, c = 0;
          for (; c < a.path.length; ) {
            const u = a.path[c];
            c === a.path.length - 1 ? (o[u] = o[u] || { _errors: [] }, o[u]._errors.push(r(a))) : o[u] = o[u] || { _errors: [] }, o = o[u], c++;
          }
        }
    };
    return s(this), n;
  }
  static assert(e2) {
    if (!(e2 instanceof _A))
      throw new Error(`Not a ZodError: ${e2}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, x.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e2 = (r) => r.message) {
    const r = {}, n = [];
    for (const s of this.issues)
      s.path.length > 0 ? (r[s.path[0]] = r[s.path[0]] || [], r[s.path[0]].push(e2(s))) : n.push(e2(s));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
};
A.create = (t) => new A(t);
var pe = (t, e2) => {
  let r;
  switch (t.code) {
    case f.invalid_type:
      t.received === h.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
      break;
    case f.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(t.expected, x.jsonStringifyReplacer)}`;
      break;
    case f.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${x.joinValues(t.keys, ", ")}`;
      break;
    case f.invalid_union:
      r = "Invalid input";
      break;
    case f.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${x.joinValues(t.options)}`;
      break;
    case f.invalid_enum_value:
      r = `Invalid enum value. Expected ${x.joinValues(t.options)}, received '${t.received}'`;
      break;
    case f.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case f.invalid_return_type:
      r = "Invalid function return type";
      break;
    case f.invalid_date:
      r = "Invalid date";
      break;
    case f.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : x.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
      break;
    case f.too_small:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
      break;
    case f.too_big:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
      break;
    case f.custom:
      r = "Invalid input";
      break;
    case f.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case f.not_multiple_of:
      r = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case f.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = e2.defaultError, x.assertNever(t);
  }
  return { message: r };
};
var Jr = pe;
function hi(t) {
  Jr = t;
}
function He() {
  return Jr;
}
var Fe = (t) => {
  const { data: e2, path: r, errorMaps: n, issueData: s } = t, i = [...r, ...s.path || []], a = {
    ...s,
    path: i
  };
  if (s.message !== void 0)
    return {
      ...s,
      path: i,
      message: s.message
    };
  let o = "";
  const c = n.filter((u) => !!u).slice().reverse();
  for (const u of c)
    o = u(a, { data: e2, defaultError: o }).message;
  return {
    ...s,
    path: i,
    message: o
  };
};
var mi = [];
function p(t, e2) {
  const r = He(), n = Fe({
    issueData: e2,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      t.schemaErrorMap,
      r,
      r === pe ? void 0 : pe
      // then global default map
    ].filter((s) => !!s)
  });
  t.common.issues.push(n);
}
var L = class _L {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e2, r) {
    const n = [];
    for (const s of r) {
      if (s.status === "aborted")
        return v;
      s.status === "dirty" && e2.dirty(), n.push(s.value);
    }
    return { status: e2.value, value: n };
  }
  static async mergeObjectAsync(e2, r) {
    const n = [];
    for (const s of r) {
      const i = await s.key, a = await s.value;
      n.push({
        key: i,
        value: a
      });
    }
    return _L.mergeObjectSync(e2, n);
  }
  static mergeObjectSync(e2, r) {
    const n = {};
    for (const s of r) {
      const { key: i, value: a } = s;
      if (i.status === "aborted" || a.status === "aborted")
        return v;
      i.status === "dirty" && e2.dirty(), a.status === "dirty" && e2.dirty(), i.value !== "__proto__" && (typeof a.value < "u" || s.alwaysSet) && (n[i.value] = a.value);
    }
    return { status: e2.value, value: n };
  }
};
var v = Object.freeze({
  status: "aborted"
});
var de = (t) => ({ status: "dirty", value: t });
var I = (t) => ({ status: "valid", value: t });
var kt = (t) => t.status === "aborted";
var Tt = (t) => t.status === "dirty";
var Re = (t) => t.status === "valid";
var Oe = (t) => typeof Promise < "u" && t instanceof Promise;
function Je(t, e2, r, n) {
  if (r === "a" && !n)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e2 == "function" ? t !== e2 || !n : !e2.has(t))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e2.get(t);
}
function Yr(t, e2, r, n, s) {
  if (n === "m")
    throw new TypeError("Private method is not writable");
  if (n === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e2 == "function" ? t !== e2 || !s : !e2.has(t))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return n === "a" ? s.call(t, r) : s ? s.value = r : e2.set(t, r), r;
}
var g;
(function(t) {
  t.errToObj = (e2) => typeof e2 == "string" ? { message: e2 } : e2 || {}, t.toString = (e2) => typeof e2 == "string" ? e2 : e2 == null ? void 0 : e2.message;
})(g || (g = {}));
var xe;
var ke;
var V = class {
  constructor(e2, r, n, s) {
    this._cachedPath = [], this.parent = e2, this.data = r, this._path = n, this._key = s;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
var or = (t, e2) => {
  if (Re(e2))
    return { success: true, data: e2.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: false,
    get error() {
      if (this._error)
        return this._error;
      const r = new A(t.common.issues);
      return this._error = r, this._error;
    }
  };
};
function b(t) {
  if (!t)
    return {};
  const { errorMap: e2, invalid_type_error: r, required_error: n, description: s } = t;
  if (e2 && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e2 ? { errorMap: e2, description: s } : { errorMap: (a, o) => {
    var c, u;
    const { message: l } = t;
    return a.code === "invalid_enum_value" ? { message: l ?? o.defaultError } : typeof o.data > "u" ? { message: (c = l ?? n) !== null && c !== void 0 ? c : o.defaultError } : a.code !== "invalid_type" ? { message: o.defaultError } : { message: (u = l ?? r) !== null && u !== void 0 ? u : o.defaultError };
  }, description: s };
}
var w = class {
  constructor(e2) {
    this.spa = this.safeParseAsync, this._def = e2, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e2) {
    return Q(e2.data);
  }
  _getOrReturnCtx(e2, r) {
    return r || {
      common: e2.parent.common,
      data: e2.data,
      parsedType: Q(e2.data),
      schemaErrorMap: this._def.errorMap,
      path: e2.path,
      parent: e2.parent
    };
  }
  _processInputParams(e2) {
    return {
      status: new L(),
      ctx: {
        common: e2.parent.common,
        data: e2.data,
        parsedType: Q(e2.data),
        schemaErrorMap: this._def.errorMap,
        path: e2.path,
        parent: e2.parent
      }
    };
  }
  _parseSync(e2) {
    const r = this._parse(e2);
    if (Oe(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(e2) {
    const r = this._parse(e2);
    return Promise.resolve(r);
  }
  parse(e2, r) {
    const n = this.safeParse(e2, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(e2, r) {
    var n;
    const s = {
      common: {
        issues: [],
        async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : false,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e2,
      parsedType: Q(e2)
    }, i = this._parseSync({ data: e2, path: s.path, parent: s });
    return or(s, i);
  }
  async parseAsync(e2, r) {
    const n = await this.safeParseAsync(e2, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(e2, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: true
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e2,
      parsedType: Q(e2)
    }, s = this._parse({ data: e2, path: n.path, parent: n }), i = await (Oe(s) ? s : Promise.resolve(s));
    return or(n, i);
  }
  refine(e2, r) {
    const n = (s) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(s) : r;
    return this._refinement((s, i) => {
      const a = e2(s), o = () => i.addIssue({
        code: f.custom,
        ...n(s)
      });
      return typeof Promise < "u" && a instanceof Promise ? a.then((c) => c ? true : (o(), false)) : a ? true : (o(), false);
    });
  }
  refinement(e2, r) {
    return this._refinement((n, s) => e2(n) ? true : (s.addIssue(typeof r == "function" ? r(n, s) : r), false));
  }
  _refinement(e2) {
    return new U({
      schema: this,
      typeName: _.ZodEffects,
      effect: { type: "refinement", refinement: e2 }
    });
  }
  superRefine(e2) {
    return this._refinement(e2);
  }
  optional() {
    return B.create(this, this._def);
  }
  nullable() {
    return te.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Z.create(this, this._def);
  }
  promise() {
    return me.create(this, this._def);
  }
  or(e2) {
    return Le.create([this, e2], this._def);
  }
  and(e2) {
    return Ie.create(this, e2, this._def);
  }
  transform(e2) {
    return new U({
      ...b(this._def),
      schema: this,
      typeName: _.ZodEffects,
      effect: { type: "transform", transform: e2 }
    });
  }
  default(e2) {
    const r = typeof e2 == "function" ? e2 : () => e2;
    return new De({
      ...b(this._def),
      innerType: this,
      defaultValue: r,
      typeName: _.ZodDefault
    });
  }
  brand() {
    return new qt({
      typeName: _.ZodBranded,
      type: this,
      ...b(this._def)
    });
  }
  catch(e2) {
    const r = typeof e2 == "function" ? e2 : () => e2;
    return new Ze({
      ...b(this._def),
      innerType: this,
      catchValue: r,
      typeName: _.ZodCatch
    });
  }
  describe(e2) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: e2
    });
  }
  pipe(e2) {
    return Be.create(this, e2);
  }
  readonly() {
    return Ue.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var yi = /^c[^\s-]{8,}$/i;
var gi = /^[0-9a-z]+$/;
var _i = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var vi = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var bi = /^[a-z0-9_-]{21}$/i;
var wi = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var xi = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var ki = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
var gt;
var Ti = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var Ei = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var Ci = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var Gr = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
var Ri = new RegExp(`^${Gr}$`);
function Qr(t) {
  let e2 = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return t.precision ? e2 = `${e2}\\.\\d{${t.precision}}` : t.precision == null && (e2 = `${e2}(\\.\\d+)?`), e2;
}
function Oi(t) {
  return new RegExp(`^${Qr(t)}$`);
}
function Xr(t) {
  let e2 = `${Gr}T${Qr(t)}`;
  const r = [];
  return r.push(t.local ? "Z?" : "Z"), t.offset && r.push("([+-]\\d{2}:?\\d{2})"), e2 = `${e2}(${r.join("|")})`, new RegExp(`^${e2}$`);
}
function Si(t, e2) {
  return !!((e2 === "v4" || !e2) && Ti.test(t) || (e2 === "v6" || !e2) && Ei.test(t));
}
var D = class _D extends w {
  _parse(e2) {
    if (this._def.coerce && (e2.data = String(e2.data)), this._getType(e2) !== h.string) {
      const i = this._getOrReturnCtx(e2);
      return p(i, {
        code: f.invalid_type,
        expected: h.string,
        received: i.parsedType
      }), v;
    }
    const n = new L();
    let s;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e2.data.length < i.value && (s = this._getOrReturnCtx(e2, s), p(s, {
          code: f.too_small,
          minimum: i.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: i.message
        }), n.dirty());
      else if (i.kind === "max")
        e2.data.length > i.value && (s = this._getOrReturnCtx(e2, s), p(s, {
          code: f.too_big,
          maximum: i.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: i.message
        }), n.dirty());
      else if (i.kind === "length") {
        const a = e2.data.length > i.value, o = e2.data.length < i.value;
        (a || o) && (s = this._getOrReturnCtx(e2, s), a ? p(s, {
          code: f.too_big,
          maximum: i.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: i.message
        }) : o && p(s, {
          code: f.too_small,
          minimum: i.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: i.message
        }), n.dirty());
      } else if (i.kind === "email")
        xi.test(e2.data) || (s = this._getOrReturnCtx(e2, s), p(s, {
          validation: "email",
          code: f.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "emoji")
        gt || (gt = new RegExp(ki, "u")), gt.test(e2.data) || (s = this._getOrReturnCtx(e2, s), p(s, {
          validation: "emoji",
          code: f.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "uuid")
        vi.test(e2.data) || (s = this._getOrReturnCtx(e2, s), p(s, {
          validation: "uuid",
          code: f.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "nanoid")
        bi.test(e2.data) || (s = this._getOrReturnCtx(e2, s), p(s, {
          validation: "nanoid",
          code: f.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid")
        yi.test(e2.data) || (s = this._getOrReturnCtx(e2, s), p(s, {
          validation: "cuid",
          code: f.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid2")
        gi.test(e2.data) || (s = this._getOrReturnCtx(e2, s), p(s, {
          validation: "cuid2",
          code: f.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "ulid")
        _i.test(e2.data) || (s = this._getOrReturnCtx(e2, s), p(s, {
          validation: "ulid",
          code: f.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "url")
        try {
          new URL(e2.data);
        } catch {
          s = this._getOrReturnCtx(e2, s), p(s, {
            validation: "url",
            code: f.invalid_string,
            message: i.message
          }), n.dirty();
        }
      else
        i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e2.data) || (s = this._getOrReturnCtx(e2, s), p(s, {
          validation: "regex",
          code: f.invalid_string,
          message: i.message
        }), n.dirty())) : i.kind === "trim" ? e2.data = e2.data.trim() : i.kind === "includes" ? e2.data.includes(i.value, i.position) || (s = this._getOrReturnCtx(e2, s), p(s, {
          code: f.invalid_string,
          validation: { includes: i.value, position: i.position },
          message: i.message
        }), n.dirty()) : i.kind === "toLowerCase" ? e2.data = e2.data.toLowerCase() : i.kind === "toUpperCase" ? e2.data = e2.data.toUpperCase() : i.kind === "startsWith" ? e2.data.startsWith(i.value) || (s = this._getOrReturnCtx(e2, s), p(s, {
          code: f.invalid_string,
          validation: { startsWith: i.value },
          message: i.message
        }), n.dirty()) : i.kind === "endsWith" ? e2.data.endsWith(i.value) || (s = this._getOrReturnCtx(e2, s), p(s, {
          code: f.invalid_string,
          validation: { endsWith: i.value },
          message: i.message
        }), n.dirty()) : i.kind === "datetime" ? Xr(i).test(e2.data) || (s = this._getOrReturnCtx(e2, s), p(s, {
          code: f.invalid_string,
          validation: "datetime",
          message: i.message
        }), n.dirty()) : i.kind === "date" ? Ri.test(e2.data) || (s = this._getOrReturnCtx(e2, s), p(s, {
          code: f.invalid_string,
          validation: "date",
          message: i.message
        }), n.dirty()) : i.kind === "time" ? Oi(i).test(e2.data) || (s = this._getOrReturnCtx(e2, s), p(s, {
          code: f.invalid_string,
          validation: "time",
          message: i.message
        }), n.dirty()) : i.kind === "duration" ? wi.test(e2.data) || (s = this._getOrReturnCtx(e2, s), p(s, {
          validation: "duration",
          code: f.invalid_string,
          message: i.message
        }), n.dirty()) : i.kind === "ip" ? Si(e2.data, i.version) || (s = this._getOrReturnCtx(e2, s), p(s, {
          validation: "ip",
          code: f.invalid_string,
          message: i.message
        }), n.dirty()) : i.kind === "base64" ? Ci.test(e2.data) || (s = this._getOrReturnCtx(e2, s), p(s, {
          validation: "base64",
          code: f.invalid_string,
          message: i.message
        }), n.dirty()) : x.assertNever(i);
    return { status: n.value, value: e2.data };
  }
  _regex(e2, r, n) {
    return this.refinement((s) => e2.test(s), {
      validation: r,
      code: f.invalid_string,
      ...g.errToObj(n)
    });
  }
  _addCheck(e2) {
    return new _D({
      ...this._def,
      checks: [...this._def.checks, e2]
    });
  }
  email(e2) {
    return this._addCheck({ kind: "email", ...g.errToObj(e2) });
  }
  url(e2) {
    return this._addCheck({ kind: "url", ...g.errToObj(e2) });
  }
  emoji(e2) {
    return this._addCheck({ kind: "emoji", ...g.errToObj(e2) });
  }
  uuid(e2) {
    return this._addCheck({ kind: "uuid", ...g.errToObj(e2) });
  }
  nanoid(e2) {
    return this._addCheck({ kind: "nanoid", ...g.errToObj(e2) });
  }
  cuid(e2) {
    return this._addCheck({ kind: "cuid", ...g.errToObj(e2) });
  }
  cuid2(e2) {
    return this._addCheck({ kind: "cuid2", ...g.errToObj(e2) });
  }
  ulid(e2) {
    return this._addCheck({ kind: "ulid", ...g.errToObj(e2) });
  }
  base64(e2) {
    return this._addCheck({ kind: "base64", ...g.errToObj(e2) });
  }
  ip(e2) {
    return this._addCheck({ kind: "ip", ...g.errToObj(e2) });
  }
  datetime(e2) {
    var r, n;
    return typeof e2 == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: false,
      local: false,
      message: e2
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e2 == null ? void 0 : e2.precision) > "u" ? null : e2 == null ? void 0 : e2.precision,
      offset: (r = e2 == null ? void 0 : e2.offset) !== null && r !== void 0 ? r : false,
      local: (n = e2 == null ? void 0 : e2.local) !== null && n !== void 0 ? n : false,
      ...g.errToObj(e2 == null ? void 0 : e2.message)
    });
  }
  date(e2) {
    return this._addCheck({ kind: "date", message: e2 });
  }
  time(e2) {
    return typeof e2 == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e2
    }) : this._addCheck({
      kind: "time",
      precision: typeof (e2 == null ? void 0 : e2.precision) > "u" ? null : e2 == null ? void 0 : e2.precision,
      ...g.errToObj(e2 == null ? void 0 : e2.message)
    });
  }
  duration(e2) {
    return this._addCheck({ kind: "duration", ...g.errToObj(e2) });
  }
  regex(e2, r) {
    return this._addCheck({
      kind: "regex",
      regex: e2,
      ...g.errToObj(r)
    });
  }
  includes(e2, r) {
    return this._addCheck({
      kind: "includes",
      value: e2,
      position: r == null ? void 0 : r.position,
      ...g.errToObj(r == null ? void 0 : r.message)
    });
  }
  startsWith(e2, r) {
    return this._addCheck({
      kind: "startsWith",
      value: e2,
      ...g.errToObj(r)
    });
  }
  endsWith(e2, r) {
    return this._addCheck({
      kind: "endsWith",
      value: e2,
      ...g.errToObj(r)
    });
  }
  min(e2, r) {
    return this._addCheck({
      kind: "min",
      value: e2,
      ...g.errToObj(r)
    });
  }
  max(e2, r) {
    return this._addCheck({
      kind: "max",
      value: e2,
      ...g.errToObj(r)
    });
  }
  length(e2, r) {
    return this._addCheck({
      kind: "length",
      value: e2,
      ...g.errToObj(r)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(e2) {
    return this.min(1, g.errToObj(e2));
  }
  trim() {
    return new _D({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _D({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _D({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e2) => e2.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e2) => e2.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e2) => e2.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e2) => e2.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e2) => e2.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e2) => e2.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e2) => e2.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e2) => e2.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e2) => e2.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e2) => e2.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e2) => e2.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e2) => e2.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e2) => e2.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((e2) => e2.kind === "base64");
  }
  get minLength() {
    let e2 = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e2 === null || r.value > e2) && (e2 = r.value);
    return e2;
  }
  get maxLength() {
    let e2 = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e2 === null || r.value < e2) && (e2 = r.value);
    return e2;
  }
};
D.create = (t) => {
  var e2;
  return new D({
    checks: [],
    typeName: _.ZodString,
    coerce: (e2 = t == null ? void 0 : t.coerce) !== null && e2 !== void 0 ? e2 : false,
    ...b(t)
  });
};
function Pi(t, e2) {
  const r = (t.toString().split(".")[1] || "").length, n = (e2.toString().split(".")[1] || "").length, s = r > n ? r : n, i = parseInt(t.toFixed(s).replace(".", "")), a = parseInt(e2.toFixed(s).replace(".", ""));
  return i % a / Math.pow(10, s);
}
var X = class _X extends w {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e2) {
    if (this._def.coerce && (e2.data = Number(e2.data)), this._getType(e2) !== h.number) {
      const i = this._getOrReturnCtx(e2);
      return p(i, {
        code: f.invalid_type,
        expected: h.number,
        received: i.parsedType
      }), v;
    }
    let n;
    const s = new L();
    for (const i of this._def.checks)
      i.kind === "int" ? x.isInteger(e2.data) || (n = this._getOrReturnCtx(e2, n), p(n, {
        code: f.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), s.dirty()) : i.kind === "min" ? (i.inclusive ? e2.data < i.value : e2.data <= i.value) && (n = this._getOrReturnCtx(e2, n), p(n, {
        code: f.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: false,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e2.data > i.value : e2.data >= i.value) && (n = this._getOrReturnCtx(e2, n), p(n, {
        code: f.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: false,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? Pi(e2.data, i.value) !== 0 && (n = this._getOrReturnCtx(e2, n), p(n, {
        code: f.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : i.kind === "finite" ? Number.isFinite(e2.data) || (n = this._getOrReturnCtx(e2, n), p(n, {
        code: f.not_finite,
        message: i.message
      }), s.dirty()) : x.assertNever(i);
    return { status: s.value, value: e2.data };
  }
  gte(e2, r) {
    return this.setLimit("min", e2, true, g.toString(r));
  }
  gt(e2, r) {
    return this.setLimit("min", e2, false, g.toString(r));
  }
  lte(e2, r) {
    return this.setLimit("max", e2, true, g.toString(r));
  }
  lt(e2, r) {
    return this.setLimit("max", e2, false, g.toString(r));
  }
  setLimit(e2, r, n, s) {
    return new _X({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e2,
          value: r,
          inclusive: n,
          message: g.toString(s)
        }
      ]
    });
  }
  _addCheck(e2) {
    return new _X({
      ...this._def,
      checks: [...this._def.checks, e2]
    });
  }
  int(e2) {
    return this._addCheck({
      kind: "int",
      message: g.toString(e2)
    });
  }
  positive(e2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: g.toString(e2)
    });
  }
  negative(e2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: g.toString(e2)
    });
  }
  nonpositive(e2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: g.toString(e2)
    });
  }
  nonnegative(e2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: g.toString(e2)
    });
  }
  multipleOf(e2, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e2,
      message: g.toString(r)
    });
  }
  finite(e2) {
    return this._addCheck({
      kind: "finite",
      message: g.toString(e2)
    });
  }
  safe(e2) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: g.toString(e2)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: g.toString(e2)
    });
  }
  get minValue() {
    let e2 = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e2 === null || r.value > e2) && (e2 = r.value);
    return e2;
  }
  get maxValue() {
    let e2 = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e2 === null || r.value < e2) && (e2 = r.value);
    return e2;
  }
  get isInt() {
    return !!this._def.checks.find((e2) => e2.kind === "int" || e2.kind === "multipleOf" && x.isInteger(e2.value));
  }
  get isFinite() {
    let e2 = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return true;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (e2 === null || n.value < e2) && (e2 = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(e2);
  }
};
X.create = (t) => new X({
  checks: [],
  typeName: _.ZodNumber,
  coerce: (t == null ? void 0 : t.coerce) || false,
  ...b(t)
});
var K = class _K extends w {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e2) {
    if (this._def.coerce && (e2.data = BigInt(e2.data)), this._getType(e2) !== h.bigint) {
      const i = this._getOrReturnCtx(e2);
      return p(i, {
        code: f.invalid_type,
        expected: h.bigint,
        received: i.parsedType
      }), v;
    }
    let n;
    const s = new L();
    for (const i of this._def.checks)
      i.kind === "min" ? (i.inclusive ? e2.data < i.value : e2.data <= i.value) && (n = this._getOrReturnCtx(e2, n), p(n, {
        code: f.too_small,
        type: "bigint",
        minimum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e2.data > i.value : e2.data >= i.value) && (n = this._getOrReturnCtx(e2, n), p(n, {
        code: f.too_big,
        type: "bigint",
        maximum: i.value,
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? e2.data % i.value !== BigInt(0) && (n = this._getOrReturnCtx(e2, n), p(n, {
        code: f.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : x.assertNever(i);
    return { status: s.value, value: e2.data };
  }
  gte(e2, r) {
    return this.setLimit("min", e2, true, g.toString(r));
  }
  gt(e2, r) {
    return this.setLimit("min", e2, false, g.toString(r));
  }
  lte(e2, r) {
    return this.setLimit("max", e2, true, g.toString(r));
  }
  lt(e2, r) {
    return this.setLimit("max", e2, false, g.toString(r));
  }
  setLimit(e2, r, n, s) {
    return new _K({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e2,
          value: r,
          inclusive: n,
          message: g.toString(s)
        }
      ]
    });
  }
  _addCheck(e2) {
    return new _K({
      ...this._def,
      checks: [...this._def.checks, e2]
    });
  }
  positive(e2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: g.toString(e2)
    });
  }
  negative(e2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: g.toString(e2)
    });
  }
  nonpositive(e2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: g.toString(e2)
    });
  }
  nonnegative(e2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: g.toString(e2)
    });
  }
  multipleOf(e2, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e2,
      message: g.toString(r)
    });
  }
  get minValue() {
    let e2 = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e2 === null || r.value > e2) && (e2 = r.value);
    return e2;
  }
  get maxValue() {
    let e2 = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e2 === null || r.value < e2) && (e2 = r.value);
    return e2;
  }
};
K.create = (t) => {
  var e2;
  return new K({
    checks: [],
    typeName: _.ZodBigInt,
    coerce: (e2 = t == null ? void 0 : t.coerce) !== null && e2 !== void 0 ? e2 : false,
    ...b(t)
  });
};
var Se = class extends w {
  _parse(e2) {
    if (this._def.coerce && (e2.data = !!e2.data), this._getType(e2) !== h.boolean) {
      const n = this._getOrReturnCtx(e2);
      return p(n, {
        code: f.invalid_type,
        expected: h.boolean,
        received: n.parsedType
      }), v;
    }
    return I(e2.data);
  }
};
Se.create = (t) => new Se({
  typeName: _.ZodBoolean,
  coerce: (t == null ? void 0 : t.coerce) || false,
  ...b(t)
});
var se = class _se extends w {
  _parse(e2) {
    if (this._def.coerce && (e2.data = new Date(e2.data)), this._getType(e2) !== h.date) {
      const i = this._getOrReturnCtx(e2);
      return p(i, {
        code: f.invalid_type,
        expected: h.date,
        received: i.parsedType
      }), v;
    }
    if (isNaN(e2.data.getTime())) {
      const i = this._getOrReturnCtx(e2);
      return p(i, {
        code: f.invalid_date
      }), v;
    }
    const n = new L();
    let s;
    for (const i of this._def.checks)
      i.kind === "min" ? e2.data.getTime() < i.value && (s = this._getOrReturnCtx(e2, s), p(s, {
        code: f.too_small,
        message: i.message,
        inclusive: true,
        exact: false,
        minimum: i.value,
        type: "date"
      }), n.dirty()) : i.kind === "max" ? e2.data.getTime() > i.value && (s = this._getOrReturnCtx(e2, s), p(s, {
        code: f.too_big,
        message: i.message,
        inclusive: true,
        exact: false,
        maximum: i.value,
        type: "date"
      }), n.dirty()) : x.assertNever(i);
    return {
      status: n.value,
      value: new Date(e2.data.getTime())
    };
  }
  _addCheck(e2) {
    return new _se({
      ...this._def,
      checks: [...this._def.checks, e2]
    });
  }
  min(e2, r) {
    return this._addCheck({
      kind: "min",
      value: e2.getTime(),
      message: g.toString(r)
    });
  }
  max(e2, r) {
    return this._addCheck({
      kind: "max",
      value: e2.getTime(),
      message: g.toString(r)
    });
  }
  get minDate() {
    let e2 = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e2 === null || r.value > e2) && (e2 = r.value);
    return e2 != null ? new Date(e2) : null;
  }
  get maxDate() {
    let e2 = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e2 === null || r.value < e2) && (e2 = r.value);
    return e2 != null ? new Date(e2) : null;
  }
};
se.create = (t) => new se({
  checks: [],
  coerce: (t == null ? void 0 : t.coerce) || false,
  typeName: _.ZodDate,
  ...b(t)
});
var Ye = class extends w {
  _parse(e2) {
    if (this._getType(e2) !== h.symbol) {
      const n = this._getOrReturnCtx(e2);
      return p(n, {
        code: f.invalid_type,
        expected: h.symbol,
        received: n.parsedType
      }), v;
    }
    return I(e2.data);
  }
};
Ye.create = (t) => new Ye({
  typeName: _.ZodSymbol,
  ...b(t)
});
var Pe = class extends w {
  _parse(e2) {
    if (this._getType(e2) !== h.undefined) {
      const n = this._getOrReturnCtx(e2);
      return p(n, {
        code: f.invalid_type,
        expected: h.undefined,
        received: n.parsedType
      }), v;
    }
    return I(e2.data);
  }
};
Pe.create = (t) => new Pe({
  typeName: _.ZodUndefined,
  ...b(t)
});
var Ne = class extends w {
  _parse(e2) {
    if (this._getType(e2) !== h.null) {
      const n = this._getOrReturnCtx(e2);
      return p(n, {
        code: f.invalid_type,
        expected: h.null,
        received: n.parsedType
      }), v;
    }
    return I(e2.data);
  }
};
Ne.create = (t) => new Ne({
  typeName: _.ZodNull,
  ...b(t)
});
var he = class extends w {
  constructor() {
    super(...arguments), this._any = true;
  }
  _parse(e2) {
    return I(e2.data);
  }
};
he.create = (t) => new he({
  typeName: _.ZodAny,
  ...b(t)
});
var ne = class extends w {
  constructor() {
    super(...arguments), this._unknown = true;
  }
  _parse(e2) {
    return I(e2.data);
  }
};
ne.create = (t) => new ne({
  typeName: _.ZodUnknown,
  ...b(t)
});
var Y = class extends w {
  _parse(e2) {
    const r = this._getOrReturnCtx(e2);
    return p(r, {
      code: f.invalid_type,
      expected: h.never,
      received: r.parsedType
    }), v;
  }
};
Y.create = (t) => new Y({
  typeName: _.ZodNever,
  ...b(t)
});
var Ge = class extends w {
  _parse(e2) {
    if (this._getType(e2) !== h.undefined) {
      const n = this._getOrReturnCtx(e2);
      return p(n, {
        code: f.invalid_type,
        expected: h.void,
        received: n.parsedType
      }), v;
    }
    return I(e2.data);
  }
};
Ge.create = (t) => new Ge({
  typeName: _.ZodVoid,
  ...b(t)
});
var Z = class _Z extends w {
  _parse(e2) {
    const { ctx: r, status: n } = this._processInputParams(e2), s = this._def;
    if (r.parsedType !== h.array)
      return p(r, {
        code: f.invalid_type,
        expected: h.array,
        received: r.parsedType
      }), v;
    if (s.exactLength !== null) {
      const a = r.data.length > s.exactLength.value, o = r.data.length < s.exactLength.value;
      (a || o) && (p(r, {
        code: a ? f.too_big : f.too_small,
        minimum: o ? s.exactLength.value : void 0,
        maximum: a ? s.exactLength.value : void 0,
        type: "array",
        inclusive: true,
        exact: true,
        message: s.exactLength.message
      }), n.dirty());
    }
    if (s.minLength !== null && r.data.length < s.minLength.value && (p(r, {
      code: f.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: s.minLength.message
    }), n.dirty()), s.maxLength !== null && r.data.length > s.maxLength.value && (p(r, {
      code: f.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: s.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((a, o) => s.type._parseAsync(new V(r, a, r.path, o)))).then((a) => L.mergeArray(n, a));
    const i = [...r.data].map((a, o) => s.type._parseSync(new V(r, a, r.path, o)));
    return L.mergeArray(n, i);
  }
  get element() {
    return this._def.type;
  }
  min(e2, r) {
    return new _Z({
      ...this._def,
      minLength: { value: e2, message: g.toString(r) }
    });
  }
  max(e2, r) {
    return new _Z({
      ...this._def,
      maxLength: { value: e2, message: g.toString(r) }
    });
  }
  length(e2, r) {
    return new _Z({
      ...this._def,
      exactLength: { value: e2, message: g.toString(r) }
    });
  }
  nonempty(e2) {
    return this.min(1, e2);
  }
};
Z.create = (t, e2) => new Z({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: _.ZodArray,
  ...b(e2)
});
function ue(t) {
  if (t instanceof C) {
    const e2 = {};
    for (const r in t.shape) {
      const n = t.shape[r];
      e2[r] = B.create(ue(n));
    }
    return new C({
      ...t._def,
      shape: () => e2
    });
  } else
    return t instanceof Z ? new Z({
      ...t._def,
      type: ue(t.element)
    }) : t instanceof B ? B.create(ue(t.unwrap())) : t instanceof te ? te.create(ue(t.unwrap())) : t instanceof z ? z.create(t.items.map((e2) => ue(e2))) : t;
}
var C = class _C extends w {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e2 = this._def.shape(), r = x.objectKeys(e2);
    return this._cached = { shape: e2, keys: r };
  }
  _parse(e2) {
    if (this._getType(e2) !== h.object) {
      const u = this._getOrReturnCtx(e2);
      return p(u, {
        code: f.invalid_type,
        expected: h.object,
        received: u.parsedType
      }), v;
    }
    const { status: n, ctx: s } = this._processInputParams(e2), { shape: i, keys: a } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof Y && this._def.unknownKeys === "strip"))
      for (const u in s.data)
        a.includes(u) || o.push(u);
    const c = [];
    for (const u of a) {
      const l = i[u], m = s.data[u];
      c.push({
        key: { status: "valid", value: u },
        value: l._parse(new V(s, m, s.path, u)),
        alwaysSet: u in s.data
      });
    }
    if (this._def.catchall instanceof Y) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const l of o)
          c.push({
            key: { status: "valid", value: l },
            value: { status: "valid", value: s.data[l] }
          });
      else if (u === "strict")
        o.length > 0 && (p(s, {
          code: f.unrecognized_keys,
          keys: o
        }), n.dirty());
      else if (u !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const l of o) {
        const m = s.data[l];
        c.push({
          key: { status: "valid", value: l },
          value: u._parse(
            new V(s, m, s.path, l)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: l in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const l of c) {
        const m = await l.key, y = await l.value;
        u.push({
          key: m,
          value: y,
          alwaysSet: l.alwaysSet
        });
      }
      return u;
    }).then((u) => L.mergeObjectSync(n, u)) : L.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e2) {
    return g.errToObj, new _C({
      ...this._def,
      unknownKeys: "strict",
      ...e2 !== void 0 ? {
        errorMap: (r, n) => {
          var s, i, a, o;
          const c = (a = (i = (s = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(s, r, n).message) !== null && a !== void 0 ? a : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (o = g.errToObj(e2).message) !== null && o !== void 0 ? o : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new _C({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _C({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e2) {
    return new _C({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e2
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e2) {
    return new _C({
      unknownKeys: e2._def.unknownKeys,
      catchall: e2._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e2._def.shape()
      }),
      typeName: _.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e2, r) {
    return this.augment({ [e2]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e2) {
    return new _C({
      ...this._def,
      catchall: e2
    });
  }
  pick(e2) {
    const r = {};
    return x.objectKeys(e2).forEach((n) => {
      e2[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  omit(e2) {
    const r = {};
    return x.objectKeys(this.shape).forEach((n) => {
      e2[n] || (r[n] = this.shape[n]);
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return ue(this);
  }
  partial(e2) {
    const r = {};
    return x.objectKeys(this.shape).forEach((n) => {
      const s = this.shape[n];
      e2 && !e2[n] ? r[n] = s : r[n] = s.optional();
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  required(e2) {
    const r = {};
    return x.objectKeys(this.shape).forEach((n) => {
      if (e2 && !e2[n])
        r[n] = this.shape[n];
      else {
        let i = this.shape[n];
        for (; i instanceof B; )
          i = i._def.innerType;
        r[n] = i;
      }
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return Kr(x.objectKeys(this.shape));
  }
};
C.create = (t, e2) => new C({
  shape: () => t,
  unknownKeys: "strip",
  catchall: Y.create(),
  typeName: _.ZodObject,
  ...b(e2)
});
C.strictCreate = (t, e2) => new C({
  shape: () => t,
  unknownKeys: "strict",
  catchall: Y.create(),
  typeName: _.ZodObject,
  ...b(e2)
});
C.lazycreate = (t, e2) => new C({
  shape: t,
  unknownKeys: "strip",
  catchall: Y.create(),
  typeName: _.ZodObject,
  ...b(e2)
});
var Le = class extends w {
  _parse(e2) {
    const { ctx: r } = this._processInputParams(e2), n = this._def.options;
    function s(i) {
      for (const o of i)
        if (o.result.status === "valid")
          return o.result;
      for (const o of i)
        if (o.result.status === "dirty")
          return r.common.issues.push(...o.ctx.common.issues), o.result;
      const a = i.map((o) => new A(o.ctx.common.issues));
      return p(r, {
        code: f.invalid_union,
        unionErrors: a
      }), v;
    }
    if (r.common.async)
      return Promise.all(n.map(async (i) => {
        const a = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: r.data,
            path: r.path,
            parent: a
          }),
          ctx: a
        };
      })).then(s);
    {
      let i;
      const a = [];
      for (const c of n) {
        const u = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, l = c._parseSync({
          data: r.data,
          path: r.path,
          parent: u
        });
        if (l.status === "valid")
          return l;
        l.status === "dirty" && !i && (i = { result: l, ctx: u }), u.common.issues.length && a.push(u.common.issues);
      }
      if (i)
        return r.common.issues.push(...i.ctx.common.issues), i.result;
      const o = a.map((c) => new A(c));
      return p(r, {
        code: f.invalid_union,
        unionErrors: o
      }), v;
    }
  }
  get options() {
    return this._def.options;
  }
};
Le.create = (t, e2) => new Le({
  options: t,
  typeName: _.ZodUnion,
  ...b(e2)
});
var J = (t) => t instanceof Ae ? J(t.schema) : t instanceof U ? J(t.innerType()) : t instanceof $e ? [t.value] : t instanceof ee ? t.options : t instanceof Me ? x.objectValues(t.enum) : t instanceof De ? J(t._def.innerType) : t instanceof Pe ? [void 0] : t instanceof Ne ? [null] : t instanceof B ? [void 0, ...J(t.unwrap())] : t instanceof te ? [null, ...J(t.unwrap())] : t instanceof qt || t instanceof Ue ? J(t.unwrap()) : t instanceof Ze ? J(t._def.innerType) : [];
var ct = class _ct extends w {
  _parse(e2) {
    const { ctx: r } = this._processInputParams(e2);
    if (r.parsedType !== h.object)
      return p(r, {
        code: f.invalid_type,
        expected: h.object,
        received: r.parsedType
      }), v;
    const n = this.discriminator, s = r.data[n], i = this.optionsMap.get(s);
    return i ? r.common.async ? i._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : i._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (p(r, {
      code: f.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), v);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e2, r, n) {
    const s = /* @__PURE__ */ new Map();
    for (const i of r) {
      const a = J(i.shape[e2]);
      if (!a.length)
        throw new Error(`A discriminator value for key \`${e2}\` could not be extracted from all schema options`);
      for (const o of a) {
        if (s.has(o))
          throw new Error(`Discriminator property ${String(e2)} has duplicate value ${String(o)}`);
        s.set(o, i);
      }
    }
    return new _ct({
      typeName: _.ZodDiscriminatedUnion,
      discriminator: e2,
      options: r,
      optionsMap: s,
      ...b(n)
    });
  }
};
function Et(t, e2) {
  const r = Q(t), n = Q(e2);
  if (t === e2)
    return { valid: true, data: t };
  if (r === h.object && n === h.object) {
    const s = x.objectKeys(e2), i = x.objectKeys(t).filter((o) => s.indexOf(o) !== -1), a = { ...t, ...e2 };
    for (const o of i) {
      const c = Et(t[o], e2[o]);
      if (!c.valid)
        return { valid: false };
      a[o] = c.data;
    }
    return { valid: true, data: a };
  } else if (r === h.array && n === h.array) {
    if (t.length !== e2.length)
      return { valid: false };
    const s = [];
    for (let i = 0; i < t.length; i++) {
      const a = t[i], o = e2[i], c = Et(a, o);
      if (!c.valid)
        return { valid: false };
      s.push(c.data);
    }
    return { valid: true, data: s };
  } else
    return r === h.date && n === h.date && +t == +e2 ? { valid: true, data: t } : { valid: false };
}
var Ie = class extends w {
  _parse(e2) {
    const { status: r, ctx: n } = this._processInputParams(e2), s = (i, a) => {
      if (kt(i) || kt(a))
        return v;
      const o = Et(i.value, a.value);
      return o.valid ? ((Tt(i) || Tt(a)) && r.dirty(), { status: r.value, value: o.data }) : (p(n, {
        code: f.invalid_intersection_types
      }), v);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([i, a]) => s(i, a)) : s(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
};
Ie.create = (t, e2, r) => new Ie({
  left: t,
  right: e2,
  typeName: _.ZodIntersection,
  ...b(r)
});
var z = class _z extends w {
  _parse(e2) {
    const { status: r, ctx: n } = this._processInputParams(e2);
    if (n.parsedType !== h.array)
      return p(n, {
        code: f.invalid_type,
        expected: h.array,
        received: n.parsedType
      }), v;
    if (n.data.length < this._def.items.length)
      return p(n, {
        code: f.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      }), v;
    !this._def.rest && n.data.length > this._def.items.length && (p(n, {
      code: f.too_big,
      maximum: this._def.items.length,
      inclusive: true,
      exact: false,
      type: "array"
    }), r.dirty());
    const i = [...n.data].map((a, o) => {
      const c = this._def.items[o] || this._def.rest;
      return c ? c._parse(new V(n, a, n.path, o)) : null;
    }).filter((a) => !!a);
    return n.common.async ? Promise.all(i).then((a) => L.mergeArray(r, a)) : L.mergeArray(r, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e2) {
    return new _z({
      ...this._def,
      rest: e2
    });
  }
};
z.create = (t, e2) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new z({
    items: t,
    typeName: _.ZodTuple,
    rest: null,
    ...b(e2)
  });
};
var je = class _je extends w {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e2) {
    const { status: r, ctx: n } = this._processInputParams(e2);
    if (n.parsedType !== h.object)
      return p(n, {
        code: f.invalid_type,
        expected: h.object,
        received: n.parsedType
      }), v;
    const s = [], i = this._def.keyType, a = this._def.valueType;
    for (const o in n.data)
      s.push({
        key: i._parse(new V(n, o, n.path, o)),
        value: a._parse(new V(n, n.data[o], n.path, o)),
        alwaysSet: o in n.data
      });
    return n.common.async ? L.mergeObjectAsync(r, s) : L.mergeObjectSync(r, s);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e2, r, n) {
    return r instanceof w ? new _je({
      keyType: e2,
      valueType: r,
      typeName: _.ZodRecord,
      ...b(n)
    }) : new _je({
      keyType: D.create(),
      valueType: e2,
      typeName: _.ZodRecord,
      ...b(r)
    });
  }
};
var Qe = class extends w {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e2) {
    const { status: r, ctx: n } = this._processInputParams(e2);
    if (n.parsedType !== h.map)
      return p(n, {
        code: f.invalid_type,
        expected: h.map,
        received: n.parsedType
      }), v;
    const s = this._def.keyType, i = this._def.valueType, a = [...n.data.entries()].map(([o, c], u) => ({
      key: s._parse(new V(n, o, n.path, [u, "key"])),
      value: i._parse(new V(n, c, n.path, [u, "value"]))
    }));
    if (n.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of a) {
          const u = await c.key, l = await c.value;
          if (u.status === "aborted" || l.status === "aborted")
            return v;
          (u.status === "dirty" || l.status === "dirty") && r.dirty(), o.set(u.value, l.value);
        }
        return { status: r.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const c of a) {
        const u = c.key, l = c.value;
        if (u.status === "aborted" || l.status === "aborted")
          return v;
        (u.status === "dirty" || l.status === "dirty") && r.dirty(), o.set(u.value, l.value);
      }
      return { status: r.value, value: o };
    }
  }
};
Qe.create = (t, e2, r) => new Qe({
  valueType: e2,
  keyType: t,
  typeName: _.ZodMap,
  ...b(r)
});
var ie = class _ie extends w {
  _parse(e2) {
    const { status: r, ctx: n } = this._processInputParams(e2);
    if (n.parsedType !== h.set)
      return p(n, {
        code: f.invalid_type,
        expected: h.set,
        received: n.parsedType
      }), v;
    const s = this._def;
    s.minSize !== null && n.data.size < s.minSize.value && (p(n, {
      code: f.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: s.minSize.message
    }), r.dirty()), s.maxSize !== null && n.data.size > s.maxSize.value && (p(n, {
      code: f.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: s.maxSize.message
    }), r.dirty());
    const i = this._def.valueType;
    function a(c) {
      const u = /* @__PURE__ */ new Set();
      for (const l of c) {
        if (l.status === "aborted")
          return v;
        l.status === "dirty" && r.dirty(), u.add(l.value);
      }
      return { status: r.value, value: u };
    }
    const o = [...n.data.values()].map((c, u) => i._parse(new V(n, c, n.path, u)));
    return n.common.async ? Promise.all(o).then((c) => a(c)) : a(o);
  }
  min(e2, r) {
    return new _ie({
      ...this._def,
      minSize: { value: e2, message: g.toString(r) }
    });
  }
  max(e2, r) {
    return new _ie({
      ...this._def,
      maxSize: { value: e2, message: g.toString(r) }
    });
  }
  size(e2, r) {
    return this.min(e2, r).max(e2, r);
  }
  nonempty(e2) {
    return this.min(1, e2);
  }
};
ie.create = (t, e2) => new ie({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: _.ZodSet,
  ...b(e2)
});
var le = class _le extends w {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e2) {
    const { ctx: r } = this._processInputParams(e2);
    if (r.parsedType !== h.function)
      return p(r, {
        code: f.invalid_type,
        expected: h.function,
        received: r.parsedType
      }), v;
    function n(o, c) {
      return Fe({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          He(),
          pe
        ].filter((u) => !!u),
        issueData: {
          code: f.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function s(o, c) {
      return Fe({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          He(),
          pe
        ].filter((u) => !!u),
        issueData: {
          code: f.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const i = { errorMap: r.common.contextualErrorMap }, a = r.data;
    if (this._def.returns instanceof me) {
      const o = this;
      return I(async function(...c) {
        const u = new A([]), l = await o._def.args.parseAsync(c, i).catch((k) => {
          throw u.addIssue(n(c, k)), u;
        }), m = await Reflect.apply(a, this, l);
        return await o._def.returns._def.type.parseAsync(m, i).catch((k) => {
          throw u.addIssue(s(m, k)), u;
        });
      });
    } else {
      const o = this;
      return I(function(...c) {
        const u = o._def.args.safeParse(c, i);
        if (!u.success)
          throw new A([n(c, u.error)]);
        const l = Reflect.apply(a, this, u.data), m = o._def.returns.safeParse(l, i);
        if (!m.success)
          throw new A([s(l, m.error)]);
        return m.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e2) {
    return new _le({
      ...this._def,
      args: z.create(e2).rest(ne.create())
    });
  }
  returns(e2) {
    return new _le({
      ...this._def,
      returns: e2
    });
  }
  implement(e2) {
    return this.parse(e2);
  }
  strictImplement(e2) {
    return this.parse(e2);
  }
  static create(e2, r, n) {
    return new _le({
      args: e2 || z.create([]).rest(ne.create()),
      returns: r || ne.create(),
      typeName: _.ZodFunction,
      ...b(n)
    });
  }
};
var Ae = class extends w {
  get schema() {
    return this._def.getter();
  }
  _parse(e2) {
    const { ctx: r } = this._processInputParams(e2);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
};
Ae.create = (t, e2) => new Ae({
  getter: t,
  typeName: _.ZodLazy,
  ...b(e2)
});
var $e = class extends w {
  _parse(e2) {
    if (e2.data !== this._def.value) {
      const r = this._getOrReturnCtx(e2);
      return p(r, {
        received: r.data,
        code: f.invalid_literal,
        expected: this._def.value
      }), v;
    }
    return { status: "valid", value: e2.data };
  }
  get value() {
    return this._def.value;
  }
};
$e.create = (t, e2) => new $e({
  value: t,
  typeName: _.ZodLiteral,
  ...b(e2)
});
function Kr(t, e2) {
  return new ee({
    values: t,
    typeName: _.ZodEnum,
    ...b(e2)
  });
}
var ee = class _ee extends w {
  constructor() {
    super(...arguments), xe.set(this, void 0);
  }
  _parse(e2) {
    if (typeof e2.data != "string") {
      const r = this._getOrReturnCtx(e2), n = this._def.values;
      return p(r, {
        expected: x.joinValues(n),
        received: r.parsedType,
        code: f.invalid_type
      }), v;
    }
    if (Je(this, xe, "f") || Yr(this, xe, new Set(this._def.values), "f"), !Je(this, xe, "f").has(e2.data)) {
      const r = this._getOrReturnCtx(e2), n = this._def.values;
      return p(r, {
        received: r.data,
        code: f.invalid_enum_value,
        options: n
      }), v;
    }
    return I(e2.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e2 = {};
    for (const r of this._def.values)
      e2[r] = r;
    return e2;
  }
  get Values() {
    const e2 = {};
    for (const r of this._def.values)
      e2[r] = r;
    return e2;
  }
  get Enum() {
    const e2 = {};
    for (const r of this._def.values)
      e2[r] = r;
    return e2;
  }
  extract(e2, r = this._def) {
    return _ee.create(e2, {
      ...this._def,
      ...r
    });
  }
  exclude(e2, r = this._def) {
    return _ee.create(this.options.filter((n) => !e2.includes(n)), {
      ...this._def,
      ...r
    });
  }
};
xe = /* @__PURE__ */ new WeakMap();
ee.create = Kr;
var Me = class extends w {
  constructor() {
    super(...arguments), ke.set(this, void 0);
  }
  _parse(e2) {
    const r = x.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e2);
    if (n.parsedType !== h.string && n.parsedType !== h.number) {
      const s = x.objectValues(r);
      return p(n, {
        expected: x.joinValues(s),
        received: n.parsedType,
        code: f.invalid_type
      }), v;
    }
    if (Je(this, ke, "f") || Yr(this, ke, new Set(x.getValidEnumValues(this._def.values)), "f"), !Je(this, ke, "f").has(e2.data)) {
      const s = x.objectValues(r);
      return p(n, {
        received: n.data,
        code: f.invalid_enum_value,
        options: s
      }), v;
    }
    return I(e2.data);
  }
  get enum() {
    return this._def.values;
  }
};
ke = /* @__PURE__ */ new WeakMap();
Me.create = (t, e2) => new Me({
  values: t,
  typeName: _.ZodNativeEnum,
  ...b(e2)
});
var me = class extends w {
  unwrap() {
    return this._def.type;
  }
  _parse(e2) {
    const { ctx: r } = this._processInputParams(e2);
    if (r.parsedType !== h.promise && r.common.async === false)
      return p(r, {
        code: f.invalid_type,
        expected: h.promise,
        received: r.parsedType
      }), v;
    const n = r.parsedType === h.promise ? r.data : Promise.resolve(r.data);
    return I(n.then((s) => this._def.type.parseAsync(s, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
};
me.create = (t, e2) => new me({
  type: t,
  typeName: _.ZodPromise,
  ...b(e2)
});
var U = class extends w {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === _.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e2) {
    const { status: r, ctx: n } = this._processInputParams(e2), s = this._def.effect || null, i = {
      addIssue: (a) => {
        p(n, a), a.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), s.type === "preprocess") {
      const a = s.transform(n.data, i);
      if (n.common.async)
        return Promise.resolve(a).then(async (o) => {
          if (r.value === "aborted")
            return v;
          const c = await this._def.schema._parseAsync({
            data: o,
            path: n.path,
            parent: n
          });
          return c.status === "aborted" ? v : c.status === "dirty" || r.value === "dirty" ? de(c.value) : c;
        });
      {
        if (r.value === "aborted")
          return v;
        const o = this._def.schema._parseSync({
          data: a,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? v : o.status === "dirty" || r.value === "dirty" ? de(o.value) : o;
      }
    }
    if (s.type === "refinement") {
      const a = (o) => {
        const c = s.refinement(o, i);
        if (n.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (n.common.async === false) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? v : (o.status === "dirty" && r.dirty(), a(o.value), { status: r.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => o.status === "aborted" ? v : (o.status === "dirty" && r.dirty(), a(o.value).then(() => ({ status: r.value, value: o.value }))));
    }
    if (s.type === "transform")
      if (n.common.async === false) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!Re(a))
          return a;
        const o = s.transform(a.value, i);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => Re(a) ? Promise.resolve(s.transform(a.value, i)).then((o) => ({ status: r.value, value: o })) : a);
    x.assertNever(s);
  }
};
U.create = (t, e2, r) => new U({
  schema: t,
  typeName: _.ZodEffects,
  effect: e2,
  ...b(r)
});
U.createWithPreprocess = (t, e2, r) => new U({
  schema: e2,
  effect: { type: "preprocess", transform: t },
  typeName: _.ZodEffects,
  ...b(r)
});
var B = class extends w {
  _parse(e2) {
    return this._getType(e2) === h.undefined ? I(void 0) : this._def.innerType._parse(e2);
  }
  unwrap() {
    return this._def.innerType;
  }
};
B.create = (t, e2) => new B({
  innerType: t,
  typeName: _.ZodOptional,
  ...b(e2)
});
var te = class extends w {
  _parse(e2) {
    return this._getType(e2) === h.null ? I(null) : this._def.innerType._parse(e2);
  }
  unwrap() {
    return this._def.innerType;
  }
};
te.create = (t, e2) => new te({
  innerType: t,
  typeName: _.ZodNullable,
  ...b(e2)
});
var De = class extends w {
  _parse(e2) {
    const { ctx: r } = this._processInputParams(e2);
    let n = r.data;
    return r.parsedType === h.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
De.create = (t, e2) => new De({
  innerType: t,
  typeName: _.ZodDefault,
  defaultValue: typeof e2.default == "function" ? e2.default : () => e2.default,
  ...b(e2)
});
var Ze = class extends w {
  _parse(e2) {
    const { ctx: r } = this._processInputParams(e2), n = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, s = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return Oe(s) ? s.then((i) => ({
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new A(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new A(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
Ze.create = (t, e2) => new Ze({
  innerType: t,
  typeName: _.ZodCatch,
  catchValue: typeof e2.catch == "function" ? e2.catch : () => e2.catch,
  ...b(e2)
});
var Xe = class extends w {
  _parse(e2) {
    if (this._getType(e2) !== h.nan) {
      const n = this._getOrReturnCtx(e2);
      return p(n, {
        code: f.invalid_type,
        expected: h.nan,
        received: n.parsedType
      }), v;
    }
    return { status: "valid", value: e2.data };
  }
};
Xe.create = (t) => new Xe({
  typeName: _.ZodNaN,
  ...b(t)
});
var Ni = Symbol("zod_brand");
var qt = class extends w {
  _parse(e2) {
    const { ctx: r } = this._processInputParams(e2), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var Be = class _Be extends w {
  _parse(e2) {
    const { status: r, ctx: n } = this._processInputParams(e2);
    if (n.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return i.status === "aborted" ? v : i.status === "dirty" ? (r.dirty(), de(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return s.status === "aborted" ? v : s.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(e2, r) {
    return new _Be({
      in: e2,
      out: r,
      typeName: _.ZodPipeline
    });
  }
};
var Ue = class extends w {
  _parse(e2) {
    const r = this._def.innerType._parse(e2), n = (s) => (Re(s) && (s.value = Object.freeze(s.value)), s);
    return Oe(r) ? r.then((s) => n(s)) : n(r);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Ue.create = (t, e2) => new Ue({
  innerType: t,
  typeName: _.ZodReadonly,
  ...b(e2)
});
function en(t, e2 = {}, r) {
  return t ? he.create().superRefine((n, s) => {
    var i, a;
    if (!t(n)) {
      const o = typeof e2 == "function" ? e2(n) : typeof e2 == "string" ? { message: e2 } : e2, c = (a = (i = o.fatal) !== null && i !== void 0 ? i : r) !== null && a !== void 0 ? a : true, u = typeof o == "string" ? { message: o } : o;
      s.addIssue({ code: "custom", ...u, fatal: c });
    }
  }) : he.create();
}
var Li = {
  object: C.lazycreate
};
var _;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly";
})(_ || (_ = {}));
var Ii = (t, e2 = {
  message: `Input not instance of ${t.name}`
}) => en((r) => r instanceof t, e2);
var tn = D.create;
var rn = X.create;
var ji = Xe.create;
var Ai = K.create;
var nn = Se.create;
var $i = se.create;
var Mi = Ye.create;
var Di = Pe.create;
var Zi = Ne.create;
var Ui = he.create;
var qi = ne.create;
var Bi = Y.create;
var Vi = Ge.create;
var zi = Z.create;
var Wi = C.create;
var Hi = C.strictCreate;
var Fi = Le.create;
var Ji = ct.create;
var Yi = Ie.create;
var Gi = z.create;
var Qi = je.create;
var Xi = Qe.create;
var Ki = ie.create;
var ea = le.create;
var ta = Ae.create;
var ra = $e.create;
var na = ee.create;
var sa = Me.create;
var ia = me.create;
var cr = U.create;
var aa = B.create;
var oa = te.create;
var ca = U.createWithPreprocess;
var ua = Be.create;
var da = () => tn().optional();
var la = () => rn().optional();
var fa = () => nn().optional();
var pa = {
  string: (t) => D.create({ ...t, coerce: true }),
  number: (t) => X.create({ ...t, coerce: true }),
  boolean: (t) => Se.create({
    ...t,
    coerce: true
  }),
  bigint: (t) => K.create({ ...t, coerce: true }),
  date: (t) => se.create({ ...t, coerce: true })
};
var ha = v;
var d = Object.freeze({
  __proto__: null,
  defaultErrorMap: pe,
  setErrorMap: hi,
  getErrorMap: He,
  makeIssue: Fe,
  EMPTY_PATH: mi,
  addIssueToContext: p,
  ParseStatus: L,
  INVALID: v,
  DIRTY: de,
  OK: I,
  isAborted: kt,
  isDirty: Tt,
  isValid: Re,
  isAsync: Oe,
  get util() {
    return x;
  },
  get objectUtil() {
    return xt;
  },
  ZodParsedType: h,
  getParsedType: Q,
  ZodType: w,
  datetimeRegex: Xr,
  ZodString: D,
  ZodNumber: X,
  ZodBigInt: K,
  ZodBoolean: Se,
  ZodDate: se,
  ZodSymbol: Ye,
  ZodUndefined: Pe,
  ZodNull: Ne,
  ZodAny: he,
  ZodUnknown: ne,
  ZodNever: Y,
  ZodVoid: Ge,
  ZodArray: Z,
  ZodObject: C,
  ZodUnion: Le,
  ZodDiscriminatedUnion: ct,
  ZodIntersection: Ie,
  ZodTuple: z,
  ZodRecord: je,
  ZodMap: Qe,
  ZodSet: ie,
  ZodFunction: le,
  ZodLazy: Ae,
  ZodLiteral: $e,
  ZodEnum: ee,
  ZodNativeEnum: Me,
  ZodPromise: me,
  ZodEffects: U,
  ZodTransformer: U,
  ZodOptional: B,
  ZodNullable: te,
  ZodDefault: De,
  ZodCatch: Ze,
  ZodNaN: Xe,
  BRAND: Ni,
  ZodBranded: qt,
  ZodPipeline: Be,
  ZodReadonly: Ue,
  custom: en,
  Schema: w,
  ZodSchema: w,
  late: Li,
  get ZodFirstPartyTypeKind() {
    return _;
  },
  coerce: pa,
  any: Ui,
  array: zi,
  bigint: Ai,
  boolean: nn,
  date: $i,
  discriminatedUnion: Ji,
  effect: cr,
  enum: na,
  function: ea,
  instanceof: Ii,
  intersection: Yi,
  lazy: ta,
  literal: ra,
  map: Xi,
  nan: ji,
  nativeEnum: sa,
  never: Bi,
  null: Zi,
  nullable: oa,
  number: rn,
  object: Wi,
  oboolean: fa,
  onumber: la,
  optional: aa,
  ostring: da,
  pipeline: ua,
  preprocess: ca,
  promise: ia,
  record: Qi,
  set: Ki,
  strictObject: Hi,
  string: tn,
  symbol: Mi,
  transformer: cr,
  tuple: Gi,
  undefined: Di,
  union: Fi,
  unknown: qi,
  void: Vi,
  NEVER: ha,
  ZodIssueCode: f,
  quotelessJson: pi,
  ZodError: A
});
var sn = /^0x[0-9a-f]+$/i;
var an = /^\d+$/;
var ma = d.string().min(1, "The short string cannot be empty").max(31, "The short string cannot exceed 31 characters").refine(
  (t) => !sn.test(t),
  "The shortString should not be a hex string"
).refine(
  (t) => !an.test(t),
  "The shortString should not be an integer string"
);
var M = d.union([
  d.string().regex(
    sn,
    "Only hex, integers and bigint are supported in calldata"
  ),
  d.string().regex(
    an,
    "Only hex, integers and bigint are supported in calldata"
  ),
  ma,
  d.number().int("Only hex, integers and bigint are supported in calldata"),
  d.bigint()
]);
var qe = d.object({
  contractAddress: d.string(),
  entrypoint: d.string(),
  calldata: d.array(M.or(d.array(M))).optional()
});
var Ct = d.array(qe).nonempty();
var on = d.object({
  types: d.record(
    d.array(
      d.union([
        d.object({
          name: d.string(),
          type: d.literal("merkletree"),
          contains: d.string()
        }),
        d.object({
          name: d.string(),
          type: d.literal("enum"),
          contains: d.string()
        }),
        d.object({
          name: d.string(),
          type: d.string()
        })
      ])
    )
  ),
  primaryType: d.string(),
  domain: d.record(d.unknown()),
  message: d.record(d.unknown()).or(d.object({}))
});
var Rt = d.object({
  type: d.literal("ERC20"),
  options: d.object({
    address: d.string(),
    symbol: d.string().optional(),
    decimals: d.number().optional(),
    image: d.string().optional(),
    name: d.string().optional()
  })
});
var ya = d.union([
  d.object({
    id: d.string(),
    chain_id: d.string(),
    chain_name: d.string(),
    rpc_urls: d.array(d.string()).optional(),
    native_currency: Rt.optional(),
    block_explorer_url: d.array(d.string()).optional()
  }),
  d.object({
    id: d.string(),
    chainId: d.string(),
    chainName: d.string(),
    rpcUrls: d.array(d.string()).optional(),
    nativeCurrency: Rt.optional(),
    blockExplorerUrl: d.array(d.string()).optional()
  }).transform((t) => ({
    id: t.id,
    chain_id: t.chainId,
    chain_name: t.chainName,
    rpc_urls: t.rpcUrls,
    native_currency: t.nativeCurrency,
    block_explorer_url: t.blockExplorerUrl
  }))
]);
var _t = {
  enable: d.tuple([
    d.object({
      starknetVersion: d.union([d.literal("v3"), d.literal("v4"), d.literal("v5")]).optional()
    }).optional()
  ]).or(d.tuple([])),
  addStarknetChain: d.tuple([ya]),
  switchStarknetChain: d.tuple([
    d.object({
      chainId: d.string()
    })
  ]),
  watchAsset: d.tuple([Rt]),
  requestAccounts: d.tuple([
    d.object({
      silent_mode: d.boolean().optional()
    })
  ]),
  execute: d.tuple([
    Ct.or(qe),
    d.object({
      nonce: M.optional(),
      maxFee: M.optional(),
      version: M.optional()
    }).optional()
  ]),
  signMessage: d.tuple([on])
};
d.tuple([
  Ct.or(qe),
  d.object({
    nonce: M.optional(),
    maxFee: M.optional(),
    version: M.optional()
  }).optional()
]).or(
  d.tuple([
    Ct.or(qe),
    d.array(d.any()).optional(),
    d.object({
      nonce: M.optional(),
      maxFee: M.optional(),
      version: M.optional()
    }).optional()
  ])
);
var cn = d.object({
  contract_address: d.string(),
  entry_point: d.string(),
  calldata: d.array(M).optional()
}).transform(({ contract_address: t, entry_point: e2, calldata: r }) => ({
  contractAddress: t,
  entrypoint: e2,
  calldata: r || []
}));
var ga = d.array(cn).nonempty();
var _a2 = {
  ZERO: 0,
  ONE: 1
};
var va = d.object({
  address: d.string(),
  class_hash: d.string(),
  salt: d.string(),
  calldata: d.array(d.string()),
  sigdata: d.array(d.string()).optional(),
  //version: z.literal([0, 1]),
  version: d.nativeEnum(_a2)
  // allow only 0 | 1, workaround since zod doesn't support literals as numbers
});
var ba = d.object({
  callbackData: d.string().optional(),
  approvalRequests: d.array(
    d.object({
      tokenAddress: d.string(),
      amount: d.string(),
      spender: d.string()
    })
  ),
  sessionTypedData: on
});
var wa = d.object({
  account: d.string().array().optional(),
  chainId: d.string().optional(),
  signature: d.string().array().optional(),
  approvalTransactionHash: d.string().optional(),
  deploymentPayload: d.any().optional(),
  approvalRequestsCalls: d.array(qe).optional(),
  errorCode: d.enum([
    "USER_REJECTED",
    "ACCOUNT_NOT_DEPLOYED",
    "NOT_ENOUGH_BALANCE",
    "NOT_ENOUGH_BALANCE_DEPLOYMENT",
    "GENERIC_ERROR"
  ]).optional()
});
var O = Kn.create({
  isServer: false,
  allowOutsideOfServer: true
});
var Ot = fn;
var St = "";
var un = "";
var Na = ({
  width: t = 775,
  height: e2 = 385,
  origin: r,
  location: n,
  atLeftBottom: s = false
}) => {
  const i = (window == null ? void 0 : window.outerWidth) ?? (window == null ? void 0 : window.innerWidth) ?? (window == null ? void 0 : window.screen.width) ?? 0, a = (window == null ? void 0 : window.outerHeight) ?? (window == null ? void 0 : window.innerHeight) ?? (window == null ? void 0 : window.screen.height) ?? 0, o = (window == null ? void 0 : window.screenLeft) ?? (window == null ? void 0 : window.screenX) ?? 0, c = (window == null ? void 0 : window.screenTop) ?? (window == null ? void 0 : window.screenY) ?? 0, u = s ? 0 : o + i / 2 - t / 2, l = s ? window.screen.availHeight + 10 : c + a / 2 - e2 / 2;
  Ot = r ?? Ot, St = n ?? St, un = `width=${t},height=${e2},top=${l},left=${u},toolbar=no,menubar=no,scrollbars=no,location=no,status=no,popup=1`;
};
O.router({
  authorize: O.procedure.output(d.boolean()).mutation(async () => true),
  connect: O.procedure.mutation(async () => ""),
  connectWebwallet: O.procedure.input(
    d.object({
      theme: d.enum(["light", "dark", "auto"]).optional()
    })
  ).output(
    d.object({
      account: d.string().array().optional(),
      chainId: d.string().optional()
    })
  ).mutation(async () => ({})),
  connectWebwalletSSO: O.procedure.input(
    d.object({ token: d.string(), authorizedPartyId: d.string().optional() })
  ).output(
    d.object({
      account: d.string().array().optional(),
      chainId: d.string().optional()
    })
  ).mutation(async () => ({})),
  connectAndSignSession: O.procedure.input(ba).output(wa).mutation(async () => ({})),
  enable: O.procedure.output(d.string()).mutation(async () => ""),
  execute: O.procedure.input(_t.execute).output(d.string()).mutation(async () => ""),
  signMessage: O.procedure.input(_t.signMessage).output(d.string().array()).mutation(async () => []),
  getLoginStatus: O.procedure.output(
    d.object({
      isLoggedIn: d.boolean(),
      hasSession: d.boolean().optional(),
      isPreauthorized: d.boolean().optional()
    })
  ).mutation(async () => ({
    isLoggedIn: true
  })),
  // RPC Messages
  requestAccounts: O.procedure.input(d.object({ silent_mode: d.boolean().optional() })).output(d.string().array()).mutation(async () => []),
  requestChainId: O.procedure.output(d.string()).mutation(async () => ""),
  signTypedData: O.procedure.input(_t.signMessage).output(d.string().array()).mutation(async () => []),
  getPermissions: O.procedure.output(d.array(d.enum([e.ACCOUNTS]))).mutation(async () => [e.ACCOUNTS]),
  addInvokeTransaction: O.procedure.input(cn.or(ga)).output(d.string()).mutation(async (t) => ""),
  addStarknetChain: O.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  switchStarknetChain: O.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  watchAsset: O.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  updateModal: O.procedure.subscription(async () => {
  }),
  deploymentData: O.procedure.output(va).mutation(async () => ({
    address: "",
    calldata: [],
    version: 0,
    class_hash: "",
    salt: ""
  }))
});
var La = ({
  iframe: t
}) => Dn({
  links: [
    In({
      enabled: (e2) => typeof window < "u" || e2.direction === "down" && e2.result instanceof Error
    }),
    bn({
      condition(e2) {
        if (!t && e2.type === "subscription")
          throw new Error(
            "subscription is not supported without an iframe window"
          );
        return !!t;
      },
      true: vt.windowLink({
        window,
        postWindow: t,
        postOrigin: "*"
      }),
      false: vt.popupLink({
        listenWindow: window,
        createPopup: () => {
          let e2 = null;
          const r = document.createElement("button");
          if (r.style.display = "none", r.addEventListener("click", () => {
            e2 = window.open(
              `${Ot}${St}`,
              "popup",
              un
            );
          }), r.click(), (async () => {
            for (; !e2; )
              await new Promise((n) => setTimeout(n, 100));
          })(), !e2)
            throw new Error("Could not open popup");
          return e2;
        },
        postOrigin: "*"
      })
    })
  ]
});

export {
  fn,
  Ea,
  Ca,
  Ra,
  Oa,
  Sa,
  Na,
  La
};
/*! Bundled license information:

starknetkit/dist/trpc-870d4938.js:
  (* istanbul ignore if -- @preserve *)
  (* istanbul ignore next -- @preserve *)
*/
//# sourceMappingURL=chunk-JPG53TQT.js.map
